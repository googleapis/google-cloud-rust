// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Parameters that can be configured on Linux nodes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LinuxNodeConfig {
    /// The Linux kernel parameters to be applied to the nodes and all pods running
    /// on the nodes.
    ///
    /// The following parameters are supported.
    ///
    /// net.core.busy_poll
    /// net.core.busy_read
    /// net.core.netdev_max_backlog
    /// net.core.rmem_max
    /// net.core.rmem_default
    /// net.core.wmem_default
    /// net.core.wmem_max
    /// net.core.optmem_max
    /// net.core.somaxconn
    /// net.ipv4.tcp_rmem
    /// net.ipv4.tcp_wmem
    /// net.ipv4.tcp_tw_reuse
    /// net.ipv4.tcp_max_orphans
    /// net.netfilter.nf_conntrack_max
    /// net.netfilter.nf_conntrack_buckets
    /// net.netfilter.nf_conntrack_tcp_timeout_close_wait
    /// net.netfilter.nf_conntrack_tcp_timeout_time_wait
    /// net.netfilter.nf_conntrack_tcp_timeout_established
    /// net.netfilter.nf_conntrack_acct
    /// kernel.shmmni
    /// kernel.shmmax
    /// kernel.shmall
    /// fs.aio-max-nr
    /// fs.file-max
    /// fs.inotify.max_user_instances
    /// fs.inotify.max_user_watches
    /// fs.nr_open
    /// vm.dirty_background_ratio
    /// vm.dirty_expire_centisecs
    /// vm.dirty_ratio
    /// vm.dirty_writeback_centisecs
    /// vm.max_map_count
    /// vm.overcommit_memory
    /// vm.overcommit_ratio
    /// vm.vfs_cache_pressure
    /// vm.swappiness
    /// vm.watermark_scale_factor
    /// vm.min_free_kbytes
    pub sysctls: std::collections::HashMap<std::string::String, std::string::String>,

    /// cgroup_mode specifies the cgroup mode to be used on the node.
    pub cgroup_mode: crate::model::linux_node_config::CgroupMode,

    /// Optional. Amounts for 2M and 1G hugepages
    pub hugepages: std::option::Option<crate::model::linux_node_config::HugepagesConfig>,

    /// Optional. Transparent hugepage support for anonymous memory can be entirely
    /// disabled (mostly for debugging purposes) or only enabled inside
    /// MADV_HUGEPAGE regions (to avoid the risk of consuming more memory
    /// resources) or enabled system wide.
    ///
    /// See <https://docs.kernel.org/admin-guide/mm/transhuge.html>
    /// for more details.
    pub transparent_hugepage_enabled: crate::model::linux_node_config::TransparentHugepageEnabled,

    /// Optional. Defines the transparent hugepage defrag configuration on the
    /// node. VM hugepage allocation can be managed by either limiting
    /// defragmentation for delayed allocation or skipping it entirely for
    /// immediate allocation only.
    ///
    /// See <https://docs.kernel.org/admin-guide/mm/transhuge.html>
    /// for more details.
    pub transparent_hugepage_defrag: crate::model::linux_node_config::TransparentHugepageDefrag,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LinuxNodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sysctls][crate::model::LinuxNodeConfig::sysctls].
    pub fn set_sysctls<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.sysctls = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [cgroup_mode][crate::model::LinuxNodeConfig::cgroup_mode].
    pub fn set_cgroup_mode<T: std::convert::Into<crate::model::linux_node_config::CgroupMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.cgroup_mode = v.into();
        self
    }

    /// Sets the value of [hugepages][crate::model::LinuxNodeConfig::hugepages].
    pub fn set_hugepages<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::linux_node_config::HugepagesConfig>,
    {
        self.hugepages = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hugepages][crate::model::LinuxNodeConfig::hugepages].
    pub fn set_or_clear_hugepages<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::linux_node_config::HugepagesConfig>,
    {
        self.hugepages = v.map(|x| x.into());
        self
    }

    /// Sets the value of [transparent_hugepage_enabled][crate::model::LinuxNodeConfig::transparent_hugepage_enabled].
    pub fn set_transparent_hugepage_enabled<
        T: std::convert::Into<crate::model::linux_node_config::TransparentHugepageEnabled>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transparent_hugepage_enabled = v.into();
        self
    }

    /// Sets the value of [transparent_hugepage_defrag][crate::model::LinuxNodeConfig::transparent_hugepage_defrag].
    pub fn set_transparent_hugepage_defrag<
        T: std::convert::Into<crate::model::linux_node_config::TransparentHugepageDefrag>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transparent_hugepage_defrag = v.into();
        self
    }
}

impl wkt::message::Message for LinuxNodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LinuxNodeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LinuxNodeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sysctls,
            __cgroup_mode,
            __hugepages,
            __transparent_hugepage_enabled,
            __transparent_hugepage_defrag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LinuxNodeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sysctls" => Ok(__FieldTag::__sysctls),
                            "cgroupMode" => Ok(__FieldTag::__cgroup_mode),
                            "cgroup_mode" => Ok(__FieldTag::__cgroup_mode),
                            "hugepages" => Ok(__FieldTag::__hugepages),
                            "transparentHugepageEnabled" => {
                                Ok(__FieldTag::__transparent_hugepage_enabled)
                            }
                            "transparent_hugepage_enabled" => {
                                Ok(__FieldTag::__transparent_hugepage_enabled)
                            }
                            "transparentHugepageDefrag" => {
                                Ok(__FieldTag::__transparent_hugepage_defrag)
                            }
                            "transparent_hugepage_defrag" => {
                                Ok(__FieldTag::__transparent_hugepage_defrag)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LinuxNodeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LinuxNodeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sysctls => {
                            if !fields.insert(__FieldTag::__sysctls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sysctls",
                                ));
                            }
                            result.sysctls = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cgroup_mode => {
                            if !fields.insert(__FieldTag::__cgroup_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cgroup_mode",
                                ));
                            }
                            result.cgroup_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::linux_node_config::CgroupMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hugepages => {
                            if !fields.insert(__FieldTag::__hugepages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hugepages",
                                ));
                            }
                            result.hugepages = map.next_value::<std::option::Option<
                                crate::model::linux_node_config::HugepagesConfig,
                            >>()?;
                        }
                        __FieldTag::__transparent_hugepage_enabled => {
                            if !fields.insert(__FieldTag::__transparent_hugepage_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transparent_hugepage_enabled",
                                ));
                            }
                            result.transparent_hugepage_enabled = map
                                .next_value::<std::option::Option<
                                    crate::model::linux_node_config::TransparentHugepageEnabled,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transparent_hugepage_defrag => {
                            if !fields.insert(__FieldTag::__transparent_hugepage_defrag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transparent_hugepage_defrag",
                                ));
                            }
                            result.transparent_hugepage_defrag = map
                                .next_value::<std::option::Option<
                                    crate::model::linux_node_config::TransparentHugepageDefrag,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LinuxNodeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sysctls.is_empty() {
            state.serialize_entry("sysctls", &self.sysctls)?;
        }
        if !wkt::internal::is_default(&self.cgroup_mode) {
            state.serialize_entry("cgroupMode", &self.cgroup_mode)?;
        }
        if self.hugepages.is_some() {
            state.serialize_entry("hugepages", &self.hugepages)?;
        }
        if !wkt::internal::is_default(&self.transparent_hugepage_enabled) {
            state.serialize_entry(
                "transparentHugepageEnabled",
                &self.transparent_hugepage_enabled,
            )?;
        }
        if !wkt::internal::is_default(&self.transparent_hugepage_defrag) {
            state.serialize_entry(
                "transparentHugepageDefrag",
                &self.transparent_hugepage_defrag,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LinuxNodeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LinuxNodeConfig");
        debug_struct.field("sysctls", &self.sysctls);
        debug_struct.field("cgroup_mode", &self.cgroup_mode);
        debug_struct.field("hugepages", &self.hugepages);
        debug_struct.field(
            "transparent_hugepage_enabled",
            &self.transparent_hugepage_enabled,
        );
        debug_struct.field(
            "transparent_hugepage_defrag",
            &self.transparent_hugepage_defrag,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [LinuxNodeConfig].
pub mod linux_node_config {
    #[allow(unused_imports)]
    use super::*;

    /// Hugepages amount in both 2m and 1g size
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct HugepagesConfig {
        /// Optional. Amount of 2M hugepages
        pub hugepage_size2m: std::option::Option<i32>,

        /// Optional. Amount of 1G hugepages
        pub hugepage_size1g: std::option::Option<i32>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl HugepagesConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [hugepage_size2m][crate::model::linux_node_config::HugepagesConfig::hugepage_size2m].
        pub fn set_hugepage_size2m<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.hugepage_size2m = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [hugepage_size2m][crate::model::linux_node_config::HugepagesConfig::hugepage_size2m].
        pub fn set_or_clear_hugepage_size2m<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.hugepage_size2m = v.map(|x| x.into());
            self
        }

        /// Sets the value of [hugepage_size1g][crate::model::linux_node_config::HugepagesConfig::hugepage_size1g].
        pub fn set_hugepage_size1g<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.hugepage_size1g = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [hugepage_size1g][crate::model::linux_node_config::HugepagesConfig::hugepage_size1g].
        pub fn set_or_clear_hugepage_size1g<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.hugepage_size1g = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for HugepagesConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.LinuxNodeConfig.HugepagesConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for HugepagesConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __hugepage_size2m,
                __hugepage_size1g,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for HugepagesConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "hugepageSize2m" => Ok(__FieldTag::__hugepage_size2m),
                                "hugepage_size2m" => Ok(__FieldTag::__hugepage_size2m),
                                "hugepageSize1g" => Ok(__FieldTag::__hugepage_size1g),
                                "hugepage_size1g" => Ok(__FieldTag::__hugepage_size1g),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = HugepagesConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct HugepagesConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__hugepage_size2m => {
                                if !fields.insert(__FieldTag::__hugepage_size2m) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hugepage_size2m",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.hugepage_size2m = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::__hugepage_size1g => {
                                if !fields.insert(__FieldTag::__hugepage_size1g) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hugepage_size1g",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.hugepage_size1g = map.next_value::<__With>()?.0;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for HugepagesConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.hugepage_size2m.is_some() {
                struct __With<'a>(&'a std::option::Option<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("hugepageSize2m", &__With(&self.hugepage_size2m))?;
            }
            if self.hugepage_size1g.is_some() {
                struct __With<'a>(&'a std::option::Option<i32>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("hugepageSize1g", &__With(&self.hugepage_size1g))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for HugepagesConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("HugepagesConfig");
            debug_struct.field("hugepage_size2m", &self.hugepage_size2m);
            debug_struct.field("hugepage_size1g", &self.hugepage_size1g);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Possible cgroup modes that can be used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CgroupMode {
        /// CGROUP_MODE_UNSPECIFIED is when unspecified cgroup configuration is used.
        /// The default for the GKE node OS image will be used.
        Unspecified,
        /// CGROUP_MODE_V1 specifies to use cgroupv1 for the cgroup configuration on
        /// the node image.
        V1,
        /// CGROUP_MODE_V2 specifies to use cgroupv2 for the cgroup configuration on
        /// the node image.
        V2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CgroupMode::value] or
        /// [CgroupMode::name].
        UnknownValue(cgroup_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cgroup_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CgroupMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::V1 => std::option::Option::Some(1),
                Self::V2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CGROUP_MODE_UNSPECIFIED"),
                Self::V1 => std::option::Option::Some("CGROUP_MODE_V1"),
                Self::V2 => std::option::Option::Some("CGROUP_MODE_V2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CgroupMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CgroupMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CgroupMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::V1,
                2 => Self::V2,
                _ => Self::UnknownValue(cgroup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CgroupMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CGROUP_MODE_UNSPECIFIED" => Self::Unspecified,
                "CGROUP_MODE_V1" => Self::V1,
                "CGROUP_MODE_V2" => Self::V2,
                _ => Self::UnknownValue(cgroup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CgroupMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::V1 => serializer.serialize_i32(1),
                Self::V2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CgroupMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CgroupMode>::new(
                ".google.container.v1.LinuxNodeConfig.CgroupMode",
            ))
        }
    }

    /// Possible values for transparent hugepage enabled support.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TransparentHugepageEnabled {
        /// Default value. GKE will not modify the kernel configuration.
        Unspecified,
        /// Transparent hugepage support for anonymous memory is enabled system wide.
        Always,
        /// Transparent hugepage support for anonymous memory is enabled inside
        /// MADV_HUGEPAGE regions. This is the default kernel configuration.
        Madvise,
        /// Transparent hugepage support for anonymous memory is disabled.
        Never,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TransparentHugepageEnabled::value] or
        /// [TransparentHugepageEnabled::name].
        UnknownValue(transparent_hugepage_enabled::UnknownValue),
    }

    #[doc(hidden)]
    pub mod transparent_hugepage_enabled {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TransparentHugepageEnabled {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Always => std::option::Option::Some(1),
                Self::Madvise => std::option::Option::Some(2),
                Self::Never => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("TRANSPARENT_HUGEPAGE_ENABLED_UNSPECIFIED")
                }
                Self::Always => std::option::Option::Some("TRANSPARENT_HUGEPAGE_ENABLED_ALWAYS"),
                Self::Madvise => std::option::Option::Some("TRANSPARENT_HUGEPAGE_ENABLED_MADVISE"),
                Self::Never => std::option::Option::Some("TRANSPARENT_HUGEPAGE_ENABLED_NEVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TransparentHugepageEnabled {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TransparentHugepageEnabled {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TransparentHugepageEnabled {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Always,
                2 => Self::Madvise,
                3 => Self::Never,
                _ => Self::UnknownValue(transparent_hugepage_enabled::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TransparentHugepageEnabled {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRANSPARENT_HUGEPAGE_ENABLED_UNSPECIFIED" => Self::Unspecified,
                "TRANSPARENT_HUGEPAGE_ENABLED_ALWAYS" => Self::Always,
                "TRANSPARENT_HUGEPAGE_ENABLED_MADVISE" => Self::Madvise,
                "TRANSPARENT_HUGEPAGE_ENABLED_NEVER" => Self::Never,
                _ => Self::UnknownValue(transparent_hugepage_enabled::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TransparentHugepageEnabled {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Always => serializer.serialize_i32(1),
                Self::Madvise => serializer.serialize_i32(2),
                Self::Never => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TransparentHugepageEnabled {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<TransparentHugepageEnabled>::new(
                    ".google.container.v1.LinuxNodeConfig.TransparentHugepageEnabled",
                ),
            )
        }
    }

    /// Possible values for transparent hugepage defrag support.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TransparentHugepageDefrag {
        /// Default value. GKE will not modify the kernel configuration.
        Unspecified,
        /// It means that an application requesting THP will stall on allocation
        /// failure and directly reclaim pages and compact memory in an effort to
        /// allocate a THP immediately.
        Always,
        /// It means that an application will wake kswapd in the background to
        /// reclaim pages and wake kcompactd to compact memory so that THP is
        /// available in the near future. Itâ€™s the responsibility of khugepaged to
        /// then install the THP pages later.
        Defer,
        /// It means that an application will enter direct reclaim and compaction
        /// like always, but only for regions that have used madvise(MADV_HUGEPAGE);
        /// all other regions will wake kswapd in the background to reclaim pages and
        /// wake kcompactd to compact memory so that THP is available in the near
        /// future.
        DeferWithMadvise,
        /// It means that an application will enter direct reclaim like always but
        /// only for regions that are have used madvise(MADV_HUGEPAGE). This is the
        /// default kernel configuration.
        Madvise,
        /// It means that an application will never enter direct reclaim or
        /// compaction.
        Never,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TransparentHugepageDefrag::value] or
        /// [TransparentHugepageDefrag::name].
        UnknownValue(transparent_hugepage_defrag::UnknownValue),
    }

    #[doc(hidden)]
    pub mod transparent_hugepage_defrag {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TransparentHugepageDefrag {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Always => std::option::Option::Some(1),
                Self::Defer => std::option::Option::Some(2),
                Self::DeferWithMadvise => std::option::Option::Some(3),
                Self::Madvise => std::option::Option::Some(4),
                Self::Never => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("TRANSPARENT_HUGEPAGE_DEFRAG_UNSPECIFIED")
                }
                Self::Always => std::option::Option::Some("TRANSPARENT_HUGEPAGE_DEFRAG_ALWAYS"),
                Self::Defer => std::option::Option::Some("TRANSPARENT_HUGEPAGE_DEFRAG_DEFER"),
                Self::DeferWithMadvise => {
                    std::option::Option::Some("TRANSPARENT_HUGEPAGE_DEFRAG_DEFER_WITH_MADVISE")
                }
                Self::Madvise => std::option::Option::Some("TRANSPARENT_HUGEPAGE_DEFRAG_MADVISE"),
                Self::Never => std::option::Option::Some("TRANSPARENT_HUGEPAGE_DEFRAG_NEVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TransparentHugepageDefrag {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TransparentHugepageDefrag {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TransparentHugepageDefrag {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Always,
                2 => Self::Defer,
                3 => Self::DeferWithMadvise,
                4 => Self::Madvise,
                5 => Self::Never,
                _ => Self::UnknownValue(transparent_hugepage_defrag::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TransparentHugepageDefrag {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRANSPARENT_HUGEPAGE_DEFRAG_UNSPECIFIED" => Self::Unspecified,
                "TRANSPARENT_HUGEPAGE_DEFRAG_ALWAYS" => Self::Always,
                "TRANSPARENT_HUGEPAGE_DEFRAG_DEFER" => Self::Defer,
                "TRANSPARENT_HUGEPAGE_DEFRAG_DEFER_WITH_MADVISE" => Self::DeferWithMadvise,
                "TRANSPARENT_HUGEPAGE_DEFRAG_MADVISE" => Self::Madvise,
                "TRANSPARENT_HUGEPAGE_DEFRAG_NEVER" => Self::Never,
                _ => Self::UnknownValue(transparent_hugepage_defrag::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TransparentHugepageDefrag {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Always => serializer.serialize_i32(1),
                Self::Defer => serializer.serialize_i32(2),
                Self::DeferWithMadvise => serializer.serialize_i32(3),
                Self::Madvise => serializer.serialize_i32(4),
                Self::Never => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TransparentHugepageDefrag {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<TransparentHugepageDefrag>::new(
                    ".google.container.v1.LinuxNodeConfig.TransparentHugepageDefrag",
                ),
            )
        }
    }
}

/// Parameters that can be configured on Windows nodes.
/// Windows Node Config that define the parameters that will be used to
/// configure the Windows node pool settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WindowsNodeConfig {
    /// OSVersion specifies the Windows node config to be used on the node.
    pub os_version: crate::model::windows_node_config::OSVersion,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WindowsNodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_version][crate::model::WindowsNodeConfig::os_version].
    pub fn set_os_version<T: std::convert::Into<crate::model::windows_node_config::OSVersion>>(
        mut self,
        v: T,
    ) -> Self {
        self.os_version = v.into();
        self
    }
}

impl wkt::message::Message for WindowsNodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.WindowsNodeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WindowsNodeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsNodeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osVersion" => Ok(__FieldTag::__os_version),
                            "os_version" => Ok(__FieldTag::__os_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WindowsNodeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsNodeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_version => {
                            if !fields.insert(__FieldTag::__os_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_version",
                                ));
                            }
                            result.os_version =
                                map.next_value::<std::option::Option<
                                    crate::model::windows_node_config::OSVersion,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WindowsNodeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.os_version) {
            state.serialize_entry("osVersion", &self.os_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WindowsNodeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WindowsNodeConfig");
        debug_struct.field("os_version", &self.os_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [WindowsNodeConfig].
pub mod windows_node_config {
    #[allow(unused_imports)]
    use super::*;

    /// Possible OS version that can be used.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OSVersion {
        /// When OSVersion is not specified.
        Unspecified,
        /// LTSC2019 specifies to use LTSC2019 as the Windows Servercore Base Image.
        Ltsc2019,
        /// LTSC2022 specifies to use LTSC2022 as the Windows Servercore Base Image.
        Ltsc2022,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OSVersion::value] or
        /// [OSVersion::name].
        UnknownValue(os_version::UnknownValue),
    }

    #[doc(hidden)]
    pub mod os_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OSVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ltsc2019 => std::option::Option::Some(1),
                Self::Ltsc2022 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OS_VERSION_UNSPECIFIED"),
                Self::Ltsc2019 => std::option::Option::Some("OS_VERSION_LTSC2019"),
                Self::Ltsc2022 => std::option::Option::Some("OS_VERSION_LTSC2022"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OSVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OSVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OSVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ltsc2019,
                2 => Self::Ltsc2022,
                _ => Self::UnknownValue(os_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OSVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OS_VERSION_UNSPECIFIED" => Self::Unspecified,
                "OS_VERSION_LTSC2019" => Self::Ltsc2019,
                "OS_VERSION_LTSC2022" => Self::Ltsc2022,
                _ => Self::UnknownValue(os_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OSVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ltsc2019 => serializer.serialize_i32(1),
                Self::Ltsc2022 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OSVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OSVersion>::new(
                ".google.container.v1.WindowsNodeConfig.OSVersion",
            ))
        }
    }
}

/// Node kubelet configs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeKubeletConfig {
    /// Control the CPU management policy on the node.
    /// See
    /// <https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/>
    ///
    /// The following values are allowed.
    ///
    /// * "none": the default, which represents the existing scheduling behavior.
    /// * "static": allows pods with certain resource characteristics to be granted
    ///   increased CPU affinity and exclusivity on the node.
    ///   The default value is 'none' if unspecified.
    pub cpu_manager_policy: std::string::String,

    /// Optional. Controls Topology Manager configuration on the node.
    /// For more information, see:
    /// <https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/>
    pub topology_manager: std::option::Option<crate::model::TopologyManager>,

    /// Optional. Controls NUMA-aware Memory Manager configuration on the
    /// node. For more information, see:
    /// <https://kubernetes.io/docs/tasks/administer-cluster/memory-manager/>
    pub memory_manager: std::option::Option<crate::model::MemoryManager>,

    /// Enable CPU CFS quota enforcement for containers that specify CPU limits.
    ///
    /// This option is enabled by default which makes kubelet use CFS quota
    /// (<https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt>) to
    /// enforce container CPU limits. Otherwise, CPU limits will not be enforced at
    /// all.
    ///
    /// Disable this option to mitigate CPU throttling problems while still having
    /// your pods to be in Guaranteed QoS class by specifying the CPU limits.
    ///
    /// The default value is 'true' if unspecified.
    pub cpu_cfs_quota: std::option::Option<wkt::BoolValue>,

    /// Set the CPU CFS quota period value 'cpu.cfs_period_us'.
    ///
    /// The string must be a sequence of decimal numbers, each with optional
    /// fraction and a unit suffix, such as "300ms".
    /// Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h".
    /// The value must be a positive duration.
    pub cpu_cfs_quota_period: std::string::String,

    /// Set the Pod PID limits. See
    /// <https://kubernetes.io/docs/concepts/policy/pid-limiting/#pod-pid-limits>
    ///
    /// Controls the maximum number of processes allowed to run in a pod. The value
    /// must be greater than or equal to 1024 and less than 4194304.
    pub pod_pids_limit: i64,

    /// Enable or disable Kubelet read only port.
    pub insecure_kubelet_readonly_port_enabled: std::option::Option<bool>,

    /// Optional. Defines the percent of disk usage before which image garbage
    /// collection is never run. Lowest disk usage to garbage collect to. The
    /// percent is calculated as this field value out of 100.
    ///
    /// The value must be between 10 and 85, inclusive and smaller than
    /// image_gc_high_threshold_percent.
    ///
    /// The default value is 80 if unspecified.
    pub image_gc_low_threshold_percent: i32,

    /// Optional. Defines the percent of disk usage after which image garbage
    /// collection is always run. The percent is calculated as this field value out
    /// of 100.
    ///
    /// The value must be between 10 and 85, inclusive and greater than
    /// image_gc_low_threshold_percent.
    ///
    /// The default value is 85 if unspecified.
    pub image_gc_high_threshold_percent: i32,

    /// Optional. Defines the minimum age for an unused image before it is garbage
    /// collected.
    ///
    /// The string must be a sequence of decimal numbers, each with optional
    /// fraction and a unit suffix, such as "300s", "1.5h", and "2h45m". Valid time
    /// units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h".
    ///
    /// The value must be a positive duration less than or equal to 2 minutes.
    ///
    /// The default value is "2m0s" if unspecified.
    pub image_minimum_gc_age: std::string::String,

    /// Optional. Defines the maximum age an image can be unused before it is
    /// garbage collected. The string must be a sequence of decimal numbers, each
    /// with optional fraction and a unit suffix, such as "300s", "1.5h", and
    /// "2h45m". Valid time units are "ns", "us" (or "Âµs"), "ms", "s", "m", "h".
    ///
    /// The value must be a positive duration greater than image_minimum_gc_age
    /// or "0s".
    ///
    /// The default value is "0s" if unspecified, which disables this field,
    /// meaning images won't be garbage collected based on being unused for too
    /// long.
    pub image_maximum_gc_age: std::string::String,

    /// Optional. Defines the maximum size of the container log file before it is
    /// rotated. See
    /// <https://kubernetes.io/docs/concepts/cluster-administration/logging/#log-rotation>
    ///
    /// Valid format is positive number + unit, e.g. 100Ki, 10Mi. Valid units are
    /// Ki, Mi, Gi.
    /// The value must be between 10Mi and 500Mi, inclusive.
    ///
    /// Note that the total container log size (container_log_max_size *
    /// container_log_max_files) cannot exceed 1% of the total
    /// storage of the node, to avoid disk pressure caused by log files.
    ///
    /// The default value is 10Mi if unspecified.
    pub container_log_max_size: std::string::String,

    /// Optional. Defines the maximum number of container log files that can be
    /// present for a container. See
    /// <https://kubernetes.io/docs/concepts/cluster-administration/logging/#log-rotation>
    ///
    /// The value must be an integer between 2 and 10, inclusive.
    /// The default value is 5 if unspecified.
    pub container_log_max_files: i32,

    /// Optional. Defines a comma-separated allowlist of unsafe sysctls or sysctl
    /// patterns (ending in `*`).
    ///
    /// The unsafe namespaced sysctl groups are `kernel.shm*`, `kernel.msg*`,
    /// `kernel.sem`, `fs.mqueue.*`, and `net.*`. Leaving this allowlist empty
    /// means they cannot be set on Pods.
    ///
    /// To allow certain sysctls or sysctl patterns to be set on Pods, list them
    /// separated by commas.
    /// For example: `kernel.msg*,net.ipv4.route.min_pmtu`.
    ///
    /// See <https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/>
    /// for more details.
    pub allowed_unsafe_sysctls: std::vec::Vec<std::string::String>,

    /// Optional. eviction_soft is a map of signal names to quantities that defines
    /// soft eviction thresholds. Each signal is compared to its corresponding
    /// threshold to determine if a pod eviction should occur.
    pub eviction_soft: std::option::Option<crate::model::EvictionSignals>,

    /// Optional. eviction_soft_grace_period is a map of signal names to quantities
    /// that defines grace periods for each soft eviction signal. The grace period
    /// is the amount of time that a pod must be under pressure before an eviction
    /// occurs.
    pub eviction_soft_grace_period: std::option::Option<crate::model::EvictionGracePeriod>,

    /// Optional. eviction_minimum_reclaim is a map of signal names to quantities
    /// that defines minimum reclaims, which describe the minimum amount of a given
    /// resource the kubelet will reclaim when performing a pod eviction while that
    /// resource is under pressure.
    pub eviction_minimum_reclaim: std::option::Option<crate::model::EvictionMinimumReclaim>,

    /// Optional. eviction_max_pod_grace_period_seconds is the maximum allowed
    /// grace period (in seconds) to use when terminating pods in response to a
    /// soft eviction threshold being met. This value effectively caps the Pod's
    /// terminationGracePeriodSeconds value during soft evictions. Default: 0.
    /// Range: [0, 300].
    pub eviction_max_pod_grace_period_seconds: i32,

    /// Optional. Defines the maximum number of image pulls in parallel.
    /// The range is 2 to 5, inclusive.
    /// The default value is 2 or 3 depending on the disk type.
    ///
    /// See
    /// <https://kubernetes.io/docs/concepts/containers/images/#maximum-parallel-image-pulls>
    /// for more details.
    pub max_parallel_image_pulls: i32,

    /// Optional. Defines whether to enable single process OOM killer.
    /// If true, will prevent the memory.oom.group flag from being set for
    /// container cgroups in cgroups v2. This causes processes in the container to
    /// be OOM killed individually instead of as a group.
    pub single_process_oom_kill: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeKubeletConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_manager_policy][crate::model::NodeKubeletConfig::cpu_manager_policy].
    pub fn set_cpu_manager_policy<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cpu_manager_policy = v.into();
        self
    }

    /// Sets the value of [topology_manager][crate::model::NodeKubeletConfig::topology_manager].
    pub fn set_topology_manager<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TopologyManager>,
    {
        self.topology_manager = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [topology_manager][crate::model::NodeKubeletConfig::topology_manager].
    pub fn set_or_clear_topology_manager<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TopologyManager>,
    {
        self.topology_manager = v.map(|x| x.into());
        self
    }

    /// Sets the value of [memory_manager][crate::model::NodeKubeletConfig::memory_manager].
    pub fn set_memory_manager<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MemoryManager>,
    {
        self.memory_manager = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [memory_manager][crate::model::NodeKubeletConfig::memory_manager].
    pub fn set_or_clear_memory_manager<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MemoryManager>,
    {
        self.memory_manager = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpu_cfs_quota][crate::model::NodeKubeletConfig::cpu_cfs_quota].
    pub fn set_cpu_cfs_quota<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.cpu_cfs_quota = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cpu_cfs_quota][crate::model::NodeKubeletConfig::cpu_cfs_quota].
    pub fn set_or_clear_cpu_cfs_quota<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.cpu_cfs_quota = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpu_cfs_quota_period][crate::model::NodeKubeletConfig::cpu_cfs_quota_period].
    pub fn set_cpu_cfs_quota_period<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cpu_cfs_quota_period = v.into();
        self
    }

    /// Sets the value of [pod_pids_limit][crate::model::NodeKubeletConfig::pod_pids_limit].
    pub fn set_pod_pids_limit<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.pod_pids_limit = v.into();
        self
    }

    /// Sets the value of [insecure_kubelet_readonly_port_enabled][crate::model::NodeKubeletConfig::insecure_kubelet_readonly_port_enabled].
    pub fn set_insecure_kubelet_readonly_port_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.insecure_kubelet_readonly_port_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insecure_kubelet_readonly_port_enabled][crate::model::NodeKubeletConfig::insecure_kubelet_readonly_port_enabled].
    pub fn set_or_clear_insecure_kubelet_readonly_port_enabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.insecure_kubelet_readonly_port_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [image_gc_low_threshold_percent][crate::model::NodeKubeletConfig::image_gc_low_threshold_percent].
    pub fn set_image_gc_low_threshold_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.image_gc_low_threshold_percent = v.into();
        self
    }

    /// Sets the value of [image_gc_high_threshold_percent][crate::model::NodeKubeletConfig::image_gc_high_threshold_percent].
    pub fn set_image_gc_high_threshold_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.image_gc_high_threshold_percent = v.into();
        self
    }

    /// Sets the value of [image_minimum_gc_age][crate::model::NodeKubeletConfig::image_minimum_gc_age].
    pub fn set_image_minimum_gc_age<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.image_minimum_gc_age = v.into();
        self
    }

    /// Sets the value of [image_maximum_gc_age][crate::model::NodeKubeletConfig::image_maximum_gc_age].
    pub fn set_image_maximum_gc_age<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.image_maximum_gc_age = v.into();
        self
    }

    /// Sets the value of [container_log_max_size][crate::model::NodeKubeletConfig::container_log_max_size].
    pub fn set_container_log_max_size<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_log_max_size = v.into();
        self
    }

    /// Sets the value of [container_log_max_files][crate::model::NodeKubeletConfig::container_log_max_files].
    pub fn set_container_log_max_files<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.container_log_max_files = v.into();
        self
    }

    /// Sets the value of [allowed_unsafe_sysctls][crate::model::NodeKubeletConfig::allowed_unsafe_sysctls].
    pub fn set_allowed_unsafe_sysctls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.allowed_unsafe_sysctls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [eviction_soft][crate::model::NodeKubeletConfig::eviction_soft].
    pub fn set_eviction_soft<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EvictionSignals>,
    {
        self.eviction_soft = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [eviction_soft][crate::model::NodeKubeletConfig::eviction_soft].
    pub fn set_or_clear_eviction_soft<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EvictionSignals>,
    {
        self.eviction_soft = v.map(|x| x.into());
        self
    }

    /// Sets the value of [eviction_soft_grace_period][crate::model::NodeKubeletConfig::eviction_soft_grace_period].
    pub fn set_eviction_soft_grace_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EvictionGracePeriod>,
    {
        self.eviction_soft_grace_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [eviction_soft_grace_period][crate::model::NodeKubeletConfig::eviction_soft_grace_period].
    pub fn set_or_clear_eviction_soft_grace_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EvictionGracePeriod>,
    {
        self.eviction_soft_grace_period = v.map(|x| x.into());
        self
    }

    /// Sets the value of [eviction_minimum_reclaim][crate::model::NodeKubeletConfig::eviction_minimum_reclaim].
    pub fn set_eviction_minimum_reclaim<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EvictionMinimumReclaim>,
    {
        self.eviction_minimum_reclaim = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [eviction_minimum_reclaim][crate::model::NodeKubeletConfig::eviction_minimum_reclaim].
    pub fn set_or_clear_eviction_minimum_reclaim<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EvictionMinimumReclaim>,
    {
        self.eviction_minimum_reclaim = v.map(|x| x.into());
        self
    }

    /// Sets the value of [eviction_max_pod_grace_period_seconds][crate::model::NodeKubeletConfig::eviction_max_pod_grace_period_seconds].
    pub fn set_eviction_max_pod_grace_period_seconds<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.eviction_max_pod_grace_period_seconds = v.into();
        self
    }

    /// Sets the value of [max_parallel_image_pulls][crate::model::NodeKubeletConfig::max_parallel_image_pulls].
    pub fn set_max_parallel_image_pulls<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_parallel_image_pulls = v.into();
        self
    }

    /// Sets the value of [single_process_oom_kill][crate::model::NodeKubeletConfig::single_process_oom_kill].
    pub fn set_single_process_oom_kill<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.single_process_oom_kill = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [single_process_oom_kill][crate::model::NodeKubeletConfig::single_process_oom_kill].
    pub fn set_or_clear_single_process_oom_kill<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.single_process_oom_kill = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodeKubeletConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeKubeletConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeKubeletConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpu_manager_policy,
            __topology_manager,
            __memory_manager,
            __cpu_cfs_quota,
            __cpu_cfs_quota_period,
            __pod_pids_limit,
            __insecure_kubelet_readonly_port_enabled,
            __image_gc_low_threshold_percent,
            __image_gc_high_threshold_percent,
            __image_minimum_gc_age,
            __image_maximum_gc_age,
            __container_log_max_size,
            __container_log_max_files,
            __allowed_unsafe_sysctls,
            __eviction_soft,
            __eviction_soft_grace_period,
            __eviction_minimum_reclaim,
            __eviction_max_pod_grace_period_seconds,
            __max_parallel_image_pulls,
            __single_process_oom_kill,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeKubeletConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpuManagerPolicy" => Ok(__FieldTag::__cpu_manager_policy),
                            "cpu_manager_policy" => Ok(__FieldTag::__cpu_manager_policy),
                            "topologyManager" => Ok(__FieldTag::__topology_manager),
                            "topology_manager" => Ok(__FieldTag::__topology_manager),
                            "memoryManager" => Ok(__FieldTag::__memory_manager),
                            "memory_manager" => Ok(__FieldTag::__memory_manager),
                            "cpuCfsQuota" => Ok(__FieldTag::__cpu_cfs_quota),
                            "cpu_cfs_quota" => Ok(__FieldTag::__cpu_cfs_quota),
                            "cpuCfsQuotaPeriod" => Ok(__FieldTag::__cpu_cfs_quota_period),
                            "cpu_cfs_quota_period" => Ok(__FieldTag::__cpu_cfs_quota_period),
                            "podPidsLimit" => Ok(__FieldTag::__pod_pids_limit),
                            "pod_pids_limit" => Ok(__FieldTag::__pod_pids_limit),
                            "insecureKubeletReadonlyPortEnabled" => {
                                Ok(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            }
                            "insecure_kubelet_readonly_port_enabled" => {
                                Ok(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            }
                            "imageGcLowThresholdPercent" => {
                                Ok(__FieldTag::__image_gc_low_threshold_percent)
                            }
                            "image_gc_low_threshold_percent" => {
                                Ok(__FieldTag::__image_gc_low_threshold_percent)
                            }
                            "imageGcHighThresholdPercent" => {
                                Ok(__FieldTag::__image_gc_high_threshold_percent)
                            }
                            "image_gc_high_threshold_percent" => {
                                Ok(__FieldTag::__image_gc_high_threshold_percent)
                            }
                            "imageMinimumGcAge" => Ok(__FieldTag::__image_minimum_gc_age),
                            "image_minimum_gc_age" => Ok(__FieldTag::__image_minimum_gc_age),
                            "imageMaximumGcAge" => Ok(__FieldTag::__image_maximum_gc_age),
                            "image_maximum_gc_age" => Ok(__FieldTag::__image_maximum_gc_age),
                            "containerLogMaxSize" => Ok(__FieldTag::__container_log_max_size),
                            "container_log_max_size" => Ok(__FieldTag::__container_log_max_size),
                            "containerLogMaxFiles" => Ok(__FieldTag::__container_log_max_files),
                            "container_log_max_files" => Ok(__FieldTag::__container_log_max_files),
                            "allowedUnsafeSysctls" => Ok(__FieldTag::__allowed_unsafe_sysctls),
                            "allowed_unsafe_sysctls" => Ok(__FieldTag::__allowed_unsafe_sysctls),
                            "evictionSoft" => Ok(__FieldTag::__eviction_soft),
                            "eviction_soft" => Ok(__FieldTag::__eviction_soft),
                            "evictionSoftGracePeriod" => {
                                Ok(__FieldTag::__eviction_soft_grace_period)
                            }
                            "eviction_soft_grace_period" => {
                                Ok(__FieldTag::__eviction_soft_grace_period)
                            }
                            "evictionMinimumReclaim" => Ok(__FieldTag::__eviction_minimum_reclaim),
                            "eviction_minimum_reclaim" => {
                                Ok(__FieldTag::__eviction_minimum_reclaim)
                            }
                            "evictionMaxPodGracePeriodSeconds" => {
                                Ok(__FieldTag::__eviction_max_pod_grace_period_seconds)
                            }
                            "eviction_max_pod_grace_period_seconds" => {
                                Ok(__FieldTag::__eviction_max_pod_grace_period_seconds)
                            }
                            "maxParallelImagePulls" => Ok(__FieldTag::__max_parallel_image_pulls),
                            "max_parallel_image_pulls" => {
                                Ok(__FieldTag::__max_parallel_image_pulls)
                            }
                            "singleProcessOomKill" => Ok(__FieldTag::__single_process_oom_kill),
                            "single_process_oom_kill" => Ok(__FieldTag::__single_process_oom_kill),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeKubeletConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeKubeletConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpu_manager_policy => {
                            if !fields.insert(__FieldTag::__cpu_manager_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_manager_policy",
                                ));
                            }
                            result.cpu_manager_policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__topology_manager => {
                            if !fields.insert(__FieldTag::__topology_manager) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topology_manager",
                                ));
                            }
                            result.topology_manager = map
                                .next_value::<std::option::Option<crate::model::TopologyManager>>(
                                )?;
                        }
                        __FieldTag::__memory_manager => {
                            if !fields.insert(__FieldTag::__memory_manager) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_manager",
                                ));
                            }
                            result.memory_manager = map
                                .next_value::<std::option::Option<crate::model::MemoryManager>>()?;
                        }
                        __FieldTag::__cpu_cfs_quota => {
                            if !fields.insert(__FieldTag::__cpu_cfs_quota) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_cfs_quota",
                                ));
                            }
                            result.cpu_cfs_quota =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__cpu_cfs_quota_period => {
                            if !fields.insert(__FieldTag::__cpu_cfs_quota_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_cfs_quota_period",
                                ));
                            }
                            result.cpu_cfs_quota_period = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_pids_limit => {
                            if !fields.insert(__FieldTag::__pod_pids_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_pids_limit",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pod_pids_limit =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__insecure_kubelet_readonly_port_enabled => {
                            if !fields.insert(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insecure_kubelet_readonly_port_enabled",
                                ));
                            }
                            result.insecure_kubelet_readonly_port_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__image_gc_low_threshold_percent => {
                            if !fields.insert(__FieldTag::__image_gc_low_threshold_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_gc_low_threshold_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.image_gc_low_threshold_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__image_gc_high_threshold_percent => {
                            if !fields.insert(__FieldTag::__image_gc_high_threshold_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_gc_high_threshold_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.image_gc_high_threshold_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__image_minimum_gc_age => {
                            if !fields.insert(__FieldTag::__image_minimum_gc_age) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_minimum_gc_age",
                                ));
                            }
                            result.image_minimum_gc_age = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_maximum_gc_age => {
                            if !fields.insert(__FieldTag::__image_maximum_gc_age) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_maximum_gc_age",
                                ));
                            }
                            result.image_maximum_gc_age = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_log_max_size => {
                            if !fields.insert(__FieldTag::__container_log_max_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_log_max_size",
                                ));
                            }
                            result.container_log_max_size = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_log_max_files => {
                            if !fields.insert(__FieldTag::__container_log_max_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_log_max_files",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.container_log_max_files =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__allowed_unsafe_sysctls => {
                            if !fields.insert(__FieldTag::__allowed_unsafe_sysctls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_unsafe_sysctls",
                                ));
                            }
                            result.allowed_unsafe_sysctls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__eviction_soft => {
                            if !fields.insert(__FieldTag::__eviction_soft) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eviction_soft",
                                ));
                            }
                            result.eviction_soft = map
                                .next_value::<std::option::Option<crate::model::EvictionSignals>>(
                                )?;
                        }
                        __FieldTag::__eviction_soft_grace_period => {
                            if !fields.insert(__FieldTag::__eviction_soft_grace_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eviction_soft_grace_period",
                                ));
                            }
                            result.eviction_soft_grace_period = map.next_value::<std::option::Option<crate::model::EvictionGracePeriod>>()?
                                ;
                        }
                        __FieldTag::__eviction_minimum_reclaim => {
                            if !fields.insert(__FieldTag::__eviction_minimum_reclaim) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eviction_minimum_reclaim",
                                ));
                            }
                            result.eviction_minimum_reclaim = map.next_value::<std::option::Option<crate::model::EvictionMinimumReclaim>>()?
                                ;
                        }
                        __FieldTag::__eviction_max_pod_grace_period_seconds => {
                            if !fields.insert(__FieldTag::__eviction_max_pod_grace_period_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eviction_max_pod_grace_period_seconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.eviction_max_pod_grace_period_seconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_parallel_image_pulls => {
                            if !fields.insert(__FieldTag::__max_parallel_image_pulls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_parallel_image_pulls",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_parallel_image_pulls =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__single_process_oom_kill => {
                            if !fields.insert(__FieldTag::__single_process_oom_kill) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_process_oom_kill",
                                ));
                            }
                            result.single_process_oom_kill =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeKubeletConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cpu_manager_policy.is_empty() {
            state.serialize_entry("cpuManagerPolicy", &self.cpu_manager_policy)?;
        }
        if self.topology_manager.is_some() {
            state.serialize_entry("topologyManager", &self.topology_manager)?;
        }
        if self.memory_manager.is_some() {
            state.serialize_entry("memoryManager", &self.memory_manager)?;
        }
        if self.cpu_cfs_quota.is_some() {
            state.serialize_entry("cpuCfsQuota", &self.cpu_cfs_quota)?;
        }
        if !self.cpu_cfs_quota_period.is_empty() {
            state.serialize_entry("cpuCfsQuotaPeriod", &self.cpu_cfs_quota_period)?;
        }
        if !wkt::internal::is_default(&self.pod_pids_limit) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("podPidsLimit", &__With(&self.pod_pids_limit))?;
        }
        if self.insecure_kubelet_readonly_port_enabled.is_some() {
            state.serialize_entry(
                "insecureKubeletReadonlyPortEnabled",
                &self.insecure_kubelet_readonly_port_enabled,
            )?;
        }
        if !wkt::internal::is_default(&self.image_gc_low_threshold_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "imageGcLowThresholdPercent",
                &__With(&self.image_gc_low_threshold_percent),
            )?;
        }
        if !wkt::internal::is_default(&self.image_gc_high_threshold_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "imageGcHighThresholdPercent",
                &__With(&self.image_gc_high_threshold_percent),
            )?;
        }
        if !self.image_minimum_gc_age.is_empty() {
            state.serialize_entry("imageMinimumGcAge", &self.image_minimum_gc_age)?;
        }
        if !self.image_maximum_gc_age.is_empty() {
            state.serialize_entry("imageMaximumGcAge", &self.image_maximum_gc_age)?;
        }
        if !self.container_log_max_size.is_empty() {
            state.serialize_entry("containerLogMaxSize", &self.container_log_max_size)?;
        }
        if !wkt::internal::is_default(&self.container_log_max_files) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "containerLogMaxFiles",
                &__With(&self.container_log_max_files),
            )?;
        }
        if !self.allowed_unsafe_sysctls.is_empty() {
            state.serialize_entry("allowedUnsafeSysctls", &self.allowed_unsafe_sysctls)?;
        }
        if self.eviction_soft.is_some() {
            state.serialize_entry("evictionSoft", &self.eviction_soft)?;
        }
        if self.eviction_soft_grace_period.is_some() {
            state.serialize_entry("evictionSoftGracePeriod", &self.eviction_soft_grace_period)?;
        }
        if self.eviction_minimum_reclaim.is_some() {
            state.serialize_entry("evictionMinimumReclaim", &self.eviction_minimum_reclaim)?;
        }
        if !wkt::internal::is_default(&self.eviction_max_pod_grace_period_seconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "evictionMaxPodGracePeriodSeconds",
                &__With(&self.eviction_max_pod_grace_period_seconds),
            )?;
        }
        if !wkt::internal::is_default(&self.max_parallel_image_pulls) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxParallelImagePulls",
                &__With(&self.max_parallel_image_pulls),
            )?;
        }
        if self.single_process_oom_kill.is_some() {
            state.serialize_entry("singleProcessOomKill", &self.single_process_oom_kill)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodeKubeletConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeKubeletConfig");
        debug_struct.field("cpu_manager_policy", &self.cpu_manager_policy);
        debug_struct.field("topology_manager", &self.topology_manager);
        debug_struct.field("memory_manager", &self.memory_manager);
        debug_struct.field("cpu_cfs_quota", &self.cpu_cfs_quota);
        debug_struct.field("cpu_cfs_quota_period", &self.cpu_cfs_quota_period);
        debug_struct.field("pod_pids_limit", &self.pod_pids_limit);
        debug_struct.field(
            "insecure_kubelet_readonly_port_enabled",
            &self.insecure_kubelet_readonly_port_enabled,
        );
        debug_struct.field(
            "image_gc_low_threshold_percent",
            &self.image_gc_low_threshold_percent,
        );
        debug_struct.field(
            "image_gc_high_threshold_percent",
            &self.image_gc_high_threshold_percent,
        );
        debug_struct.field("image_minimum_gc_age", &self.image_minimum_gc_age);
        debug_struct.field("image_maximum_gc_age", &self.image_maximum_gc_age);
        debug_struct.field("container_log_max_size", &self.container_log_max_size);
        debug_struct.field("container_log_max_files", &self.container_log_max_files);
        debug_struct.field("allowed_unsafe_sysctls", &self.allowed_unsafe_sysctls);
        debug_struct.field("eviction_soft", &self.eviction_soft);
        debug_struct.field(
            "eviction_soft_grace_period",
            &self.eviction_soft_grace_period,
        );
        debug_struct.field("eviction_minimum_reclaim", &self.eviction_minimum_reclaim);
        debug_struct.field(
            "eviction_max_pod_grace_period_seconds",
            &self.eviction_max_pod_grace_period_seconds,
        );
        debug_struct.field("max_parallel_image_pulls", &self.max_parallel_image_pulls);
        debug_struct.field("single_process_oom_kill", &self.single_process_oom_kill);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// TopologyManager defines the configuration options for Topology Manager
/// feature. See
/// <https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TopologyManager {
    /// Configures the strategy for resource alignment.
    /// Allowed values are:
    ///
    /// * none: the default policy, and does not perform any topology alignment.
    /// * restricted: the topology manager stores the preferred NUMA node affinity
    ///   for the container, and will reject the pod if the affinity if not
    ///   preferred.
    /// * best-effort: the topology manager stores the preferred NUMA node affinity
    ///   for the container. If the affinity is not preferred, the topology manager
    ///   will admit the pod to the node anyway.
    /// * single-numa-node: the topology manager determines if the single NUMA node
    ///   affinity is possible. If it is, Topology Manager will store this and the
    ///   Hint Providers can then use this information when making the resource
    ///   allocation decision. If, however, this is not possible then the
    ///   Topology Manager will reject the pod from the node. This will result in a
    ///   pod in a Terminated state with a pod admission failure.
    ///
    /// The default policy value is 'none' if unspecified.
    /// Details about each strategy can be found
    /// [here](https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/#topology-manager-policies).
    pub policy: std::string::String,

    /// The Topology Manager aligns resources in following scopes:
    ///
    /// * container
    /// * pod
    ///
    /// The default scope is 'container' if unspecified.
    /// See
    /// <https://kubernetes.io/docs/tasks/administer-cluster/topology-manager/#topology-manager-scopes>
    pub scope: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TopologyManager {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::TopologyManager::policy].
    pub fn set_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [scope][crate::model::TopologyManager::scope].
    pub fn set_scope<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.scope = v.into();
        self
    }
}

impl wkt::message::Message for TopologyManager {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.TopologyManager"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TopologyManager {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy,
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TopologyManager")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policy" => Ok(__FieldTag::__policy),
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TopologyManager;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TopologyManager")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TopologyManager {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policy.is_empty() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TopologyManager {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TopologyManager");
        debug_struct.field("policy", &self.policy);
        debug_struct.field("scope", &self.scope);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The option enables the Kubernetes NUMA-aware Memory Manager feature.
/// Detailed description about the feature can be found
/// [here](https://kubernetes.io/docs/tasks/administer-cluster/memory-manager/).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MemoryManager {
    /// Controls the memory management policy on the Node.
    /// See
    /// <https://kubernetes.io/docs/tasks/administer-cluster/memory-manager/#policies>
    ///
    /// The following values are allowed.
    ///
    /// * "none"
    /// * "static"
    ///   The default value is 'none' if unspecified.
    pub policy: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MemoryManager {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::MemoryManager::policy].
    pub fn set_policy<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.policy = v.into();
        self
    }
}

impl wkt::message::Message for MemoryManager {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MemoryManager"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MemoryManager {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MemoryManager")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policy" => Ok(__FieldTag::__policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MemoryManager;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MemoryManager")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MemoryManager {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policy.is_empty() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MemoryManager {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MemoryManager");
        debug_struct.field("policy", &self.policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Eviction signals are the current state of a particular resource at a specific
/// point in time. The kubelet uses eviction signals to make eviction decisions
/// by comparing the signals to eviction thresholds, which are the minimum amount
/// of the resource that should be available on the node.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvictionSignals {
    /// Optional. Memory available (i.e. capacity - workingSet), in bytes. Defines
    /// the amount of "memory.available" signal in kubelet. Default is unset, if
    /// not specified in the kubelet config. Format: positive number + unit, e.g.
    /// 100Ki, 10Mi, 5Gi. Valid units are Ki, Mi, Gi. Must be >= 100Mi and <= 50%
    /// of the node's memory. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub memory_available: std::string::String,

    /// Optional. Amount of storage available on filesystem that kubelet uses for
    /// volumes, daemon logs, etc. Defines the amount of "nodefs.available" signal
    /// in kubelet. Default is unset, if not specified in the kubelet config. It
    /// takses percentage value for now. Sample format: "30%". Must be >= 10% and
    /// <= 50%. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub nodefs_available: std::string::String,

    /// Optional. Amount of inodes available on filesystem that kubelet uses for
    /// volumes, daemon logs, etc. Defines the amount of "nodefs.inodesFree" signal
    /// in kubelet. Default is unset, if not specified in the kubelet config. Linux
    /// only. It takses percentage value for now. Sample format: "30%". Must be >=
    /// 5% and <= 50%. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub nodefs_inodes_free: std::string::String,

    /// Optional. Amount of storage available on filesystem that container runtime
    /// uses for storing images layers. If the container filesystem and image
    /// filesystem are not separate, then imagefs can store both image layers and
    /// writeable layers. Defines the amount of "imagefs.available" signal in
    /// kubelet. Default is unset, if not specified in the kubelet config. It
    /// takses percentage value for now. Sample format: "30%". Must be >= 15% and
    /// <= 50%. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub imagefs_available: std::string::String,

    /// Optional. Amount of inodes available on filesystem that container runtime
    /// uses for storing images layers. Defines the amount of "imagefs.inodesFree"
    /// signal in kubelet. Default is unset, if not specified in the kubelet
    /// config. Linux only. It takses percentage value for now. Sample format:
    /// "30%". Must be >= 5% and <= 50%. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub imagefs_inodes_free: std::string::String,

    /// Optional. Amount of PID available for pod allocation. Defines the amount of
    /// "pid.available" signal in kubelet. Default is unset, if not specified in
    /// the kubelet config. It takses percentage value for now. Sample format:
    /// "30%". Must be >= 10% and <= 50%. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub pid_available: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvictionSignals {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [memory_available][crate::model::EvictionSignals::memory_available].
    pub fn set_memory_available<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.memory_available = v.into();
        self
    }

    /// Sets the value of [nodefs_available][crate::model::EvictionSignals::nodefs_available].
    pub fn set_nodefs_available<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.nodefs_available = v.into();
        self
    }

    /// Sets the value of [nodefs_inodes_free][crate::model::EvictionSignals::nodefs_inodes_free].
    pub fn set_nodefs_inodes_free<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.nodefs_inodes_free = v.into();
        self
    }

    /// Sets the value of [imagefs_available][crate::model::EvictionSignals::imagefs_available].
    pub fn set_imagefs_available<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.imagefs_available = v.into();
        self
    }

    /// Sets the value of [imagefs_inodes_free][crate::model::EvictionSignals::imagefs_inodes_free].
    pub fn set_imagefs_inodes_free<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.imagefs_inodes_free = v.into();
        self
    }

    /// Sets the value of [pid_available][crate::model::EvictionSignals::pid_available].
    pub fn set_pid_available<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pid_available = v.into();
        self
    }
}

impl wkt::message::Message for EvictionSignals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.EvictionSignals"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvictionSignals {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __memory_available,
            __nodefs_available,
            __nodefs_inodes_free,
            __imagefs_available,
            __imagefs_inodes_free,
            __pid_available,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvictionSignals")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "memoryAvailable" => Ok(__FieldTag::__memory_available),
                            "memory_available" => Ok(__FieldTag::__memory_available),
                            "nodefsAvailable" => Ok(__FieldTag::__nodefs_available),
                            "nodefs_available" => Ok(__FieldTag::__nodefs_available),
                            "nodefsInodesFree" => Ok(__FieldTag::__nodefs_inodes_free),
                            "nodefs_inodes_free" => Ok(__FieldTag::__nodefs_inodes_free),
                            "imagefsAvailable" => Ok(__FieldTag::__imagefs_available),
                            "imagefs_available" => Ok(__FieldTag::__imagefs_available),
                            "imagefsInodesFree" => Ok(__FieldTag::__imagefs_inodes_free),
                            "imagefs_inodes_free" => Ok(__FieldTag::__imagefs_inodes_free),
                            "pidAvailable" => Ok(__FieldTag::__pid_available),
                            "pid_available" => Ok(__FieldTag::__pid_available),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvictionSignals;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvictionSignals")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__memory_available => {
                            if !fields.insert(__FieldTag::__memory_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_available",
                                ));
                            }
                            result.memory_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_available => {
                            if !fields.insert(__FieldTag::__nodefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_available",
                                ));
                            }
                            result.nodefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_inodes_free => {
                            if !fields.insert(__FieldTag::__nodefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_inodes_free",
                                ));
                            }
                            result.nodefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_available => {
                            if !fields.insert(__FieldTag::__imagefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_available",
                                ));
                            }
                            result.imagefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_inodes_free => {
                            if !fields.insert(__FieldTag::__imagefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_inodes_free",
                                ));
                            }
                            result.imagefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pid_available => {
                            if !fields.insert(__FieldTag::__pid_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pid_available",
                                ));
                            }
                            result.pid_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvictionSignals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.memory_available.is_empty() {
            state.serialize_entry("memoryAvailable", &self.memory_available)?;
        }
        if !self.nodefs_available.is_empty() {
            state.serialize_entry("nodefsAvailable", &self.nodefs_available)?;
        }
        if !self.nodefs_inodes_free.is_empty() {
            state.serialize_entry("nodefsInodesFree", &self.nodefs_inodes_free)?;
        }
        if !self.imagefs_available.is_empty() {
            state.serialize_entry("imagefsAvailable", &self.imagefs_available)?;
        }
        if !self.imagefs_inodes_free.is_empty() {
            state.serialize_entry("imagefsInodesFree", &self.imagefs_inodes_free)?;
        }
        if !self.pid_available.is_empty() {
            state.serialize_entry("pidAvailable", &self.pid_available)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EvictionSignals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvictionSignals");
        debug_struct.field("memory_available", &self.memory_available);
        debug_struct.field("nodefs_available", &self.nodefs_available);
        debug_struct.field("nodefs_inodes_free", &self.nodefs_inodes_free);
        debug_struct.field("imagefs_available", &self.imagefs_available);
        debug_struct.field("imagefs_inodes_free", &self.imagefs_inodes_free);
        debug_struct.field("pid_available", &self.pid_available);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Eviction grace periods are grace periods for each eviction signal.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvictionGracePeriod {
    /// Optional. Grace period for eviction due to memory available signal. Sample
    /// format: "10s". Must be >= 0. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub memory_available: std::string::String,

    /// Optional. Grace period for eviction due to nodefs available signal. Sample
    /// format: "10s". Must be >= 0. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub nodefs_available: std::string::String,

    /// Optional. Grace period for eviction due to nodefs inodes free signal.
    /// Sample format: "10s". Must be >= 0. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub nodefs_inodes_free: std::string::String,

    /// Optional. Grace period for eviction due to imagefs available signal. Sample
    /// format: "10s". Must be >= 0. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub imagefs_available: std::string::String,

    /// Optional. Grace period for eviction due to imagefs inodes free signal.
    /// Sample format: "10s". Must be >= 0. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub imagefs_inodes_free: std::string::String,

    /// Optional. Grace period for eviction due to pid available signal. Sample
    /// format: "10s". Must be >= 0. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub pid_available: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvictionGracePeriod {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [memory_available][crate::model::EvictionGracePeriod::memory_available].
    pub fn set_memory_available<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.memory_available = v.into();
        self
    }

    /// Sets the value of [nodefs_available][crate::model::EvictionGracePeriod::nodefs_available].
    pub fn set_nodefs_available<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.nodefs_available = v.into();
        self
    }

    /// Sets the value of [nodefs_inodes_free][crate::model::EvictionGracePeriod::nodefs_inodes_free].
    pub fn set_nodefs_inodes_free<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.nodefs_inodes_free = v.into();
        self
    }

    /// Sets the value of [imagefs_available][crate::model::EvictionGracePeriod::imagefs_available].
    pub fn set_imagefs_available<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.imagefs_available = v.into();
        self
    }

    /// Sets the value of [imagefs_inodes_free][crate::model::EvictionGracePeriod::imagefs_inodes_free].
    pub fn set_imagefs_inodes_free<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.imagefs_inodes_free = v.into();
        self
    }

    /// Sets the value of [pid_available][crate::model::EvictionGracePeriod::pid_available].
    pub fn set_pid_available<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pid_available = v.into();
        self
    }
}

impl wkt::message::Message for EvictionGracePeriod {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.EvictionGracePeriod"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvictionGracePeriod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __memory_available,
            __nodefs_available,
            __nodefs_inodes_free,
            __imagefs_available,
            __imagefs_inodes_free,
            __pid_available,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvictionGracePeriod")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "memoryAvailable" => Ok(__FieldTag::__memory_available),
                            "memory_available" => Ok(__FieldTag::__memory_available),
                            "nodefsAvailable" => Ok(__FieldTag::__nodefs_available),
                            "nodefs_available" => Ok(__FieldTag::__nodefs_available),
                            "nodefsInodesFree" => Ok(__FieldTag::__nodefs_inodes_free),
                            "nodefs_inodes_free" => Ok(__FieldTag::__nodefs_inodes_free),
                            "imagefsAvailable" => Ok(__FieldTag::__imagefs_available),
                            "imagefs_available" => Ok(__FieldTag::__imagefs_available),
                            "imagefsInodesFree" => Ok(__FieldTag::__imagefs_inodes_free),
                            "imagefs_inodes_free" => Ok(__FieldTag::__imagefs_inodes_free),
                            "pidAvailable" => Ok(__FieldTag::__pid_available),
                            "pid_available" => Ok(__FieldTag::__pid_available),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvictionGracePeriod;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvictionGracePeriod")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__memory_available => {
                            if !fields.insert(__FieldTag::__memory_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_available",
                                ));
                            }
                            result.memory_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_available => {
                            if !fields.insert(__FieldTag::__nodefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_available",
                                ));
                            }
                            result.nodefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_inodes_free => {
                            if !fields.insert(__FieldTag::__nodefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_inodes_free",
                                ));
                            }
                            result.nodefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_available => {
                            if !fields.insert(__FieldTag::__imagefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_available",
                                ));
                            }
                            result.imagefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_inodes_free => {
                            if !fields.insert(__FieldTag::__imagefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_inodes_free",
                                ));
                            }
                            result.imagefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pid_available => {
                            if !fields.insert(__FieldTag::__pid_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pid_available",
                                ));
                            }
                            result.pid_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvictionGracePeriod {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.memory_available.is_empty() {
            state.serialize_entry("memoryAvailable", &self.memory_available)?;
        }
        if !self.nodefs_available.is_empty() {
            state.serialize_entry("nodefsAvailable", &self.nodefs_available)?;
        }
        if !self.nodefs_inodes_free.is_empty() {
            state.serialize_entry("nodefsInodesFree", &self.nodefs_inodes_free)?;
        }
        if !self.imagefs_available.is_empty() {
            state.serialize_entry("imagefsAvailable", &self.imagefs_available)?;
        }
        if !self.imagefs_inodes_free.is_empty() {
            state.serialize_entry("imagefsInodesFree", &self.imagefs_inodes_free)?;
        }
        if !self.pid_available.is_empty() {
            state.serialize_entry("pidAvailable", &self.pid_available)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EvictionGracePeriod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvictionGracePeriod");
        debug_struct.field("memory_available", &self.memory_available);
        debug_struct.field("nodefs_available", &self.nodefs_available);
        debug_struct.field("nodefs_inodes_free", &self.nodefs_inodes_free);
        debug_struct.field("imagefs_available", &self.imagefs_available);
        debug_struct.field("imagefs_inodes_free", &self.imagefs_inodes_free);
        debug_struct.field("pid_available", &self.pid_available);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Eviction minimum reclaims are the resource amounts of minimum reclaims for
/// each eviction signal.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EvictionMinimumReclaim {
    /// Optional. Minimum reclaim for eviction due to memory available signal. Only
    /// take percentage value for now. Sample format: "10%". Must be <=10%. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub memory_available: std::string::String,

    /// Optional. Minimum reclaim for eviction due to nodefs available signal. Only
    /// take percentage value for now. Sample format: "10%". Must be <=10%. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub nodefs_available: std::string::String,

    /// Optional. Minimum reclaim for eviction due to nodefs inodes free signal.
    /// Only take percentage value for now. Sample format: "10%". Must be <=10%.
    /// See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub nodefs_inodes_free: std::string::String,

    /// Optional. Minimum reclaim for eviction due to imagefs available signal.
    /// Only take percentage value for now. Sample format: "10%". Must be <=10%.
    /// See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub imagefs_available: std::string::String,

    /// Optional. Minimum reclaim for eviction due to imagefs inodes free signal.
    /// Only take percentage value for now. Sample format: "10%". Must be <=10%.
    /// See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub imagefs_inodes_free: std::string::String,

    /// Optional. Minimum reclaim for eviction due to pid available signal. Only
    /// take percentage value for now. Sample format: "10%". Must be <=10%. See
    /// <https://kubernetes.io/docs/concepts/scheduling-eviction/node-pressure-eviction/#eviction-signals>
    pub pid_available: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EvictionMinimumReclaim {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [memory_available][crate::model::EvictionMinimumReclaim::memory_available].
    pub fn set_memory_available<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.memory_available = v.into();
        self
    }

    /// Sets the value of [nodefs_available][crate::model::EvictionMinimumReclaim::nodefs_available].
    pub fn set_nodefs_available<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.nodefs_available = v.into();
        self
    }

    /// Sets the value of [nodefs_inodes_free][crate::model::EvictionMinimumReclaim::nodefs_inodes_free].
    pub fn set_nodefs_inodes_free<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.nodefs_inodes_free = v.into();
        self
    }

    /// Sets the value of [imagefs_available][crate::model::EvictionMinimumReclaim::imagefs_available].
    pub fn set_imagefs_available<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.imagefs_available = v.into();
        self
    }

    /// Sets the value of [imagefs_inodes_free][crate::model::EvictionMinimumReclaim::imagefs_inodes_free].
    pub fn set_imagefs_inodes_free<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.imagefs_inodes_free = v.into();
        self
    }

    /// Sets the value of [pid_available][crate::model::EvictionMinimumReclaim::pid_available].
    pub fn set_pid_available<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pid_available = v.into();
        self
    }
}

impl wkt::message::Message for EvictionMinimumReclaim {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.EvictionMinimumReclaim"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EvictionMinimumReclaim {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __memory_available,
            __nodefs_available,
            __nodefs_inodes_free,
            __imagefs_available,
            __imagefs_inodes_free,
            __pid_available,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvictionMinimumReclaim")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "memoryAvailable" => Ok(__FieldTag::__memory_available),
                            "memory_available" => Ok(__FieldTag::__memory_available),
                            "nodefsAvailable" => Ok(__FieldTag::__nodefs_available),
                            "nodefs_available" => Ok(__FieldTag::__nodefs_available),
                            "nodefsInodesFree" => Ok(__FieldTag::__nodefs_inodes_free),
                            "nodefs_inodes_free" => Ok(__FieldTag::__nodefs_inodes_free),
                            "imagefsAvailable" => Ok(__FieldTag::__imagefs_available),
                            "imagefs_available" => Ok(__FieldTag::__imagefs_available),
                            "imagefsInodesFree" => Ok(__FieldTag::__imagefs_inodes_free),
                            "imagefs_inodes_free" => Ok(__FieldTag::__imagefs_inodes_free),
                            "pidAvailable" => Ok(__FieldTag::__pid_available),
                            "pid_available" => Ok(__FieldTag::__pid_available),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EvictionMinimumReclaim;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvictionMinimumReclaim")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__memory_available => {
                            if !fields.insert(__FieldTag::__memory_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_available",
                                ));
                            }
                            result.memory_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_available => {
                            if !fields.insert(__FieldTag::__nodefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_available",
                                ));
                            }
                            result.nodefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_inodes_free => {
                            if !fields.insert(__FieldTag::__nodefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_inodes_free",
                                ));
                            }
                            result.nodefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_available => {
                            if !fields.insert(__FieldTag::__imagefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_available",
                                ));
                            }
                            result.imagefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_inodes_free => {
                            if !fields.insert(__FieldTag::__imagefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_inodes_free",
                                ));
                            }
                            result.imagefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pid_available => {
                            if !fields.insert(__FieldTag::__pid_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pid_available",
                                ));
                            }
                            result.pid_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EvictionMinimumReclaim {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.memory_available.is_empty() {
            state.serialize_entry("memoryAvailable", &self.memory_available)?;
        }
        if !self.nodefs_available.is_empty() {
            state.serialize_entry("nodefsAvailable", &self.nodefs_available)?;
        }
        if !self.nodefs_inodes_free.is_empty() {
            state.serialize_entry("nodefsInodesFree", &self.nodefs_inodes_free)?;
        }
        if !self.imagefs_available.is_empty() {
            state.serialize_entry("imagefsAvailable", &self.imagefs_available)?;
        }
        if !self.imagefs_inodes_free.is_empty() {
            state.serialize_entry("imagefsInodesFree", &self.imagefs_inodes_free)?;
        }
        if !self.pid_available.is_empty() {
            state.serialize_entry("pidAvailable", &self.pid_available)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EvictionMinimumReclaim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvictionMinimumReclaim");
        debug_struct.field("memory_available", &self.memory_available);
        debug_struct.field("nodefs_available", &self.nodefs_available);
        debug_struct.field("nodefs_inodes_free", &self.nodefs_inodes_free);
        debug_struct.field("imagefs_available", &self.imagefs_available);
        debug_struct.field("imagefs_inodes_free", &self.imagefs_inodes_free);
        debug_struct.field("pid_available", &self.pid_available);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Parameters that describe the nodes in a cluster.
///
/// GKE Autopilot clusters do not
/// recognize parameters in `NodeConfig`. Use
/// [AutoprovisioningNodePoolDefaults][google.container.v1.AutoprovisioningNodePoolDefaults]
/// instead.
///
/// [google.container.v1.AutoprovisioningNodePoolDefaults]: crate::model::AutoprovisioningNodePoolDefaults
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeConfig {
    /// The name of a Google Compute Engine [machine
    /// type](https://cloud.google.com/compute/docs/machine-types)
    ///
    /// If unspecified, the default machine type is `e2-medium`.
    pub machine_type: std::string::String,

    /// Size of the disk attached to each node, specified in GB.
    /// The smallest allowed disk size is 10GB.
    ///
    /// If unspecified, the default disk size is 100GB.
    pub disk_size_gb: i32,

    /// The set of Google API scopes to be made available on all of the
    /// node VMs under the "default" service account.
    ///
    /// The following scopes are recommended, but not required, and by default are
    /// not included:
    ///
    /// * `<https://www.googleapis.com/auth/compute>` is required for mounting
    ///   persistent storage on your nodes.
    /// * `<https://www.googleapis.com/auth/devstorage.read_only>` is required for
    ///   communicating with **gcr.io**
    ///   (the [Google Container
    ///   Registry](https://cloud.google.com/container-registry/)).
    ///
    /// If unspecified, no scopes are added, unless Cloud Logging or Cloud
    /// Monitoring are enabled, in which case their required scopes will be added.
    pub oauth_scopes: std::vec::Vec<std::string::String>,

    /// The Google Cloud Platform Service Account to be used by the node VMs.
    /// Specify the email address of the Service Account; otherwise, if no Service
    /// Account is specified, the "default" service account is used.
    pub service_account: std::string::String,

    /// The metadata key/value pairs assigned to instances in the cluster.
    ///
    /// Keys must conform to the regexp `[a-zA-Z0-9-_]+` and be less than 128 bytes
    /// in length. These are reflected as part of a URL in the metadata server.
    /// Additionally, to avoid ambiguity, keys must not conflict with any other
    /// metadata keys for the project or be one of the reserved keys:
    ///
    /// - "cluster-location"
    /// - "cluster-name"
    /// - "cluster-uid"
    /// - "configure-sh"
    /// - "containerd-configure-sh"
    /// - "enable-os-login"
    /// - "gci-ensure-gke-docker"
    /// - "gci-metrics-enabled"
    /// - "gci-update-strategy"
    /// - "instance-template"
    /// - "kube-env"
    /// - "startup-script"
    /// - "user-data"
    /// - "disable-address-manager"
    /// - "windows-startup-script-ps1"
    /// - "common-psm1"
    /// - "k8s-node-setup-psm1"
    /// - "install-ssh-psm1"
    /// - "user-profile-psm1"
    ///
    /// Values are free-form strings, and only have meaning as interpreted by
    /// the image running in the instance. The only restriction placed on them is
    /// that each value's size must be less than or equal to 32 KB.
    ///
    /// The total size of all keys and values must be less than 512 KB.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// The image type to use for this node. Note that for a given image type,
    /// the latest version of it will be used. Please see
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/node-images>
    /// for available image types.
    pub image_type: std::string::String,

    /// The map of Kubernetes labels (key/value pairs) to be applied to each node.
    /// These will added in addition to any default label(s) that
    /// Kubernetes may apply to the node.
    /// In case of conflict in label keys, the applied set may differ depending on
    /// the Kubernetes version -- it's best to assume the behavior is undefined
    /// and conflicts should be avoided.
    /// For more information, including usage and the valid values, see:
    /// <https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/>
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The number of local SSD disks to be attached to the node.
    ///
    /// The limit for this value is dependent upon the maximum number of
    /// disks available on a machine per zone. See:
    /// <https://cloud.google.com/compute/docs/disks/local-ssd>
    /// for more information.
    pub local_ssd_count: i32,

    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls and are specified by
    /// the client during cluster or node pool creation. Each tag within the list
    /// must comply with RFC1035.
    pub tags: std::vec::Vec<std::string::String>,

    /// Whether the nodes are created as preemptible VM instances. See:
    /// <https://cloud.google.com/compute/docs/instances/preemptible>
    /// for more information about preemptible VM instances.
    pub preemptible: bool,

    /// A list of hardware accelerators to be attached to each node.
    /// See
    /// <https://cloud.google.com/compute/docs/gpus>
    /// for more information about support for GPUs.
    pub accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or
    /// 'pd-balanced')
    ///
    /// If unspecified, the default disk type is 'pd-standard'
    pub disk_type: std::string::String,

    /// Minimum CPU platform to be used by this instance. The instance may be
    /// scheduled on the specified or newer CPU platform. Applicable values are the
    /// friendly names of CPU platforms, such as
    /// `minCpuPlatform: "Intel Haswell"` or
    /// `minCpuPlatform: "Intel Sandy Bridge"`. For more
    /// information, read [how to specify min CPU
    /// platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
    pub min_cpu_platform: std::string::String,

    /// The workload metadata configuration for this node.
    pub workload_metadata_config: std::option::Option<crate::model::WorkloadMetadataConfig>,

    /// List of kubernetes taints to be applied to each node.
    ///
    /// For more information, including usage and the valid values, see:
    /// <https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/>
    pub taints: std::vec::Vec<crate::model::NodeTaint>,

    /// Sandbox configuration for this node.
    pub sandbox_config: std::option::Option<crate::model::SandboxConfig>,

    /// Setting this field will assign instances of this
    /// pool to run on the specified node group. This is useful for running
    /// workloads on [sole tenant
    /// nodes](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes).
    pub node_group: std::string::String,

    /// The optional reservation affinity. Setting this field will apply
    /// the specified [Zonal Compute
    /// Reservation](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources)
    /// to this node pool.
    pub reservation_affinity: std::option::Option<crate::model::ReservationAffinity>,

    /// Shielded Instance options.
    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    /// Parameters that can be configured on Linux nodes.
    pub linux_node_config: std::option::Option<crate::model::LinuxNodeConfig>,

    /// Node kubelet configs.
    pub kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    /// The Customer Managed Encryption Key used to encrypt the boot disk attached
    /// to each node in the node pool. This should be of the form
    /// projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME].
    /// For more information about protecting resources with Cloud KMS Keys please
    /// see:
    /// <https://cloud.google.com/compute/docs/disks/customer-managed-encryption>
    pub boot_disk_kms_key: std::string::String,

    /// Google Container File System (image streaming) configs.
    pub gcfs_config: std::option::Option<crate::model::GcfsConfig>,

    /// Advanced features for the Compute Engine VM.
    pub advanced_machine_features: std::option::Option<crate::model::AdvancedMachineFeatures>,

    /// Enable or disable gvnic in the node pool.
    pub gvnic: std::option::Option<crate::model::VirtualNIC>,

    /// Spot flag for enabling Spot VM, which is a rebrand of
    /// the existing preemptible flag.
    pub spot: bool,

    /// Confidential nodes config.
    /// All the nodes in the node pool will be Confidential VM once enabled.
    pub confidential_nodes: std::option::Option<crate::model::ConfidentialNodes>,

    /// Enable or disable NCCL fast socket for the node pool.
    pub fast_socket: std::option::Option<crate::model::FastSocket>,

    /// The resource labels for the node pool to use to annotate any related
    /// Google Compute Engine resources.
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Logging configuration.
    pub logging_config: std::option::Option<crate::model::NodePoolLoggingConfig>,

    /// Parameters that can be configured on Windows nodes.
    pub windows_node_config: std::option::Option<crate::model::WindowsNodeConfig>,

    /// Parameters for using raw-block Local NVMe SSDs.
    pub local_nvme_ssd_block_config: std::option::Option<crate::model::LocalNvmeSsdBlockConfig>,

    /// Parameters for the node ephemeral storage using Local SSDs.
    /// If unspecified, ephemeral storage is backed by the boot disk.
    pub ephemeral_storage_local_ssd_config:
        std::option::Option<crate::model::EphemeralStorageLocalSsdConfig>,

    /// Parameters for node pools to be backed by shared sole tenant node groups.
    pub sole_tenant_config: std::option::Option<crate::model::SoleTenantConfig>,

    /// Parameters for containerd customization.
    pub containerd_config: std::option::Option<crate::model::ContainerdConfig>,

    /// A map of resource manager tag keys and values to be attached to the nodes.
    pub resource_manager_tags: std::option::Option<crate::model::ResourceManagerTags>,

    /// Optional. Reserved for future use.
    pub enable_confidential_storage: bool,

    /// List of secondary boot disks attached to the nodes.
    pub secondary_boot_disks: std::vec::Vec<crate::model::SecondaryBootDisk>,

    /// List of Storage Pools where boot disks are provisioned.
    pub storage_pools: std::vec::Vec<std::string::String>,

    /// Secondary boot disk update strategy.
    pub secondary_boot_disk_update_strategy:
        std::option::Option<crate::model::SecondaryBootDiskUpdateStrategy>,

    /// The maximum duration for the nodes to exist.
    /// If unspecified, the nodes can exist indefinitely.
    pub max_run_duration: std::option::Option<wkt::Duration>,

    /// Specifies which method should be used for encrypting the
    /// Local SSDs attached to the node.
    pub local_ssd_encryption_mode:
        std::option::Option<crate::model::node_config::LocalSsdEncryptionMode>,

    /// Output only. effective_cgroup_mode is the cgroup mode actually used by the
    /// node pool. It is determined by the cgroup mode specified in the
    /// LinuxNodeConfig or the default cgroup mode based on the cluster creation
    /// version.
    pub effective_cgroup_mode: crate::model::node_config::EffectiveCgroupMode,

    /// Flex Start flag for enabling Flex Start VM.
    pub flex_start: std::option::Option<bool>,

    /// The boot disk configuration for the node pool.
    pub boot_disk: std::option::Option<crate::model::BootDisk>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::NodeConfig::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::NodeConfig::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [oauth_scopes][crate::model::NodeConfig::oauth_scopes].
    pub fn set_oauth_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.oauth_scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::NodeConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::NodeConfig::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [image_type][crate::model::NodeConfig::image_type].
    pub fn set_image_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NodeConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [local_ssd_count][crate::model::NodeConfig::local_ssd_count].
    pub fn set_local_ssd_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.local_ssd_count = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::NodeConfig::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [preemptible][crate::model::NodeConfig::preemptible].
    pub fn set_preemptible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.preemptible = v.into();
        self
    }

    /// Sets the value of [accelerators][crate::model::NodeConfig::accelerators].
    pub fn set_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disk_type][crate::model::NodeConfig::disk_type].
    pub fn set_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::NodeConfig::min_cpu_platform].
    pub fn set_min_cpu_platform<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_cpu_platform = v.into();
        self
    }

    /// Sets the value of [workload_metadata_config][crate::model::NodeConfig::workload_metadata_config].
    pub fn set_workload_metadata_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadMetadataConfig>,
    {
        self.workload_metadata_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workload_metadata_config][crate::model::NodeConfig::workload_metadata_config].
    pub fn set_or_clear_workload_metadata_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadMetadataConfig>,
    {
        self.workload_metadata_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [taints][crate::model::NodeConfig::taints].
    pub fn set_taints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodeTaint>,
    {
        use std::iter::Iterator;
        self.taints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [sandbox_config][crate::model::NodeConfig::sandbox_config].
    pub fn set_sandbox_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SandboxConfig>,
    {
        self.sandbox_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sandbox_config][crate::model::NodeConfig::sandbox_config].
    pub fn set_or_clear_sandbox_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SandboxConfig>,
    {
        self.sandbox_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_group][crate::model::NodeConfig::node_group].
    pub fn set_node_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_group = v.into();
        self
    }

    /// Sets the value of [reservation_affinity][crate::model::NodeConfig::reservation_affinity].
    pub fn set_reservation_affinity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reservation_affinity][crate::model::NodeConfig::reservation_affinity].
    pub fn set_or_clear_reservation_affinity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::NodeConfig::shielded_instance_config].
    pub fn set_shielded_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_config][crate::model::NodeConfig::shielded_instance_config].
    pub fn set_or_clear_shielded_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [linux_node_config][crate::model::NodeConfig::linux_node_config].
    pub fn set_linux_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LinuxNodeConfig>,
    {
        self.linux_node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [linux_node_config][crate::model::NodeConfig::linux_node_config].
    pub fn set_or_clear_linux_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LinuxNodeConfig>,
    {
        self.linux_node_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kubelet_config][crate::model::NodeConfig::kubelet_config].
    pub fn set_kubelet_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.kubelet_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kubelet_config][crate::model::NodeConfig::kubelet_config].
    pub fn set_or_clear_kubelet_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.kubelet_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boot_disk_kms_key][crate::model::NodeConfig::boot_disk_kms_key].
    pub fn set_boot_disk_kms_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_disk_kms_key = v.into();
        self
    }

    /// Sets the value of [gcfs_config][crate::model::NodeConfig::gcfs_config].
    pub fn set_gcfs_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcfsConfig>,
    {
        self.gcfs_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcfs_config][crate::model::NodeConfig::gcfs_config].
    pub fn set_or_clear_gcfs_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcfsConfig>,
    {
        self.gcfs_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [advanced_machine_features][crate::model::NodeConfig::advanced_machine_features].
    pub fn set_advanced_machine_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_machine_features][crate::model::NodeConfig::advanced_machine_features].
    pub fn set_or_clear_advanced_machine_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gvnic][crate::model::NodeConfig::gvnic].
    pub fn set_gvnic<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VirtualNIC>,
    {
        self.gvnic = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gvnic][crate::model::NodeConfig::gvnic].
    pub fn set_or_clear_gvnic<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VirtualNIC>,
    {
        self.gvnic = v.map(|x| x.into());
        self
    }

    /// Sets the value of [spot][crate::model::NodeConfig::spot].
    pub fn set_spot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.spot = v.into();
        self
    }

    /// Sets the value of [confidential_nodes][crate::model::NodeConfig::confidential_nodes].
    pub fn set_confidential_nodes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialNodes>,
    {
        self.confidential_nodes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_nodes][crate::model::NodeConfig::confidential_nodes].
    pub fn set_or_clear_confidential_nodes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialNodes>,
    {
        self.confidential_nodes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fast_socket][crate::model::NodeConfig::fast_socket].
    pub fn set_fast_socket<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FastSocket>,
    {
        self.fast_socket = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fast_socket][crate::model::NodeConfig::fast_socket].
    pub fn set_or_clear_fast_socket<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FastSocket>,
    {
        self.fast_socket = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_labels][crate::model::NodeConfig::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [logging_config][crate::model::NodeConfig::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolLoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::NodeConfig::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolLoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [windows_node_config][crate::model::NodeConfig::windows_node_config].
    pub fn set_windows_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WindowsNodeConfig>,
    {
        self.windows_node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [windows_node_config][crate::model::NodeConfig::windows_node_config].
    pub fn set_or_clear_windows_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WindowsNodeConfig>,
    {
        self.windows_node_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [local_nvme_ssd_block_config][crate::model::NodeConfig::local_nvme_ssd_block_config].
    pub fn set_local_nvme_ssd_block_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LocalNvmeSsdBlockConfig>,
    {
        self.local_nvme_ssd_block_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [local_nvme_ssd_block_config][crate::model::NodeConfig::local_nvme_ssd_block_config].
    pub fn set_or_clear_local_nvme_ssd_block_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LocalNvmeSsdBlockConfig>,
    {
        self.local_nvme_ssd_block_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ephemeral_storage_local_ssd_config][crate::model::NodeConfig::ephemeral_storage_local_ssd_config].
    pub fn set_ephemeral_storage_local_ssd_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EphemeralStorageLocalSsdConfig>,
    {
        self.ephemeral_storage_local_ssd_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ephemeral_storage_local_ssd_config][crate::model::NodeConfig::ephemeral_storage_local_ssd_config].
    pub fn set_or_clear_ephemeral_storage_local_ssd_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::EphemeralStorageLocalSsdConfig>,
    {
        self.ephemeral_storage_local_ssd_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sole_tenant_config][crate::model::NodeConfig::sole_tenant_config].
    pub fn set_sole_tenant_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SoleTenantConfig>,
    {
        self.sole_tenant_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sole_tenant_config][crate::model::NodeConfig::sole_tenant_config].
    pub fn set_or_clear_sole_tenant_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SoleTenantConfig>,
    {
        self.sole_tenant_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [containerd_config][crate::model::NodeConfig::containerd_config].
    pub fn set_containerd_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContainerdConfig>,
    {
        self.containerd_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [containerd_config][crate::model::NodeConfig::containerd_config].
    pub fn set_or_clear_containerd_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContainerdConfig>,
    {
        self.containerd_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::NodeConfig::resource_manager_tags].
    pub fn set_resource_manager_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceManagerTags>,
    {
        self.resource_manager_tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_manager_tags][crate::model::NodeConfig::resource_manager_tags].
    pub fn set_or_clear_resource_manager_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceManagerTags>,
    {
        self.resource_manager_tags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_confidential_storage][crate::model::NodeConfig::enable_confidential_storage].
    pub fn set_enable_confidential_storage<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_confidential_storage = v.into();
        self
    }

    /// Sets the value of [secondary_boot_disks][crate::model::NodeConfig::secondary_boot_disks].
    pub fn set_secondary_boot_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecondaryBootDisk>,
    {
        use std::iter::Iterator;
        self.secondary_boot_disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [storage_pools][crate::model::NodeConfig::storage_pools].
    pub fn set_storage_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.storage_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [secondary_boot_disk_update_strategy][crate::model::NodeConfig::secondary_boot_disk_update_strategy].
    pub fn set_secondary_boot_disk_update_strategy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecondaryBootDiskUpdateStrategy>,
    {
        self.secondary_boot_disk_update_strategy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secondary_boot_disk_update_strategy][crate::model::NodeConfig::secondary_boot_disk_update_strategy].
    pub fn set_or_clear_secondary_boot_disk_update_strategy<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::SecondaryBootDiskUpdateStrategy>,
    {
        self.secondary_boot_disk_update_strategy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_run_duration][crate::model::NodeConfig::max_run_duration].
    pub fn set_max_run_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_run_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_run_duration][crate::model::NodeConfig::max_run_duration].
    pub fn set_or_clear_max_run_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_run_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [local_ssd_encryption_mode][crate::model::NodeConfig::local_ssd_encryption_mode].
    pub fn set_local_ssd_encryption_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::node_config::LocalSsdEncryptionMode>,
    {
        self.local_ssd_encryption_mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [local_ssd_encryption_mode][crate::model::NodeConfig::local_ssd_encryption_mode].
    pub fn set_or_clear_local_ssd_encryption_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::node_config::LocalSsdEncryptionMode>,
    {
        self.local_ssd_encryption_mode = v.map(|x| x.into());
        self
    }

    /// Sets the value of [effective_cgroup_mode][crate::model::NodeConfig::effective_cgroup_mode].
    pub fn set_effective_cgroup_mode<
        T: std::convert::Into<crate::model::node_config::EffectiveCgroupMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.effective_cgroup_mode = v.into();
        self
    }

    /// Sets the value of [flex_start][crate::model::NodeConfig::flex_start].
    pub fn set_flex_start<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.flex_start = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [flex_start][crate::model::NodeConfig::flex_start].
    pub fn set_or_clear_flex_start<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.flex_start = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boot_disk][crate::model::NodeConfig::boot_disk].
    pub fn set_boot_disk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BootDisk>,
    {
        self.boot_disk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boot_disk][crate::model::NodeConfig::boot_disk].
    pub fn set_or_clear_boot_disk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BootDisk>,
    {
        self.boot_disk = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machine_type,
            __disk_size_gb,
            __oauth_scopes,
            __service_account,
            __metadata,
            __image_type,
            __labels,
            __local_ssd_count,
            __tags,
            __preemptible,
            __accelerators,
            __disk_type,
            __min_cpu_platform,
            __workload_metadata_config,
            __taints,
            __sandbox_config,
            __node_group,
            __reservation_affinity,
            __shielded_instance_config,
            __linux_node_config,
            __kubelet_config,
            __boot_disk_kms_key,
            __gcfs_config,
            __advanced_machine_features,
            __gvnic,
            __spot,
            __confidential_nodes,
            __fast_socket,
            __resource_labels,
            __logging_config,
            __windows_node_config,
            __local_nvme_ssd_block_config,
            __ephemeral_storage_local_ssd_config,
            __sole_tenant_config,
            __containerd_config,
            __resource_manager_tags,
            __enable_confidential_storage,
            __secondary_boot_disks,
            __storage_pools,
            __secondary_boot_disk_update_strategy,
            __max_run_duration,
            __local_ssd_encryption_mode,
            __effective_cgroup_mode,
            __flex_start,
            __boot_disk,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "oauthScopes" => Ok(__FieldTag::__oauth_scopes),
                            "oauth_scopes" => Ok(__FieldTag::__oauth_scopes),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "imageType" => Ok(__FieldTag::__image_type),
                            "image_type" => Ok(__FieldTag::__image_type),
                            "labels" => Ok(__FieldTag::__labels),
                            "localSsdCount" => Ok(__FieldTag::__local_ssd_count),
                            "local_ssd_count" => Ok(__FieldTag::__local_ssd_count),
                            "tags" => Ok(__FieldTag::__tags),
                            "preemptible" => Ok(__FieldTag::__preemptible),
                            "accelerators" => Ok(__FieldTag::__accelerators),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "minCpuPlatform" => Ok(__FieldTag::__min_cpu_platform),
                            "min_cpu_platform" => Ok(__FieldTag::__min_cpu_platform),
                            "workloadMetadataConfig" => Ok(__FieldTag::__workload_metadata_config),
                            "workload_metadata_config" => {
                                Ok(__FieldTag::__workload_metadata_config)
                            }
                            "taints" => Ok(__FieldTag::__taints),
                            "sandboxConfig" => Ok(__FieldTag::__sandbox_config),
                            "sandbox_config" => Ok(__FieldTag::__sandbox_config),
                            "nodeGroup" => Ok(__FieldTag::__node_group),
                            "node_group" => Ok(__FieldTag::__node_group),
                            "reservationAffinity" => Ok(__FieldTag::__reservation_affinity),
                            "reservation_affinity" => Ok(__FieldTag::__reservation_affinity),
                            "shieldedInstanceConfig" => Ok(__FieldTag::__shielded_instance_config),
                            "shielded_instance_config" => {
                                Ok(__FieldTag::__shielded_instance_config)
                            }
                            "linuxNodeConfig" => Ok(__FieldTag::__linux_node_config),
                            "linux_node_config" => Ok(__FieldTag::__linux_node_config),
                            "kubeletConfig" => Ok(__FieldTag::__kubelet_config),
                            "kubelet_config" => Ok(__FieldTag::__kubelet_config),
                            "bootDiskKmsKey" => Ok(__FieldTag::__boot_disk_kms_key),
                            "boot_disk_kms_key" => Ok(__FieldTag::__boot_disk_kms_key),
                            "gcfsConfig" => Ok(__FieldTag::__gcfs_config),
                            "gcfs_config" => Ok(__FieldTag::__gcfs_config),
                            "advancedMachineFeatures" => {
                                Ok(__FieldTag::__advanced_machine_features)
                            }
                            "advanced_machine_features" => {
                                Ok(__FieldTag::__advanced_machine_features)
                            }
                            "gvnic" => Ok(__FieldTag::__gvnic),
                            "spot" => Ok(__FieldTag::__spot),
                            "confidentialNodes" => Ok(__FieldTag::__confidential_nodes),
                            "confidential_nodes" => Ok(__FieldTag::__confidential_nodes),
                            "fastSocket" => Ok(__FieldTag::__fast_socket),
                            "fast_socket" => Ok(__FieldTag::__fast_socket),
                            "resourceLabels" => Ok(__FieldTag::__resource_labels),
                            "resource_labels" => Ok(__FieldTag::__resource_labels),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "windowsNodeConfig" => Ok(__FieldTag::__windows_node_config),
                            "windows_node_config" => Ok(__FieldTag::__windows_node_config),
                            "localNvmeSsdBlockConfig" => {
                                Ok(__FieldTag::__local_nvme_ssd_block_config)
                            }
                            "local_nvme_ssd_block_config" => {
                                Ok(__FieldTag::__local_nvme_ssd_block_config)
                            }
                            "ephemeralStorageLocalSsdConfig" => {
                                Ok(__FieldTag::__ephemeral_storage_local_ssd_config)
                            }
                            "ephemeral_storage_local_ssd_config" => {
                                Ok(__FieldTag::__ephemeral_storage_local_ssd_config)
                            }
                            "soleTenantConfig" => Ok(__FieldTag::__sole_tenant_config),
                            "sole_tenant_config" => Ok(__FieldTag::__sole_tenant_config),
                            "containerdConfig" => Ok(__FieldTag::__containerd_config),
                            "containerd_config" => Ok(__FieldTag::__containerd_config),
                            "resourceManagerTags" => Ok(__FieldTag::__resource_manager_tags),
                            "resource_manager_tags" => Ok(__FieldTag::__resource_manager_tags),
                            "enableConfidentialStorage" => {
                                Ok(__FieldTag::__enable_confidential_storage)
                            }
                            "enable_confidential_storage" => {
                                Ok(__FieldTag::__enable_confidential_storage)
                            }
                            "secondaryBootDisks" => Ok(__FieldTag::__secondary_boot_disks),
                            "secondary_boot_disks" => Ok(__FieldTag::__secondary_boot_disks),
                            "storagePools" => Ok(__FieldTag::__storage_pools),
                            "storage_pools" => Ok(__FieldTag::__storage_pools),
                            "secondaryBootDiskUpdateStrategy" => {
                                Ok(__FieldTag::__secondary_boot_disk_update_strategy)
                            }
                            "secondary_boot_disk_update_strategy" => {
                                Ok(__FieldTag::__secondary_boot_disk_update_strategy)
                            }
                            "maxRunDuration" => Ok(__FieldTag::__max_run_duration),
                            "max_run_duration" => Ok(__FieldTag::__max_run_duration),
                            "localSsdEncryptionMode" => Ok(__FieldTag::__local_ssd_encryption_mode),
                            "local_ssd_encryption_mode" => {
                                Ok(__FieldTag::__local_ssd_encryption_mode)
                            }
                            "effectiveCgroupMode" => Ok(__FieldTag::__effective_cgroup_mode),
                            "effective_cgroup_mode" => Ok(__FieldTag::__effective_cgroup_mode),
                            "flexStart" => Ok(__FieldTag::__flex_start),
                            "flex_start" => Ok(__FieldTag::__flex_start),
                            "bootDisk" => Ok(__FieldTag::__boot_disk),
                            "boot_disk" => Ok(__FieldTag::__boot_disk),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__oauth_scopes => {
                            if !fields.insert(__FieldTag::__oauth_scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_scopes",
                                ));
                            }
                            result.oauth_scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_type => {
                            if !fields.insert(__FieldTag::__image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_type",
                                ));
                            }
                            result.image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__local_ssd_count => {
                            if !fields.insert(__FieldTag::__local_ssd_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_ssd_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.local_ssd_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__preemptible => {
                            if !fields.insert(__FieldTag::__preemptible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preemptible",
                                ));
                            }
                            result.preemptible = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__accelerators => {
                            if !fields.insert(__FieldTag::__accelerators) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerators",
                                ));
                            }
                            result.accelerators =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AcceleratorConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_cpu_platform => {
                            if !fields.insert(__FieldTag::__min_cpu_platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_cpu_platform",
                                ));
                            }
                            result.min_cpu_platform = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_metadata_config => {
                            if !fields.insert(__FieldTag::__workload_metadata_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_metadata_config",
                                ));
                            }
                            result.workload_metadata_config = map.next_value::<std::option::Option<crate::model::WorkloadMetadataConfig>>()?
                                ;
                        }
                        __FieldTag::__taints => {
                            if !fields.insert(__FieldTag::__taints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taints",
                                ));
                            }
                            result.taints = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NodeTaint>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sandbox_config => {
                            if !fields.insert(__FieldTag::__sandbox_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sandbox_config",
                                ));
                            }
                            result.sandbox_config = map
                                .next_value::<std::option::Option<crate::model::SandboxConfig>>()?;
                        }
                        __FieldTag::__node_group => {
                            if !fields.insert(__FieldTag::__node_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_group",
                                ));
                            }
                            result.node_group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reservation_affinity => {
                            if !fields.insert(__FieldTag::__reservation_affinity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reservation_affinity",
                                ));
                            }
                            result.reservation_affinity = map.next_value::<std::option::Option<crate::model::ReservationAffinity>>()?
                                ;
                        }
                        __FieldTag::__shielded_instance_config => {
                            if !fields.insert(__FieldTag::__shielded_instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shielded_instance_config",
                                ));
                            }
                            result.shielded_instance_config = map.next_value::<std::option::Option<crate::model::ShieldedInstanceConfig>>()?
                                ;
                        }
                        __FieldTag::__linux_node_config => {
                            if !fields.insert(__FieldTag::__linux_node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linux_node_config",
                                ));
                            }
                            result.linux_node_config = map
                                .next_value::<std::option::Option<crate::model::LinuxNodeConfig>>(
                                )?;
                        }
                        __FieldTag::__kubelet_config => {
                            if !fields.insert(__FieldTag::__kubelet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubelet_config",
                                ));
                            }
                            result.kubelet_config = map
                                .next_value::<std::option::Option<crate::model::NodeKubeletConfig>>(
                                )?;
                        }
                        __FieldTag::__boot_disk_kms_key => {
                            if !fields.insert(__FieldTag::__boot_disk_kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk_kms_key",
                                ));
                            }
                            result.boot_disk_kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcfs_config => {
                            if !fields.insert(__FieldTag::__gcfs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcfs_config",
                                ));
                            }
                            result.gcfs_config =
                                map.next_value::<std::option::Option<crate::model::GcfsConfig>>()?;
                        }
                        __FieldTag::__advanced_machine_features => {
                            if !fields.insert(__FieldTag::__advanced_machine_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_machine_features",
                                ));
                            }
                            result.advanced_machine_features = map.next_value::<std::option::Option<crate::model::AdvancedMachineFeatures>>()?
                                ;
                        }
                        __FieldTag::__gvnic => {
                            if !fields.insert(__FieldTag::__gvnic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gvnic",
                                ));
                            }
                            result.gvnic =
                                map.next_value::<std::option::Option<crate::model::VirtualNIC>>()?;
                        }
                        __FieldTag::__spot => {
                            if !fields.insert(__FieldTag::__spot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spot",
                                ));
                            }
                            result.spot = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidential_nodes => {
                            if !fields.insert(__FieldTag::__confidential_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidential_nodes",
                                ));
                            }
                            result.confidential_nodes = map
                                .next_value::<std::option::Option<crate::model::ConfidentialNodes>>(
                                )?;
                        }
                        __FieldTag::__fast_socket => {
                            if !fields.insert(__FieldTag::__fast_socket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fast_socket",
                                ));
                            }
                            result.fast_socket =
                                map.next_value::<std::option::Option<crate::model::FastSocket>>()?;
                        }
                        __FieldTag::__resource_labels => {
                            if !fields.insert(__FieldTag::__resource_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_labels",
                                ));
                            }
                            result.resource_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map.next_value::<std::option::Option<crate::model::NodePoolLoggingConfig>>()?
                                ;
                        }
                        __FieldTag::__windows_node_config => {
                            if !fields.insert(__FieldTag::__windows_node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_node_config",
                                ));
                            }
                            result.windows_node_config = map
                                .next_value::<std::option::Option<crate::model::WindowsNodeConfig>>(
                                )?;
                        }
                        __FieldTag::__local_nvme_ssd_block_config => {
                            if !fields.insert(__FieldTag::__local_nvme_ssd_block_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_nvme_ssd_block_config",
                                ));
                            }
                            result.local_nvme_ssd_block_config = map.next_value::<std::option::Option<crate::model::LocalNvmeSsdBlockConfig>>()?
                                ;
                        }
                        __FieldTag::__ephemeral_storage_local_ssd_config => {
                            if !fields.insert(__FieldTag::__ephemeral_storage_local_ssd_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ephemeral_storage_local_ssd_config",
                                ));
                            }
                            result.ephemeral_storage_local_ssd_config =
                                map.next_value::<std::option::Option<
                                    crate::model::EphemeralStorageLocalSsdConfig,
                                >>()?;
                        }
                        __FieldTag::__sole_tenant_config => {
                            if !fields.insert(__FieldTag::__sole_tenant_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sole_tenant_config",
                                ));
                            }
                            result.sole_tenant_config = map
                                .next_value::<std::option::Option<crate::model::SoleTenantConfig>>(
                                )?;
                        }
                        __FieldTag::__containerd_config => {
                            if !fields.insert(__FieldTag::__containerd_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containerd_config",
                                ));
                            }
                            result.containerd_config = map
                                .next_value::<std::option::Option<crate::model::ContainerdConfig>>(
                                )?;
                        }
                        __FieldTag::__resource_manager_tags => {
                            if !fields.insert(__FieldTag::__resource_manager_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_manager_tags",
                                ));
                            }
                            result.resource_manager_tags = map.next_value::<std::option::Option<crate::model::ResourceManagerTags>>()?
                                ;
                        }
                        __FieldTag::__enable_confidential_storage => {
                            if !fields.insert(__FieldTag::__enable_confidential_storage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_confidential_storage",
                                ));
                            }
                            result.enable_confidential_storage = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_boot_disks => {
                            if !fields.insert(__FieldTag::__secondary_boot_disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_boot_disks",
                                ));
                            }
                            result.secondary_boot_disks =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SecondaryBootDisk>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_pools => {
                            if !fields.insert(__FieldTag::__storage_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_pools",
                                ));
                            }
                            result.storage_pools = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__secondary_boot_disk_update_strategy => {
                            if !fields.insert(__FieldTag::__secondary_boot_disk_update_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_boot_disk_update_strategy",
                                ));
                            }
                            result.secondary_boot_disk_update_strategy = map
                                .next_value::<std::option::Option<
                                    crate::model::SecondaryBootDiskUpdateStrategy,
                                >>()?;
                        }
                        __FieldTag::__max_run_duration => {
                            if !fields.insert(__FieldTag::__max_run_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_run_duration",
                                ));
                            }
                            result.max_run_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__local_ssd_encryption_mode => {
                            if !fields.insert(__FieldTag::__local_ssd_encryption_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_ssd_encryption_mode",
                                ));
                            }
                            result.local_ssd_encryption_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::node_config::LocalSsdEncryptionMode,
                                >>()?;
                        }
                        __FieldTag::__effective_cgroup_mode => {
                            if !fields.insert(__FieldTag::__effective_cgroup_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effective_cgroup_mode",
                                ));
                            }
                            result.effective_cgroup_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::node_config::EffectiveCgroupMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flex_start => {
                            if !fields.insert(__FieldTag::__flex_start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flex_start",
                                ));
                            }
                            result.flex_start = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__boot_disk => {
                            if !fields.insert(__FieldTag::__boot_disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk",
                                ));
                            }
                            result.boot_disk =
                                map.next_value::<std::option::Option<crate::model::BootDisk>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !wkt::internal::is_default(&self.disk_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if !self.oauth_scopes.is_empty() {
            state.serialize_entry("oauthScopes", &self.oauth_scopes)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.image_type.is_empty() {
            state.serialize_entry("imageType", &self.image_type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.local_ssd_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("localSsdCount", &__With(&self.local_ssd_count))?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !wkt::internal::is_default(&self.preemptible) {
            state.serialize_entry("preemptible", &self.preemptible)?;
        }
        if !self.accelerators.is_empty() {
            state.serialize_entry("accelerators", &self.accelerators)?;
        }
        if !self.disk_type.is_empty() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self.min_cpu_platform.is_empty() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if self.workload_metadata_config.is_some() {
            state.serialize_entry("workloadMetadataConfig", &self.workload_metadata_config)?;
        }
        if !self.taints.is_empty() {
            state.serialize_entry("taints", &self.taints)?;
        }
        if self.sandbox_config.is_some() {
            state.serialize_entry("sandboxConfig", &self.sandbox_config)?;
        }
        if !self.node_group.is_empty() {
            state.serialize_entry("nodeGroup", &self.node_group)?;
        }
        if self.reservation_affinity.is_some() {
            state.serialize_entry("reservationAffinity", &self.reservation_affinity)?;
        }
        if self.shielded_instance_config.is_some() {
            state.serialize_entry("shieldedInstanceConfig", &self.shielded_instance_config)?;
        }
        if self.linux_node_config.is_some() {
            state.serialize_entry("linuxNodeConfig", &self.linux_node_config)?;
        }
        if self.kubelet_config.is_some() {
            state.serialize_entry("kubeletConfig", &self.kubelet_config)?;
        }
        if !self.boot_disk_kms_key.is_empty() {
            state.serialize_entry("bootDiskKmsKey", &self.boot_disk_kms_key)?;
        }
        if self.gcfs_config.is_some() {
            state.serialize_entry("gcfsConfig", &self.gcfs_config)?;
        }
        if self.advanced_machine_features.is_some() {
            state.serialize_entry("advancedMachineFeatures", &self.advanced_machine_features)?;
        }
        if self.gvnic.is_some() {
            state.serialize_entry("gvnic", &self.gvnic)?;
        }
        if !wkt::internal::is_default(&self.spot) {
            state.serialize_entry("spot", &self.spot)?;
        }
        if self.confidential_nodes.is_some() {
            state.serialize_entry("confidentialNodes", &self.confidential_nodes)?;
        }
        if self.fast_socket.is_some() {
            state.serialize_entry("fastSocket", &self.fast_socket)?;
        }
        if !self.resource_labels.is_empty() {
            state.serialize_entry("resourceLabels", &self.resource_labels)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.windows_node_config.is_some() {
            state.serialize_entry("windowsNodeConfig", &self.windows_node_config)?;
        }
        if self.local_nvme_ssd_block_config.is_some() {
            state.serialize_entry("localNvmeSsdBlockConfig", &self.local_nvme_ssd_block_config)?;
        }
        if self.ephemeral_storage_local_ssd_config.is_some() {
            state.serialize_entry(
                "ephemeralStorageLocalSsdConfig",
                &self.ephemeral_storage_local_ssd_config,
            )?;
        }
        if self.sole_tenant_config.is_some() {
            state.serialize_entry("soleTenantConfig", &self.sole_tenant_config)?;
        }
        if self.containerd_config.is_some() {
            state.serialize_entry("containerdConfig", &self.containerd_config)?;
        }
        if self.resource_manager_tags.is_some() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !wkt::internal::is_default(&self.enable_confidential_storage) {
            state.serialize_entry(
                "enableConfidentialStorage",
                &self.enable_confidential_storage,
            )?;
        }
        if !self.secondary_boot_disks.is_empty() {
            state.serialize_entry("secondaryBootDisks", &self.secondary_boot_disks)?;
        }
        if !self.storage_pools.is_empty() {
            state.serialize_entry("storagePools", &self.storage_pools)?;
        }
        if self.secondary_boot_disk_update_strategy.is_some() {
            state.serialize_entry(
                "secondaryBootDiskUpdateStrategy",
                &self.secondary_boot_disk_update_strategy,
            )?;
        }
        if self.max_run_duration.is_some() {
            state.serialize_entry("maxRunDuration", &self.max_run_duration)?;
        }
        if self.local_ssd_encryption_mode.is_some() {
            state.serialize_entry("localSsdEncryptionMode", &self.local_ssd_encryption_mode)?;
        }
        if !wkt::internal::is_default(&self.effective_cgroup_mode) {
            state.serialize_entry("effectiveCgroupMode", &self.effective_cgroup_mode)?;
        }
        if self.flex_start.is_some() {
            state.serialize_entry("flexStart", &self.flex_start)?;
        }
        if self.boot_disk.is_some() {
            state.serialize_entry("bootDisk", &self.boot_disk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeConfig");
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field("oauth_scopes", &self.oauth_scopes);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("image_type", &self.image_type);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("local_ssd_count", &self.local_ssd_count);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("preemptible", &self.preemptible);
        debug_struct.field("accelerators", &self.accelerators);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("min_cpu_platform", &self.min_cpu_platform);
        debug_struct.field("workload_metadata_config", &self.workload_metadata_config);
        debug_struct.field("taints", &self.taints);
        debug_struct.field("sandbox_config", &self.sandbox_config);
        debug_struct.field("node_group", &self.node_group);
        debug_struct.field("reservation_affinity", &self.reservation_affinity);
        debug_struct.field("shielded_instance_config", &self.shielded_instance_config);
        debug_struct.field("linux_node_config", &self.linux_node_config);
        debug_struct.field("kubelet_config", &self.kubelet_config);
        debug_struct.field("boot_disk_kms_key", &self.boot_disk_kms_key);
        debug_struct.field("gcfs_config", &self.gcfs_config);
        debug_struct.field("advanced_machine_features", &self.advanced_machine_features);
        debug_struct.field("gvnic", &self.gvnic);
        debug_struct.field("spot", &self.spot);
        debug_struct.field("confidential_nodes", &self.confidential_nodes);
        debug_struct.field("fast_socket", &self.fast_socket);
        debug_struct.field("resource_labels", &self.resource_labels);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("windows_node_config", &self.windows_node_config);
        debug_struct.field(
            "local_nvme_ssd_block_config",
            &self.local_nvme_ssd_block_config,
        );
        debug_struct.field(
            "ephemeral_storage_local_ssd_config",
            &self.ephemeral_storage_local_ssd_config,
        );
        debug_struct.field("sole_tenant_config", &self.sole_tenant_config);
        debug_struct.field("containerd_config", &self.containerd_config);
        debug_struct.field("resource_manager_tags", &self.resource_manager_tags);
        debug_struct.field(
            "enable_confidential_storage",
            &self.enable_confidential_storage,
        );
        debug_struct.field("secondary_boot_disks", &self.secondary_boot_disks);
        debug_struct.field("storage_pools", &self.storage_pools);
        debug_struct.field(
            "secondary_boot_disk_update_strategy",
            &self.secondary_boot_disk_update_strategy,
        );
        debug_struct.field("max_run_duration", &self.max_run_duration);
        debug_struct.field("local_ssd_encryption_mode", &self.local_ssd_encryption_mode);
        debug_struct.field("effective_cgroup_mode", &self.effective_cgroup_mode);
        debug_struct.field("flex_start", &self.flex_start);
        debug_struct.field("boot_disk", &self.boot_disk);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NodeConfig].
pub mod node_config {
    #[allow(unused_imports)]
    use super::*;

    /// LocalSsdEncryptionMode specifies the method used for encrypting the Local
    /// SSDs attached to the node.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocalSsdEncryptionMode {
        /// The given node will be encrypted using keys managed by Google
        /// infrastructure and the keys will be deleted when the node is
        /// deleted.
        Unspecified,
        /// The given node will be encrypted using keys managed by Google
        /// infrastructure and the keys will be deleted when the node is
        /// deleted.
        StandardEncryption,
        /// The given node will opt-in for using ephemeral key for
        /// encryption of Local SSDs.
        /// The Local SSDs will not be able to recover data in case of node
        /// crash.
        EphemeralKeyEncryption,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LocalSsdEncryptionMode::value] or
        /// [LocalSsdEncryptionMode::name].
        UnknownValue(local_ssd_encryption_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod local_ssd_encryption_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LocalSsdEncryptionMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::StandardEncryption => std::option::Option::Some(1),
                Self::EphemeralKeyEncryption => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("LOCAL_SSD_ENCRYPTION_MODE_UNSPECIFIED")
                }
                Self::StandardEncryption => std::option::Option::Some("STANDARD_ENCRYPTION"),
                Self::EphemeralKeyEncryption => {
                    std::option::Option::Some("EPHEMERAL_KEY_ENCRYPTION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LocalSsdEncryptionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LocalSsdEncryptionMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LocalSsdEncryptionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::StandardEncryption,
                2 => Self::EphemeralKeyEncryption,
                _ => Self::UnknownValue(local_ssd_encryption_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LocalSsdEncryptionMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCAL_SSD_ENCRYPTION_MODE_UNSPECIFIED" => Self::Unspecified,
                "STANDARD_ENCRYPTION" => Self::StandardEncryption,
                "EPHEMERAL_KEY_ENCRYPTION" => Self::EphemeralKeyEncryption,
                _ => Self::UnknownValue(local_ssd_encryption_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LocalSsdEncryptionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::StandardEncryption => serializer.serialize_i32(1),
                Self::EphemeralKeyEncryption => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LocalSsdEncryptionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocalSsdEncryptionMode>::new(
                ".google.container.v1.NodeConfig.LocalSsdEncryptionMode",
            ))
        }
    }

    /// Possible effective cgroup modes for the node.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EffectiveCgroupMode {
        /// EFFECTIVE_CGROUP_MODE_UNSPECIFIED means the cgroup configuration for the
        /// node pool is unspecified, i.e. the node pool is a Windows node pool.
        Unspecified,
        /// CGROUP_MODE_V1 means the node pool is configured to use cgroupv1 for the
        /// cgroup configuration.
        V1,
        /// CGROUP_MODE_V2 means the node pool is configured to use cgroupv2 for the
        /// cgroup configuration.
        V2,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EffectiveCgroupMode::value] or
        /// [EffectiveCgroupMode::name].
        UnknownValue(effective_cgroup_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod effective_cgroup_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EffectiveCgroupMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::V1 => std::option::Option::Some(1),
                Self::V2 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EFFECTIVE_CGROUP_MODE_UNSPECIFIED"),
                Self::V1 => std::option::Option::Some("EFFECTIVE_CGROUP_MODE_V1"),
                Self::V2 => std::option::Option::Some("EFFECTIVE_CGROUP_MODE_V2"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EffectiveCgroupMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EffectiveCgroupMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EffectiveCgroupMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::V1,
                2 => Self::V2,
                _ => Self::UnknownValue(effective_cgroup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EffectiveCgroupMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EFFECTIVE_CGROUP_MODE_UNSPECIFIED" => Self::Unspecified,
                "EFFECTIVE_CGROUP_MODE_V1" => Self::V1,
                "EFFECTIVE_CGROUP_MODE_V2" => Self::V2,
                _ => Self::UnknownValue(effective_cgroup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EffectiveCgroupMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::V1 => serializer.serialize_i32(1),
                Self::V2 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EffectiveCgroupMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EffectiveCgroupMode>::new(
                ".google.container.v1.NodeConfig.EffectiveCgroupMode",
            ))
        }
    }
}

/// Specifies options for controlling advanced machine features.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvancedMachineFeatures {
    /// The number of threads per physical core. To disable simultaneous
    /// multithreading (SMT) set this to 1. If unset, the maximum number of threads
    /// supported per core by the underlying processor is assumed.
    pub threads_per_core: std::option::Option<i64>,

    /// Whether or not to enable nested virtualization (defaults to false).
    pub enable_nested_virtualization: std::option::Option<bool>,

    /// Type of Performance Monitoring Unit (PMU) requested on node pool instances.
    /// If unset, PMU will not be available to the node.
    pub performance_monitoring_unit:
        std::option::Option<crate::model::advanced_machine_features::PerformanceMonitoringUnit>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvancedMachineFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_threads_per_core<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.threads_per_core = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_or_clear_threads_per_core<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.threads_per_core = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_nested_virtualization][crate::model::AdvancedMachineFeatures::enable_nested_virtualization].
    pub fn set_enable_nested_virtualization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_nested_virtualization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_nested_virtualization][crate::model::AdvancedMachineFeatures::enable_nested_virtualization].
    pub fn set_or_clear_enable_nested_virtualization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_nested_virtualization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [performance_monitoring_unit][crate::model::AdvancedMachineFeatures::performance_monitoring_unit].
    pub fn set_performance_monitoring_unit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::advanced_machine_features::PerformanceMonitoringUnit>,
    {
        self.performance_monitoring_unit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [performance_monitoring_unit][crate::model::AdvancedMachineFeatures::performance_monitoring_unit].
    pub fn set_or_clear_performance_monitoring_unit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::advanced_machine_features::PerformanceMonitoringUnit>,
    {
        self.performance_monitoring_unit = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdvancedMachineFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AdvancedMachineFeatures"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvancedMachineFeatures {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __threads_per_core,
            __enable_nested_virtualization,
            __performance_monitoring_unit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvancedMachineFeatures")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "threadsPerCore" => Ok(__FieldTag::__threads_per_core),
                            "threads_per_core" => Ok(__FieldTag::__threads_per_core),
                            "enableNestedVirtualization" => {
                                Ok(__FieldTag::__enable_nested_virtualization)
                            }
                            "enable_nested_virtualization" => {
                                Ok(__FieldTag::__enable_nested_virtualization)
                            }
                            "performanceMonitoringUnit" => {
                                Ok(__FieldTag::__performance_monitoring_unit)
                            }
                            "performance_monitoring_unit" => {
                                Ok(__FieldTag::__performance_monitoring_unit)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvancedMachineFeatures;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvancedMachineFeatures")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__threads_per_core => {
                            if !fields.insert(__FieldTag::__threads_per_core) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threads_per_core",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.threads_per_core = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__enable_nested_virtualization => {
                            if !fields.insert(__FieldTag::__enable_nested_virtualization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_nested_virtualization",
                                ));
                            }
                            result.enable_nested_virtualization =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__performance_monitoring_unit => {
                            if !fields.insert(__FieldTag::__performance_monitoring_unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_monitoring_unit",
                                ));
                            }
                            result.performance_monitoring_unit = map
                                .next_value::<std::option::Option<
                                crate::model::advanced_machine_features::PerformanceMonitoringUnit,
                            >>(
                            )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdvancedMachineFeatures {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.threads_per_core.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("threadsPerCore", &__With(&self.threads_per_core))?;
        }
        if self.enable_nested_virtualization.is_some() {
            state.serialize_entry(
                "enableNestedVirtualization",
                &self.enable_nested_virtualization,
            )?;
        }
        if self.performance_monitoring_unit.is_some() {
            state.serialize_entry(
                "performanceMonitoringUnit",
                &self.performance_monitoring_unit,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdvancedMachineFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvancedMachineFeatures");
        debug_struct.field("threads_per_core", &self.threads_per_core);
        debug_struct.field(
            "enable_nested_virtualization",
            &self.enable_nested_virtualization,
        );
        debug_struct.field(
            "performance_monitoring_unit",
            &self.performance_monitoring_unit,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AdvancedMachineFeatures].
pub mod advanced_machine_features {
    #[allow(unused_imports)]
    use super::*;

    /// Level of PMU access.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PerformanceMonitoringUnit {
        /// PMU not enabled.
        Unspecified,
        /// Architecturally defined non-LLC events.
        Architectural,
        /// Most documented core/L2 events.
        Standard,
        /// Most documented core/L2 and LLC events.
        Enhanced,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PerformanceMonitoringUnit::value] or
        /// [PerformanceMonitoringUnit::name].
        UnknownValue(performance_monitoring_unit::UnknownValue),
    }

    #[doc(hidden)]
    pub mod performance_monitoring_unit {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PerformanceMonitoringUnit {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Architectural => std::option::Option::Some(1),
                Self::Standard => std::option::Option::Some(2),
                Self::Enhanced => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("PERFORMANCE_MONITORING_UNIT_UNSPECIFIED")
                }
                Self::Architectural => std::option::Option::Some("ARCHITECTURAL"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Enhanced => std::option::Option::Some("ENHANCED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PerformanceMonitoringUnit {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PerformanceMonitoringUnit {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PerformanceMonitoringUnit {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Architectural,
                2 => Self::Standard,
                3 => Self::Enhanced,
                _ => Self::UnknownValue(performance_monitoring_unit::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PerformanceMonitoringUnit {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERFORMANCE_MONITORING_UNIT_UNSPECIFIED" => Self::Unspecified,
                "ARCHITECTURAL" => Self::Architectural,
                "STANDARD" => Self::Standard,
                "ENHANCED" => Self::Enhanced,
                _ => Self::UnknownValue(performance_monitoring_unit::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PerformanceMonitoringUnit {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Architectural => serializer.serialize_i32(1),
                Self::Standard => serializer.serialize_i32(2),
                Self::Enhanced => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PerformanceMonitoringUnit {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PerformanceMonitoringUnit>::new(
                    ".google.container.v1.AdvancedMachineFeatures.PerformanceMonitoringUnit",
                ),
            )
        }
    }
}

/// Parameters for node pool-level network config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeNetworkConfig {
    /// Input only. Whether to create a new range for pod IPs in this node pool.
    /// Defaults are provided for `pod_range` and `pod_ipv4_cidr_block` if they
    /// are not specified.
    ///
    /// If neither `create_pod_range` or `pod_range` are specified, the
    /// cluster-level default (`ip_allocation_policy.cluster_ipv4_cidr_block`) is
    /// used.
    ///
    /// Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
    ///
    /// This field cannot be changed after the node pool has been created.
    pub create_pod_range: bool,

    /// The ID of the secondary range for pod IPs.
    /// If `create_pod_range` is true, this ID is used for the new range.
    /// If `create_pod_range` is false, uses an existing secondary range with this
    /// ID.
    ///
    /// Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
    ///
    /// This field cannot be changed after the node pool has been created.
    pub pod_range: std::string::String,

    /// The IP address range for pod IPs in this node pool.
    ///
    /// Only applicable if `create_pod_range` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) to pick a specific range to use.
    ///
    /// Only applicable if `ip_allocation_policy.use_ip_aliases` is true.
    ///
    /// This field cannot be changed after the node pool has been created.
    pub pod_ipv4_cidr_block: std::string::String,

    /// Whether nodes have internal IP addresses only.
    /// If enable_private_nodes is not specified, then the value is derived from
    /// [Cluster.NetworkConfig.default_enable_private_nodes][]
    pub enable_private_nodes: std::option::Option<bool>,

    /// Network bandwidth tier configuration.
    pub network_performance_config:
        std::option::Option<crate::model::node_network_config::NetworkPerformanceConfig>,

    /// [PRIVATE FIELD]
    /// Pod CIDR size overprovisioning config for the nodepool.
    ///
    /// Pod CIDR size per node depends on max_pods_per_node. By default, the value
    /// of max_pods_per_node is rounded off to next power of 2 and we then double
    /// that to get the size of pod CIDR block per node.
    /// Example: max_pods_per_node of 30 would result in 64 IPs (/26).
    ///
    /// This config can disable the doubling of IPs (we still round off to next
    /// power of 2)
    /// Example: max_pods_per_node of 30 will result in 32 IPs (/27) when
    /// overprovisioning is disabled.
    pub pod_cidr_overprovision_config:
        std::option::Option<crate::model::PodCIDROverprovisionConfig>,

    /// We specify the additional node networks for this node pool using this list.
    /// Each node network corresponds to an additional interface
    pub additional_node_network_configs: std::vec::Vec<crate::model::AdditionalNodeNetworkConfig>,

    /// We specify the additional pod networks for this node pool using this list.
    /// Each pod network corresponds to an additional alias IP range for the node
    pub additional_pod_network_configs: std::vec::Vec<crate::model::AdditionalPodNetworkConfig>,

    /// Output only. The utilization of the IPv4 range for the pod.
    /// The ratio is Usage/[Total number of IPs in the secondary range],
    /// Usage=numNodes*numZones*podIPsPerNode.
    pub pod_ipv4_range_utilization: f64,

    /// Output only. The subnetwork path for the node pool.
    /// Format: projects/{project}/regions/{region}/subnetworks/{subnetwork}
    /// If the cluster is associated with multiple subnetworks, the subnetwork for
    /// the node pool is picked based on the IP utilization during node pool
    /// creation and is immutable.
    pub subnetwork: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeNetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_pod_range][crate::model::NodeNetworkConfig::create_pod_range].
    pub fn set_create_pod_range<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.create_pod_range = v.into();
        self
    }

    /// Sets the value of [pod_range][crate::model::NodeNetworkConfig::pod_range].
    pub fn set_pod_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.pod_range = v.into();
        self
    }

    /// Sets the value of [pod_ipv4_cidr_block][crate::model::NodeNetworkConfig::pod_ipv4_cidr_block].
    pub fn set_pod_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.pod_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [enable_private_nodes][crate::model::NodeNetworkConfig::enable_private_nodes].
    pub fn set_enable_private_nodes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_private_nodes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_private_nodes][crate::model::NodeNetworkConfig::enable_private_nodes].
    pub fn set_or_clear_enable_private_nodes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_private_nodes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_performance_config][crate::model::NodeNetworkConfig::network_performance_config].
    pub fn set_network_performance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::node_network_config::NetworkPerformanceConfig>,
    {
        self.network_performance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_performance_config][crate::model::NodeNetworkConfig::network_performance_config].
    pub fn set_or_clear_network_performance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::node_network_config::NetworkPerformanceConfig>,
    {
        self.network_performance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pod_cidr_overprovision_config][crate::model::NodeNetworkConfig::pod_cidr_overprovision_config].
    pub fn set_pod_cidr_overprovision_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PodCIDROverprovisionConfig>,
    {
        self.pod_cidr_overprovision_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pod_cidr_overprovision_config][crate::model::NodeNetworkConfig::pod_cidr_overprovision_config].
    pub fn set_or_clear_pod_cidr_overprovision_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::PodCIDROverprovisionConfig>,
    {
        self.pod_cidr_overprovision_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_node_network_configs][crate::model::NodeNetworkConfig::additional_node_network_configs].
    pub fn set_additional_node_network_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdditionalNodeNetworkConfig>,
    {
        use std::iter::Iterator;
        self.additional_node_network_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [additional_pod_network_configs][crate::model::NodeNetworkConfig::additional_pod_network_configs].
    pub fn set_additional_pod_network_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdditionalPodNetworkConfig>,
    {
        use std::iter::Iterator;
        self.additional_pod_network_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pod_ipv4_range_utilization][crate::model::NodeNetworkConfig::pod_ipv4_range_utilization].
    pub fn set_pod_ipv4_range_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.pod_ipv4_range_utilization = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::NodeNetworkConfig::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }
}

impl wkt::message::Message for NodeNetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeNetworkConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeNetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_pod_range,
            __pod_range,
            __pod_ipv4_cidr_block,
            __enable_private_nodes,
            __network_performance_config,
            __pod_cidr_overprovision_config,
            __additional_node_network_configs,
            __additional_pod_network_configs,
            __pod_ipv4_range_utilization,
            __subnetwork,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeNetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createPodRange" => Ok(__FieldTag::__create_pod_range),
                            "create_pod_range" => Ok(__FieldTag::__create_pod_range),
                            "podRange" => Ok(__FieldTag::__pod_range),
                            "pod_range" => Ok(__FieldTag::__pod_range),
                            "podIpv4CidrBlock" => Ok(__FieldTag::__pod_ipv4_cidr_block),
                            "pod_ipv4_cidr_block" => Ok(__FieldTag::__pod_ipv4_cidr_block),
                            "enablePrivateNodes" => Ok(__FieldTag::__enable_private_nodes),
                            "enable_private_nodes" => Ok(__FieldTag::__enable_private_nodes),
                            "networkPerformanceConfig" => {
                                Ok(__FieldTag::__network_performance_config)
                            }
                            "network_performance_config" => {
                                Ok(__FieldTag::__network_performance_config)
                            }
                            "podCidrOverprovisionConfig" => {
                                Ok(__FieldTag::__pod_cidr_overprovision_config)
                            }
                            "pod_cidr_overprovision_config" => {
                                Ok(__FieldTag::__pod_cidr_overprovision_config)
                            }
                            "additionalNodeNetworkConfigs" => {
                                Ok(__FieldTag::__additional_node_network_configs)
                            }
                            "additional_node_network_configs" => {
                                Ok(__FieldTag::__additional_node_network_configs)
                            }
                            "additionalPodNetworkConfigs" => {
                                Ok(__FieldTag::__additional_pod_network_configs)
                            }
                            "additional_pod_network_configs" => {
                                Ok(__FieldTag::__additional_pod_network_configs)
                            }
                            "podIpv4RangeUtilization" => {
                                Ok(__FieldTag::__pod_ipv4_range_utilization)
                            }
                            "pod_ipv4_range_utilization" => {
                                Ok(__FieldTag::__pod_ipv4_range_utilization)
                            }
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeNetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeNetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_pod_range => {
                            if !fields.insert(__FieldTag::__create_pod_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_pod_range",
                                ));
                            }
                            result.create_pod_range = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_range => {
                            if !fields.insert(__FieldTag::__pod_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_range",
                                ));
                            }
                            result.pod_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__pod_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_ipv4_cidr_block",
                                ));
                            }
                            result.pod_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_private_nodes => {
                            if !fields.insert(__FieldTag::__enable_private_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_private_nodes",
                                ));
                            }
                            result.enable_private_nodes =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__network_performance_config => {
                            if !fields.insert(__FieldTag::__network_performance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_performance_config",
                                ));
                            }
                            result.network_performance_config = map
                                .next_value::<std::option::Option<
                                    crate::model::node_network_config::NetworkPerformanceConfig,
                                >>()?;
                        }
                        __FieldTag::__pod_cidr_overprovision_config => {
                            if !fields.insert(__FieldTag::__pod_cidr_overprovision_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_cidr_overprovision_config",
                                ));
                            }
                            result.pod_cidr_overprovision_config = map.next_value::<std::option::Option<crate::model::PodCIDROverprovisionConfig>>()?
                                ;
                        }
                        __FieldTag::__additional_node_network_configs => {
                            if !fields.insert(__FieldTag::__additional_node_network_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_node_network_configs",
                                ));
                            }
                            result.additional_node_network_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdditionalNodeNetworkConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_pod_network_configs => {
                            if !fields.insert(__FieldTag::__additional_pod_network_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_pod_network_configs",
                                ));
                            }
                            result.additional_pod_network_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdditionalPodNetworkConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_ipv4_range_utilization => {
                            if !fields.insert(__FieldTag::__pod_ipv4_range_utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_ipv4_range_utilization",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pod_ipv4_range_utilization =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeNetworkConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.create_pod_range) {
            state.serialize_entry("createPodRange", &self.create_pod_range)?;
        }
        if !self.pod_range.is_empty() {
            state.serialize_entry("podRange", &self.pod_range)?;
        }
        if !self.pod_ipv4_cidr_block.is_empty() {
            state.serialize_entry("podIpv4CidrBlock", &self.pod_ipv4_cidr_block)?;
        }
        if self.enable_private_nodes.is_some() {
            state.serialize_entry("enablePrivateNodes", &self.enable_private_nodes)?;
        }
        if self.network_performance_config.is_some() {
            state.serialize_entry("networkPerformanceConfig", &self.network_performance_config)?;
        }
        if self.pod_cidr_overprovision_config.is_some() {
            state.serialize_entry(
                "podCidrOverprovisionConfig",
                &self.pod_cidr_overprovision_config,
            )?;
        }
        if !self.additional_node_network_configs.is_empty() {
            state.serialize_entry(
                "additionalNodeNetworkConfigs",
                &self.additional_node_network_configs,
            )?;
        }
        if !self.additional_pod_network_configs.is_empty() {
            state.serialize_entry(
                "additionalPodNetworkConfigs",
                &self.additional_pod_network_configs,
            )?;
        }
        if !wkt::internal::is_default(&self.pod_ipv4_range_utilization) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "podIpv4RangeUtilization",
                &__With(&self.pod_ipv4_range_utilization),
            )?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodeNetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeNetworkConfig");
        debug_struct.field("create_pod_range", &self.create_pod_range);
        debug_struct.field("pod_range", &self.pod_range);
        debug_struct.field("pod_ipv4_cidr_block", &self.pod_ipv4_cidr_block);
        debug_struct.field("enable_private_nodes", &self.enable_private_nodes);
        debug_struct.field(
            "network_performance_config",
            &self.network_performance_config,
        );
        debug_struct.field(
            "pod_cidr_overprovision_config",
            &self.pod_cidr_overprovision_config,
        );
        debug_struct.field(
            "additional_node_network_configs",
            &self.additional_node_network_configs,
        );
        debug_struct.field(
            "additional_pod_network_configs",
            &self.additional_pod_network_configs,
        );
        debug_struct.field(
            "pod_ipv4_range_utilization",
            &self.pod_ipv4_range_utilization,
        );
        debug_struct.field("subnetwork", &self.subnetwork);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NodeNetworkConfig].
pub mod node_network_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of all network bandwidth tiers
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NetworkPerformanceConfig {
        /// Specifies the total network bandwidth tier for the NodePool.
        pub total_egress_bandwidth_tier: std::option::Option<
            crate::model::node_network_config::network_performance_config::Tier,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NetworkPerformanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_egress_bandwidth_tier][crate::model::node_network_config::NetworkPerformanceConfig::total_egress_bandwidth_tier].
        pub fn set_total_egress_bandwidth_tier<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::node_network_config::network_performance_config::Tier,
                >,
        {
            self.total_egress_bandwidth_tier = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [total_egress_bandwidth_tier][crate::model::node_network_config::NetworkPerformanceConfig::total_egress_bandwidth_tier].
        pub fn set_or_clear_total_egress_bandwidth_tier<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<
                    crate::model::node_network_config::network_performance_config::Tier,
                >,
        {
            self.total_egress_bandwidth_tier = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for NetworkPerformanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NodeNetworkConfig.NetworkPerformanceConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NetworkPerformanceConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __total_egress_bandwidth_tier,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NetworkPerformanceConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "totalEgressBandwidthTier" => {
                                    Ok(__FieldTag::__total_egress_bandwidth_tier)
                                }
                                "total_egress_bandwidth_tier" => {
                                    Ok(__FieldTag::__total_egress_bandwidth_tier)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NetworkPerformanceConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NetworkPerformanceConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__total_egress_bandwidth_tier => {
                                if !fields.insert(__FieldTag::__total_egress_bandwidth_tier) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_egress_bandwidth_tier",
                                    ));
                                }
                                result.total_egress_bandwidth_tier = map.next_value::<std::option::Option<crate::model::node_network_config::network_performance_config::Tier>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NetworkPerformanceConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.total_egress_bandwidth_tier.is_some() {
                state.serialize_entry(
                    "totalEgressBandwidthTier",
                    &self.total_egress_bandwidth_tier,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for NetworkPerformanceConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("NetworkPerformanceConfig");
            debug_struct.field(
                "total_egress_bandwidth_tier",
                &self.total_egress_bandwidth_tier,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [NetworkPerformanceConfig].
    pub mod network_performance_config {
        #[allow(unused_imports)]
        use super::*;

        /// Node network tier
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Tier {
            /// Default value
            Unspecified,
            /// Higher bandwidth, actual values based on VM size.
            Tier1,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Tier::value] or
            /// [Tier::name].
            UnknownValue(tier::UnknownValue),
        }

        #[doc(hidden)]
        pub mod tier {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Tier {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Tier1 => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TIER_UNSPECIFIED"),
                    Self::Tier1 => std::option::Option::Some("TIER_1"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Tier {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Tier {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Tier {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Tier1,
                    _ => Self::UnknownValue(tier::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Tier {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TIER_UNSPECIFIED" => Self::Unspecified,
                    "TIER_1" => Self::Tier1,
                    _ => Self::UnknownValue(tier::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Tier {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Tier1 => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Tier {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Tier>::new(
                    ".google.container.v1.NodeNetworkConfig.NetworkPerformanceConfig.Tier",
                ))
            }
        }
    }
}

/// AdditionalNodeNetworkConfig is the configuration for additional node networks
/// within the NodeNetworkConfig message
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdditionalNodeNetworkConfig {
    /// Name of the VPC where the additional interface belongs
    pub network: std::string::String,

    /// Name of the subnetwork where the additional interface belongs
    pub subnetwork: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdditionalNodeNetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::AdditionalNodeNetworkConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::AdditionalNodeNetworkConfig::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }
}

impl wkt::message::Message for AdditionalNodeNetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AdditionalNodeNetworkConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdditionalNodeNetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __subnetwork,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdditionalNodeNetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdditionalNodeNetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdditionalNodeNetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdditionalNodeNetworkConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdditionalNodeNetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdditionalNodeNetworkConfig");
        debug_struct.field("network", &self.network);
        debug_struct.field("subnetwork", &self.subnetwork);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AdditionalPodNetworkConfig is the configuration for additional pod networks
/// within the NodeNetworkConfig message
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdditionalPodNetworkConfig {
    /// Name of the subnetwork where the additional pod network belongs.
    pub subnetwork: std::string::String,

    /// The name of the secondary range on the subnet which provides IP address for
    /// this pod range.
    pub secondary_pod_range: std::string::String,

    /// The maximum number of pods per node which use this pod network.
    pub max_pods_per_node: std::option::Option<crate::model::MaxPodsConstraint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdditionalPodNetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnetwork][crate::model::AdditionalPodNetworkConfig::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [secondary_pod_range][crate::model::AdditionalPodNetworkConfig::secondary_pod_range].
    pub fn set_secondary_pod_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.secondary_pod_range = v.into();
        self
    }

    /// Sets the value of [max_pods_per_node][crate::model::AdditionalPodNetworkConfig::max_pods_per_node].
    pub fn set_max_pods_per_node<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaxPodsConstraint>,
    {
        self.max_pods_per_node = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_pods_per_node][crate::model::AdditionalPodNetworkConfig::max_pods_per_node].
    pub fn set_or_clear_max_pods_per_node<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaxPodsConstraint>,
    {
        self.max_pods_per_node = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdditionalPodNetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AdditionalPodNetworkConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdditionalPodNetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subnetwork,
            __secondary_pod_range,
            __max_pods_per_node,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdditionalPodNetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "secondaryPodRange" => Ok(__FieldTag::__secondary_pod_range),
                            "secondary_pod_range" => Ok(__FieldTag::__secondary_pod_range),
                            "maxPodsPerNode" => Ok(__FieldTag::__max_pods_per_node),
                            "max_pods_per_node" => Ok(__FieldTag::__max_pods_per_node),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdditionalPodNetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdditionalPodNetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_pod_range => {
                            if !fields.insert(__FieldTag::__secondary_pod_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_pod_range",
                                ));
                            }
                            result.secondary_pod_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_pods_per_node => {
                            if !fields.insert(__FieldTag::__max_pods_per_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_pods_per_node",
                                ));
                            }
                            result.max_pods_per_node = map
                                .next_value::<std::option::Option<crate::model::MaxPodsConstraint>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdditionalPodNetworkConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.secondary_pod_range.is_empty() {
            state.serialize_entry("secondaryPodRange", &self.secondary_pod_range)?;
        }
        if self.max_pods_per_node.is_some() {
            state.serialize_entry("maxPodsPerNode", &self.max_pods_per_node)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdditionalPodNetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdditionalPodNetworkConfig");
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("secondary_pod_range", &self.secondary_pod_range);
        debug_struct.field("max_pods_per_node", &self.max_pods_per_node);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A set of Shielded Instance options.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceConfig {
    /// Defines whether the instance has Secure Boot enabled.
    ///
    /// Secure Boot helps ensure that the system only runs authentic software by
    /// verifying the digital signature of all boot components, and halting the
    /// boot process if signature verification fails.
    pub enable_secure_boot: bool,

    /// Defines whether the instance has integrity monitoring enabled.
    ///
    /// Enables monitoring and attestation of the boot integrity of the instance.
    /// The attestation is performed against the integrity policy baseline. This
    /// baseline is initially derived from the implicitly trusted boot image when
    /// the instance is created.
    pub enable_integrity_monitoring: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShieldedInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_secure_boot][crate::model::ShieldedInstanceConfig::enable_secure_boot].
    pub fn set_enable_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_secure_boot = v.into();
        self
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_integrity_monitoring = v.into();
        self
    }
}

impl wkt::message::Message for ShieldedInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ShieldedInstanceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ShieldedInstanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_secure_boot,
            __enable_integrity_monitoring,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShieldedInstanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableSecureBoot" => Ok(__FieldTag::__enable_secure_boot),
                            "enable_secure_boot" => Ok(__FieldTag::__enable_secure_boot),
                            "enableIntegrityMonitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            "enable_integrity_monitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ShieldedInstanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShieldedInstanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_secure_boot => {
                            if !fields.insert(__FieldTag::__enable_secure_boot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_secure_boot",
                                ));
                            }
                            result.enable_secure_boot = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_integrity_monitoring => {
                            if !fields.insert(__FieldTag::__enable_integrity_monitoring) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_integrity_monitoring",
                                ));
                            }
                            result.enable_integrity_monitoring = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ShieldedInstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_secure_boot) {
            state.serialize_entry("enableSecureBoot", &self.enable_secure_boot)?;
        }
        if !wkt::internal::is_default(&self.enable_integrity_monitoring) {
            state.serialize_entry(
                "enableIntegrityMonitoring",
                &self.enable_integrity_monitoring,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ShieldedInstanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShieldedInstanceConfig");
        debug_struct.field("enable_secure_boot", &self.enable_secure_boot);
        debug_struct.field(
            "enable_integrity_monitoring",
            &self.enable_integrity_monitoring,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SandboxConfig contains configurations of the sandbox to use for the node.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SandboxConfig {
    /// Type of the sandbox to use for the node.
    pub r#type: crate::model::sandbox_config::Type,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SandboxConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::SandboxConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::sandbox_config::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }
}

impl wkt::message::Message for SandboxConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SandboxConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SandboxConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SandboxConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SandboxConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SandboxConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::sandbox_config::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SandboxConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SandboxConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SandboxConfig");
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SandboxConfig].
pub mod sandbox_config {
    #[allow(unused_imports)]
    use super::*;

    /// Possible types of sandboxes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value. This should not be used.
        Unspecified,
        /// Run sandbox using gvisor.
        Gvisor,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gvisor => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Gvisor => std::option::Option::Some("GVISOR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gvisor,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "GVISOR" => Self::Gvisor,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gvisor => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.container.v1.SandboxConfig.Type",
            ))
        }
    }
}

/// GcfsConfig contains configurations of Google Container File System
/// (image streaming).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcfsConfig {
    /// Whether to use GCFS.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcfsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::GcfsConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for GcfsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GcfsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcfsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcfsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcfsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcfsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcfsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcfsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcfsConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// [ReservationAffinity](https://cloud.google.com/compute/docs/instances/reserving-zonal-resources)
/// is the configuration of desired reservation which instances could take
/// capacity from.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReservationAffinity {
    /// Corresponds to the type of reservation consumption.
    pub consume_reservation_type: crate::model::reservation_affinity::Type,

    /// Corresponds to the label key of a reservation resource. To target a
    /// SPECIFIC_RESERVATION by name, specify
    /// "compute.googleapis.com/reservation-name" as the key and specify the name
    /// of your reservation as its value.
    pub key: std::string::String,

    /// Corresponds to the label value(s) of reservation resource(s).
    pub values: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReservationAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consume_reservation_type][crate::model::ReservationAffinity::consume_reservation_type].
    pub fn set_consume_reservation_type<
        T: std::convert::Into<crate::model::reservation_affinity::Type>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.consume_reservation_type = v.into();
        self
    }

    /// Sets the value of [key][crate::model::ReservationAffinity::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [values][crate::model::ReservationAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReservationAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ReservationAffinity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReservationAffinity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __consume_reservation_type,
            __key,
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReservationAffinity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "consumeReservationType" => Ok(__FieldTag::__consume_reservation_type),
                            "consume_reservation_type" => {
                                Ok(__FieldTag::__consume_reservation_type)
                            }
                            "key" => Ok(__FieldTag::__key),
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReservationAffinity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReservationAffinity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__consume_reservation_type => {
                            if !fields.insert(__FieldTag::__consume_reservation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consume_reservation_type",
                                ));
                            }
                            result.consume_reservation_type = map.next_value::<std::option::Option<crate::model::reservation_affinity::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReservationAffinity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.consume_reservation_type) {
            state.serialize_entry("consumeReservationType", &self.consume_reservation_type)?;
        }
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReservationAffinity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReservationAffinity");
        debug_struct.field("consume_reservation_type", &self.consume_reservation_type);
        debug_struct.field("key", &self.key);
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReservationAffinity].
pub mod reservation_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates whether to consume capacity from a reservation or not.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Default value. This should not be used.
        Unspecified,
        /// Do not consume from any reserved capacity.
        NoReservation,
        /// Consume any reservation available.
        AnyReservation,
        /// Must consume from a specific reservation. Must specify key value fields
        /// for specifying the reservations.
        SpecificReservation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoReservation => std::option::Option::Some(1),
                Self::AnyReservation => std::option::Option::Some(2),
                Self::SpecificReservation => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::NoReservation => std::option::Option::Some("NO_RESERVATION"),
                Self::AnyReservation => std::option::Option::Some("ANY_RESERVATION"),
                Self::SpecificReservation => std::option::Option::Some("SPECIFIC_RESERVATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoReservation,
                2 => Self::AnyReservation,
                3 => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "NO_RESERVATION" => Self::NoReservation,
                "ANY_RESERVATION" => Self::AnyReservation,
                "SPECIFIC_RESERVATION" => Self::SpecificReservation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoReservation => serializer.serialize_i32(1),
                Self::AnyReservation => serializer.serialize_i32(2),
                Self::SpecificReservation => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.container.v1.ReservationAffinity.Type",
            ))
        }
    }
}

/// SoleTenantConfig contains the NodeAffinities to specify what shared sole
/// tenant node groups should back the node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SoleTenantConfig {
    /// NodeAffinities used to match to a shared sole tenant node group.
    pub node_affinities: std::vec::Vec<crate::model::sole_tenant_config::NodeAffinity>,

    /// Optional. The minimum number of virtual CPUs this instance will consume
    /// when running on a sole-tenant node. This field can only be set if the node
    /// pool is created in a shared sole-tenant node group.
    pub min_node_cpus: std::option::Option<i32>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SoleTenantConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_affinities][crate::model::SoleTenantConfig::node_affinities].
    pub fn set_node_affinities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::sole_tenant_config::NodeAffinity>,
    {
        use std::iter::Iterator;
        self.node_affinities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_node_cpus][crate::model::SoleTenantConfig::min_node_cpus].
    pub fn set_min_node_cpus<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.min_node_cpus = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_node_cpus][crate::model::SoleTenantConfig::min_node_cpus].
    pub fn set_or_clear_min_node_cpus<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.min_node_cpus = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SoleTenantConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SoleTenantConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SoleTenantConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_affinities,
            __min_node_cpus,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SoleTenantConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodeAffinities" => Ok(__FieldTag::__node_affinities),
                            "node_affinities" => Ok(__FieldTag::__node_affinities),
                            "minNodeCpus" => Ok(__FieldTag::__min_node_cpus),
                            "min_node_cpus" => Ok(__FieldTag::__min_node_cpus),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SoleTenantConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SoleTenantConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_affinities => {
                            if !fields.insert(__FieldTag::__node_affinities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_affinities",
                                ));
                            }
                            result.node_affinities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::sole_tenant_config::NodeAffinity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_node_cpus => {
                            if !fields.insert(__FieldTag::__min_node_cpus) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_cpus",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_cpus = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SoleTenantConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_affinities.is_empty() {
            state.serialize_entry("nodeAffinities", &self.node_affinities)?;
        }
        if self.min_node_cpus.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minNodeCpus", &__With(&self.min_node_cpus))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SoleTenantConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SoleTenantConfig");
        debug_struct.field("node_affinities", &self.node_affinities);
        debug_struct.field("min_node_cpus", &self.min_node_cpus);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SoleTenantConfig].
pub mod sole_tenant_config {
    #[allow(unused_imports)]
    use super::*;

    /// Specifies the NodeAffinity key, values, and affinity operator according to
    /// [shared sole tenant node group
    /// affinities](https://cloud.google.com/compute/docs/nodes/sole-tenant-nodes#node_affinity_and_anti-affinity).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NodeAffinity {
        /// Key for NodeAffinity.
        pub key: std::string::String,

        /// Operator for NodeAffinity.
        pub operator: crate::model::sole_tenant_config::node_affinity::Operator,

        /// Values for NodeAffinity.
        pub values: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NodeAffinity {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::sole_tenant_config::NodeAffinity::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [operator][crate::model::sole_tenant_config::NodeAffinity::operator].
        pub fn set_operator<
            T: std::convert::Into<crate::model::sole_tenant_config::node_affinity::Operator>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.operator = v.into();
            self
        }

        /// Sets the value of [values][crate::model::sole_tenant_config::NodeAffinity::values].
        pub fn set_values<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.values = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for NodeAffinity {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.SoleTenantConfig.NodeAffinity"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NodeAffinity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key,
                __operator,
                __values,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NodeAffinity")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "key" => Ok(__FieldTag::__key),
                                "operator" => Ok(__FieldTag::__operator),
                                "values" => Ok(__FieldTag::__values),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NodeAffinity;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NodeAffinity")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                result.key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__operator => {
                                if !fields.insert(__FieldTag::__operator) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for operator",
                                    ));
                                }
                                result.operator = map
                                    .next_value::<std::option::Option<
                                        crate::model::sole_tenant_config::node_affinity::Operator,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__values => {
                                if !fields.insert(__FieldTag::__values) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for values",
                                    ));
                                }
                                result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NodeAffinity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.key.is_empty() {
                state.serialize_entry("key", &self.key)?;
            }
            if !wkt::internal::is_default(&self.operator) {
                state.serialize_entry("operator", &self.operator)?;
            }
            if !self.values.is_empty() {
                state.serialize_entry("values", &self.values)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for NodeAffinity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("NodeAffinity");
            debug_struct.field("key", &self.key);
            debug_struct.field("operator", &self.operator);
            debug_struct.field("values", &self.values);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [NodeAffinity].
    pub mod node_affinity {
        #[allow(unused_imports)]
        use super::*;

        /// Operator allows user to specify affinity or anti-affinity for the
        /// given key values.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Operator {
            /// Invalid or unspecified affinity operator.
            Unspecified,
            /// Affinity operator.
            In,
            /// Anti-affinity operator.
            NotIn,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Operator::value] or
            /// [Operator::name].
            UnknownValue(operator::UnknownValue),
        }

        #[doc(hidden)]
        pub mod operator {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Operator {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::In => std::option::Option::Some(1),
                    Self::NotIn => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("OPERATOR_UNSPECIFIED"),
                    Self::In => std::option::Option::Some("IN"),
                    Self::NotIn => std::option::Option::Some("NOT_IN"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Operator {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Operator {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Operator {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::In,
                    2 => Self::NotIn,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Operator {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "OPERATOR_UNSPECIFIED" => Self::Unspecified,
                    "IN" => Self::In,
                    "NOT_IN" => Self::NotIn,
                    _ => Self::UnknownValue(operator::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Operator {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::In => serializer.serialize_i32(1),
                    Self::NotIn => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Operator {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operator>::new(
                    ".google.container.v1.SoleTenantConfig.NodeAffinity.Operator",
                ))
            }
        }
    }
}

/// ContainerdConfig contains configuration to customize containerd.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ContainerdConfig {
    /// PrivateRegistryAccessConfig is used to configure access configuration
    /// for private container registries.
    pub private_registry_access_config:
        std::option::Option<crate::model::containerd_config::PrivateRegistryAccessConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContainerdConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [private_registry_access_config][crate::model::ContainerdConfig::private_registry_access_config].
    pub fn set_private_registry_access_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::containerd_config::PrivateRegistryAccessConfig>,
    {
        self.private_registry_access_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_registry_access_config][crate::model::ContainerdConfig::private_registry_access_config].
    pub fn set_or_clear_private_registry_access_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::containerd_config::PrivateRegistryAccessConfig>,
    {
        self.private_registry_access_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ContainerdConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ContainerdConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ContainerdConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __private_registry_access_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContainerdConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privateRegistryAccessConfig" => {
                                Ok(__FieldTag::__private_registry_access_config)
                            }
                            "private_registry_access_config" => {
                                Ok(__FieldTag::__private_registry_access_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ContainerdConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContainerdConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__private_registry_access_config => {
                            if !fields.insert(__FieldTag::__private_registry_access_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_registry_access_config",
                                ));
                            }
                            result.private_registry_access_config = map
                                .next_value::<std::option::Option<
                                    crate::model::containerd_config::PrivateRegistryAccessConfig,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ContainerdConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.private_registry_access_config.is_some() {
            state.serialize_entry(
                "privateRegistryAccessConfig",
                &self.private_registry_access_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ContainerdConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ContainerdConfig");
        debug_struct.field(
            "private_registry_access_config",
            &self.private_registry_access_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ContainerdConfig].
pub mod containerd_config {
    #[allow(unused_imports)]
    use super::*;

    /// PrivateRegistryAccessConfig contains access configuration for
    /// private container registries.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PrivateRegistryAccessConfig {

        /// Private registry access is enabled.
        pub enabled: bool,

        /// Private registry access configuration.
        pub certificate_authority_domain_config: std::vec::Vec<crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PrivateRegistryAccessConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::containerd_config::PrivateRegistryAccessConfig::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [certificate_authority_domain_config][crate::model::containerd_config::PrivateRegistryAccessConfig::certificate_authority_domain_config].
        pub fn set_certificate_authority_domain_config<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig>
        {
            use std::iter::Iterator;
            self.certificate_authority_domain_config = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PrivateRegistryAccessConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ContainerdConfig.PrivateRegistryAccessConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PrivateRegistryAccessConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                __certificate_authority_domain_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PrivateRegistryAccessConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                "certificateAuthorityDomainConfig" => {
                                    Ok(__FieldTag::__certificate_authority_domain_config)
                                }
                                "certificate_authority_domain_config" => {
                                    Ok(__FieldTag::__certificate_authority_domain_config)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PrivateRegistryAccessConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PrivateRegistryAccessConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__certificate_authority_domain_config => {
                                if !fields.insert(__FieldTag::__certificate_authority_domain_config)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for certificate_authority_domain_config",
                                    ));
                                }
                                result.certificate_authority_domain_config = map.next_value::<std::option::Option<std::vec::Vec<crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PrivateRegistryAccessConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if !self.certificate_authority_domain_config.is_empty() {
                state.serialize_entry(
                    "certificateAuthorityDomainConfig",
                    &self.certificate_authority_domain_config,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PrivateRegistryAccessConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PrivateRegistryAccessConfig");
            debug_struct.field("enabled", &self.enabled);
            debug_struct.field(
                "certificate_authority_domain_config",
                &self.certificate_authority_domain_config,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [PrivateRegistryAccessConfig].
    pub mod private_registry_access_config {
        #[allow(unused_imports)]
        use super::*;

        /// CertificateAuthorityDomainConfig configures one or more fully qualified
        /// domain names (FQDN) to a specific certificate.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CertificateAuthorityDomainConfig {

            /// List of fully qualified domain names (FQDN).
            /// Specifying port is supported.
            /// Wildcards are NOT supported.
            /// Examples:
            ///
            /// - my.customdomain.com
            /// - 10.0.1.2:5000
            pub fqdns: std::vec::Vec<std::string::String>,

            /// Certificate access config. The following are supported:
            ///
            /// - GCPSecretManagerCertificateConfig
            pub certificate_config: std::option::Option<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::CertificateConfig>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CertificateAuthorityDomainConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [fqdns][crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig::fqdns].
            pub fn set_fqdns<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.fqdns = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [certificate_config][crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig::certificate_config].
            ///
            /// Note that all the setters affecting `certificate_config` are mutually
            /// exclusive.
            pub fn set_certificate_config<T: std::convert::Into<std::option::Option<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::CertificateConfig>>>(mut self, v: T) -> Self
            {
                self.certificate_config = v.into();
                self
            }

            /// The value of [certificate_config][crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig::certificate_config]
            /// if it holds a `GcpSecretManagerCertificateConfig`, `None` if the field is not set or
            /// holds a different branch.
            pub fn gcp_secret_manager_certificate_config(&self) -> std::option::Option<&std::boxed::Box<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig>>{
                #[allow(unreachable_patterns)]
                self.certificate_config.as_ref().and_then(|v| match v {
                    crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::CertificateConfig::GcpSecretManagerCertificateConfig(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [certificate_config][crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig::certificate_config]
            /// to hold a `GcpSecretManagerCertificateConfig`.
            ///
            /// Note that all the setters affecting `certificate_config` are
            /// mutually exclusive.
            pub fn set_gcp_secret_manager_certificate_config<T: std::convert::Into<std::boxed::Box<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig>>>(mut self, v: T) -> Self{
                self.certificate_config = std::option::Option::Some(
                    crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::CertificateConfig::GcpSecretManagerCertificateConfig(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for CertificateAuthorityDomainConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.container.v1.ContainerdConfig.PrivateRegistryAccessConfig.CertificateAuthorityDomainConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CertificateAuthorityDomainConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __fqdns,
                    __gcp_secret_manager_certificate_config,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter
                                    .write_str("a field name for CertificateAuthorityDomainConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "fqdns" => Ok(__FieldTag::__fqdns),
                                    "gcpSecretManagerCertificateConfig" => {
                                        Ok(__FieldTag::__gcp_secret_manager_certificate_config)
                                    }
                                    "gcp_secret_manager_certificate_config" => {
                                        Ok(__FieldTag::__gcp_secret_manager_certificate_config)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CertificateAuthorityDomainConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CertificateAuthorityDomainConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__fqdns => {
                                    if !fields.insert(__FieldTag::__fqdns) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for fqdns"),
                                        );
                                    }
                                    result.fqdns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__gcp_secret_manager_certificate_config => {
                                    if !fields
                                        .insert(__FieldTag::__gcp_secret_manager_certificate_config)
                                    {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for gcp_secret_manager_certificate_config",
                                            ),
                                        );
                                    }
                                    if result.certificate_config.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `certificate_config`, a oneof with full ID .google.container.v1.ContainerdConfig.PrivateRegistryAccessConfig.CertificateAuthorityDomainConfig.gcp_secret_manager_certificate_config, latest field was gcpSecretManagerCertificateConfig",
                                            ),
                                        );
                                    }
                                    result.certificate_config = std::option::Option::Some(
                                        crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::CertificateConfig::GcpSecretManagerCertificateConfig(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CertificateAuthorityDomainConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.fqdns.is_empty() {
                    state.serialize_entry("fqdns", &self.fqdns)?;
                }
                if let Some(value) = self.gcp_secret_manager_certificate_config() {
                    state.serialize_entry("gcpSecretManagerCertificateConfig", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for CertificateAuthorityDomainConfig {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("CertificateAuthorityDomainConfig");
                debug_struct.field("fqdns", &self.fqdns);
                debug_struct.field("certificate_config", &self.certificate_config);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [CertificateAuthorityDomainConfig].
        pub mod certificate_authority_domain_config {
            #[allow(unused_imports)]
            use super::*;

            /// GCPSecretManagerCertificateConfig configures a secret from
            /// [Google Secret
            /// Manager](https://cloud.google.com/secret-manager).
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct GCPSecretManagerCertificateConfig {
                /// Secret URI, in the form
                /// "projects/$PROJECT_ID/secrets/$SECRET_NAME/versions/$VERSION".
                /// Version can be fixed (e.g. "2") or "latest"
                pub secret_uri: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl GCPSecretManagerCertificateConfig {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [secret_uri][crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig::secret_uri].
                pub fn set_secret_uri<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.secret_uri = v.into();
                    self
                }
            }

            impl wkt::message::Message for GCPSecretManagerCertificateConfig {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.container.v1.ContainerdConfig.PrivateRegistryAccessConfig.CertificateAuthorityDomainConfig.GCPSecretManagerCertificateConfig"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for GCPSecretManagerCertificateConfig {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __secret_uri,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str(
                                        "a field name for GCPSecretManagerCertificateConfig",
                                    )
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "secretUri" => Ok(__FieldTag::__secret_uri),
                                        "secret_uri" => Ok(__FieldTag::__secret_uri),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = GCPSecretManagerCertificateConfig;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct GCPSecretManagerCertificateConfig")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__secret_uri => {
                                        if !fields.insert(__FieldTag::__secret_uri) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for secret_uri",
                                                ),
                                            );
                                        }
                                        result.secret_uri = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for GCPSecretManagerCertificateConfig {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.secret_uri.is_empty() {
                        state.serialize_entry("secretUri", &self.secret_uri)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for GCPSecretManagerCertificateConfig {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("GCPSecretManagerCertificateConfig");
                    debug_struct.field("secret_uri", &self.secret_uri);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// Certificate access config. The following are supported:
            ///
            /// - GCPSecretManagerCertificateConfig
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum CertificateConfig {
                /// Google Secret Manager (GCP) certificate configuration.
                GcpSecretManagerCertificateConfig(std::boxed::Box<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig>),
            }
        }
    }
}

/// Kubernetes taint is composed of three fields: key, value, and effect. Effect
/// can only be one of three types:  NoSchedule, PreferNoSchedule or NoExecute.
///
/// See
/// [here](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration)
/// for more information, including usage and the valid values.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeTaint {
    /// Key for taint.
    pub key: std::string::String,

    /// Value for taint.
    pub value: std::string::String,

    /// Effect for taint.
    pub effect: crate::model::node_taint::Effect,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeTaint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::NodeTaint::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [value][crate::model::NodeTaint::value].
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [effect][crate::model::NodeTaint::effect].
    pub fn set_effect<T: std::convert::Into<crate::model::node_taint::Effect>>(
        mut self,
        v: T,
    ) -> Self {
        self.effect = v.into();
        self
    }
}

impl wkt::message::Message for NodeTaint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeTaint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeTaint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __value,
            __effect,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeTaint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "value" => Ok(__FieldTag::__value),
                            "effect" => Ok(__FieldTag::__effect),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeTaint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeTaint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__effect => {
                            if !fields.insert(__FieldTag::__effect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effect",
                                ));
                            }
                            result.effect = map.next_value::<std::option::Option<crate::model::node_taint::Effect>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeTaint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !wkt::internal::is_default(&self.effect) {
            state.serialize_entry("effect", &self.effect)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodeTaint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeTaint");
        debug_struct.field("key", &self.key);
        debug_struct.field("value", &self.value);
        debug_struct.field("effect", &self.effect);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NodeTaint].
pub mod node_taint {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for Effect in taint.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Effect {
        /// Not set
        Unspecified,
        /// NoSchedule
        NoSchedule,
        /// PreferNoSchedule
        PreferNoSchedule,
        /// NoExecute
        NoExecute,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Effect::value] or
        /// [Effect::name].
        UnknownValue(effect::UnknownValue),
    }

    #[doc(hidden)]
    pub mod effect {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Effect {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoSchedule => std::option::Option::Some(1),
                Self::PreferNoSchedule => std::option::Option::Some(2),
                Self::NoExecute => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EFFECT_UNSPECIFIED"),
                Self::NoSchedule => std::option::Option::Some("NO_SCHEDULE"),
                Self::PreferNoSchedule => std::option::Option::Some("PREFER_NO_SCHEDULE"),
                Self::NoExecute => std::option::Option::Some("NO_EXECUTE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Effect {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Effect {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Effect {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoSchedule,
                2 => Self::PreferNoSchedule,
                3 => Self::NoExecute,
                _ => Self::UnknownValue(effect::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Effect {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EFFECT_UNSPECIFIED" => Self::Unspecified,
                "NO_SCHEDULE" => Self::NoSchedule,
                "PREFER_NO_SCHEDULE" => Self::PreferNoSchedule,
                "NO_EXECUTE" => Self::NoExecute,
                _ => Self::UnknownValue(effect::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Effect {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoSchedule => serializer.serialize_i32(1),
                Self::PreferNoSchedule => serializer.serialize_i32(2),
                Self::NoExecute => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Effect {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Effect>::new(
                ".google.container.v1.NodeTaint.Effect",
            ))
        }
    }
}

/// Collection of Kubernetes [node
/// taints](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeTaints {
    /// List of node taints.
    pub taints: std::vec::Vec<crate::model::NodeTaint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeTaints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [taints][crate::model::NodeTaints::taints].
    pub fn set_taints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodeTaint>,
    {
        use std::iter::Iterator;
        self.taints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NodeTaints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeTaints"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeTaints {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __taints,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeTaints")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "taints" => Ok(__FieldTag::__taints),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeTaints;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeTaints")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__taints => {
                            if !fields.insert(__FieldTag::__taints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taints",
                                ));
                            }
                            result.taints = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NodeTaint>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeTaints {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.taints.is_empty() {
            state.serialize_entry("taints", &self.taints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodeTaints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeTaints");
        debug_struct.field("taints", &self.taints);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Collection of node-level [Kubernetes
/// labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeLabels {
    /// Map of node label keys and node label values.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeLabels {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::NodeLabels::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for NodeLabels {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeLabels"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeLabels {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeLabels")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeLabels;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeLabels")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeLabels {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodeLabels {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeLabels");
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Collection of [GCP
/// labels](https://cloud.google.com/resource-manager/docs/creating-managing-labels).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceLabels {
    /// Map of node label keys and node label values.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceLabels {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::ResourceLabels::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ResourceLabels {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ResourceLabels"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceLabels {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceLabels")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceLabels;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceLabels")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceLabels {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResourceLabels {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceLabels");
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Collection of Compute Engine network tags that can be applied to a node's
/// underlying VM instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkTags {
    /// List of network tags.
    pub tags: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkTags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tags][crate::model::NetworkTags::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for NetworkTags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NetworkTags"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkTags {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkTags")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkTags;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkTags")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkTags {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkTags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkTags");
        debug_struct.field("tags", &self.tags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The authentication information for accessing the master endpoint.
/// Authentication can be done using HTTP basic auth or using client
/// certificates.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MasterAuth {
    /// The username to use for HTTP basic authentication to the master endpoint.
    /// For clusters v1.6.0 and later, basic authentication can be disabled by
    /// leaving username unspecified (or setting it to the empty string).
    ///
    /// Warning: basic authentication is deprecated, and will be removed in GKE
    /// control plane versions 1.19 and newer. For a list of recommended
    /// authentication methods, see:
    /// <https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication>
    #[deprecated]
    pub username: std::string::String,

    /// The password to use for HTTP basic authentication to the master endpoint.
    /// Because the master endpoint is open to the Internet, you should create a
    /// strong password.  If a password is provided for cluster creation, username
    /// must be non-empty.
    ///
    /// Warning: basic authentication is deprecated, and will be removed in GKE
    /// control plane versions 1.19 and newer. For a list of recommended
    /// authentication methods, see:
    /// <https://cloud.google.com/kubernetes-engine/docs/how-to/api-server-authentication>
    #[deprecated]
    pub password: std::string::String,

    /// Configuration for client certificate authentication on the cluster. For
    /// clusters before v1.12, if no configuration is specified, a client
    /// certificate is issued.
    pub client_certificate_config: std::option::Option<crate::model::ClientCertificateConfig>,

    /// Output only. Base64-encoded public certificate that is the root of
    /// trust for the cluster.
    pub cluster_ca_certificate: std::string::String,

    /// Output only. Base64-encoded public certificate used by clients to
    /// authenticate to the cluster endpoint. Issued only if
    /// client_certificate_config is set.
    pub client_certificate: std::string::String,

    /// Output only. Base64-encoded private key used by clients to authenticate
    /// to the cluster endpoint.
    pub client_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MasterAuth {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::MasterAuth::username].
    #[deprecated]
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::MasterAuth::password].
    #[deprecated]
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [client_certificate_config][crate::model::MasterAuth::client_certificate_config].
    pub fn set_client_certificate_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClientCertificateConfig>,
    {
        self.client_certificate_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_certificate_config][crate::model::MasterAuth::client_certificate_config].
    pub fn set_or_clear_client_certificate_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClientCertificateConfig>,
    {
        self.client_certificate_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster_ca_certificate][crate::model::MasterAuth::cluster_ca_certificate].
    pub fn set_cluster_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ca_certificate = v.into();
        self
    }

    /// Sets the value of [client_certificate][crate::model::MasterAuth::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::MasterAuth::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }
}

impl wkt::message::Message for MasterAuth {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MasterAuth"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MasterAuth {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __username,
            __password,
            __client_certificate_config,
            __cluster_ca_certificate,
            __client_certificate,
            __client_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MasterAuth")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "clientCertificateConfig" => {
                                Ok(__FieldTag::__client_certificate_config)
                            }
                            "client_certificate_config" => {
                                Ok(__FieldTag::__client_certificate_config)
                            }
                            "clusterCaCertificate" => Ok(__FieldTag::__cluster_ca_certificate),
                            "cluster_ca_certificate" => Ok(__FieldTag::__cluster_ca_certificate),
                            "clientCertificate" => Ok(__FieldTag::__client_certificate),
                            "client_certificate" => Ok(__FieldTag::__client_certificate),
                            "clientKey" => Ok(__FieldTag::__client_key),
                            "client_key" => Ok(__FieldTag::__client_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MasterAuth;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MasterAuth")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_certificate_config => {
                            if !fields.insert(__FieldTag::__client_certificate_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate_config",
                                ));
                            }
                            result.client_certificate_config = map.next_value::<std::option::Option<crate::model::ClientCertificateConfig>>()?
                                ;
                        }
                        __FieldTag::__cluster_ca_certificate => {
                            if !fields.insert(__FieldTag::__cluster_ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ca_certificate",
                                ));
                            }
                            result.cluster_ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_certificate => {
                            if !fields.insert(__FieldTag::__client_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate",
                                ));
                            }
                            result.client_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_key => {
                            if !fields.insert(__FieldTag::__client_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_key",
                                ));
                            }
                            result.client_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MasterAuth {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if self.client_certificate_config.is_some() {
            state.serialize_entry("clientCertificateConfig", &self.client_certificate_config)?;
        }
        if !self.cluster_ca_certificate.is_empty() {
            state.serialize_entry("clusterCaCertificate", &self.cluster_ca_certificate)?;
        }
        if !self.client_certificate.is_empty() {
            state.serialize_entry("clientCertificate", &self.client_certificate)?;
        }
        if !self.client_key.is_empty() {
            state.serialize_entry("clientKey", &self.client_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MasterAuth {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MasterAuth");
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("client_certificate_config", &self.client_certificate_config);
        debug_struct.field("cluster_ca_certificate", &self.cluster_ca_certificate);
        debug_struct.field("client_certificate", &self.client_certificate);
        debug_struct.field("client_key", &self.client_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for client certificates on the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClientCertificateConfig {
    /// Issue a client certificate.
    pub issue_client_certificate: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClientCertificateConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue_client_certificate][crate::model::ClientCertificateConfig::issue_client_certificate].
    pub fn set_issue_client_certificate<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.issue_client_certificate = v.into();
        self
    }
}

impl wkt::message::Message for ClientCertificateConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ClientCertificateConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClientCertificateConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue_client_certificate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClientCertificateConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issueClientCertificate" => Ok(__FieldTag::__issue_client_certificate),
                            "issue_client_certificate" => {
                                Ok(__FieldTag::__issue_client_certificate)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClientCertificateConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClientCertificateConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue_client_certificate => {
                            if !fields.insert(__FieldTag::__issue_client_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_client_certificate",
                                ));
                            }
                            result.issue_client_certificate = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClientCertificateConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.issue_client_certificate) {
            state.serialize_entry("issueClientCertificate", &self.issue_client_certificate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClientCertificateConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClientCertificateConfig");
        debug_struct.field("issue_client_certificate", &self.issue_client_certificate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for the addons that can be automatically spun up in the
/// cluster, enabling additional functionality.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddonsConfig {
    /// Configuration for the HTTP (L7) load balancing controller addon, which
    /// makes it easy to set up HTTP load balancers for services in a cluster.
    pub http_load_balancing: std::option::Option<crate::model::HttpLoadBalancing>,

    /// Configuration for the horizontal pod autoscaling feature, which
    /// increases or decreases the number of replica pods a replication controller
    /// has based on the resource usage of the existing pods.
    pub horizontal_pod_autoscaling: std::option::Option<crate::model::HorizontalPodAutoscaling>,

    /// Configuration for the Kubernetes Dashboard.
    /// This addon is deprecated, and will be disabled in 1.15. It is recommended
    /// to use the Cloud Console to manage and monitor your Kubernetes clusters,
    /// workloads and applications. For more information, see:
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/dashboards>
    #[deprecated]
    pub kubernetes_dashboard: std::option::Option<crate::model::KubernetesDashboard>,

    /// Configuration for NetworkPolicy. This only tracks whether the addon
    /// is enabled or not on the Master, it does not track whether network policy
    /// is enabled for the nodes.
    pub network_policy_config: std::option::Option<crate::model::NetworkPolicyConfig>,

    /// Configuration for the Cloud Run addon, which allows the user to use a
    /// managed Knative service.
    pub cloud_run_config: std::option::Option<crate::model::CloudRunConfig>,

    /// Configuration for NodeLocalDNS, a dns cache running on cluster nodes
    pub dns_cache_config: std::option::Option<crate::model::DnsCacheConfig>,

    /// Configuration for the ConfigConnector add-on, a Kubernetes
    /// extension to manage hosted GCP services through the Kubernetes API
    pub config_connector_config: std::option::Option<crate::model::ConfigConnectorConfig>,

    /// Configuration for the Compute Engine Persistent Disk CSI driver.
    pub gce_persistent_disk_csi_driver_config:
        std::option::Option<crate::model::GcePersistentDiskCsiDriverConfig>,

    /// Configuration for the GCP Filestore CSI driver.
    pub gcp_filestore_csi_driver_config:
        std::option::Option<crate::model::GcpFilestoreCsiDriverConfig>,

    /// Configuration for the Backup for GKE agent addon.
    pub gke_backup_agent_config: std::option::Option<crate::model::GkeBackupAgentConfig>,

    /// Configuration for the Cloud Storage Fuse CSI driver.
    pub gcs_fuse_csi_driver_config: std::option::Option<crate::model::GcsFuseCsiDriverConfig>,

    /// Optional. Configuration for the StatefulHA add-on.
    pub stateful_ha_config: std::option::Option<crate::model::StatefulHAConfig>,

    /// Configuration for the Cloud Storage Parallelstore CSI driver.
    pub parallelstore_csi_driver_config:
        std::option::Option<crate::model::ParallelstoreCsiDriverConfig>,

    /// Optional. Configuration for Ray Operator addon.
    pub ray_operator_config: std::option::Option<crate::model::RayOperatorConfig>,

    /// Configuration for the High Scale Checkpointing add-on.
    pub high_scale_checkpointing_config:
        std::option::Option<crate::model::HighScaleCheckpointingConfig>,

    /// Configuration for the Lustre CSI driver.
    pub lustre_csi_driver_config: std::option::Option<crate::model::LustreCsiDriverConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddonsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [http_load_balancing][crate::model::AddonsConfig::http_load_balancing].
    pub fn set_http_load_balancing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HttpLoadBalancing>,
    {
        self.http_load_balancing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http_load_balancing][crate::model::AddonsConfig::http_load_balancing].
    pub fn set_or_clear_http_load_balancing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HttpLoadBalancing>,
    {
        self.http_load_balancing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [horizontal_pod_autoscaling][crate::model::AddonsConfig::horizontal_pod_autoscaling].
    pub fn set_horizontal_pod_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HorizontalPodAutoscaling>,
    {
        self.horizontal_pod_autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [horizontal_pod_autoscaling][crate::model::AddonsConfig::horizontal_pod_autoscaling].
    pub fn set_or_clear_horizontal_pod_autoscaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HorizontalPodAutoscaling>,
    {
        self.horizontal_pod_autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kubernetes_dashboard][crate::model::AddonsConfig::kubernetes_dashboard].
    #[deprecated]
    pub fn set_kubernetes_dashboard<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::KubernetesDashboard>,
    {
        self.kubernetes_dashboard = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kubernetes_dashboard][crate::model::AddonsConfig::kubernetes_dashboard].
    #[deprecated]
    pub fn set_or_clear_kubernetes_dashboard<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::KubernetesDashboard>,
    {
        self.kubernetes_dashboard = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_policy_config][crate::model::AddonsConfig::network_policy_config].
    pub fn set_network_policy_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPolicyConfig>,
    {
        self.network_policy_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_policy_config][crate::model::AddonsConfig::network_policy_config].
    pub fn set_or_clear_network_policy_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPolicyConfig>,
    {
        self.network_policy_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cloud_run_config][crate::model::AddonsConfig::cloud_run_config].
    pub fn set_cloud_run_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunConfig>,
    {
        self.cloud_run_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cloud_run_config][crate::model::AddonsConfig::cloud_run_config].
    pub fn set_or_clear_cloud_run_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloudRunConfig>,
    {
        self.cloud_run_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dns_cache_config][crate::model::AddonsConfig::dns_cache_config].
    pub fn set_dns_cache_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DnsCacheConfig>,
    {
        self.dns_cache_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dns_cache_config][crate::model::AddonsConfig::dns_cache_config].
    pub fn set_or_clear_dns_cache_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DnsCacheConfig>,
    {
        self.dns_cache_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config_connector_config][crate::model::AddonsConfig::config_connector_config].
    pub fn set_config_connector_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfigConnectorConfig>,
    {
        self.config_connector_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_connector_config][crate::model::AddonsConfig::config_connector_config].
    pub fn set_or_clear_config_connector_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfigConnectorConfig>,
    {
        self.config_connector_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gce_persistent_disk_csi_driver_config][crate::model::AddonsConfig::gce_persistent_disk_csi_driver_config].
    pub fn set_gce_persistent_disk_csi_driver_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcePersistentDiskCsiDriverConfig>,
    {
        self.gce_persistent_disk_csi_driver_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gce_persistent_disk_csi_driver_config][crate::model::AddonsConfig::gce_persistent_disk_csi_driver_config].
    pub fn set_or_clear_gce_persistent_disk_csi_driver_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::GcePersistentDiskCsiDriverConfig>,
    {
        self.gce_persistent_disk_csi_driver_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gcp_filestore_csi_driver_config][crate::model::AddonsConfig::gcp_filestore_csi_driver_config].
    pub fn set_gcp_filestore_csi_driver_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcpFilestoreCsiDriverConfig>,
    {
        self.gcp_filestore_csi_driver_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcp_filestore_csi_driver_config][crate::model::AddonsConfig::gcp_filestore_csi_driver_config].
    pub fn set_or_clear_gcp_filestore_csi_driver_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::GcpFilestoreCsiDriverConfig>,
    {
        self.gcp_filestore_csi_driver_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gke_backup_agent_config][crate::model::AddonsConfig::gke_backup_agent_config].
    pub fn set_gke_backup_agent_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GkeBackupAgentConfig>,
    {
        self.gke_backup_agent_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gke_backup_agent_config][crate::model::AddonsConfig::gke_backup_agent_config].
    pub fn set_or_clear_gke_backup_agent_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GkeBackupAgentConfig>,
    {
        self.gke_backup_agent_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gcs_fuse_csi_driver_config][crate::model::AddonsConfig::gcs_fuse_csi_driver_config].
    pub fn set_gcs_fuse_csi_driver_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcsFuseCsiDriverConfig>,
    {
        self.gcs_fuse_csi_driver_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcs_fuse_csi_driver_config][crate::model::AddonsConfig::gcs_fuse_csi_driver_config].
    pub fn set_or_clear_gcs_fuse_csi_driver_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcsFuseCsiDriverConfig>,
    {
        self.gcs_fuse_csi_driver_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stateful_ha_config][crate::model::AddonsConfig::stateful_ha_config].
    pub fn set_stateful_ha_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StatefulHAConfig>,
    {
        self.stateful_ha_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stateful_ha_config][crate::model::AddonsConfig::stateful_ha_config].
    pub fn set_or_clear_stateful_ha_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StatefulHAConfig>,
    {
        self.stateful_ha_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parallelstore_csi_driver_config][crate::model::AddonsConfig::parallelstore_csi_driver_config].
    pub fn set_parallelstore_csi_driver_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ParallelstoreCsiDriverConfig>,
    {
        self.parallelstore_csi_driver_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parallelstore_csi_driver_config][crate::model::AddonsConfig::parallelstore_csi_driver_config].
    pub fn set_or_clear_parallelstore_csi_driver_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ParallelstoreCsiDriverConfig>,
    {
        self.parallelstore_csi_driver_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ray_operator_config][crate::model::AddonsConfig::ray_operator_config].
    pub fn set_ray_operator_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RayOperatorConfig>,
    {
        self.ray_operator_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ray_operator_config][crate::model::AddonsConfig::ray_operator_config].
    pub fn set_or_clear_ray_operator_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RayOperatorConfig>,
    {
        self.ray_operator_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [high_scale_checkpointing_config][crate::model::AddonsConfig::high_scale_checkpointing_config].
    pub fn set_high_scale_checkpointing_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HighScaleCheckpointingConfig>,
    {
        self.high_scale_checkpointing_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [high_scale_checkpointing_config][crate::model::AddonsConfig::high_scale_checkpointing_config].
    pub fn set_or_clear_high_scale_checkpointing_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::HighScaleCheckpointingConfig>,
    {
        self.high_scale_checkpointing_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [lustre_csi_driver_config][crate::model::AddonsConfig::lustre_csi_driver_config].
    pub fn set_lustre_csi_driver_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LustreCsiDriverConfig>,
    {
        self.lustre_csi_driver_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [lustre_csi_driver_config][crate::model::AddonsConfig::lustre_csi_driver_config].
    pub fn set_or_clear_lustre_csi_driver_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LustreCsiDriverConfig>,
    {
        self.lustre_csi_driver_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AddonsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AddonsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddonsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http_load_balancing,
            __horizontal_pod_autoscaling,
            __kubernetes_dashboard,
            __network_policy_config,
            __cloud_run_config,
            __dns_cache_config,
            __config_connector_config,
            __gce_persistent_disk_csi_driver_config,
            __gcp_filestore_csi_driver_config,
            __gke_backup_agent_config,
            __gcs_fuse_csi_driver_config,
            __stateful_ha_config,
            __parallelstore_csi_driver_config,
            __ray_operator_config,
            __high_scale_checkpointing_config,
            __lustre_csi_driver_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddonsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "httpLoadBalancing" => Ok(__FieldTag::__http_load_balancing),
                            "http_load_balancing" => Ok(__FieldTag::__http_load_balancing),
                            "horizontalPodAutoscaling" => {
                                Ok(__FieldTag::__horizontal_pod_autoscaling)
                            }
                            "horizontal_pod_autoscaling" => {
                                Ok(__FieldTag::__horizontal_pod_autoscaling)
                            }
                            "kubernetesDashboard" => Ok(__FieldTag::__kubernetes_dashboard),
                            "kubernetes_dashboard" => Ok(__FieldTag::__kubernetes_dashboard),
                            "networkPolicyConfig" => Ok(__FieldTag::__network_policy_config),
                            "network_policy_config" => Ok(__FieldTag::__network_policy_config),
                            "cloudRunConfig" => Ok(__FieldTag::__cloud_run_config),
                            "cloud_run_config" => Ok(__FieldTag::__cloud_run_config),
                            "dnsCacheConfig" => Ok(__FieldTag::__dns_cache_config),
                            "dns_cache_config" => Ok(__FieldTag::__dns_cache_config),
                            "configConnectorConfig" => Ok(__FieldTag::__config_connector_config),
                            "config_connector_config" => Ok(__FieldTag::__config_connector_config),
                            "gcePersistentDiskCsiDriverConfig" => {
                                Ok(__FieldTag::__gce_persistent_disk_csi_driver_config)
                            }
                            "gce_persistent_disk_csi_driver_config" => {
                                Ok(__FieldTag::__gce_persistent_disk_csi_driver_config)
                            }
                            "gcpFilestoreCsiDriverConfig" => {
                                Ok(__FieldTag::__gcp_filestore_csi_driver_config)
                            }
                            "gcp_filestore_csi_driver_config" => {
                                Ok(__FieldTag::__gcp_filestore_csi_driver_config)
                            }
                            "gkeBackupAgentConfig" => Ok(__FieldTag::__gke_backup_agent_config),
                            "gke_backup_agent_config" => Ok(__FieldTag::__gke_backup_agent_config),
                            "gcsFuseCsiDriverConfig" => {
                                Ok(__FieldTag::__gcs_fuse_csi_driver_config)
                            }
                            "gcs_fuse_csi_driver_config" => {
                                Ok(__FieldTag::__gcs_fuse_csi_driver_config)
                            }
                            "statefulHaConfig" => Ok(__FieldTag::__stateful_ha_config),
                            "stateful_ha_config" => Ok(__FieldTag::__stateful_ha_config),
                            "parallelstoreCsiDriverConfig" => {
                                Ok(__FieldTag::__parallelstore_csi_driver_config)
                            }
                            "parallelstore_csi_driver_config" => {
                                Ok(__FieldTag::__parallelstore_csi_driver_config)
                            }
                            "rayOperatorConfig" => Ok(__FieldTag::__ray_operator_config),
                            "ray_operator_config" => Ok(__FieldTag::__ray_operator_config),
                            "highScaleCheckpointingConfig" => {
                                Ok(__FieldTag::__high_scale_checkpointing_config)
                            }
                            "high_scale_checkpointing_config" => {
                                Ok(__FieldTag::__high_scale_checkpointing_config)
                            }
                            "lustreCsiDriverConfig" => Ok(__FieldTag::__lustre_csi_driver_config),
                            "lustre_csi_driver_config" => {
                                Ok(__FieldTag::__lustre_csi_driver_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddonsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddonsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http_load_balancing => {
                            if !fields.insert(__FieldTag::__http_load_balancing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_load_balancing",
                                ));
                            }
                            result.http_load_balancing = map
                                .next_value::<std::option::Option<crate::model::HttpLoadBalancing>>(
                                )?;
                        }
                        __FieldTag::__horizontal_pod_autoscaling => {
                            if !fields.insert(__FieldTag::__horizontal_pod_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for horizontal_pod_autoscaling",
                                ));
                            }
                            result.horizontal_pod_autoscaling = map.next_value::<std::option::Option<crate::model::HorizontalPodAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__kubernetes_dashboard => {
                            if !fields.insert(__FieldTag::__kubernetes_dashboard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubernetes_dashboard",
                                ));
                            }
                            result.kubernetes_dashboard = map.next_value::<std::option::Option<crate::model::KubernetesDashboard>>()?
                                ;
                        }
                        __FieldTag::__network_policy_config => {
                            if !fields.insert(__FieldTag::__network_policy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_policy_config",
                                ));
                            }
                            result.network_policy_config = map.next_value::<std::option::Option<crate::model::NetworkPolicyConfig>>()?
                                ;
                        }
                        __FieldTag::__cloud_run_config => {
                            if !fields.insert(__FieldTag::__cloud_run_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run_config",
                                ));
                            }
                            result.cloud_run_config = map
                                .next_value::<std::option::Option<crate::model::CloudRunConfig>>(
                                )?;
                        }
                        __FieldTag::__dns_cache_config => {
                            if !fields.insert(__FieldTag::__dns_cache_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_cache_config",
                                ));
                            }
                            result.dns_cache_config = map
                                .next_value::<std::option::Option<crate::model::DnsCacheConfig>>(
                                )?;
                        }
                        __FieldTag::__config_connector_config => {
                            if !fields.insert(__FieldTag::__config_connector_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_connector_config",
                                ));
                            }
                            result.config_connector_config = map.next_value::<std::option::Option<crate::model::ConfigConnectorConfig>>()?
                                ;
                        }
                        __FieldTag::__gce_persistent_disk_csi_driver_config => {
                            if !fields.insert(__FieldTag::__gce_persistent_disk_csi_driver_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gce_persistent_disk_csi_driver_config",
                                ));
                            }
                            result.gce_persistent_disk_csi_driver_config =
                                map.next_value::<std::option::Option<
                                    crate::model::GcePersistentDiskCsiDriverConfig,
                                >>()?;
                        }
                        __FieldTag::__gcp_filestore_csi_driver_config => {
                            if !fields.insert(__FieldTag::__gcp_filestore_csi_driver_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_filestore_csi_driver_config",
                                ));
                            }
                            result.gcp_filestore_csi_driver_config = map.next_value::<std::option::Option<crate::model::GcpFilestoreCsiDriverConfig>>()?
                                ;
                        }
                        __FieldTag::__gke_backup_agent_config => {
                            if !fields.insert(__FieldTag::__gke_backup_agent_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_backup_agent_config",
                                ));
                            }
                            result.gke_backup_agent_config = map.next_value::<std::option::Option<crate::model::GkeBackupAgentConfig>>()?
                                ;
                        }
                        __FieldTag::__gcs_fuse_csi_driver_config => {
                            if !fields.insert(__FieldTag::__gcs_fuse_csi_driver_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_fuse_csi_driver_config",
                                ));
                            }
                            result.gcs_fuse_csi_driver_config = map.next_value::<std::option::Option<crate::model::GcsFuseCsiDriverConfig>>()?
                                ;
                        }
                        __FieldTag::__stateful_ha_config => {
                            if !fields.insert(__FieldTag::__stateful_ha_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stateful_ha_config",
                                ));
                            }
                            result.stateful_ha_config = map
                                .next_value::<std::option::Option<crate::model::StatefulHAConfig>>(
                                )?;
                        }
                        __FieldTag::__parallelstore_csi_driver_config => {
                            if !fields.insert(__FieldTag::__parallelstore_csi_driver_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parallelstore_csi_driver_config",
                                ));
                            }
                            result.parallelstore_csi_driver_config = map.next_value::<std::option::Option<crate::model::ParallelstoreCsiDriverConfig>>()?
                                ;
                        }
                        __FieldTag::__ray_operator_config => {
                            if !fields.insert(__FieldTag::__ray_operator_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ray_operator_config",
                                ));
                            }
                            result.ray_operator_config = map
                                .next_value::<std::option::Option<crate::model::RayOperatorConfig>>(
                                )?;
                        }
                        __FieldTag::__high_scale_checkpointing_config => {
                            if !fields.insert(__FieldTag::__high_scale_checkpointing_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for high_scale_checkpointing_config",
                                ));
                            }
                            result.high_scale_checkpointing_config = map.next_value::<std::option::Option<crate::model::HighScaleCheckpointingConfig>>()?
                                ;
                        }
                        __FieldTag::__lustre_csi_driver_config => {
                            if !fields.insert(__FieldTag::__lustre_csi_driver_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lustre_csi_driver_config",
                                ));
                            }
                            result.lustre_csi_driver_config = map.next_value::<std::option::Option<crate::model::LustreCsiDriverConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddonsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.http_load_balancing.is_some() {
            state.serialize_entry("httpLoadBalancing", &self.http_load_balancing)?;
        }
        if self.horizontal_pod_autoscaling.is_some() {
            state.serialize_entry("horizontalPodAutoscaling", &self.horizontal_pod_autoscaling)?;
        }
        if self.kubernetes_dashboard.is_some() {
            state.serialize_entry("kubernetesDashboard", &self.kubernetes_dashboard)?;
        }
        if self.network_policy_config.is_some() {
            state.serialize_entry("networkPolicyConfig", &self.network_policy_config)?;
        }
        if self.cloud_run_config.is_some() {
            state.serialize_entry("cloudRunConfig", &self.cloud_run_config)?;
        }
        if self.dns_cache_config.is_some() {
            state.serialize_entry("dnsCacheConfig", &self.dns_cache_config)?;
        }
        if self.config_connector_config.is_some() {
            state.serialize_entry("configConnectorConfig", &self.config_connector_config)?;
        }
        if self.gce_persistent_disk_csi_driver_config.is_some() {
            state.serialize_entry(
                "gcePersistentDiskCsiDriverConfig",
                &self.gce_persistent_disk_csi_driver_config,
            )?;
        }
        if self.gcp_filestore_csi_driver_config.is_some() {
            state.serialize_entry(
                "gcpFilestoreCsiDriverConfig",
                &self.gcp_filestore_csi_driver_config,
            )?;
        }
        if self.gke_backup_agent_config.is_some() {
            state.serialize_entry("gkeBackupAgentConfig", &self.gke_backup_agent_config)?;
        }
        if self.gcs_fuse_csi_driver_config.is_some() {
            state.serialize_entry("gcsFuseCsiDriverConfig", &self.gcs_fuse_csi_driver_config)?;
        }
        if self.stateful_ha_config.is_some() {
            state.serialize_entry("statefulHaConfig", &self.stateful_ha_config)?;
        }
        if self.parallelstore_csi_driver_config.is_some() {
            state.serialize_entry(
                "parallelstoreCsiDriverConfig",
                &self.parallelstore_csi_driver_config,
            )?;
        }
        if self.ray_operator_config.is_some() {
            state.serialize_entry("rayOperatorConfig", &self.ray_operator_config)?;
        }
        if self.high_scale_checkpointing_config.is_some() {
            state.serialize_entry(
                "highScaleCheckpointingConfig",
                &self.high_scale_checkpointing_config,
            )?;
        }
        if self.lustre_csi_driver_config.is_some() {
            state.serialize_entry("lustreCsiDriverConfig", &self.lustre_csi_driver_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddonsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddonsConfig");
        debug_struct.field("http_load_balancing", &self.http_load_balancing);
        debug_struct.field(
            "horizontal_pod_autoscaling",
            &self.horizontal_pod_autoscaling,
        );
        debug_struct.field("kubernetes_dashboard", &self.kubernetes_dashboard);
        debug_struct.field("network_policy_config", &self.network_policy_config);
        debug_struct.field("cloud_run_config", &self.cloud_run_config);
        debug_struct.field("dns_cache_config", &self.dns_cache_config);
        debug_struct.field("config_connector_config", &self.config_connector_config);
        debug_struct.field(
            "gce_persistent_disk_csi_driver_config",
            &self.gce_persistent_disk_csi_driver_config,
        );
        debug_struct.field(
            "gcp_filestore_csi_driver_config",
            &self.gcp_filestore_csi_driver_config,
        );
        debug_struct.field("gke_backup_agent_config", &self.gke_backup_agent_config);
        debug_struct.field(
            "gcs_fuse_csi_driver_config",
            &self.gcs_fuse_csi_driver_config,
        );
        debug_struct.field("stateful_ha_config", &self.stateful_ha_config);
        debug_struct.field(
            "parallelstore_csi_driver_config",
            &self.parallelstore_csi_driver_config,
        );
        debug_struct.field("ray_operator_config", &self.ray_operator_config);
        debug_struct.field(
            "high_scale_checkpointing_config",
            &self.high_scale_checkpointing_config,
        );
        debug_struct.field("lustre_csi_driver_config", &self.lustre_csi_driver_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration options for the HTTP (L7) load balancing controller addon,
/// which makes it easy to set up HTTP load balancers for services in a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HttpLoadBalancing {
    /// Whether the HTTP Load Balancing controller is enabled in the cluster.
    /// When enabled, it runs a small pod in the cluster that manages the load
    /// balancers.
    pub disabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpLoadBalancing {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::HttpLoadBalancing::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for HttpLoadBalancing {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.HttpLoadBalancing"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HttpLoadBalancing {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpLoadBalancing")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HttpLoadBalancing;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpLoadBalancing")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HttpLoadBalancing {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HttpLoadBalancing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpLoadBalancing");
        debug_struct.field("disabled", &self.disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration options for the horizontal pod autoscaling feature, which
/// increases or decreases the number of replica pods a replication controller
/// has based on the resource usage of the existing pods.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HorizontalPodAutoscaling {
    /// Whether the Horizontal Pod Autoscaling feature is enabled in the cluster.
    /// When enabled, it ensures that metrics are collected into Stackdriver
    /// Monitoring.
    pub disabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HorizontalPodAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::HorizontalPodAutoscaling::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for HorizontalPodAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.HorizontalPodAutoscaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HorizontalPodAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HorizontalPodAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HorizontalPodAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HorizontalPodAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HorizontalPodAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HorizontalPodAutoscaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HorizontalPodAutoscaling");
        debug_struct.field("disabled", &self.disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for the Kubernetes Dashboard.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct KubernetesDashboard {
    /// Whether the Kubernetes Dashboard is enabled for this cluster.
    pub disabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl KubernetesDashboard {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::KubernetesDashboard::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for KubernetesDashboard {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.KubernetesDashboard"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for KubernetesDashboard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KubernetesDashboard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = KubernetesDashboard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KubernetesDashboard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for KubernetesDashboard {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for KubernetesDashboard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KubernetesDashboard");
        debug_struct.field("disabled", &self.disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for NetworkPolicy. This only tracks whether the addon
/// is enabled or not on the Master, it does not track whether network policy
/// is enabled for the nodes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkPolicyConfig {
    /// Whether NetworkPolicy is enabled for this cluster.
    pub disabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkPolicyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::NetworkPolicyConfig::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for NetworkPolicyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NetworkPolicyConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkPolicyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkPolicyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkPolicyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkPolicyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkPolicyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkPolicyConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkPolicyConfig");
        debug_struct.field("disabled", &self.disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for NodeLocal DNSCache
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DnsCacheConfig {
    /// Whether NodeLocal DNSCache is enabled for this cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DnsCacheConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::DnsCacheConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for DnsCacheConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DnsCacheConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DnsCacheConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DnsCacheConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DnsCacheConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DnsCacheConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DnsCacheConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DnsCacheConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DnsCacheConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for controlling master global access settings.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivateClusterMasterGlobalAccessConfig {
    /// Whenever master is accessible globally or not.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateClusterMasterGlobalAccessConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::PrivateClusterMasterGlobalAccessConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for PrivateClusterMasterGlobalAccessConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.PrivateClusterMasterGlobalAccessConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivateClusterMasterGlobalAccessConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for PrivateClusterMasterGlobalAccessConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivateClusterMasterGlobalAccessConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateClusterMasterGlobalAccessConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivateClusterMasterGlobalAccessConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivateClusterMasterGlobalAccessConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateClusterMasterGlobalAccessConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration options for private clusters.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivateClusterConfig {
    /// Whether nodes have internal IP addresses only. If enabled, all nodes are
    /// given only RFC 1918 private addresses and communicate with the master via
    /// private networking.
    ///
    /// Deprecated: Use
    /// [NetworkConfig.default_enable_private_nodes][google.container.v1.NetworkConfig.default_enable_private_nodes]
    /// instead.
    ///
    /// [google.container.v1.NetworkConfig.default_enable_private_nodes]: crate::model::NetworkConfig::default_enable_private_nodes
    #[deprecated]
    pub enable_private_nodes: bool,

    /// Whether the master's internal IP address is used as the cluster endpoint.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.enable_public_endpoint][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.enable_public_endpoint]
    /// instead. Note that the value of enable_public_endpoint is reversed: if
    /// enable_private_endpoint is false, then enable_public_endpoint will be true.
    ///
    /// [google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.enable_public_endpoint]: crate::model::control_plane_endpoints_config::IPEndpointsConfig::enable_public_endpoint
    #[deprecated]
    pub enable_private_endpoint: bool,

    /// The IP range in CIDR notation to use for the hosted master network. This
    /// range will be used for assigning internal IP addresses to the master or
    /// set of masters, as well as the ILB VIP. This range must not overlap with
    /// any other ranges in use within the cluster's network.
    pub master_ipv4_cidr_block: std::string::String,

    /// Output only. The internal IP address of this cluster's master endpoint.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint]
    /// instead.
    ///
    /// [google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint]: crate::model::control_plane_endpoints_config::IPEndpointsConfig::private_endpoint
    #[deprecated]
    pub private_endpoint: std::string::String,

    /// Output only. The external IP address of this cluster's master endpoint.
    ///
    /// Deprecated:Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.public_endpoint][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.public_endpoint]
    /// instead.
    ///
    /// [google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.public_endpoint]: crate::model::control_plane_endpoints_config::IPEndpointsConfig::public_endpoint
    #[deprecated]
    pub public_endpoint: std::string::String,

    /// Output only. The peering name in the customer VPC used by this cluster.
    pub peering_name: std::string::String,

    /// Controls master global access settings.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.enable_global_access][]
    /// instead.
    #[deprecated]
    pub master_global_access_config:
        std::option::Option<crate::model::PrivateClusterMasterGlobalAccessConfig>,

    /// Subnet to provision the master's private endpoint during cluster creation.
    /// Specified in projects/*/regions/*/subnetworks/* format.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint_subnetwork][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint_subnetwork]
    /// instead.
    ///
    /// [google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.private_endpoint_subnetwork]: crate::model::control_plane_endpoints_config::IPEndpointsConfig::private_endpoint_subnetwork
    #[deprecated]
    pub private_endpoint_subnetwork: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivateClusterConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_private_nodes][crate::model::PrivateClusterConfig::enable_private_nodes].
    #[deprecated]
    pub fn set_enable_private_nodes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_nodes = v.into();
        self
    }

    /// Sets the value of [enable_private_endpoint][crate::model::PrivateClusterConfig::enable_private_endpoint].
    #[deprecated]
    pub fn set_enable_private_endpoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_private_endpoint = v.into();
        self
    }

    /// Sets the value of [master_ipv4_cidr_block][crate::model::PrivateClusterConfig::master_ipv4_cidr_block].
    pub fn set_master_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.master_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [private_endpoint][crate::model::PrivateClusterConfig::private_endpoint].
    #[deprecated]
    pub fn set_private_endpoint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint = v.into();
        self
    }

    /// Sets the value of [public_endpoint][crate::model::PrivateClusterConfig::public_endpoint].
    #[deprecated]
    pub fn set_public_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_endpoint = v.into();
        self
    }

    /// Sets the value of [peering_name][crate::model::PrivateClusterConfig::peering_name].
    pub fn set_peering_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.peering_name = v.into();
        self
    }

    /// Sets the value of [master_global_access_config][crate::model::PrivateClusterConfig::master_global_access_config].
    #[deprecated]
    pub fn set_master_global_access_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateClusterMasterGlobalAccessConfig>,
    {
        self.master_global_access_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [master_global_access_config][crate::model::PrivateClusterConfig::master_global_access_config].
    #[deprecated]
    pub fn set_or_clear_master_global_access_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivateClusterMasterGlobalAccessConfig>,
    {
        self.master_global_access_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_endpoint_subnetwork][crate::model::PrivateClusterConfig::private_endpoint_subnetwork].
    #[deprecated]
    pub fn set_private_endpoint_subnetwork<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_endpoint_subnetwork = v.into();
        self
    }
}

impl wkt::message::Message for PrivateClusterConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.PrivateClusterConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivateClusterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_private_nodes,
            __enable_private_endpoint,
            __master_ipv4_cidr_block,
            __private_endpoint,
            __public_endpoint,
            __peering_name,
            __master_global_access_config,
            __private_endpoint_subnetwork,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivateClusterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enablePrivateNodes" => Ok(__FieldTag::__enable_private_nodes),
                            "enable_private_nodes" => Ok(__FieldTag::__enable_private_nodes),
                            "enablePrivateEndpoint" => Ok(__FieldTag::__enable_private_endpoint),
                            "enable_private_endpoint" => Ok(__FieldTag::__enable_private_endpoint),
                            "masterIpv4CidrBlock" => Ok(__FieldTag::__master_ipv4_cidr_block),
                            "master_ipv4_cidr_block" => Ok(__FieldTag::__master_ipv4_cidr_block),
                            "privateEndpoint" => Ok(__FieldTag::__private_endpoint),
                            "private_endpoint" => Ok(__FieldTag::__private_endpoint),
                            "publicEndpoint" => Ok(__FieldTag::__public_endpoint),
                            "public_endpoint" => Ok(__FieldTag::__public_endpoint),
                            "peeringName" => Ok(__FieldTag::__peering_name),
                            "peering_name" => Ok(__FieldTag::__peering_name),
                            "masterGlobalAccessConfig" => {
                                Ok(__FieldTag::__master_global_access_config)
                            }
                            "master_global_access_config" => {
                                Ok(__FieldTag::__master_global_access_config)
                            }
                            "privateEndpointSubnetwork" => {
                                Ok(__FieldTag::__private_endpoint_subnetwork)
                            }
                            "private_endpoint_subnetwork" => {
                                Ok(__FieldTag::__private_endpoint_subnetwork)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivateClusterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateClusterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_private_nodes => {
                            if !fields.insert(__FieldTag::__enable_private_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_private_nodes",
                                ));
                            }
                            result.enable_private_nodes = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_private_endpoint => {
                            if !fields.insert(__FieldTag::__enable_private_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_private_endpoint",
                                ));
                            }
                            result.enable_private_endpoint = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__master_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__master_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_ipv4_cidr_block",
                                ));
                            }
                            result.master_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_endpoint => {
                            if !fields.insert(__FieldTag::__private_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint",
                                ));
                            }
                            result.private_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_endpoint => {
                            if !fields.insert(__FieldTag::__public_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_endpoint",
                                ));
                            }
                            result.public_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peering_name => {
                            if !fields.insert(__FieldTag::__peering_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peering_name",
                                ));
                            }
                            result.peering_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__master_global_access_config => {
                            if !fields.insert(__FieldTag::__master_global_access_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_global_access_config",
                                ));
                            }
                            result.master_global_access_config = map
                                .next_value::<std::option::Option<
                                    crate::model::PrivateClusterMasterGlobalAccessConfig,
                                >>()?;
                        }
                        __FieldTag::__private_endpoint_subnetwork => {
                            if !fields.insert(__FieldTag::__private_endpoint_subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint_subnetwork",
                                ));
                            }
                            result.private_endpoint_subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivateClusterConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_private_nodes) {
            state.serialize_entry("enablePrivateNodes", &self.enable_private_nodes)?;
        }
        if !wkt::internal::is_default(&self.enable_private_endpoint) {
            state.serialize_entry("enablePrivateEndpoint", &self.enable_private_endpoint)?;
        }
        if !self.master_ipv4_cidr_block.is_empty() {
            state.serialize_entry("masterIpv4CidrBlock", &self.master_ipv4_cidr_block)?;
        }
        if !self.private_endpoint.is_empty() {
            state.serialize_entry("privateEndpoint", &self.private_endpoint)?;
        }
        if !self.public_endpoint.is_empty() {
            state.serialize_entry("publicEndpoint", &self.public_endpoint)?;
        }
        if !self.peering_name.is_empty() {
            state.serialize_entry("peeringName", &self.peering_name)?;
        }
        if self.master_global_access_config.is_some() {
            state.serialize_entry(
                "masterGlobalAccessConfig",
                &self.master_global_access_config,
            )?;
        }
        if !self.private_endpoint_subnetwork.is_empty() {
            state.serialize_entry(
                "privateEndpointSubnetwork",
                &self.private_endpoint_subnetwork,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivateClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateClusterConfig");
        debug_struct.field("enable_private_nodes", &self.enable_private_nodes);
        debug_struct.field("enable_private_endpoint", &self.enable_private_endpoint);
        debug_struct.field("master_ipv4_cidr_block", &self.master_ipv4_cidr_block);
        debug_struct.field("private_endpoint", &self.private_endpoint);
        debug_struct.field("public_endpoint", &self.public_endpoint);
        debug_struct.field("peering_name", &self.peering_name);
        debug_struct.field(
            "master_global_access_config",
            &self.master_global_access_config,
        );
        debug_struct.field(
            "private_endpoint_subnetwork",
            &self.private_endpoint_subnetwork,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for returning group information from authenticators.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuthenticatorGroupsConfig {
    /// Whether this cluster should return group membership lookups
    /// during authentication using a group of security groups.
    pub enabled: bool,

    /// The name of the security group-of-groups to be used. Only relevant
    /// if enabled = true.
    pub security_group: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthenticatorGroupsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::AuthenticatorGroupsConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [security_group][crate::model::AuthenticatorGroupsConfig::security_group].
    pub fn set_security_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.security_group = v.into();
        self
    }
}

impl wkt::message::Message for AuthenticatorGroupsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AuthenticatorGroupsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuthenticatorGroupsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __security_group,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuthenticatorGroupsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "securityGroup" => Ok(__FieldTag::__security_group),
                            "security_group" => Ok(__FieldTag::__security_group),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuthenticatorGroupsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuthenticatorGroupsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__security_group => {
                            if !fields.insert(__FieldTag::__security_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_group",
                                ));
                            }
                            result.security_group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuthenticatorGroupsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.security_group.is_empty() {
            state.serialize_entry("securityGroup", &self.security_group)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AuthenticatorGroupsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthenticatorGroupsConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("security_group", &self.security_group);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration options for the Cloud Run feature.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloudRunConfig {
    /// Whether Cloud Run addon is enabled for this cluster.
    pub disabled: bool,

    /// Which load balancer type is installed for Cloud Run.
    pub load_balancer_type: crate::model::cloud_run_config::LoadBalancerType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloudRunConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::CloudRunConfig::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [load_balancer_type][crate::model::CloudRunConfig::load_balancer_type].
    pub fn set_load_balancer_type<
        T: std::convert::Into<crate::model::cloud_run_config::LoadBalancerType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.load_balancer_type = v.into();
        self
    }
}

impl wkt::message::Message for CloudRunConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CloudRunConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloudRunConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            __load_balancer_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRunConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            "loadBalancerType" => Ok(__FieldTag::__load_balancer_type),
                            "load_balancer_type" => Ok(__FieldTag::__load_balancer_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloudRunConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRunConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__load_balancer_type => {
                            if !fields.insert(__FieldTag::__load_balancer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_type",
                                ));
                            }
                            result.load_balancer_type = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_run_config::LoadBalancerType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloudRunConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !wkt::internal::is_default(&self.load_balancer_type) {
            state.serialize_entry("loadBalancerType", &self.load_balancer_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloudRunConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudRunConfig");
        debug_struct.field("disabled", &self.disabled);
        debug_struct.field("load_balancer_type", &self.load_balancer_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloudRunConfig].
pub mod cloud_run_config {
    #[allow(unused_imports)]
    use super::*;

    /// Load balancer type of ingress service of Cloud Run.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LoadBalancerType {
        /// Load balancer type for Cloud Run is unspecified.
        Unspecified,
        /// Install external load balancer for Cloud Run.
        External,
        /// Install internal load balancer for Cloud Run.
        Internal,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LoadBalancerType::value] or
        /// [LoadBalancerType::name].
        UnknownValue(load_balancer_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod load_balancer_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LoadBalancerType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::External => std::option::Option::Some(1),
                Self::Internal => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOAD_BALANCER_TYPE_UNSPECIFIED"),
                Self::External => std::option::Option::Some("LOAD_BALANCER_TYPE_EXTERNAL"),
                Self::Internal => std::option::Option::Some("LOAD_BALANCER_TYPE_INTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LoadBalancerType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LoadBalancerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LoadBalancerType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::External,
                2 => Self::Internal,
                _ => Self::UnknownValue(load_balancer_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LoadBalancerType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOAD_BALANCER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "LOAD_BALANCER_TYPE_EXTERNAL" => Self::External,
                "LOAD_BALANCER_TYPE_INTERNAL" => Self::Internal,
                _ => Self::UnknownValue(load_balancer_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LoadBalancerType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::External => serializer.serialize_i32(1),
                Self::Internal => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LoadBalancerType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LoadBalancerType>::new(
                ".google.container.v1.CloudRunConfig.LoadBalancerType",
            ))
        }
    }
}

/// Configuration options for the Config Connector add-on.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfigConnectorConfig {
    /// Whether Cloud Connector is enabled for this cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigConnectorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ConfigConnectorConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ConfigConnectorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ConfigConnectorConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfigConnectorConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigConnectorConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfigConnectorConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigConnectorConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfigConnectorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConfigConnectorConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigConnectorConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for the Compute Engine PD CSI driver.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcePersistentDiskCsiDriverConfig {
    /// Whether the Compute Engine PD CSI driver is enabled for this cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcePersistentDiskCsiDriverConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::GcePersistentDiskCsiDriverConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for GcePersistentDiskCsiDriverConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GcePersistentDiskCsiDriverConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcePersistentDiskCsiDriverConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcePersistentDiskCsiDriverConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcePersistentDiskCsiDriverConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcePersistentDiskCsiDriverConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcePersistentDiskCsiDriverConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcePersistentDiskCsiDriverConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcePersistentDiskCsiDriverConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for the GCP Filestore CSI driver.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcpFilestoreCsiDriverConfig {
    /// Whether the GCP Filestore CSI driver is enabled for this cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcpFilestoreCsiDriverConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::GcpFilestoreCsiDriverConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for GcpFilestoreCsiDriverConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GcpFilestoreCsiDriverConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcpFilestoreCsiDriverConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcpFilestoreCsiDriverConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcpFilestoreCsiDriverConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcpFilestoreCsiDriverConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcpFilestoreCsiDriverConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcpFilestoreCsiDriverConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcpFilestoreCsiDriverConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for the Cloud Storage Fuse CSI driver.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GcsFuseCsiDriverConfig {
    /// Whether the Cloud Storage Fuse CSI driver is enabled for this cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcsFuseCsiDriverConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::GcsFuseCsiDriverConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for GcsFuseCsiDriverConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GcsFuseCsiDriverConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcsFuseCsiDriverConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsFuseCsiDriverConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcsFuseCsiDriverConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsFuseCsiDriverConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcsFuseCsiDriverConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GcsFuseCsiDriverConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsFuseCsiDriverConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for the Cloud Storage Parallelstore CSI driver.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ParallelstoreCsiDriverConfig {
    /// Whether the Cloud Storage Parallelstore CSI driver is enabled for this
    /// cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ParallelstoreCsiDriverConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ParallelstoreCsiDriverConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ParallelstoreCsiDriverConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ParallelstoreCsiDriverConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ParallelstoreCsiDriverConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ParallelstoreCsiDriverConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ParallelstoreCsiDriverConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ParallelstoreCsiDriverConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ParallelstoreCsiDriverConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ParallelstoreCsiDriverConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ParallelstoreCsiDriverConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for the High Scale Checkpointing.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HighScaleCheckpointingConfig {
    /// Whether the High Scale Checkpointing is enabled for this
    /// cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HighScaleCheckpointingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::HighScaleCheckpointingConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for HighScaleCheckpointingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.HighScaleCheckpointingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HighScaleCheckpointingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HighScaleCheckpointingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HighScaleCheckpointingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HighScaleCheckpointingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HighScaleCheckpointingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for HighScaleCheckpointingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HighScaleCheckpointingConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for the Lustre CSI driver.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LustreCsiDriverConfig {
    /// Whether the Lustre CSI driver is enabled for this cluster.
    pub enabled: bool,

    /// If set to true, the Lustre CSI driver will install Lustre kernel modules
    /// using port 6988.
    pub enable_legacy_lustre_port: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LustreCsiDriverConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::LustreCsiDriverConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [enable_legacy_lustre_port][crate::model::LustreCsiDriverConfig::enable_legacy_lustre_port].
    pub fn set_enable_legacy_lustre_port<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_legacy_lustre_port = v.into();
        self
    }
}

impl wkt::message::Message for LustreCsiDriverConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LustreCsiDriverConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LustreCsiDriverConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __enable_legacy_lustre_port,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LustreCsiDriverConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "enableLegacyLustrePort" => Ok(__FieldTag::__enable_legacy_lustre_port),
                            "enable_legacy_lustre_port" => {
                                Ok(__FieldTag::__enable_legacy_lustre_port)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LustreCsiDriverConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LustreCsiDriverConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_legacy_lustre_port => {
                            if !fields.insert(__FieldTag::__enable_legacy_lustre_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_legacy_lustre_port",
                                ));
                            }
                            result.enable_legacy_lustre_port = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LustreCsiDriverConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.enable_legacy_lustre_port) {
            state.serialize_entry("enableLegacyLustrePort", &self.enable_legacy_lustre_port)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LustreCsiDriverConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LustreCsiDriverConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("enable_legacy_lustre_port", &self.enable_legacy_lustre_port);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration options for the Ray Operator add-on.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RayOperatorConfig {
    /// Whether the Ray Operator addon is enabled for this cluster.
    pub enabled: bool,

    /// Optional. Logging configuration for Ray clusters.
    pub ray_cluster_logging_config: std::option::Option<crate::model::RayClusterLoggingConfig>,

    /// Optional. Monitoring configuration for Ray clusters.
    pub ray_cluster_monitoring_config:
        std::option::Option<crate::model::RayClusterMonitoringConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RayOperatorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::RayOperatorConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [ray_cluster_logging_config][crate::model::RayOperatorConfig::ray_cluster_logging_config].
    pub fn set_ray_cluster_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RayClusterLoggingConfig>,
    {
        self.ray_cluster_logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ray_cluster_logging_config][crate::model::RayOperatorConfig::ray_cluster_logging_config].
    pub fn set_or_clear_ray_cluster_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RayClusterLoggingConfig>,
    {
        self.ray_cluster_logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ray_cluster_monitoring_config][crate::model::RayOperatorConfig::ray_cluster_monitoring_config].
    pub fn set_ray_cluster_monitoring_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RayClusterMonitoringConfig>,
    {
        self.ray_cluster_monitoring_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ray_cluster_monitoring_config][crate::model::RayOperatorConfig::ray_cluster_monitoring_config].
    pub fn set_or_clear_ray_cluster_monitoring_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::RayClusterMonitoringConfig>,
    {
        self.ray_cluster_monitoring_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RayOperatorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RayOperatorConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RayOperatorConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __ray_cluster_logging_config,
            __ray_cluster_monitoring_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RayOperatorConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "rayClusterLoggingConfig" => {
                                Ok(__FieldTag::__ray_cluster_logging_config)
                            }
                            "ray_cluster_logging_config" => {
                                Ok(__FieldTag::__ray_cluster_logging_config)
                            }
                            "rayClusterMonitoringConfig" => {
                                Ok(__FieldTag::__ray_cluster_monitoring_config)
                            }
                            "ray_cluster_monitoring_config" => {
                                Ok(__FieldTag::__ray_cluster_monitoring_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RayOperatorConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RayOperatorConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ray_cluster_logging_config => {
                            if !fields.insert(__FieldTag::__ray_cluster_logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ray_cluster_logging_config",
                                ));
                            }
                            result.ray_cluster_logging_config = map.next_value::<std::option::Option<crate::model::RayClusterLoggingConfig>>()?
                                ;
                        }
                        __FieldTag::__ray_cluster_monitoring_config => {
                            if !fields.insert(__FieldTag::__ray_cluster_monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ray_cluster_monitoring_config",
                                ));
                            }
                            result.ray_cluster_monitoring_config = map.next_value::<std::option::Option<crate::model::RayClusterMonitoringConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RayOperatorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.ray_cluster_logging_config.is_some() {
            state.serialize_entry("rayClusterLoggingConfig", &self.ray_cluster_logging_config)?;
        }
        if self.ray_cluster_monitoring_config.is_some() {
            state.serialize_entry(
                "rayClusterMonitoringConfig",
                &self.ray_cluster_monitoring_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RayOperatorConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RayOperatorConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field(
            "ray_cluster_logging_config",
            &self.ray_cluster_logging_config,
        );
        debug_struct.field(
            "ray_cluster_monitoring_config",
            &self.ray_cluster_monitoring_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for the Backup for GKE Agent.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GkeBackupAgentConfig {
    /// Whether the Backup for GKE agent is enabled for this cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GkeBackupAgentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::GkeBackupAgentConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for GkeBackupAgentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GkeBackupAgentConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GkeBackupAgentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GkeBackupAgentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GkeBackupAgentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GkeBackupAgentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GkeBackupAgentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GkeBackupAgentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GkeBackupAgentConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for the Stateful HA add-on.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StatefulHAConfig {
    /// Whether the Stateful HA add-on is enabled for this cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StatefulHAConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::StatefulHAConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for StatefulHAConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.StatefulHAConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StatefulHAConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StatefulHAConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StatefulHAConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StatefulHAConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StatefulHAConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StatefulHAConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StatefulHAConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration options for the master authorized networks feature. Enabled
/// master authorized networks will disallow all external traffic to access
/// Kubernetes master through HTTPS except traffic from the given CIDR blocks,
/// Google Compute Engine Public IPs and Google Prod IPs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MasterAuthorizedNetworksConfig {
    /// Whether or not master authorized networks is enabled.
    pub enabled: bool,

    /// cidr_blocks define up to 50 external networks that could access
    /// Kubernetes master through HTTPS.
    pub cidr_blocks: std::vec::Vec<crate::model::master_authorized_networks_config::CidrBlock>,

    /// Whether master is accessible via Google Compute Engine Public IP addresses.
    pub gcp_public_cidrs_access_enabled: std::option::Option<bool>,

    /// Whether master authorized networks is enforced on private endpoint or not.
    pub private_endpoint_enforcement_enabled: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MasterAuthorizedNetworksConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::MasterAuthorizedNetworksConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [cidr_blocks][crate::model::MasterAuthorizedNetworksConfig::cidr_blocks].
    pub fn set_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::master_authorized_networks_config::CidrBlock>,
    {
        use std::iter::Iterator;
        self.cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [gcp_public_cidrs_access_enabled][crate::model::MasterAuthorizedNetworksConfig::gcp_public_cidrs_access_enabled].
    pub fn set_gcp_public_cidrs_access_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.gcp_public_cidrs_access_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcp_public_cidrs_access_enabled][crate::model::MasterAuthorizedNetworksConfig::gcp_public_cidrs_access_enabled].
    pub fn set_or_clear_gcp_public_cidrs_access_enabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.gcp_public_cidrs_access_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_endpoint_enforcement_enabled][crate::model::MasterAuthorizedNetworksConfig::private_endpoint_enforcement_enabled].
    pub fn set_private_endpoint_enforcement_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.private_endpoint_enforcement_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_endpoint_enforcement_enabled][crate::model::MasterAuthorizedNetworksConfig::private_endpoint_enforcement_enabled].
    pub fn set_or_clear_private_endpoint_enforcement_enabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.private_endpoint_enforcement_enabled = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MasterAuthorizedNetworksConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MasterAuthorizedNetworksConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MasterAuthorizedNetworksConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __cidr_blocks,
            __gcp_public_cidrs_access_enabled,
            __private_endpoint_enforcement_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MasterAuthorizedNetworksConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "cidrBlocks" => Ok(__FieldTag::__cidr_blocks),
                            "cidr_blocks" => Ok(__FieldTag::__cidr_blocks),
                            "gcpPublicCidrsAccessEnabled" => {
                                Ok(__FieldTag::__gcp_public_cidrs_access_enabled)
                            }
                            "gcp_public_cidrs_access_enabled" => {
                                Ok(__FieldTag::__gcp_public_cidrs_access_enabled)
                            }
                            "privateEndpointEnforcementEnabled" => {
                                Ok(__FieldTag::__private_endpoint_enforcement_enabled)
                            }
                            "private_endpoint_enforcement_enabled" => {
                                Ok(__FieldTag::__private_endpoint_enforcement_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MasterAuthorizedNetworksConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MasterAuthorizedNetworksConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cidr_blocks => {
                            if !fields.insert(__FieldTag::__cidr_blocks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cidr_blocks",
                                ));
                            }
                            result.cidr_blocks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::master_authorized_networks_config::CidrBlock,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_public_cidrs_access_enabled => {
                            if !fields.insert(__FieldTag::__gcp_public_cidrs_access_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_public_cidrs_access_enabled",
                                ));
                            }
                            result.gcp_public_cidrs_access_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__private_endpoint_enforcement_enabled => {
                            if !fields.insert(__FieldTag::__private_endpoint_enforcement_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint_enforcement_enabled",
                                ));
                            }
                            result.private_endpoint_enforcement_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MasterAuthorizedNetworksConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.cidr_blocks.is_empty() {
            state.serialize_entry("cidrBlocks", &self.cidr_blocks)?;
        }
        if self.gcp_public_cidrs_access_enabled.is_some() {
            state.serialize_entry(
                "gcpPublicCidrsAccessEnabled",
                &self.gcp_public_cidrs_access_enabled,
            )?;
        }
        if self.private_endpoint_enforcement_enabled.is_some() {
            state.serialize_entry(
                "privateEndpointEnforcementEnabled",
                &self.private_endpoint_enforcement_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MasterAuthorizedNetworksConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MasterAuthorizedNetworksConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("cidr_blocks", &self.cidr_blocks);
        debug_struct.field(
            "gcp_public_cidrs_access_enabled",
            &self.gcp_public_cidrs_access_enabled,
        );
        debug_struct.field(
            "private_endpoint_enforcement_enabled",
            &self.private_endpoint_enforcement_enabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MasterAuthorizedNetworksConfig].
pub mod master_authorized_networks_config {
    #[allow(unused_imports)]
    use super::*;

    /// CidrBlock contains an optional name and one CIDR block.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CidrBlock {
        /// display_name is an optional field for users to identify CIDR blocks.
        pub display_name: std::string::String,

        /// cidr_block must be specified in CIDR notation.
        pub cidr_block: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CidrBlock {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [display_name][crate::model::master_authorized_networks_config::CidrBlock::display_name].
        pub fn set_display_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.display_name = v.into();
            self
        }

        /// Sets the value of [cidr_block][crate::model::master_authorized_networks_config::CidrBlock::cidr_block].
        pub fn set_cidr_block<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cidr_block = v.into();
            self
        }
    }

    impl wkt::message::Message for CidrBlock {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.MasterAuthorizedNetworksConfig.CidrBlock"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CidrBlock {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __display_name,
                __cidr_block,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CidrBlock")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "displayName" => Ok(__FieldTag::__display_name),
                                "display_name" => Ok(__FieldTag::__display_name),
                                "cidrBlock" => Ok(__FieldTag::__cidr_block),
                                "cidr_block" => Ok(__FieldTag::__cidr_block),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CidrBlock;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CidrBlock")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__display_name => {
                                if !fields.insert(__FieldTag::__display_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for display_name",
                                    ));
                                }
                                result.display_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cidr_block => {
                                if !fields.insert(__FieldTag::__cidr_block) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cidr_block",
                                    ));
                                }
                                result.cidr_block = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CidrBlock {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.display_name.is_empty() {
                state.serialize_entry("displayName", &self.display_name)?;
            }
            if !self.cidr_block.is_empty() {
                state.serialize_entry("cidrBlock", &self.cidr_block)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for CidrBlock {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("CidrBlock");
            debug_struct.field("display_name", &self.display_name);
            debug_struct.field("cidr_block", &self.cidr_block);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Configuration for the legacy Attribute Based Access Control authorization
/// mode.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LegacyAbac {
    /// Whether the ABAC authorizer is enabled for this cluster. When enabled,
    /// identities in the system, including service accounts, nodes, and
    /// controllers, will have statically granted permissions beyond those
    /// provided by the RBAC configuration or IAM.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LegacyAbac {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::LegacyAbac::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for LegacyAbac {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LegacyAbac"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LegacyAbac {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LegacyAbac")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LegacyAbac;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LegacyAbac")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LegacyAbac {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LegacyAbac {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LegacyAbac");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration options for the NetworkPolicy feature.
/// <https://kubernetes.io/docs/concepts/services-networking/networkpolicies/>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkPolicy {
    /// The selected network policy provider.
    pub provider: crate::model::network_policy::Provider,

    /// Whether network policy is enabled on the cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [provider][crate::model::NetworkPolicy::provider].
    pub fn set_provider<T: std::convert::Into<crate::model::network_policy::Provider>>(
        mut self,
        v: T,
    ) -> Self {
        self.provider = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::NetworkPolicy::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for NetworkPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NetworkPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __provider,
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "provider" => Ok(__FieldTag::__provider),
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__provider => {
                            if !fields.insert(__FieldTag::__provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provider",
                                ));
                            }
                            result.provider = map.next_value::<std::option::Option<crate::model::network_policy::Provider>>()?.unwrap_or_default();
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.provider) {
            state.serialize_entry("provider", &self.provider)?;
        }
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkPolicy");
        debug_struct.field("provider", &self.provider);
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NetworkPolicy].
pub mod network_policy {
    #[allow(unused_imports)]
    use super::*;

    /// Allowed Network Policy providers.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Provider {
        /// Not set
        Unspecified,
        /// Tigera (Calico Felix).
        Calico,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Provider::value] or
        /// [Provider::name].
        UnknownValue(provider::UnknownValue),
    }

    #[doc(hidden)]
    pub mod provider {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Provider {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Calico => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROVIDER_UNSPECIFIED"),
                Self::Calico => std::option::Option::Some("CALICO"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Provider {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Provider {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Provider {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Calico,
                _ => Self::UnknownValue(provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Provider {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROVIDER_UNSPECIFIED" => Self::Unspecified,
                "CALICO" => Self::Calico,
                _ => Self::UnknownValue(provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Provider {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Calico => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Provider {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Provider>::new(
                ".google.container.v1.NetworkPolicy.Provider",
            ))
        }
    }
}

/// Configuration for Binary Authorization.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BinaryAuthorization {
    /// This field is deprecated. Leave this unset and instead configure
    /// BinaryAuthorization using evaluation_mode. If evaluation_mode is set to
    /// anything other than EVALUATION_MODE_UNSPECIFIED, this field is ignored.
    #[deprecated]
    pub enabled: bool,

    /// Mode of operation for binauthz policy evaluation. If unspecified, defaults
    /// to DISABLED.
    pub evaluation_mode: crate::model::binary_authorization::EvaluationMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BinaryAuthorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::BinaryAuthorization::enabled].
    #[deprecated]
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [evaluation_mode][crate::model::BinaryAuthorization::evaluation_mode].
    pub fn set_evaluation_mode<
        T: std::convert::Into<crate::model::binary_authorization::EvaluationMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.evaluation_mode = v.into();
        self
    }
}

impl wkt::message::Message for BinaryAuthorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.BinaryAuthorization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BinaryAuthorization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __evaluation_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BinaryAuthorization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "evaluationMode" => Ok(__FieldTag::__evaluation_mode),
                            "evaluation_mode" => Ok(__FieldTag::__evaluation_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BinaryAuthorization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BinaryAuthorization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__evaluation_mode => {
                            if !fields.insert(__FieldTag::__evaluation_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation_mode",
                                ));
                            }
                            result.evaluation_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::binary_authorization::EvaluationMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BinaryAuthorization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.evaluation_mode) {
            state.serialize_entry("evaluationMode", &self.evaluation_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BinaryAuthorization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BinaryAuthorization");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("evaluation_mode", &self.evaluation_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BinaryAuthorization].
pub mod binary_authorization {
    #[allow(unused_imports)]
    use super::*;

    /// Binary Authorization mode of operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EvaluationMode {
        /// Default value
        Unspecified,
        /// Disable BinaryAuthorization
        Disabled,
        /// Enforce Kubernetes admission requests with BinaryAuthorization using the
        /// project's singleton policy. This is equivalent to setting the
        /// enabled boolean to true.
        ProjectSingletonPolicyEnforce,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EvaluationMode::value] or
        /// [EvaluationMode::name].
        UnknownValue(evaluation_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod evaluation_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EvaluationMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::ProjectSingletonPolicyEnforce => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVALUATION_MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::ProjectSingletonPolicyEnforce => {
                    std::option::Option::Some("PROJECT_SINGLETON_POLICY_ENFORCE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EvaluationMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EvaluationMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EvaluationMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::ProjectSingletonPolicyEnforce,
                _ => Self::UnknownValue(evaluation_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EvaluationMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVALUATION_MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "PROJECT_SINGLETON_POLICY_ENFORCE" => Self::ProjectSingletonPolicyEnforce,
                _ => Self::UnknownValue(evaluation_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EvaluationMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::ProjectSingletonPolicyEnforce => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EvaluationMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EvaluationMode>::new(
                ".google.container.v1.BinaryAuthorization.EvaluationMode",
            ))
        }
    }
}

/// [PRIVATE FIELD]
/// Config for pod CIDR size overprovisioning.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PodCIDROverprovisionConfig {
    /// Whether Pod CIDR overprovisioning is disabled.
    /// Note: Pod CIDR overprovisioning is enabled by default.
    pub disable: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PodCIDROverprovisionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disable][crate::model::PodCIDROverprovisionConfig::disable].
    pub fn set_disable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable = v.into();
        self
    }
}

impl wkt::message::Message for PodCIDROverprovisionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.PodCIDROverprovisionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PodCIDROverprovisionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PodCIDROverprovisionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disable" => Ok(__FieldTag::__disable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PodCIDROverprovisionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PodCIDROverprovisionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disable => {
                            if !fields.insert(__FieldTag::__disable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable",
                                ));
                            }
                            result.disable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PodCIDROverprovisionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disable) {
            state.serialize_entry("disable", &self.disable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PodCIDROverprovisionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PodCIDROverprovisionConfig");
        debug_struct.field("disable", &self.disable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for controlling how IPs are allocated in the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IPAllocationPolicy {
    /// Whether alias IPs will be used for pod IPs in the cluster.
    /// This is used in conjunction with use_routes. It cannot
    /// be true if use_routes is true. If both use_ip_aliases and use_routes are
    /// false, then the server picks the default IP allocation mode
    pub use_ip_aliases: bool,

    /// Whether a new subnetwork will be created automatically for the cluster.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    pub create_subnetwork: bool,

    /// A custom subnetwork name to be used if `create_subnetwork` is true.  If
    /// this field is empty, then an automatic name will be chosen for the new
    /// subnetwork.
    pub subnetwork_name: std::string::String,

    /// This field is deprecated, use cluster_ipv4_cidr_block.
    #[deprecated]
    pub cluster_ipv4_cidr: std::string::String,

    /// This field is deprecated, use node_ipv4_cidr_block.
    #[deprecated]
    pub node_ipv4_cidr: std::string::String,

    /// This field is deprecated, use services_ipv4_cidr_block.
    #[deprecated]
    pub services_ipv4_cidr: std::string::String,

    /// The name of the secondary range to be used for the cluster CIDR
    /// block.  The secondary range will be used for pod IP
    /// addresses. This must be an existing secondary range associated
    /// with the cluster subnetwork.
    ///
    /// This field is only applicable with use_ip_aliases is true and
    /// create_subnetwork is false.
    pub cluster_secondary_range_name: std::string::String,

    /// The name of the secondary range to be used as for the services
    /// CIDR block.  The secondary range will be used for service
    /// ClusterIPs. This must be an existing secondary range associated
    /// with the cluster subnetwork.
    ///
    /// This field is only applicable with use_ip_aliases is true and
    /// create_subnetwork is false.
    pub services_secondary_range_name: std::string::String,

    /// The IP address range for the cluster pod IPs. If this field is set, then
    /// `cluster.cluster_ipv4_cidr` must be left blank.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    pub cluster_ipv4_cidr_block: std::string::String,

    /// The IP address range of the instance IPs in this cluster.
    ///
    /// This is applicable only if `create_subnetwork` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    pub node_ipv4_cidr_block: std::string::String,

    /// The IP address range of the services IPs in this cluster. If blank, a range
    /// will be automatically chosen with the default size.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    ///
    /// Set to blank to have a range chosen with the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    pub services_ipv4_cidr_block: std::string::String,

    /// The IP address range of the Cloud TPUs in this cluster. If unspecified, a
    /// range will be automatically chosen with the default size.
    ///
    /// This field is only applicable when `use_ip_aliases` is true.
    ///
    /// If unspecified, the range will use the default size.
    ///
    /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
    /// netmask.
    ///
    /// Set to a
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
    /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
    /// to use.
    ///
    /// This field is deprecated due to the deprecation of 2VM TPU. The end of life
    /// date for 2VM TPU is 2025-04-25.
    #[deprecated]
    pub tpu_ipv4_cidr_block: std::string::String,

    /// Whether routes will be used for pod IPs in the cluster.
    /// This is used in conjunction with use_ip_aliases. It cannot be true if
    /// use_ip_aliases is true. If both use_ip_aliases and use_routes are false,
    /// then the server picks the default IP allocation mode
    pub use_routes: bool,

    /// The IP stack type of the cluster
    pub stack_type: crate::model::StackType,

    /// The ipv6 access type (internal or external) when create_subnetwork is true
    pub ipv6_access_type: crate::model::IPv6AccessType,

    /// [PRIVATE FIELD]
    /// Pod CIDR size overprovisioning config for the cluster.
    ///
    /// Pod CIDR size per node depends on max_pods_per_node. By default, the value
    /// of max_pods_per_node is doubled and then rounded off to next power of 2 to
    /// get the size of pod CIDR block per node.
    /// Example: max_pods_per_node of 30 would result in 64 IPs (/26).
    ///
    /// This config can disable the doubling of IPs (we still round off to next
    /// power of 2)
    /// Example: max_pods_per_node of 30 will result in 32 IPs (/27) when
    /// overprovisioning is disabled.
    pub pod_cidr_overprovision_config:
        std::option::Option<crate::model::PodCIDROverprovisionConfig>,

    /// Output only. The subnet's IPv6 CIDR block used by nodes and pods.
    pub subnet_ipv6_cidr_block: std::string::String,

    /// Output only. The services IPv6 CIDR block for the cluster.
    pub services_ipv6_cidr_block: std::string::String,

    /// Output only. The additional pod ranges that are added to the cluster.
    /// These pod ranges can be used by new node pools to allocate pod IPs
    /// automatically. Once the range is removed it will not show up in
    /// IPAllocationPolicy.
    pub additional_pod_ranges_config: std::option::Option<crate::model::AdditionalPodRangesConfig>,

    /// Output only. The utilization of the cluster default IPv4 range for the
    /// pod. The ratio is Usage/[Total number of IPs in the secondary range],
    /// Usage=numNodes*numZones*podIPsPerNode.
    pub default_pod_ipv4_range_utilization: f64,

    /// Output only. The additional IP ranges that are added to the cluster.
    /// These IP ranges can be used by new node pools to allocate node and pod IPs
    /// automatically.
    /// Each AdditionalIPRangesConfig corresponds to a single subnetwork.
    /// Once a range is removed it will not show up in IPAllocationPolicy.
    pub additional_ip_ranges_configs: std::vec::Vec<crate::model::AdditionalIPRangesConfig>,

    /// Optional. AutoIpamConfig contains all information related to Auto IPAM
    pub auto_ipam_config: std::option::Option<crate::model::AutoIpamConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IPAllocationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [use_ip_aliases][crate::model::IPAllocationPolicy::use_ip_aliases].
    pub fn set_use_ip_aliases<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_ip_aliases = v.into();
        self
    }

    /// Sets the value of [create_subnetwork][crate::model::IPAllocationPolicy::create_subnetwork].
    pub fn set_create_subnetwork<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.create_subnetwork = v.into();
        self
    }

    /// Sets the value of [subnetwork_name][crate::model::IPAllocationPolicy::subnetwork_name].
    pub fn set_subnetwork_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork_name = v.into();
        self
    }

    /// Sets the value of [cluster_ipv4_cidr][crate::model::IPAllocationPolicy::cluster_ipv4_cidr].
    #[deprecated]
    pub fn set_cluster_ipv4_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ipv4_cidr = v.into();
        self
    }

    /// Sets the value of [node_ipv4_cidr][crate::model::IPAllocationPolicy::node_ipv4_cidr].
    #[deprecated]
    pub fn set_node_ipv4_cidr<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_ipv4_cidr = v.into();
        self
    }

    /// Sets the value of [services_ipv4_cidr][crate::model::IPAllocationPolicy::services_ipv4_cidr].
    #[deprecated]
    pub fn set_services_ipv4_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ipv4_cidr = v.into();
        self
    }

    /// Sets the value of [cluster_secondary_range_name][crate::model::IPAllocationPolicy::cluster_secondary_range_name].
    pub fn set_cluster_secondary_range_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_secondary_range_name = v.into();
        self
    }

    /// Sets the value of [services_secondary_range_name][crate::model::IPAllocationPolicy::services_secondary_range_name].
    pub fn set_services_secondary_range_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_secondary_range_name = v.into();
        self
    }

    /// Sets the value of [cluster_ipv4_cidr_block][crate::model::IPAllocationPolicy::cluster_ipv4_cidr_block].
    pub fn set_cluster_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [node_ipv4_cidr_block][crate::model::IPAllocationPolicy::node_ipv4_cidr_block].
    pub fn set_node_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [services_ipv4_cidr_block][crate::model::IPAllocationPolicy::services_ipv4_cidr_block].
    pub fn set_services_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [tpu_ipv4_cidr_block][crate::model::IPAllocationPolicy::tpu_ipv4_cidr_block].
    #[deprecated]
    pub fn set_tpu_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tpu_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [use_routes][crate::model::IPAllocationPolicy::use_routes].
    pub fn set_use_routes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.use_routes = v.into();
        self
    }

    /// Sets the value of [stack_type][crate::model::IPAllocationPolicy::stack_type].
    pub fn set_stack_type<T: std::convert::Into<crate::model::StackType>>(mut self, v: T) -> Self {
        self.stack_type = v.into();
        self
    }

    /// Sets the value of [ipv6_access_type][crate::model::IPAllocationPolicy::ipv6_access_type].
    pub fn set_ipv6_access_type<T: std::convert::Into<crate::model::IPv6AccessType>>(
        mut self,
        v: T,
    ) -> Self {
        self.ipv6_access_type = v.into();
        self
    }

    /// Sets the value of [pod_cidr_overprovision_config][crate::model::IPAllocationPolicy::pod_cidr_overprovision_config].
    pub fn set_pod_cidr_overprovision_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PodCIDROverprovisionConfig>,
    {
        self.pod_cidr_overprovision_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pod_cidr_overprovision_config][crate::model::IPAllocationPolicy::pod_cidr_overprovision_config].
    pub fn set_or_clear_pod_cidr_overprovision_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::PodCIDROverprovisionConfig>,
    {
        self.pod_cidr_overprovision_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnet_ipv6_cidr_block][crate::model::IPAllocationPolicy::subnet_ipv6_cidr_block].
    pub fn set_subnet_ipv6_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.subnet_ipv6_cidr_block = v.into();
        self
    }

    /// Sets the value of [services_ipv6_cidr_block][crate::model::IPAllocationPolicy::services_ipv6_cidr_block].
    pub fn set_services_ipv6_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ipv6_cidr_block = v.into();
        self
    }

    /// Sets the value of [additional_pod_ranges_config][crate::model::IPAllocationPolicy::additional_pod_ranges_config].
    pub fn set_additional_pod_ranges_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdditionalPodRangesConfig>,
    {
        self.additional_pod_ranges_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [additional_pod_ranges_config][crate::model::IPAllocationPolicy::additional_pod_ranges_config].
    pub fn set_or_clear_additional_pod_ranges_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdditionalPodRangesConfig>,
    {
        self.additional_pod_ranges_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_pod_ipv4_range_utilization][crate::model::IPAllocationPolicy::default_pod_ipv4_range_utilization].
    pub fn set_default_pod_ipv4_range_utilization<T: std::convert::Into<f64>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_pod_ipv4_range_utilization = v.into();
        self
    }

    /// Sets the value of [additional_ip_ranges_configs][crate::model::IPAllocationPolicy::additional_ip_ranges_configs].
    pub fn set_additional_ip_ranges_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdditionalIPRangesConfig>,
    {
        use std::iter::Iterator;
        self.additional_ip_ranges_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [auto_ipam_config][crate::model::IPAllocationPolicy::auto_ipam_config].
    pub fn set_auto_ipam_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoIpamConfig>,
    {
        self.auto_ipam_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auto_ipam_config][crate::model::IPAllocationPolicy::auto_ipam_config].
    pub fn set_or_clear_auto_ipam_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutoIpamConfig>,
    {
        self.auto_ipam_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for IPAllocationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.IPAllocationPolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IPAllocationPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_ip_aliases,
            __create_subnetwork,
            __subnetwork_name,
            __cluster_ipv4_cidr,
            __node_ipv4_cidr,
            __services_ipv4_cidr,
            __cluster_secondary_range_name,
            __services_secondary_range_name,
            __cluster_ipv4_cidr_block,
            __node_ipv4_cidr_block,
            __services_ipv4_cidr_block,
            __tpu_ipv4_cidr_block,
            __use_routes,
            __stack_type,
            __ipv6_access_type,
            __pod_cidr_overprovision_config,
            __subnet_ipv6_cidr_block,
            __services_ipv6_cidr_block,
            __additional_pod_ranges_config,
            __default_pod_ipv4_range_utilization,
            __additional_ip_ranges_configs,
            __auto_ipam_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IPAllocationPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "useIpAliases" => Ok(__FieldTag::__use_ip_aliases),
                            "use_ip_aliases" => Ok(__FieldTag::__use_ip_aliases),
                            "createSubnetwork" => Ok(__FieldTag::__create_subnetwork),
                            "create_subnetwork" => Ok(__FieldTag::__create_subnetwork),
                            "subnetworkName" => Ok(__FieldTag::__subnetwork_name),
                            "subnetwork_name" => Ok(__FieldTag::__subnetwork_name),
                            "clusterIpv4Cidr" => Ok(__FieldTag::__cluster_ipv4_cidr),
                            "cluster_ipv4_cidr" => Ok(__FieldTag::__cluster_ipv4_cidr),
                            "nodeIpv4Cidr" => Ok(__FieldTag::__node_ipv4_cidr),
                            "node_ipv4_cidr" => Ok(__FieldTag::__node_ipv4_cidr),
                            "servicesIpv4Cidr" => Ok(__FieldTag::__services_ipv4_cidr),
                            "services_ipv4_cidr" => Ok(__FieldTag::__services_ipv4_cidr),
                            "clusterSecondaryRangeName" => {
                                Ok(__FieldTag::__cluster_secondary_range_name)
                            }
                            "cluster_secondary_range_name" => {
                                Ok(__FieldTag::__cluster_secondary_range_name)
                            }
                            "servicesSecondaryRangeName" => {
                                Ok(__FieldTag::__services_secondary_range_name)
                            }
                            "services_secondary_range_name" => {
                                Ok(__FieldTag::__services_secondary_range_name)
                            }
                            "clusterIpv4CidrBlock" => Ok(__FieldTag::__cluster_ipv4_cidr_block),
                            "cluster_ipv4_cidr_block" => Ok(__FieldTag::__cluster_ipv4_cidr_block),
                            "nodeIpv4CidrBlock" => Ok(__FieldTag::__node_ipv4_cidr_block),
                            "node_ipv4_cidr_block" => Ok(__FieldTag::__node_ipv4_cidr_block),
                            "servicesIpv4CidrBlock" => Ok(__FieldTag::__services_ipv4_cidr_block),
                            "services_ipv4_cidr_block" => {
                                Ok(__FieldTag::__services_ipv4_cidr_block)
                            }
                            "tpuIpv4CidrBlock" => Ok(__FieldTag::__tpu_ipv4_cidr_block),
                            "tpu_ipv4_cidr_block" => Ok(__FieldTag::__tpu_ipv4_cidr_block),
                            "useRoutes" => Ok(__FieldTag::__use_routes),
                            "use_routes" => Ok(__FieldTag::__use_routes),
                            "stackType" => Ok(__FieldTag::__stack_type),
                            "stack_type" => Ok(__FieldTag::__stack_type),
                            "ipv6AccessType" => Ok(__FieldTag::__ipv6_access_type),
                            "ipv6_access_type" => Ok(__FieldTag::__ipv6_access_type),
                            "podCidrOverprovisionConfig" => {
                                Ok(__FieldTag::__pod_cidr_overprovision_config)
                            }
                            "pod_cidr_overprovision_config" => {
                                Ok(__FieldTag::__pod_cidr_overprovision_config)
                            }
                            "subnetIpv6CidrBlock" => Ok(__FieldTag::__subnet_ipv6_cidr_block),
                            "subnet_ipv6_cidr_block" => Ok(__FieldTag::__subnet_ipv6_cidr_block),
                            "servicesIpv6CidrBlock" => Ok(__FieldTag::__services_ipv6_cidr_block),
                            "services_ipv6_cidr_block" => {
                                Ok(__FieldTag::__services_ipv6_cidr_block)
                            }
                            "additionalPodRangesConfig" => {
                                Ok(__FieldTag::__additional_pod_ranges_config)
                            }
                            "additional_pod_ranges_config" => {
                                Ok(__FieldTag::__additional_pod_ranges_config)
                            }
                            "defaultPodIpv4RangeUtilization" => {
                                Ok(__FieldTag::__default_pod_ipv4_range_utilization)
                            }
                            "default_pod_ipv4_range_utilization" => {
                                Ok(__FieldTag::__default_pod_ipv4_range_utilization)
                            }
                            "additionalIpRangesConfigs" => {
                                Ok(__FieldTag::__additional_ip_ranges_configs)
                            }
                            "additional_ip_ranges_configs" => {
                                Ok(__FieldTag::__additional_ip_ranges_configs)
                            }
                            "autoIpamConfig" => Ok(__FieldTag::__auto_ipam_config),
                            "auto_ipam_config" => Ok(__FieldTag::__auto_ipam_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IPAllocationPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IPAllocationPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_ip_aliases => {
                            if !fields.insert(__FieldTag::__use_ip_aliases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_ip_aliases",
                                ));
                            }
                            result.use_ip_aliases = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_subnetwork => {
                            if !fields.insert(__FieldTag::__create_subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_subnetwork",
                                ));
                            }
                            result.create_subnetwork = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork_name => {
                            if !fields.insert(__FieldTag::__subnetwork_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork_name",
                                ));
                            }
                            result.subnetwork_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_ipv4_cidr => {
                            if !fields.insert(__FieldTag::__cluster_ipv4_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ipv4_cidr",
                                ));
                            }
                            result.cluster_ipv4_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_ipv4_cidr => {
                            if !fields.insert(__FieldTag::__node_ipv4_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_ipv4_cidr",
                                ));
                            }
                            result.node_ipv4_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__services_ipv4_cidr => {
                            if !fields.insert(__FieldTag::__services_ipv4_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_ipv4_cidr",
                                ));
                            }
                            result.services_ipv4_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_secondary_range_name => {
                            if !fields.insert(__FieldTag::__cluster_secondary_range_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_secondary_range_name",
                                ));
                            }
                            result.cluster_secondary_range_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__services_secondary_range_name => {
                            if !fields.insert(__FieldTag::__services_secondary_range_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_secondary_range_name",
                                ));
                            }
                            result.services_secondary_range_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__cluster_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ipv4_cidr_block",
                                ));
                            }
                            result.cluster_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__node_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_ipv4_cidr_block",
                                ));
                            }
                            result.node_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__services_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__services_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_ipv4_cidr_block",
                                ));
                            }
                            result.services_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tpu_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__tpu_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tpu_ipv4_cidr_block",
                                ));
                            }
                            result.tpu_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_routes => {
                            if !fields.insert(__FieldTag::__use_routes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_routes",
                                ));
                            }
                            result.use_routes = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stack_type => {
                            if !fields.insert(__FieldTag::__stack_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stack_type",
                                ));
                            }
                            result.stack_type = map
                                .next_value::<std::option::Option<crate::model::StackType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ipv6_access_type => {
                            if !fields.insert(__FieldTag::__ipv6_access_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ipv6_access_type",
                                ));
                            }
                            result.ipv6_access_type = map
                                .next_value::<std::option::Option<crate::model::IPv6AccessType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_cidr_overprovision_config => {
                            if !fields.insert(__FieldTag::__pod_cidr_overprovision_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_cidr_overprovision_config",
                                ));
                            }
                            result.pod_cidr_overprovision_config = map.next_value::<std::option::Option<crate::model::PodCIDROverprovisionConfig>>()?
                                ;
                        }
                        __FieldTag::__subnet_ipv6_cidr_block => {
                            if !fields.insert(__FieldTag::__subnet_ipv6_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet_ipv6_cidr_block",
                                ));
                            }
                            result.subnet_ipv6_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__services_ipv6_cidr_block => {
                            if !fields.insert(__FieldTag::__services_ipv6_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_ipv6_cidr_block",
                                ));
                            }
                            result.services_ipv6_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_pod_ranges_config => {
                            if !fields.insert(__FieldTag::__additional_pod_ranges_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_pod_ranges_config",
                                ));
                            }
                            result.additional_pod_ranges_config = map.next_value::<std::option::Option<crate::model::AdditionalPodRangesConfig>>()?
                                ;
                        }
                        __FieldTag::__default_pod_ipv4_range_utilization => {
                            if !fields.insert(__FieldTag::__default_pod_ipv4_range_utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_pod_ipv4_range_utilization",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.default_pod_ipv4_range_utilization =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__additional_ip_ranges_configs => {
                            if !fields.insert(__FieldTag::__additional_ip_ranges_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_ip_ranges_configs",
                                ));
                            }
                            result.additional_ip_ranges_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdditionalIPRangesConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_ipam_config => {
                            if !fields.insert(__FieldTag::__auto_ipam_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_ipam_config",
                                ));
                            }
                            result.auto_ipam_config = map
                                .next_value::<std::option::Option<crate::model::AutoIpamConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IPAllocationPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.use_ip_aliases) {
            state.serialize_entry("useIpAliases", &self.use_ip_aliases)?;
        }
        if !wkt::internal::is_default(&self.create_subnetwork) {
            state.serialize_entry("createSubnetwork", &self.create_subnetwork)?;
        }
        if !self.subnetwork_name.is_empty() {
            state.serialize_entry("subnetworkName", &self.subnetwork_name)?;
        }
        if !self.cluster_ipv4_cidr.is_empty() {
            state.serialize_entry("clusterIpv4Cidr", &self.cluster_ipv4_cidr)?;
        }
        if !self.node_ipv4_cidr.is_empty() {
            state.serialize_entry("nodeIpv4Cidr", &self.node_ipv4_cidr)?;
        }
        if !self.services_ipv4_cidr.is_empty() {
            state.serialize_entry("servicesIpv4Cidr", &self.services_ipv4_cidr)?;
        }
        if !self.cluster_secondary_range_name.is_empty() {
            state.serialize_entry(
                "clusterSecondaryRangeName",
                &self.cluster_secondary_range_name,
            )?;
        }
        if !self.services_secondary_range_name.is_empty() {
            state.serialize_entry(
                "servicesSecondaryRangeName",
                &self.services_secondary_range_name,
            )?;
        }
        if !self.cluster_ipv4_cidr_block.is_empty() {
            state.serialize_entry("clusterIpv4CidrBlock", &self.cluster_ipv4_cidr_block)?;
        }
        if !self.node_ipv4_cidr_block.is_empty() {
            state.serialize_entry("nodeIpv4CidrBlock", &self.node_ipv4_cidr_block)?;
        }
        if !self.services_ipv4_cidr_block.is_empty() {
            state.serialize_entry("servicesIpv4CidrBlock", &self.services_ipv4_cidr_block)?;
        }
        if !self.tpu_ipv4_cidr_block.is_empty() {
            state.serialize_entry("tpuIpv4CidrBlock", &self.tpu_ipv4_cidr_block)?;
        }
        if !wkt::internal::is_default(&self.use_routes) {
            state.serialize_entry("useRoutes", &self.use_routes)?;
        }
        if !wkt::internal::is_default(&self.stack_type) {
            state.serialize_entry("stackType", &self.stack_type)?;
        }
        if !wkt::internal::is_default(&self.ipv6_access_type) {
            state.serialize_entry("ipv6AccessType", &self.ipv6_access_type)?;
        }
        if self.pod_cidr_overprovision_config.is_some() {
            state.serialize_entry(
                "podCidrOverprovisionConfig",
                &self.pod_cidr_overprovision_config,
            )?;
        }
        if !self.subnet_ipv6_cidr_block.is_empty() {
            state.serialize_entry("subnetIpv6CidrBlock", &self.subnet_ipv6_cidr_block)?;
        }
        if !self.services_ipv6_cidr_block.is_empty() {
            state.serialize_entry("servicesIpv6CidrBlock", &self.services_ipv6_cidr_block)?;
        }
        if self.additional_pod_ranges_config.is_some() {
            state.serialize_entry(
                "additionalPodRangesConfig",
                &self.additional_pod_ranges_config,
            )?;
        }
        if !wkt::internal::is_default(&self.default_pod_ipv4_range_utilization) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "defaultPodIpv4RangeUtilization",
                &__With(&self.default_pod_ipv4_range_utilization),
            )?;
        }
        if !self.additional_ip_ranges_configs.is_empty() {
            state.serialize_entry(
                "additionalIpRangesConfigs",
                &self.additional_ip_ranges_configs,
            )?;
        }
        if self.auto_ipam_config.is_some() {
            state.serialize_entry("autoIpamConfig", &self.auto_ipam_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IPAllocationPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IPAllocationPolicy");
        debug_struct.field("use_ip_aliases", &self.use_ip_aliases);
        debug_struct.field("create_subnetwork", &self.create_subnetwork);
        debug_struct.field("subnetwork_name", &self.subnetwork_name);
        debug_struct.field("cluster_ipv4_cidr", &self.cluster_ipv4_cidr);
        debug_struct.field("node_ipv4_cidr", &self.node_ipv4_cidr);
        debug_struct.field("services_ipv4_cidr", &self.services_ipv4_cidr);
        debug_struct.field(
            "cluster_secondary_range_name",
            &self.cluster_secondary_range_name,
        );
        debug_struct.field(
            "services_secondary_range_name",
            &self.services_secondary_range_name,
        );
        debug_struct.field("cluster_ipv4_cidr_block", &self.cluster_ipv4_cidr_block);
        debug_struct.field("node_ipv4_cidr_block", &self.node_ipv4_cidr_block);
        debug_struct.field("services_ipv4_cidr_block", &self.services_ipv4_cidr_block);
        debug_struct.field("tpu_ipv4_cidr_block", &self.tpu_ipv4_cidr_block);
        debug_struct.field("use_routes", &self.use_routes);
        debug_struct.field("stack_type", &self.stack_type);
        debug_struct.field("ipv6_access_type", &self.ipv6_access_type);
        debug_struct.field(
            "pod_cidr_overprovision_config",
            &self.pod_cidr_overprovision_config,
        );
        debug_struct.field("subnet_ipv6_cidr_block", &self.subnet_ipv6_cidr_block);
        debug_struct.field("services_ipv6_cidr_block", &self.services_ipv6_cidr_block);
        debug_struct.field(
            "additional_pod_ranges_config",
            &self.additional_pod_ranges_config,
        );
        debug_struct.field(
            "default_pod_ipv4_range_utilization",
            &self.default_pod_ipv4_range_utilization,
        );
        debug_struct.field(
            "additional_ip_ranges_configs",
            &self.additional_ip_ranges_configs,
        );
        debug_struct.field("auto_ipam_config", &self.auto_ipam_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Google Kubernetes Engine cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Cluster {
    /// The name of this cluster. The name must be unique within this project
    /// and location (e.g. zone or region), and can be up to 40 characters with
    /// the following restrictions:
    ///
    /// * Lowercase letters, numbers, and hyphens only.
    /// * Must start with a letter.
    /// * Must end with a number or a letter.
    pub name: std::string::String,

    /// An optional description of this cluster.
    pub description: std::string::String,

    /// The number of nodes to create in this cluster. You must ensure that your
    /// Compute Engine [resource
    /// quota](https://cloud.google.com/compute/quotas)
    /// is sufficient for this number of instances. You must also have available
    /// firewall and routes quota.
    /// For requests, this field should only be used in lieu of a
    /// "node_pool" object, since this configuration (along with the
    /// "node_config") will be used to create a "NodePool" object with an
    /// auto-generated name. Do not use this and a node_pool at the same time.
    ///
    /// This field is deprecated, use node_pool.initial_node_count instead.
    #[deprecated]
    pub initial_node_count: i32,

    /// Parameters used in creating the cluster's nodes.
    /// For requests, this field should only be used in lieu of a
    /// "node_pool" object, since this configuration (along with the
    /// "initial_node_count") will be used to create a "NodePool" object with an
    /// auto-generated name. Do not use this and a node_pool at the same time.
    /// For responses, this field will be populated with the node configuration of
    /// the first node pool. (For configuration of each node pool, see
    /// `node_pool.config`)
    ///
    /// If unspecified, the defaults are used.
    /// This field is deprecated, use node_pool.config instead.
    #[deprecated]
    pub node_config: std::option::Option<crate::model::NodeConfig>,

    /// The authentication information for accessing the master endpoint.
    /// If unspecified, the defaults are used:
    /// For clusters before v1.12, if master_auth is unspecified, `username` will
    /// be set to "admin", a random password will be generated, and a client
    /// certificate will be issued.
    pub master_auth: std::option::Option<crate::model::MasterAuth>,

    /// The logging service the cluster should use to write logs.
    /// Currently available options:
    ///
    /// * `logging.googleapis.com/kubernetes` - The Cloud Logging
    ///   service with a Kubernetes-native resource model
    /// * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
    ///   available as of GKE 1.15).
    /// * `none` - no logs will be exported from the cluster.
    ///
    /// If left as an empty string,`logging.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
    pub logging_service: std::string::String,

    /// The monitoring service the cluster should use to write metrics.
    /// Currently available options:
    ///
    /// * `monitoring.googleapis.com/kubernetes` - The Cloud Monitoring
    ///   service with a Kubernetes-native resource model
    /// * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
    ///   longer available as of GKE 1.15).
    /// * `none` - No metrics will be exported from the cluster.
    ///
    /// If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
    pub monitoring_service: std::string::String,

    /// The name of the Google Compute Engine
    /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
    /// to which the cluster is connected. If left unspecified, the `default`
    /// network will be used.
    pub network: std::string::String,

    /// The IP address range of the container pods in this cluster, in
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `10.96.0.0/14`). Leave blank to have
    /// one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
    pub cluster_ipv4_cidr: std::string::String,

    /// Configurations for the various addons available to run in the cluster.
    pub addons_config: std::option::Option<crate::model::AddonsConfig>,

    /// The name of the Google Compute Engine
    /// [subnetwork](https://cloud.google.com/compute/docs/subnetworks)
    /// to which the cluster is connected.
    pub subnetwork: std::string::String,

    /// The node pools associated with this cluster.
    /// This field should not be set if "node_config" or "initial_node_count" are
    /// specified.
    pub node_pools: std::vec::Vec<crate::model::NodePool>,

    /// The list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster's nodes should be located.
    ///
    /// This field provides a default value if
    /// [NodePool.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations)
    /// are not specified during node pool creation.
    ///
    /// Warning: changing cluster locations will update the
    /// [NodePool.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools#NodePool.FIELDS.locations)
    /// of all node pools and will result in nodes being added and/or removed.
    pub locations: std::vec::Vec<std::string::String>,

    /// Kubernetes alpha features are enabled on this cluster. This includes alpha
    /// API groups (e.g. v1alpha1) and features that may not be production ready in
    /// the kubernetes version of the master and nodes.
    /// The cluster has no SLA for uptime and master/node upgrades are disabled.
    /// Alpha enabled clusters are automatically deleted thirty days after
    /// creation.
    pub enable_kubernetes_alpha: bool,

    /// The list of user specified Kubernetes feature gates.
    /// Each string represents the activation status of a feature gate (e.g.
    /// "featureX=true" or "featureX=false")
    pub alpha_cluster_feature_gates: std::vec::Vec<std::string::String>,

    /// The resource labels for the cluster to use to annotate any related
    /// Google Compute Engine resources.
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The fingerprint of the set of labels for this cluster.
    pub label_fingerprint: std::string::String,

    /// Configuration for the legacy ABAC authorization mode.
    pub legacy_abac: std::option::Option<crate::model::LegacyAbac>,

    /// Configuration options for the NetworkPolicy feature.
    pub network_policy: std::option::Option<crate::model::NetworkPolicy>,

    /// Configuration for cluster IP allocation.
    pub ip_allocation_policy: std::option::Option<crate::model::IPAllocationPolicy>,

    /// The configuration options for master authorized networks feature.
    ///
    /// Deprecated: Use
    /// [ControlPlaneEndpointsConfig.IPEndpointsConfig.authorized_networks_config][google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.authorized_networks_config]
    /// instead.
    ///
    /// [google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig.authorized_networks_config]: crate::model::control_plane_endpoints_config::IPEndpointsConfig::authorized_networks_config
    #[deprecated]
    pub master_authorized_networks_config:
        std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,

    /// Configure the maintenance policy for this cluster.
    pub maintenance_policy: std::option::Option<crate::model::MaintenancePolicy>,

    /// Configuration for Binary Authorization.
    pub binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,

    /// Cluster-level autoscaling configuration.
    pub autoscaling: std::option::Option<crate::model::ClusterAutoscaling>,

    /// Configuration for cluster networking.
    pub network_config: std::option::Option<crate::model::NetworkConfig>,

    /// The default constraint on the maximum number of pods that can be run
    /// simultaneously on a node in the node pool of this cluster. Only honored
    /// if cluster created with IP Alias support.
    pub default_max_pods_constraint: std::option::Option<crate::model::MaxPodsConstraint>,

    /// Configuration for exporting resource usages. Resource usage export is
    /// disabled when this config is unspecified.
    pub resource_usage_export_config: std::option::Option<crate::model::ResourceUsageExportConfig>,

    /// Configuration controlling RBAC group membership information.
    pub authenticator_groups_config: std::option::Option<crate::model::AuthenticatorGroupsConfig>,

    /// Configuration for private cluster.
    pub private_cluster_config: std::option::Option<crate::model::PrivateClusterConfig>,

    /// Configuration of etcd encryption.
    pub database_encryption: std::option::Option<crate::model::DatabaseEncryption>,

    /// Cluster-level Vertical Pod Autoscaling configuration.
    pub vertical_pod_autoscaling: std::option::Option<crate::model::VerticalPodAutoscaling>,

    /// Shielded Nodes configuration.
    pub shielded_nodes: std::option::Option<crate::model::ShieldedNodes>,

    /// Release channel configuration. If left unspecified on cluster creation and
    /// a version is specified, the cluster is enrolled in the most mature release
    /// channel where the version is available (first checking STABLE, then
    /// REGULAR, and finally RAPID). Otherwise, if no release channel
    /// configuration and no version is specified, the cluster is enrolled in the
    /// REGULAR channel with its default version.
    pub release_channel: std::option::Option<crate::model::ReleaseChannel>,

    /// Configuration for the use of Kubernetes Service Accounts in GCP IAM
    /// policies.
    pub workload_identity_config: std::option::Option<crate::model::WorkloadIdentityConfig>,

    /// Configuration for issuance of mTLS keys and certificates to Kubernetes
    /// pods.
    pub mesh_certificates: std::option::Option<crate::model::MeshCertificates>,

    /// Configuration for the fine-grained cost management feature.
    pub cost_management_config: std::option::Option<crate::model::CostManagementConfig>,

    /// Notification configuration of the cluster.
    pub notification_config: std::option::Option<crate::model::NotificationConfig>,

    /// Configuration of Confidential Nodes.
    /// All the nodes in the cluster will be Confidential VM once enabled.
    pub confidential_nodes: std::option::Option<crate::model::ConfidentialNodes>,

    /// Configuration for Identity Service component.
    pub identity_service_config: std::option::Option<crate::model::IdentityServiceConfig>,

    /// Output only. Server-defined URL for the resource.
    pub self_link: std::string::String,

    /// Output only. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field is deprecated, use location
    /// instead.
    #[deprecated]
    pub zone: std::string::String,

    /// Output only. The IP address of this cluster's master endpoint.
    /// The endpoint can be accessed from the internet at
    /// `https://username:password@endpoint/`.
    ///
    /// See the `masterAuth` property of this resource for username and
    /// password information.
    pub endpoint: std::string::String,

    /// The initial Kubernetes version for this cluster.  Valid versions are those
    /// found in validMasterVersions returned by getServerConfig.  The version can
    /// be upgraded over time; such upgrades are reflected in
    /// currentMasterVersion and currentNodeVersion.
    ///
    /// Users may specify either explicit versions offered by
    /// Kubernetes Engine or version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "","-": picks the default Kubernetes version
    pub initial_cluster_version: std::string::String,

    /// Output only. The current software version of the master endpoint.
    pub current_master_version: std::string::String,

    /// Output only. Deprecated, use
    /// [NodePools.version](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters.nodePools)
    /// instead. The current version of the node software components. If they are
    /// currently at multiple versions because they're in the process of being
    /// upgraded, this reflects the minimum version of all nodes.
    #[deprecated]
    pub current_node_version: std::string::String,

    /// Output only. The time the cluster was created, in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    pub create_time: std::string::String,

    /// Output only. The current status of this cluster.
    pub status: crate::model::cluster::Status,

    /// Output only. Deprecated. Use conditions instead.
    /// Additional information about the current status of this
    /// cluster, if available.
    #[deprecated]
    pub status_message: std::string::String,

    /// Output only. The size of the address space on each node for hosting
    /// containers. This is provisioned from within the `container_ipv4_cidr`
    /// range. This field will only be set when cluster is in route-based network
    /// mode.
    pub node_ipv4_cidr_size: i32,

    /// Output only. The IP address range of the Kubernetes services in
    /// this cluster, in
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `1.2.3.4/29`). Service addresses are
    /// typically put in the last `/16` from the container CIDR.
    pub services_ipv4_cidr: std::string::String,

    /// Output only. Deprecated. Use node_pools.instance_group_urls.
    #[deprecated]
    pub instance_group_urls: std::vec::Vec<std::string::String>,

    /// Output only. The number of nodes currently in the cluster. Deprecated.
    /// Call Kubernetes API directly to retrieve node information.
    #[deprecated]
    pub current_node_count: i32,

    /// Output only. The time the cluster will be automatically
    /// deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    pub expire_time: std::string::String,

    /// Output only. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
    /// or
    /// [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
    /// in which the cluster resides.
    pub location: std::string::String,

    /// Enable the ability to use Cloud TPUs in this cluster.
    /// This field is deprecated due to the deprecation of 2VM TPU. The end of life
    /// date for 2VM TPU is 2025-04-25.
    #[deprecated]
    pub enable_tpu: bool,

    /// Output only. The IP address range of the Cloud TPUs in this cluster, in
    /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
    /// notation (e.g. `1.2.3.4/29`).
    /// This field is deprecated due to the deprecation of 2VM TPU. The end of life
    /// date for 2VM TPU is 2025-04-25.
    #[deprecated]
    pub tpu_ipv4_cidr_block: std::string::String,

    /// Which conditions caused the current cluster state.
    pub conditions: std::vec::Vec<crate::model::StatusCondition>,

    /// Autopilot configuration for the cluster.
    pub autopilot: std::option::Option<crate::model::Autopilot>,

    /// Output only. Unique id for the cluster.
    pub id: std::string::String,

    /// Default NodePool settings for the entire cluster. These settings are
    /// overridden if specified on the specific NodePool object.
    pub node_pool_defaults: std::option::Option<crate::model::NodePoolDefaults>,

    /// Logging configuration for the cluster.
    pub logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// Monitoring configuration for the cluster.
    pub monitoring_config: std::option::Option<crate::model::MonitoringConfig>,

    /// Node pool configs that apply to all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    pub node_pool_auto_config: std::option::Option<crate::model::NodePoolAutoConfig>,

    /// The config for pod autoscaling.
    pub pod_autoscaling: std::option::Option<crate::model::PodAutoscaling>,

    /// This checksum is computed by the server based on the value of cluster
    /// fields, and may be sent on update requests to ensure the client has an
    /// up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Fleet information for the cluster.
    pub fleet: std::option::Option<crate::model::Fleet>,

    /// Enable/Disable Security Posture API features for the cluster.
    pub security_posture_config: std::option::Option<crate::model::SecurityPostureConfig>,

    /// Configuration for all cluster's control plane endpoints.
    pub control_plane_endpoints_config:
        std::option::Option<crate::model::ControlPlaneEndpointsConfig>,

    /// Beta APIs Config
    pub enable_k8s_beta_apis: std::option::Option<crate::model::K8sBetaAPIConfig>,

    /// GKE Enterprise Configuration.
    pub enterprise_config: std::option::Option<crate::model::EnterpriseConfig>,

    /// Secret CSI driver configuration.
    pub secret_manager_config: std::option::Option<crate::model::SecretManagerConfig>,

    /// Enable/Disable Compliance Posture features for the cluster.
    pub compliance_posture_config: std::option::Option<crate::model::CompliancePostureConfig>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: std::option::Option<bool>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: std::option::Option<bool>,

    /// The Custom keys configuration for the cluster.
    pub user_managed_keys_config: std::option::Option<crate::model::UserManagedKeysConfig>,

    /// RBACBindingConfig allows user to restrict ClusterRoleBindings an
    /// RoleBindings that can be created.
    pub rbac_binding_config: std::option::Option<crate::model::RBACBindingConfig>,

    /// Configuration for GKE auto upgrades.
    pub gke_auto_upgrade_config: std::option::Option<crate::model::GkeAutoUpgradeConfig>,

    /// Configuration for limiting anonymous access to all endpoints except the
    /// health checks.
    pub anonymous_authentication_config:
        std::option::Option<crate::model::AnonymousAuthenticationConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Cluster::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [initial_node_count][crate::model::Cluster::initial_node_count].
    #[deprecated]
    pub fn set_initial_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.initial_node_count = v.into();
        self
    }

    /// Sets the value of [node_config][crate::model::Cluster::node_config].
    #[deprecated]
    pub fn set_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_config][crate::model::Cluster::node_config].
    #[deprecated]
    pub fn set_or_clear_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.node_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [master_auth][crate::model::Cluster::master_auth].
    pub fn set_master_auth<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MasterAuth>,
    {
        self.master_auth = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [master_auth][crate::model::Cluster::master_auth].
    pub fn set_or_clear_master_auth<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MasterAuth>,
    {
        self.master_auth = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_service][crate::model::Cluster::logging_service].
    pub fn set_logging_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.logging_service = v.into();
        self
    }

    /// Sets the value of [monitoring_service][crate::model::Cluster::monitoring_service].
    pub fn set_monitoring_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monitoring_service = v.into();
        self
    }

    /// Sets the value of [network][crate::model::Cluster::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [cluster_ipv4_cidr][crate::model::Cluster::cluster_ipv4_cidr].
    pub fn set_cluster_ipv4_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ipv4_cidr = v.into();
        self
    }

    /// Sets the value of [addons_config][crate::model::Cluster::addons_config].
    pub fn set_addons_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AddonsConfig>,
    {
        self.addons_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [addons_config][crate::model::Cluster::addons_config].
    pub fn set_or_clear_addons_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AddonsConfig>,
    {
        self.addons_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnetwork][crate::model::Cluster::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [node_pools][crate::model::Cluster::node_pools].
    pub fn set_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodePool>,
    {
        use std::iter::Iterator;
        self.node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [locations][crate::model::Cluster::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [enable_kubernetes_alpha][crate::model::Cluster::enable_kubernetes_alpha].
    pub fn set_enable_kubernetes_alpha<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_kubernetes_alpha = v.into();
        self
    }

    /// Sets the value of [alpha_cluster_feature_gates][crate::model::Cluster::alpha_cluster_feature_gates].
    pub fn set_alpha_cluster_feature_gates<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.alpha_cluster_feature_gates = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_labels][crate::model::Cluster::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [label_fingerprint][crate::model::Cluster::label_fingerprint].
    pub fn set_label_fingerprint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.label_fingerprint = v.into();
        self
    }

    /// Sets the value of [legacy_abac][crate::model::Cluster::legacy_abac].
    pub fn set_legacy_abac<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LegacyAbac>,
    {
        self.legacy_abac = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [legacy_abac][crate::model::Cluster::legacy_abac].
    pub fn set_or_clear_legacy_abac<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LegacyAbac>,
    {
        self.legacy_abac = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_policy][crate::model::Cluster::network_policy].
    pub fn set_network_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPolicy>,
    {
        self.network_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_policy][crate::model::Cluster::network_policy].
    pub fn set_or_clear_network_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPolicy>,
    {
        self.network_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ip_allocation_policy][crate::model::Cluster::ip_allocation_policy].
    pub fn set_ip_allocation_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IPAllocationPolicy>,
    {
        self.ip_allocation_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_allocation_policy][crate::model::Cluster::ip_allocation_policy].
    pub fn set_or_clear_ip_allocation_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IPAllocationPolicy>,
    {
        self.ip_allocation_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [master_authorized_networks_config][crate::model::Cluster::master_authorized_networks_config].
    #[deprecated]
    pub fn set_master_authorized_networks_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MasterAuthorizedNetworksConfig>,
    {
        self.master_authorized_networks_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [master_authorized_networks_config][crate::model::Cluster::master_authorized_networks_config].
    #[deprecated]
    pub fn set_or_clear_master_authorized_networks_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::MasterAuthorizedNetworksConfig>,
    {
        self.master_authorized_networks_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_policy][crate::model::Cluster::maintenance_policy].
    pub fn set_maintenance_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenancePolicy>,
    {
        self.maintenance_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_policy][crate::model::Cluster::maintenance_policy].
    pub fn set_or_clear_maintenance_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenancePolicy>,
    {
        self.maintenance_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [binary_authorization][crate::model::Cluster::binary_authorization].
    pub fn set_binary_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.binary_authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [binary_authorization][crate::model::Cluster::binary_authorization].
    pub fn set_or_clear_binary_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.binary_authorization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autoscaling][crate::model::Cluster::autoscaling].
    pub fn set_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterAutoscaling>,
    {
        self.autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling][crate::model::Cluster::autoscaling].
    pub fn set_or_clear_autoscaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterAutoscaling>,
    {
        self.autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_config][crate::model::Cluster::network_config].
    pub fn set_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkConfig>,
    {
        self.network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_config][crate::model::Cluster::network_config].
    pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkConfig>,
    {
        self.network_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_max_pods_constraint][crate::model::Cluster::default_max_pods_constraint].
    pub fn set_default_max_pods_constraint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaxPodsConstraint>,
    {
        self.default_max_pods_constraint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_max_pods_constraint][crate::model::Cluster::default_max_pods_constraint].
    pub fn set_or_clear_default_max_pods_constraint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaxPodsConstraint>,
    {
        self.default_max_pods_constraint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_usage_export_config][crate::model::Cluster::resource_usage_export_config].
    pub fn set_resource_usage_export_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceUsageExportConfig>,
    {
        self.resource_usage_export_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_usage_export_config][crate::model::Cluster::resource_usage_export_config].
    pub fn set_or_clear_resource_usage_export_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceUsageExportConfig>,
    {
        self.resource_usage_export_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authenticator_groups_config][crate::model::Cluster::authenticator_groups_config].
    pub fn set_authenticator_groups_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthenticatorGroupsConfig>,
    {
        self.authenticator_groups_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authenticator_groups_config][crate::model::Cluster::authenticator_groups_config].
    pub fn set_or_clear_authenticator_groups_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthenticatorGroupsConfig>,
    {
        self.authenticator_groups_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_cluster_config][crate::model::Cluster::private_cluster_config].
    pub fn set_private_cluster_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateClusterConfig>,
    {
        self.private_cluster_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_cluster_config][crate::model::Cluster::private_cluster_config].
    pub fn set_or_clear_private_cluster_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivateClusterConfig>,
    {
        self.private_cluster_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [database_encryption][crate::model::Cluster::database_encryption].
    pub fn set_database_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseEncryption>,
    {
        self.database_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [database_encryption][crate::model::Cluster::database_encryption].
    pub fn set_or_clear_database_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseEncryption>,
    {
        self.database_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vertical_pod_autoscaling][crate::model::Cluster::vertical_pod_autoscaling].
    pub fn set_vertical_pod_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VerticalPodAutoscaling>,
    {
        self.vertical_pod_autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vertical_pod_autoscaling][crate::model::Cluster::vertical_pod_autoscaling].
    pub fn set_or_clear_vertical_pod_autoscaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VerticalPodAutoscaling>,
    {
        self.vertical_pod_autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [shielded_nodes][crate::model::Cluster::shielded_nodes].
    pub fn set_shielded_nodes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedNodes>,
    {
        self.shielded_nodes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_nodes][crate::model::Cluster::shielded_nodes].
    pub fn set_or_clear_shielded_nodes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedNodes>,
    {
        self.shielded_nodes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [release_channel][crate::model::Cluster::release_channel].
    pub fn set_release_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReleaseChannel>,
    {
        self.release_channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [release_channel][crate::model::Cluster::release_channel].
    pub fn set_or_clear_release_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReleaseChannel>,
    {
        self.release_channel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [workload_identity_config][crate::model::Cluster::workload_identity_config].
    pub fn set_workload_identity_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadIdentityConfig>,
    {
        self.workload_identity_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workload_identity_config][crate::model::Cluster::workload_identity_config].
    pub fn set_or_clear_workload_identity_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadIdentityConfig>,
    {
        self.workload_identity_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mesh_certificates][crate::model::Cluster::mesh_certificates].
    pub fn set_mesh_certificates<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MeshCertificates>,
    {
        self.mesh_certificates = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mesh_certificates][crate::model::Cluster::mesh_certificates].
    pub fn set_or_clear_mesh_certificates<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MeshCertificates>,
    {
        self.mesh_certificates = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cost_management_config][crate::model::Cluster::cost_management_config].
    pub fn set_cost_management_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CostManagementConfig>,
    {
        self.cost_management_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cost_management_config][crate::model::Cluster::cost_management_config].
    pub fn set_or_clear_cost_management_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CostManagementConfig>,
    {
        self.cost_management_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [notification_config][crate::model::Cluster::notification_config].
    pub fn set_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [notification_config][crate::model::Cluster::notification_config].
    pub fn set_or_clear_notification_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.notification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidential_nodes][crate::model::Cluster::confidential_nodes].
    pub fn set_confidential_nodes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialNodes>,
    {
        self.confidential_nodes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_nodes][crate::model::Cluster::confidential_nodes].
    pub fn set_or_clear_confidential_nodes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialNodes>,
    {
        self.confidential_nodes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [identity_service_config][crate::model::Cluster::identity_service_config].
    pub fn set_identity_service_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IdentityServiceConfig>,
    {
        self.identity_service_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [identity_service_config][crate::model::Cluster::identity_service_config].
    pub fn set_or_clear_identity_service_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::IdentityServiceConfig>,
    {
        self.identity_service_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::Cluster::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::Cluster::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::Cluster::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [initial_cluster_version][crate::model::Cluster::initial_cluster_version].
    pub fn set_initial_cluster_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.initial_cluster_version = v.into();
        self
    }

    /// Sets the value of [current_master_version][crate::model::Cluster::current_master_version].
    pub fn set_current_master_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.current_master_version = v.into();
        self
    }

    /// Sets the value of [current_node_version][crate::model::Cluster::current_node_version].
    #[deprecated]
    pub fn set_current_node_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.current_node_version = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Cluster::status].
    pub fn set_status<T: std::convert::Into<crate::model::cluster::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::Cluster::status_message].
    #[deprecated]
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [node_ipv4_cidr_size][crate::model::Cluster::node_ipv4_cidr_size].
    pub fn set_node_ipv4_cidr_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_ipv4_cidr_size = v.into();
        self
    }

    /// Sets the value of [services_ipv4_cidr][crate::model::Cluster::services_ipv4_cidr].
    pub fn set_services_ipv4_cidr<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.services_ipv4_cidr = v.into();
        self
    }

    /// Sets the value of [instance_group_urls][crate::model::Cluster::instance_group_urls].
    #[deprecated]
    pub fn set_instance_group_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_group_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [current_node_count][crate::model::Cluster::current_node_count].
    #[deprecated]
    pub fn set_current_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.current_node_count = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Cluster::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Cluster::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [enable_tpu][crate::model::Cluster::enable_tpu].
    #[deprecated]
    pub fn set_enable_tpu<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_tpu = v.into();
        self
    }

    /// Sets the value of [tpu_ipv4_cidr_block][crate::model::Cluster::tpu_ipv4_cidr_block].
    #[deprecated]
    pub fn set_tpu_ipv4_cidr_block<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.tpu_ipv4_cidr_block = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::Cluster::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StatusCondition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [autopilot][crate::model::Cluster::autopilot].
    pub fn set_autopilot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Autopilot>,
    {
        self.autopilot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autopilot][crate::model::Cluster::autopilot].
    pub fn set_or_clear_autopilot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Autopilot>,
    {
        self.autopilot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::Cluster::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [node_pool_defaults][crate::model::Cluster::node_pool_defaults].
    pub fn set_node_pool_defaults<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolDefaults>,
    {
        self.node_pool_defaults = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_pool_defaults][crate::model::Cluster::node_pool_defaults].
    pub fn set_or_clear_node_pool_defaults<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolDefaults>,
    {
        self.node_pool_defaults = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::Cluster::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::Cluster::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [monitoring_config][crate::model::Cluster::monitoring_config].
    pub fn set_monitoring_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringConfig>,
    {
        self.monitoring_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [monitoring_config][crate::model::Cluster::monitoring_config].
    pub fn set_or_clear_monitoring_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringConfig>,
    {
        self.monitoring_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_pool_auto_config][crate::model::Cluster::node_pool_auto_config].
    pub fn set_node_pool_auto_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolAutoConfig>,
    {
        self.node_pool_auto_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_pool_auto_config][crate::model::Cluster::node_pool_auto_config].
    pub fn set_or_clear_node_pool_auto_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolAutoConfig>,
    {
        self.node_pool_auto_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [pod_autoscaling][crate::model::Cluster::pod_autoscaling].
    pub fn set_pod_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PodAutoscaling>,
    {
        self.pod_autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pod_autoscaling][crate::model::Cluster::pod_autoscaling].
    pub fn set_or_clear_pod_autoscaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PodAutoscaling>,
    {
        self.pod_autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Cluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [fleet][crate::model::Cluster::fleet].
    pub fn set_fleet<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.fleet = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fleet][crate::model::Cluster::fleet].
    pub fn set_or_clear_fleet<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.fleet = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_posture_config][crate::model::Cluster::security_posture_config].
    pub fn set_security_posture_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecurityPostureConfig>,
    {
        self.security_posture_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_posture_config][crate::model::Cluster::security_posture_config].
    pub fn set_or_clear_security_posture_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecurityPostureConfig>,
    {
        self.security_posture_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [control_plane_endpoints_config][crate::model::Cluster::control_plane_endpoints_config].
    pub fn set_control_plane_endpoints_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ControlPlaneEndpointsConfig>,
    {
        self.control_plane_endpoints_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control_plane_endpoints_config][crate::model::Cluster::control_plane_endpoints_config].
    pub fn set_or_clear_control_plane_endpoints_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ControlPlaneEndpointsConfig>,
    {
        self.control_plane_endpoints_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_k8s_beta_apis][crate::model::Cluster::enable_k8s_beta_apis].
    pub fn set_enable_k8s_beta_apis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::K8sBetaAPIConfig>,
    {
        self.enable_k8s_beta_apis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_k8s_beta_apis][crate::model::Cluster::enable_k8s_beta_apis].
    pub fn set_or_clear_enable_k8s_beta_apis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::K8sBetaAPIConfig>,
    {
        self.enable_k8s_beta_apis = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enterprise_config][crate::model::Cluster::enterprise_config].
    pub fn set_enterprise_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EnterpriseConfig>,
    {
        self.enterprise_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enterprise_config][crate::model::Cluster::enterprise_config].
    pub fn set_or_clear_enterprise_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EnterpriseConfig>,
    {
        self.enterprise_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secret_manager_config][crate::model::Cluster::secret_manager_config].
    pub fn set_secret_manager_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecretManagerConfig>,
    {
        self.secret_manager_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [secret_manager_config][crate::model::Cluster::secret_manager_config].
    pub fn set_or_clear_secret_manager_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SecretManagerConfig>,
    {
        self.secret_manager_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compliance_posture_config][crate::model::Cluster::compliance_posture_config].
    pub fn set_compliance_posture_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompliancePostureConfig>,
    {
        self.compliance_posture_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compliance_posture_config][crate::model::Cluster::compliance_posture_config].
    pub fn set_or_clear_compliance_posture_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompliancePostureConfig>,
    {
        self.compliance_posture_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Cluster::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::Cluster::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Cluster::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::Cluster::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_managed_keys_config][crate::model::Cluster::user_managed_keys_config].
    pub fn set_user_managed_keys_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserManagedKeysConfig>,
    {
        self.user_managed_keys_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_managed_keys_config][crate::model::Cluster::user_managed_keys_config].
    pub fn set_or_clear_user_managed_keys_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserManagedKeysConfig>,
    {
        self.user_managed_keys_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rbac_binding_config][crate::model::Cluster::rbac_binding_config].
    pub fn set_rbac_binding_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RBACBindingConfig>,
    {
        self.rbac_binding_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rbac_binding_config][crate::model::Cluster::rbac_binding_config].
    pub fn set_or_clear_rbac_binding_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RBACBindingConfig>,
    {
        self.rbac_binding_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gke_auto_upgrade_config][crate::model::Cluster::gke_auto_upgrade_config].
    pub fn set_gke_auto_upgrade_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GkeAutoUpgradeConfig>,
    {
        self.gke_auto_upgrade_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gke_auto_upgrade_config][crate::model::Cluster::gke_auto_upgrade_config].
    pub fn set_or_clear_gke_auto_upgrade_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GkeAutoUpgradeConfig>,
    {
        self.gke_auto_upgrade_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [anonymous_authentication_config][crate::model::Cluster::anonymous_authentication_config].
    pub fn set_anonymous_authentication_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnonymousAuthenticationConfig>,
    {
        self.anonymous_authentication_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [anonymous_authentication_config][crate::model::Cluster::anonymous_authentication_config].
    pub fn set_or_clear_anonymous_authentication_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::AnonymousAuthenticationConfig>,
    {
        self.anonymous_authentication_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.Cluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __initial_node_count,
            __node_config,
            __master_auth,
            __logging_service,
            __monitoring_service,
            __network,
            __cluster_ipv4_cidr,
            __addons_config,
            __subnetwork,
            __node_pools,
            __locations,
            __enable_kubernetes_alpha,
            __alpha_cluster_feature_gates,
            __resource_labels,
            __label_fingerprint,
            __legacy_abac,
            __network_policy,
            __ip_allocation_policy,
            __master_authorized_networks_config,
            __maintenance_policy,
            __binary_authorization,
            __autoscaling,
            __network_config,
            __default_max_pods_constraint,
            __resource_usage_export_config,
            __authenticator_groups_config,
            __private_cluster_config,
            __database_encryption,
            __vertical_pod_autoscaling,
            __shielded_nodes,
            __release_channel,
            __workload_identity_config,
            __mesh_certificates,
            __cost_management_config,
            __notification_config,
            __confidential_nodes,
            __identity_service_config,
            __self_link,
            __zone,
            __endpoint,
            __initial_cluster_version,
            __current_master_version,
            __current_node_version,
            __create_time,
            __status,
            __status_message,
            __node_ipv4_cidr_size,
            __services_ipv4_cidr,
            __instance_group_urls,
            __current_node_count,
            __expire_time,
            __location,
            __enable_tpu,
            __tpu_ipv4_cidr_block,
            __conditions,
            __autopilot,
            __id,
            __node_pool_defaults,
            __logging_config,
            __monitoring_config,
            __node_pool_auto_config,
            __pod_autoscaling,
            __etag,
            __fleet,
            __security_posture_config,
            __control_plane_endpoints_config,
            __enable_k8s_beta_apis,
            __enterprise_config,
            __secret_manager_config,
            __compliance_posture_config,
            __satisfies_pzs,
            __satisfies_pzi,
            __user_managed_keys_config,
            __rbac_binding_config,
            __gke_auto_upgrade_config,
            __anonymous_authentication_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "initialNodeCount" => Ok(__FieldTag::__initial_node_count),
                            "initial_node_count" => Ok(__FieldTag::__initial_node_count),
                            "nodeConfig" => Ok(__FieldTag::__node_config),
                            "node_config" => Ok(__FieldTag::__node_config),
                            "masterAuth" => Ok(__FieldTag::__master_auth),
                            "master_auth" => Ok(__FieldTag::__master_auth),
                            "loggingService" => Ok(__FieldTag::__logging_service),
                            "logging_service" => Ok(__FieldTag::__logging_service),
                            "monitoringService" => Ok(__FieldTag::__monitoring_service),
                            "monitoring_service" => Ok(__FieldTag::__monitoring_service),
                            "network" => Ok(__FieldTag::__network),
                            "clusterIpv4Cidr" => Ok(__FieldTag::__cluster_ipv4_cidr),
                            "cluster_ipv4_cidr" => Ok(__FieldTag::__cluster_ipv4_cidr),
                            "addonsConfig" => Ok(__FieldTag::__addons_config),
                            "addons_config" => Ok(__FieldTag::__addons_config),
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "nodePools" => Ok(__FieldTag::__node_pools),
                            "node_pools" => Ok(__FieldTag::__node_pools),
                            "locations" => Ok(__FieldTag::__locations),
                            "enableKubernetesAlpha" => Ok(__FieldTag::__enable_kubernetes_alpha),
                            "enable_kubernetes_alpha" => Ok(__FieldTag::__enable_kubernetes_alpha),
                            "alphaClusterFeatureGates" => {
                                Ok(__FieldTag::__alpha_cluster_feature_gates)
                            }
                            "alpha_cluster_feature_gates" => {
                                Ok(__FieldTag::__alpha_cluster_feature_gates)
                            }
                            "resourceLabels" => Ok(__FieldTag::__resource_labels),
                            "resource_labels" => Ok(__FieldTag::__resource_labels),
                            "labelFingerprint" => Ok(__FieldTag::__label_fingerprint),
                            "label_fingerprint" => Ok(__FieldTag::__label_fingerprint),
                            "legacyAbac" => Ok(__FieldTag::__legacy_abac),
                            "legacy_abac" => Ok(__FieldTag::__legacy_abac),
                            "networkPolicy" => Ok(__FieldTag::__network_policy),
                            "network_policy" => Ok(__FieldTag::__network_policy),
                            "ipAllocationPolicy" => Ok(__FieldTag::__ip_allocation_policy),
                            "ip_allocation_policy" => Ok(__FieldTag::__ip_allocation_policy),
                            "masterAuthorizedNetworksConfig" => {
                                Ok(__FieldTag::__master_authorized_networks_config)
                            }
                            "master_authorized_networks_config" => {
                                Ok(__FieldTag::__master_authorized_networks_config)
                            }
                            "maintenancePolicy" => Ok(__FieldTag::__maintenance_policy),
                            "maintenance_policy" => Ok(__FieldTag::__maintenance_policy),
                            "binaryAuthorization" => Ok(__FieldTag::__binary_authorization),
                            "binary_authorization" => Ok(__FieldTag::__binary_authorization),
                            "autoscaling" => Ok(__FieldTag::__autoscaling),
                            "networkConfig" => Ok(__FieldTag::__network_config),
                            "network_config" => Ok(__FieldTag::__network_config),
                            "defaultMaxPodsConstraint" => {
                                Ok(__FieldTag::__default_max_pods_constraint)
                            }
                            "default_max_pods_constraint" => {
                                Ok(__FieldTag::__default_max_pods_constraint)
                            }
                            "resourceUsageExportConfig" => {
                                Ok(__FieldTag::__resource_usage_export_config)
                            }
                            "resource_usage_export_config" => {
                                Ok(__FieldTag::__resource_usage_export_config)
                            }
                            "authenticatorGroupsConfig" => {
                                Ok(__FieldTag::__authenticator_groups_config)
                            }
                            "authenticator_groups_config" => {
                                Ok(__FieldTag::__authenticator_groups_config)
                            }
                            "privateClusterConfig" => Ok(__FieldTag::__private_cluster_config),
                            "private_cluster_config" => Ok(__FieldTag::__private_cluster_config),
                            "databaseEncryption" => Ok(__FieldTag::__database_encryption),
                            "database_encryption" => Ok(__FieldTag::__database_encryption),
                            "verticalPodAutoscaling" => Ok(__FieldTag::__vertical_pod_autoscaling),
                            "vertical_pod_autoscaling" => {
                                Ok(__FieldTag::__vertical_pod_autoscaling)
                            }
                            "shieldedNodes" => Ok(__FieldTag::__shielded_nodes),
                            "shielded_nodes" => Ok(__FieldTag::__shielded_nodes),
                            "releaseChannel" => Ok(__FieldTag::__release_channel),
                            "release_channel" => Ok(__FieldTag::__release_channel),
                            "workloadIdentityConfig" => Ok(__FieldTag::__workload_identity_config),
                            "workload_identity_config" => {
                                Ok(__FieldTag::__workload_identity_config)
                            }
                            "meshCertificates" => Ok(__FieldTag::__mesh_certificates),
                            "mesh_certificates" => Ok(__FieldTag::__mesh_certificates),
                            "costManagementConfig" => Ok(__FieldTag::__cost_management_config),
                            "cost_management_config" => Ok(__FieldTag::__cost_management_config),
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            "confidentialNodes" => Ok(__FieldTag::__confidential_nodes),
                            "confidential_nodes" => Ok(__FieldTag::__confidential_nodes),
                            "identityServiceConfig" => Ok(__FieldTag::__identity_service_config),
                            "identity_service_config" => Ok(__FieldTag::__identity_service_config),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "zone" => Ok(__FieldTag::__zone),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "initialClusterVersion" => Ok(__FieldTag::__initial_cluster_version),
                            "initial_cluster_version" => Ok(__FieldTag::__initial_cluster_version),
                            "currentMasterVersion" => Ok(__FieldTag::__current_master_version),
                            "current_master_version" => Ok(__FieldTag::__current_master_version),
                            "currentNodeVersion" => Ok(__FieldTag::__current_node_version),
                            "current_node_version" => Ok(__FieldTag::__current_node_version),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "status" => Ok(__FieldTag::__status),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "nodeIpv4CidrSize" => Ok(__FieldTag::__node_ipv4_cidr_size),
                            "node_ipv4_cidr_size" => Ok(__FieldTag::__node_ipv4_cidr_size),
                            "servicesIpv4Cidr" => Ok(__FieldTag::__services_ipv4_cidr),
                            "services_ipv4_cidr" => Ok(__FieldTag::__services_ipv4_cidr),
                            "instanceGroupUrls" => Ok(__FieldTag::__instance_group_urls),
                            "instance_group_urls" => Ok(__FieldTag::__instance_group_urls),
                            "currentNodeCount" => Ok(__FieldTag::__current_node_count),
                            "current_node_count" => Ok(__FieldTag::__current_node_count),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "location" => Ok(__FieldTag::__location),
                            "enableTpu" => Ok(__FieldTag::__enable_tpu),
                            "enable_tpu" => Ok(__FieldTag::__enable_tpu),
                            "tpuIpv4CidrBlock" => Ok(__FieldTag::__tpu_ipv4_cidr_block),
                            "tpu_ipv4_cidr_block" => Ok(__FieldTag::__tpu_ipv4_cidr_block),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "autopilot" => Ok(__FieldTag::__autopilot),
                            "id" => Ok(__FieldTag::__id),
                            "nodePoolDefaults" => Ok(__FieldTag::__node_pool_defaults),
                            "node_pool_defaults" => Ok(__FieldTag::__node_pool_defaults),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "monitoringConfig" => Ok(__FieldTag::__monitoring_config),
                            "monitoring_config" => Ok(__FieldTag::__monitoring_config),
                            "nodePoolAutoConfig" => Ok(__FieldTag::__node_pool_auto_config),
                            "node_pool_auto_config" => Ok(__FieldTag::__node_pool_auto_config),
                            "podAutoscaling" => Ok(__FieldTag::__pod_autoscaling),
                            "pod_autoscaling" => Ok(__FieldTag::__pod_autoscaling),
                            "etag" => Ok(__FieldTag::__etag),
                            "fleet" => Ok(__FieldTag::__fleet),
                            "securityPostureConfig" => Ok(__FieldTag::__security_posture_config),
                            "security_posture_config" => Ok(__FieldTag::__security_posture_config),
                            "controlPlaneEndpointsConfig" => {
                                Ok(__FieldTag::__control_plane_endpoints_config)
                            }
                            "control_plane_endpoints_config" => {
                                Ok(__FieldTag::__control_plane_endpoints_config)
                            }
                            "enableK8sBetaApis" => Ok(__FieldTag::__enable_k8s_beta_apis),
                            "enable_k8s_beta_apis" => Ok(__FieldTag::__enable_k8s_beta_apis),
                            "enterpriseConfig" => Ok(__FieldTag::__enterprise_config),
                            "enterprise_config" => Ok(__FieldTag::__enterprise_config),
                            "secretManagerConfig" => Ok(__FieldTag::__secret_manager_config),
                            "secret_manager_config" => Ok(__FieldTag::__secret_manager_config),
                            "compliancePostureConfig" => {
                                Ok(__FieldTag::__compliance_posture_config)
                            }
                            "compliance_posture_config" => {
                                Ok(__FieldTag::__compliance_posture_config)
                            }
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "userManagedKeysConfig" => Ok(__FieldTag::__user_managed_keys_config),
                            "user_managed_keys_config" => {
                                Ok(__FieldTag::__user_managed_keys_config)
                            }
                            "rbacBindingConfig" => Ok(__FieldTag::__rbac_binding_config),
                            "rbac_binding_config" => Ok(__FieldTag::__rbac_binding_config),
                            "gkeAutoUpgradeConfig" => Ok(__FieldTag::__gke_auto_upgrade_config),
                            "gke_auto_upgrade_config" => Ok(__FieldTag::__gke_auto_upgrade_config),
                            "anonymousAuthenticationConfig" => {
                                Ok(__FieldTag::__anonymous_authentication_config)
                            }
                            "anonymous_authentication_config" => {
                                Ok(__FieldTag::__anonymous_authentication_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__initial_node_count => {
                            if !fields.insert(__FieldTag::__initial_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initial_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__node_config => {
                            if !fields.insert(__FieldTag::__node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_config",
                                ));
                            }
                            result.node_config =
                                map.next_value::<std::option::Option<crate::model::NodeConfig>>()?;
                        }
                        __FieldTag::__master_auth => {
                            if !fields.insert(__FieldTag::__master_auth) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_auth",
                                ));
                            }
                            result.master_auth =
                                map.next_value::<std::option::Option<crate::model::MasterAuth>>()?;
                        }
                        __FieldTag::__logging_service => {
                            if !fields.insert(__FieldTag::__logging_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_service",
                                ));
                            }
                            result.logging_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monitoring_service => {
                            if !fields.insert(__FieldTag::__monitoring_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitoring_service",
                                ));
                            }
                            result.monitoring_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_ipv4_cidr => {
                            if !fields.insert(__FieldTag::__cluster_ipv4_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ipv4_cidr",
                                ));
                            }
                            result.cluster_ipv4_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__addons_config => {
                            if !fields.insert(__FieldTag::__addons_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for addons_config",
                                ));
                            }
                            result.addons_config = map
                                .next_value::<std::option::Option<crate::model::AddonsConfig>>()?;
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pools => {
                            if !fields.insert(__FieldTag::__node_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pools",
                                ));
                            }
                            result.node_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NodePool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__enable_kubernetes_alpha => {
                            if !fields.insert(__FieldTag::__enable_kubernetes_alpha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_kubernetes_alpha",
                                ));
                            }
                            result.enable_kubernetes_alpha = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__alpha_cluster_feature_gates => {
                            if !fields.insert(__FieldTag::__alpha_cluster_feature_gates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alpha_cluster_feature_gates",
                                ));
                            }
                            result.alpha_cluster_feature_gates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource_labels => {
                            if !fields.insert(__FieldTag::__resource_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_labels",
                                ));
                            }
                            result.resource_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__label_fingerprint => {
                            if !fields.insert(__FieldTag::__label_fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_fingerprint",
                                ));
                            }
                            result.label_fingerprint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__legacy_abac => {
                            if !fields.insert(__FieldTag::__legacy_abac) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for legacy_abac",
                                ));
                            }
                            result.legacy_abac =
                                map.next_value::<std::option::Option<crate::model::LegacyAbac>>()?;
                        }
                        __FieldTag::__network_policy => {
                            if !fields.insert(__FieldTag::__network_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_policy",
                                ));
                            }
                            result.network_policy = map
                                .next_value::<std::option::Option<crate::model::NetworkPolicy>>()?;
                        }
                        __FieldTag::__ip_allocation_policy => {
                            if !fields.insert(__FieldTag::__ip_allocation_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_allocation_policy",
                                ));
                            }
                            result.ip_allocation_policy = map.next_value::<std::option::Option<crate::model::IPAllocationPolicy>>()?
                                ;
                        }
                        __FieldTag::__master_authorized_networks_config => {
                            if !fields.insert(__FieldTag::__master_authorized_networks_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_authorized_networks_config",
                                ));
                            }
                            result.master_authorized_networks_config =
                                map.next_value::<std::option::Option<
                                    crate::model::MasterAuthorizedNetworksConfig,
                                >>()?;
                        }
                        __FieldTag::__maintenance_policy => {
                            if !fields.insert(__FieldTag::__maintenance_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_policy",
                                ));
                            }
                            result.maintenance_policy = map
                                .next_value::<std::option::Option<crate::model::MaintenancePolicy>>(
                                )?;
                        }
                        __FieldTag::__binary_authorization => {
                            if !fields.insert(__FieldTag::__binary_authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_authorization",
                                ));
                            }
                            result.binary_authorization = map.next_value::<std::option::Option<crate::model::BinaryAuthorization>>()?
                                ;
                        }
                        __FieldTag::__autoscaling => {
                            if !fields.insert(__FieldTag::__autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling",
                                ));
                            }
                            result.autoscaling = map.next_value::<std::option::Option<crate::model::ClusterAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__network_config => {
                            if !fields.insert(__FieldTag::__network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_config",
                                ));
                            }
                            result.network_config = map
                                .next_value::<std::option::Option<crate::model::NetworkConfig>>()?;
                        }
                        __FieldTag::__default_max_pods_constraint => {
                            if !fields.insert(__FieldTag::__default_max_pods_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_max_pods_constraint",
                                ));
                            }
                            result.default_max_pods_constraint = map
                                .next_value::<std::option::Option<crate::model::MaxPodsConstraint>>(
                                )?;
                        }
                        __FieldTag::__resource_usage_export_config => {
                            if !fields.insert(__FieldTag::__resource_usage_export_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_usage_export_config",
                                ));
                            }
                            result.resource_usage_export_config = map.next_value::<std::option::Option<crate::model::ResourceUsageExportConfig>>()?
                                ;
                        }
                        __FieldTag::__authenticator_groups_config => {
                            if !fields.insert(__FieldTag::__authenticator_groups_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authenticator_groups_config",
                                ));
                            }
                            result.authenticator_groups_config = map.next_value::<std::option::Option<crate::model::AuthenticatorGroupsConfig>>()?
                                ;
                        }
                        __FieldTag::__private_cluster_config => {
                            if !fields.insert(__FieldTag::__private_cluster_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_cluster_config",
                                ));
                            }
                            result.private_cluster_config = map.next_value::<std::option::Option<crate::model::PrivateClusterConfig>>()?
                                ;
                        }
                        __FieldTag::__database_encryption => {
                            if !fields.insert(__FieldTag::__database_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_encryption",
                                ));
                            }
                            result.database_encryption = map.next_value::<std::option::Option<crate::model::DatabaseEncryption>>()?
                                ;
                        }
                        __FieldTag::__vertical_pod_autoscaling => {
                            if !fields.insert(__FieldTag::__vertical_pod_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertical_pod_autoscaling",
                                ));
                            }
                            result.vertical_pod_autoscaling = map.next_value::<std::option::Option<crate::model::VerticalPodAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__shielded_nodes => {
                            if !fields.insert(__FieldTag::__shielded_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shielded_nodes",
                                ));
                            }
                            result.shielded_nodes = map
                                .next_value::<std::option::Option<crate::model::ShieldedNodes>>()?;
                        }
                        __FieldTag::__release_channel => {
                            if !fields.insert(__FieldTag::__release_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_channel",
                                ));
                            }
                            result.release_channel = map
                                .next_value::<std::option::Option<crate::model::ReleaseChannel>>(
                                )?;
                        }
                        __FieldTag::__workload_identity_config => {
                            if !fields.insert(__FieldTag::__workload_identity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_identity_config",
                                ));
                            }
                            result.workload_identity_config = map.next_value::<std::option::Option<crate::model::WorkloadIdentityConfig>>()?
                                ;
                        }
                        __FieldTag::__mesh_certificates => {
                            if !fields.insert(__FieldTag::__mesh_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mesh_certificates",
                                ));
                            }
                            result.mesh_certificates = map
                                .next_value::<std::option::Option<crate::model::MeshCertificates>>(
                                )?;
                        }
                        __FieldTag::__cost_management_config => {
                            if !fields.insert(__FieldTag::__cost_management_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_management_config",
                                ));
                            }
                            result.cost_management_config = map.next_value::<std::option::Option<crate::model::CostManagementConfig>>()?
                                ;
                        }
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_config",
                                ));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__confidential_nodes => {
                            if !fields.insert(__FieldTag::__confidential_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidential_nodes",
                                ));
                            }
                            result.confidential_nodes = map
                                .next_value::<std::option::Option<crate::model::ConfidentialNodes>>(
                                )?;
                        }
                        __FieldTag::__identity_service_config => {
                            if !fields.insert(__FieldTag::__identity_service_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_service_config",
                                ));
                            }
                            result.identity_service_config = map.next_value::<std::option::Option<crate::model::IdentityServiceConfig>>()?
                                ;
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__initial_cluster_version => {
                            if !fields.insert(__FieldTag::__initial_cluster_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_cluster_version",
                                ));
                            }
                            result.initial_cluster_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__current_master_version => {
                            if !fields.insert(__FieldTag::__current_master_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_master_version",
                                ));
                            }
                            result.current_master_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__current_node_version => {
                            if !fields.insert(__FieldTag::__current_node_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_node_version",
                                ));
                            }
                            result.current_node_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::cluster::Status>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_ipv4_cidr_size => {
                            if !fields.insert(__FieldTag::__node_ipv4_cidr_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_ipv4_cidr_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.node_ipv4_cidr_size =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__services_ipv4_cidr => {
                            if !fields.insert(__FieldTag::__services_ipv4_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_ipv4_cidr",
                                ));
                            }
                            result.services_ipv4_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_group_urls => {
                            if !fields.insert(__FieldTag::__instance_group_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_group_urls",
                                ));
                            }
                            result.instance_group_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__current_node_count => {
                            if !fields.insert(__FieldTag::__current_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.current_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_tpu => {
                            if !fields.insert(__FieldTag::__enable_tpu) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_tpu",
                                ));
                            }
                            result.enable_tpu = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tpu_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__tpu_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tpu_ipv4_cidr_block",
                                ));
                            }
                            result.tpu_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StatusCondition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autopilot => {
                            if !fields.insert(__FieldTag::__autopilot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autopilot",
                                ));
                            }
                            result.autopilot =
                                map.next_value::<std::option::Option<crate::model::Autopilot>>()?;
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_defaults => {
                            if !fields.insert(__FieldTag::__node_pool_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_defaults",
                                ));
                            }
                            result.node_pool_defaults = map
                                .next_value::<std::option::Option<crate::model::NodePoolDefaults>>(
                                )?;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__monitoring_config => {
                            if !fields.insert(__FieldTag::__monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitoring_config",
                                ));
                            }
                            result.monitoring_config = map
                                .next_value::<std::option::Option<crate::model::MonitoringConfig>>(
                                )?;
                        }
                        __FieldTag::__node_pool_auto_config => {
                            if !fields.insert(__FieldTag::__node_pool_auto_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_auto_config",
                                ));
                            }
                            result.node_pool_auto_config = map.next_value::<std::option::Option<crate::model::NodePoolAutoConfig>>()?
                                ;
                        }
                        __FieldTag::__pod_autoscaling => {
                            if !fields.insert(__FieldTag::__pod_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_autoscaling",
                                ));
                            }
                            result.pod_autoscaling = map
                                .next_value::<std::option::Option<crate::model::PodAutoscaling>>(
                                )?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fleet => {
                            if !fields.insert(__FieldTag::__fleet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fleet",
                                ));
                            }
                            result.fleet =
                                map.next_value::<std::option::Option<crate::model::Fleet>>()?;
                        }
                        __FieldTag::__security_posture_config => {
                            if !fields.insert(__FieldTag::__security_posture_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_posture_config",
                                ));
                            }
                            result.security_posture_config = map.next_value::<std::option::Option<crate::model::SecurityPostureConfig>>()?
                                ;
                        }
                        __FieldTag::__control_plane_endpoints_config => {
                            if !fields.insert(__FieldTag::__control_plane_endpoints_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane_endpoints_config",
                                ));
                            }
                            result.control_plane_endpoints_config = map.next_value::<std::option::Option<crate::model::ControlPlaneEndpointsConfig>>()?
                                ;
                        }
                        __FieldTag::__enable_k8s_beta_apis => {
                            if !fields.insert(__FieldTag::__enable_k8s_beta_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_k8s_beta_apis",
                                ));
                            }
                            result.enable_k8s_beta_apis = map
                                .next_value::<std::option::Option<crate::model::K8sBetaAPIConfig>>(
                                )?;
                        }
                        __FieldTag::__enterprise_config => {
                            if !fields.insert(__FieldTag::__enterprise_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enterprise_config",
                                ));
                            }
                            result.enterprise_config = map
                                .next_value::<std::option::Option<crate::model::EnterpriseConfig>>(
                                )?;
                        }
                        __FieldTag::__secret_manager_config => {
                            if !fields.insert(__FieldTag::__secret_manager_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_manager_config",
                                ));
                            }
                            result.secret_manager_config = map.next_value::<std::option::Option<crate::model::SecretManagerConfig>>()?
                                ;
                        }
                        __FieldTag::__compliance_posture_config => {
                            if !fields.insert(__FieldTag::__compliance_posture_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance_posture_config",
                                ));
                            }
                            result.compliance_posture_config = map.next_value::<std::option::Option<crate::model::CompliancePostureConfig>>()?
                                ;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__user_managed_keys_config => {
                            if !fields.insert(__FieldTag::__user_managed_keys_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_managed_keys_config",
                                ));
                            }
                            result.user_managed_keys_config = map.next_value::<std::option::Option<crate::model::UserManagedKeysConfig>>()?
                                ;
                        }
                        __FieldTag::__rbac_binding_config => {
                            if !fields.insert(__FieldTag::__rbac_binding_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rbac_binding_config",
                                ));
                            }
                            result.rbac_binding_config = map
                                .next_value::<std::option::Option<crate::model::RBACBindingConfig>>(
                                )?;
                        }
                        __FieldTag::__gke_auto_upgrade_config => {
                            if !fields.insert(__FieldTag::__gke_auto_upgrade_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_auto_upgrade_config",
                                ));
                            }
                            result.gke_auto_upgrade_config = map.next_value::<std::option::Option<crate::model::GkeAutoUpgradeConfig>>()?
                                ;
                        }
                        __FieldTag::__anonymous_authentication_config => {
                            if !fields.insert(__FieldTag::__anonymous_authentication_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for anonymous_authentication_config",
                                ));
                            }
                            result.anonymous_authentication_config =
                                map.next_value::<std::option::Option<
                                    crate::model::AnonymousAuthenticationConfig,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.initial_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("initialNodeCount", &__With(&self.initial_node_count))?;
        }
        if self.node_config.is_some() {
            state.serialize_entry("nodeConfig", &self.node_config)?;
        }
        if self.master_auth.is_some() {
            state.serialize_entry("masterAuth", &self.master_auth)?;
        }
        if !self.logging_service.is_empty() {
            state.serialize_entry("loggingService", &self.logging_service)?;
        }
        if !self.monitoring_service.is_empty() {
            state.serialize_entry("monitoringService", &self.monitoring_service)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.cluster_ipv4_cidr.is_empty() {
            state.serialize_entry("clusterIpv4Cidr", &self.cluster_ipv4_cidr)?;
        }
        if self.addons_config.is_some() {
            state.serialize_entry("addonsConfig", &self.addons_config)?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.node_pools.is_empty() {
            state.serialize_entry("nodePools", &self.node_pools)?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if !wkt::internal::is_default(&self.enable_kubernetes_alpha) {
            state.serialize_entry("enableKubernetesAlpha", &self.enable_kubernetes_alpha)?;
        }
        if !self.alpha_cluster_feature_gates.is_empty() {
            state.serialize_entry(
                "alphaClusterFeatureGates",
                &self.alpha_cluster_feature_gates,
            )?;
        }
        if !self.resource_labels.is_empty() {
            state.serialize_entry("resourceLabels", &self.resource_labels)?;
        }
        if !self.label_fingerprint.is_empty() {
            state.serialize_entry("labelFingerprint", &self.label_fingerprint)?;
        }
        if self.legacy_abac.is_some() {
            state.serialize_entry("legacyAbac", &self.legacy_abac)?;
        }
        if self.network_policy.is_some() {
            state.serialize_entry("networkPolicy", &self.network_policy)?;
        }
        if self.ip_allocation_policy.is_some() {
            state.serialize_entry("ipAllocationPolicy", &self.ip_allocation_policy)?;
        }
        if self.master_authorized_networks_config.is_some() {
            state.serialize_entry(
                "masterAuthorizedNetworksConfig",
                &self.master_authorized_networks_config,
            )?;
        }
        if self.maintenance_policy.is_some() {
            state.serialize_entry("maintenancePolicy", &self.maintenance_policy)?;
        }
        if self.binary_authorization.is_some() {
            state.serialize_entry("binaryAuthorization", &self.binary_authorization)?;
        }
        if self.autoscaling.is_some() {
            state.serialize_entry("autoscaling", &self.autoscaling)?;
        }
        if self.network_config.is_some() {
            state.serialize_entry("networkConfig", &self.network_config)?;
        }
        if self.default_max_pods_constraint.is_some() {
            state.serialize_entry(
                "defaultMaxPodsConstraint",
                &self.default_max_pods_constraint,
            )?;
        }
        if self.resource_usage_export_config.is_some() {
            state.serialize_entry(
                "resourceUsageExportConfig",
                &self.resource_usage_export_config,
            )?;
        }
        if self.authenticator_groups_config.is_some() {
            state.serialize_entry(
                "authenticatorGroupsConfig",
                &self.authenticator_groups_config,
            )?;
        }
        if self.private_cluster_config.is_some() {
            state.serialize_entry("privateClusterConfig", &self.private_cluster_config)?;
        }
        if self.database_encryption.is_some() {
            state.serialize_entry("databaseEncryption", &self.database_encryption)?;
        }
        if self.vertical_pod_autoscaling.is_some() {
            state.serialize_entry("verticalPodAutoscaling", &self.vertical_pod_autoscaling)?;
        }
        if self.shielded_nodes.is_some() {
            state.serialize_entry("shieldedNodes", &self.shielded_nodes)?;
        }
        if self.release_channel.is_some() {
            state.serialize_entry("releaseChannel", &self.release_channel)?;
        }
        if self.workload_identity_config.is_some() {
            state.serialize_entry("workloadIdentityConfig", &self.workload_identity_config)?;
        }
        if self.mesh_certificates.is_some() {
            state.serialize_entry("meshCertificates", &self.mesh_certificates)?;
        }
        if self.cost_management_config.is_some() {
            state.serialize_entry("costManagementConfig", &self.cost_management_config)?;
        }
        if self.notification_config.is_some() {
            state.serialize_entry("notificationConfig", &self.notification_config)?;
        }
        if self.confidential_nodes.is_some() {
            state.serialize_entry("confidentialNodes", &self.confidential_nodes)?;
        }
        if self.identity_service_config.is_some() {
            state.serialize_entry("identityServiceConfig", &self.identity_service_config)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.endpoint.is_empty() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if !self.initial_cluster_version.is_empty() {
            state.serialize_entry("initialClusterVersion", &self.initial_cluster_version)?;
        }
        if !self.current_master_version.is_empty() {
            state.serialize_entry("currentMasterVersion", &self.current_master_version)?;
        }
        if !self.current_node_version.is_empty() {
            state.serialize_entry("currentNodeVersion", &self.current_node_version)?;
        }
        if !self.create_time.is_empty() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.node_ipv4_cidr_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nodeIpv4CidrSize", &__With(&self.node_ipv4_cidr_size))?;
        }
        if !self.services_ipv4_cidr.is_empty() {
            state.serialize_entry("servicesIpv4Cidr", &self.services_ipv4_cidr)?;
        }
        if !self.instance_group_urls.is_empty() {
            state.serialize_entry("instanceGroupUrls", &self.instance_group_urls)?;
        }
        if !wkt::internal::is_default(&self.current_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("currentNodeCount", &__With(&self.current_node_count))?;
        }
        if !self.expire_time.is_empty() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.enable_tpu) {
            state.serialize_entry("enableTpu", &self.enable_tpu)?;
        }
        if !self.tpu_ipv4_cidr_block.is_empty() {
            state.serialize_entry("tpuIpv4CidrBlock", &self.tpu_ipv4_cidr_block)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if self.autopilot.is_some() {
            state.serialize_entry("autopilot", &self.autopilot)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.node_pool_defaults.is_some() {
            state.serialize_entry("nodePoolDefaults", &self.node_pool_defaults)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.monitoring_config.is_some() {
            state.serialize_entry("monitoringConfig", &self.monitoring_config)?;
        }
        if self.node_pool_auto_config.is_some() {
            state.serialize_entry("nodePoolAutoConfig", &self.node_pool_auto_config)?;
        }
        if self.pod_autoscaling.is_some() {
            state.serialize_entry("podAutoscaling", &self.pod_autoscaling)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.fleet.is_some() {
            state.serialize_entry("fleet", &self.fleet)?;
        }
        if self.security_posture_config.is_some() {
            state.serialize_entry("securityPostureConfig", &self.security_posture_config)?;
        }
        if self.control_plane_endpoints_config.is_some() {
            state.serialize_entry(
                "controlPlaneEndpointsConfig",
                &self.control_plane_endpoints_config,
            )?;
        }
        if self.enable_k8s_beta_apis.is_some() {
            state.serialize_entry("enableK8sBetaApis", &self.enable_k8s_beta_apis)?;
        }
        if self.enterprise_config.is_some() {
            state.serialize_entry("enterpriseConfig", &self.enterprise_config)?;
        }
        if self.secret_manager_config.is_some() {
            state.serialize_entry("secretManagerConfig", &self.secret_manager_config)?;
        }
        if self.compliance_posture_config.is_some() {
            state.serialize_entry("compliancePostureConfig", &self.compliance_posture_config)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.user_managed_keys_config.is_some() {
            state.serialize_entry("userManagedKeysConfig", &self.user_managed_keys_config)?;
        }
        if self.rbac_binding_config.is_some() {
            state.serialize_entry("rbacBindingConfig", &self.rbac_binding_config)?;
        }
        if self.gke_auto_upgrade_config.is_some() {
            state.serialize_entry("gkeAutoUpgradeConfig", &self.gke_auto_upgrade_config)?;
        }
        if self.anonymous_authentication_config.is_some() {
            state.serialize_entry(
                "anonymousAuthenticationConfig",
                &self.anonymous_authentication_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Cluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cluster");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("initial_node_count", &self.initial_node_count);
        debug_struct.field("node_config", &self.node_config);
        debug_struct.field("master_auth", &self.master_auth);
        debug_struct.field("logging_service", &self.logging_service);
        debug_struct.field("monitoring_service", &self.monitoring_service);
        debug_struct.field("network", &self.network);
        debug_struct.field("cluster_ipv4_cidr", &self.cluster_ipv4_cidr);
        debug_struct.field("addons_config", &self.addons_config);
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("node_pools", &self.node_pools);
        debug_struct.field("locations", &self.locations);
        debug_struct.field("enable_kubernetes_alpha", &self.enable_kubernetes_alpha);
        debug_struct.field(
            "alpha_cluster_feature_gates",
            &self.alpha_cluster_feature_gates,
        );
        debug_struct.field("resource_labels", &self.resource_labels);
        debug_struct.field("label_fingerprint", &self.label_fingerprint);
        debug_struct.field("legacy_abac", &self.legacy_abac);
        debug_struct.field("network_policy", &self.network_policy);
        debug_struct.field("ip_allocation_policy", &self.ip_allocation_policy);
        debug_struct.field(
            "master_authorized_networks_config",
            &self.master_authorized_networks_config,
        );
        debug_struct.field("maintenance_policy", &self.maintenance_policy);
        debug_struct.field("binary_authorization", &self.binary_authorization);
        debug_struct.field("autoscaling", &self.autoscaling);
        debug_struct.field("network_config", &self.network_config);
        debug_struct.field(
            "default_max_pods_constraint",
            &self.default_max_pods_constraint,
        );
        debug_struct.field(
            "resource_usage_export_config",
            &self.resource_usage_export_config,
        );
        debug_struct.field(
            "authenticator_groups_config",
            &self.authenticator_groups_config,
        );
        debug_struct.field("private_cluster_config", &self.private_cluster_config);
        debug_struct.field("database_encryption", &self.database_encryption);
        debug_struct.field("vertical_pod_autoscaling", &self.vertical_pod_autoscaling);
        debug_struct.field("shielded_nodes", &self.shielded_nodes);
        debug_struct.field("release_channel", &self.release_channel);
        debug_struct.field("workload_identity_config", &self.workload_identity_config);
        debug_struct.field("mesh_certificates", &self.mesh_certificates);
        debug_struct.field("cost_management_config", &self.cost_management_config);
        debug_struct.field("notification_config", &self.notification_config);
        debug_struct.field("confidential_nodes", &self.confidential_nodes);
        debug_struct.field("identity_service_config", &self.identity_service_config);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("endpoint", &self.endpoint);
        debug_struct.field("initial_cluster_version", &self.initial_cluster_version);
        debug_struct.field("current_master_version", &self.current_master_version);
        debug_struct.field("current_node_version", &self.current_node_version);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("status", &self.status);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("node_ipv4_cidr_size", &self.node_ipv4_cidr_size);
        debug_struct.field("services_ipv4_cidr", &self.services_ipv4_cidr);
        debug_struct.field("instance_group_urls", &self.instance_group_urls);
        debug_struct.field("current_node_count", &self.current_node_count);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("location", &self.location);
        debug_struct.field("enable_tpu", &self.enable_tpu);
        debug_struct.field("tpu_ipv4_cidr_block", &self.tpu_ipv4_cidr_block);
        debug_struct.field("conditions", &self.conditions);
        debug_struct.field("autopilot", &self.autopilot);
        debug_struct.field("id", &self.id);
        debug_struct.field("node_pool_defaults", &self.node_pool_defaults);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("monitoring_config", &self.monitoring_config);
        debug_struct.field("node_pool_auto_config", &self.node_pool_auto_config);
        debug_struct.field("pod_autoscaling", &self.pod_autoscaling);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("fleet", &self.fleet);
        debug_struct.field("security_posture_config", &self.security_posture_config);
        debug_struct.field(
            "control_plane_endpoints_config",
            &self.control_plane_endpoints_config,
        );
        debug_struct.field("enable_k8s_beta_apis", &self.enable_k8s_beta_apis);
        debug_struct.field("enterprise_config", &self.enterprise_config);
        debug_struct.field("secret_manager_config", &self.secret_manager_config);
        debug_struct.field("compliance_posture_config", &self.compliance_posture_config);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("user_managed_keys_config", &self.user_managed_keys_config);
        debug_struct.field("rbac_binding_config", &self.rbac_binding_config);
        debug_struct.field("gke_auto_upgrade_config", &self.gke_auto_upgrade_config);
        debug_struct.field(
            "anonymous_authentication_config",
            &self.anonymous_authentication_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Cluster].
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// The current status of the cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Not set.
        Unspecified,
        /// The PROVISIONING state indicates the cluster is being created.
        Provisioning,
        /// The RUNNING state indicates the cluster has been created and is fully
        /// usable.
        Running,
        /// The RECONCILING state indicates that some work is actively being done on
        /// the cluster, such as upgrading the master or node software. Details can
        /// be found in the `statusMessage` field.
        Reconciling,
        /// The STOPPING state indicates the cluster is being deleted.
        Stopping,
        /// The ERROR state indicates the cluster is unusable. It will be
        /// automatically deleted. Details can be found in the `statusMessage` field.
        Error,
        /// The DEGRADED state indicates the cluster requires user action to restore
        /// full functionality. Details can be found in the `statusMessage` field.
        Degraded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Reconciling => std::option::Option::Some(3),
                Self::Stopping => std::option::Option::Some(4),
                Self::Error => std::option::Option::Some(5),
                Self::Degraded => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Degraded => std::option::Option::Some("DEGRADED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::Reconciling,
                4 => Self::Stopping,
                5 => Self::Error,
                6 => Self::Degraded,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "RECONCILING" => Self::Reconciling,
                "STOPPING" => Self::Stopping,
                "ERROR" => Self::Error,
                "DEGRADED" => Self::Degraded,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Reconciling => serializer.serialize_i32(3),
                Self::Stopping => serializer.serialize_i32(4),
                Self::Error => serializer.serialize_i32(5),
                Self::Degraded => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.container.v1.Cluster.Status",
            ))
        }
    }
}

/// RBACBindingConfig allows user to restrict ClusterRoleBindings an RoleBindings
/// that can be created.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RBACBindingConfig {
    /// Setting this to true will allow any ClusterRoleBinding and RoleBinding
    /// with subjets system:anonymous or system:unauthenticated.
    pub enable_insecure_binding_system_unauthenticated: std::option::Option<bool>,

    /// Setting this to true will allow any ClusterRoleBinding and RoleBinding
    /// with subjects system:authenticated.
    pub enable_insecure_binding_system_authenticated: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RBACBindingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_insecure_binding_system_unauthenticated][crate::model::RBACBindingConfig::enable_insecure_binding_system_unauthenticated].
    pub fn set_enable_insecure_binding_system_unauthenticated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_insecure_binding_system_unauthenticated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_insecure_binding_system_unauthenticated][crate::model::RBACBindingConfig::enable_insecure_binding_system_unauthenticated].
    pub fn set_or_clear_enable_insecure_binding_system_unauthenticated<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_insecure_binding_system_unauthenticated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_insecure_binding_system_authenticated][crate::model::RBACBindingConfig::enable_insecure_binding_system_authenticated].
    pub fn set_enable_insecure_binding_system_authenticated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_insecure_binding_system_authenticated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_insecure_binding_system_authenticated][crate::model::RBACBindingConfig::enable_insecure_binding_system_authenticated].
    pub fn set_or_clear_enable_insecure_binding_system_authenticated<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_insecure_binding_system_authenticated = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RBACBindingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RBACBindingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RBACBindingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_insecure_binding_system_unauthenticated,
            __enable_insecure_binding_system_authenticated,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RBACBindingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableInsecureBindingSystemUnauthenticated" => {
                                Ok(__FieldTag::__enable_insecure_binding_system_unauthenticated)
                            }
                            "enable_insecure_binding_system_unauthenticated" => {
                                Ok(__FieldTag::__enable_insecure_binding_system_unauthenticated)
                            }
                            "enableInsecureBindingSystemAuthenticated" => {
                                Ok(__FieldTag::__enable_insecure_binding_system_authenticated)
                            }
                            "enable_insecure_binding_system_authenticated" => {
                                Ok(__FieldTag::__enable_insecure_binding_system_authenticated)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RBACBindingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RBACBindingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_insecure_binding_system_unauthenticated => {
                            if !fields.insert(
                                __FieldTag::__enable_insecure_binding_system_unauthenticated,
                            ) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_insecure_binding_system_unauthenticated",
                                ));
                            }
                            result.enable_insecure_binding_system_unauthenticated =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__enable_insecure_binding_system_authenticated => {
                            if !fields
                                .insert(__FieldTag::__enable_insecure_binding_system_authenticated)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_insecure_binding_system_authenticated",
                                ));
                            }
                            result.enable_insecure_binding_system_authenticated =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RBACBindingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self
            .enable_insecure_binding_system_unauthenticated
            .is_some()
        {
            state.serialize_entry(
                "enableInsecureBindingSystemUnauthenticated",
                &self.enable_insecure_binding_system_unauthenticated,
            )?;
        }
        if self.enable_insecure_binding_system_authenticated.is_some() {
            state.serialize_entry(
                "enableInsecureBindingSystemAuthenticated",
                &self.enable_insecure_binding_system_authenticated,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RBACBindingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RBACBindingConfig");
        debug_struct.field(
            "enable_insecure_binding_system_unauthenticated",
            &self.enable_insecure_binding_system_unauthenticated,
        );
        debug_struct.field(
            "enable_insecure_binding_system_authenticated",
            &self.enable_insecure_binding_system_authenticated,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UserManagedKeysConfig holds the resource address to Keys which are used
/// for signing certs and token that are used for communication within cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UserManagedKeysConfig {
    /// The Certificate Authority Service caPool to use for the cluster CA in this
    /// cluster.
    pub cluster_ca: std::string::String,

    /// Resource path of the Certificate Authority Service caPool to use for the
    /// etcd API CA in this cluster.
    pub etcd_api_ca: std::string::String,

    /// Resource path of the Certificate Authority Service caPool to use for the
    /// etcd peer CA in this cluster.
    pub etcd_peer_ca: std::string::String,

    /// The Cloud KMS cryptoKeyVersions to use for signing service account JWTs
    /// issued by this cluster.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{cryptoKey}/cryptoKeyVersions/{cryptoKeyVersion}`
    pub service_account_signing_keys: std::vec::Vec<std::string::String>,

    /// The Cloud KMS cryptoKeyVersions to use for verifying service account JWTs
    /// issued by this cluster.
    ///
    /// Format:
    /// `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{cryptoKey}/cryptoKeyVersions/{cryptoKeyVersion}`
    pub service_account_verification_keys: std::vec::Vec<std::string::String>,

    /// The Certificate Authority Service caPool to use for the aggregation CA in
    /// this cluster.
    pub aggregation_ca: std::string::String,

    /// The Cloud KMS cryptoKey to use for Confidential Hyperdisk on the control
    /// plane nodes.
    pub control_plane_disk_encryption_key: std::string::String,

    /// Resource path of the Cloud KMS cryptoKey to use for encryption of internal
    /// etcd backups.
    pub gkeops_etcd_backup_encryption_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserManagedKeysConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_ca][crate::model::UserManagedKeysConfig::cluster_ca].
    pub fn set_cluster_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_ca = v.into();
        self
    }

    /// Sets the value of [etcd_api_ca][crate::model::UserManagedKeysConfig::etcd_api_ca].
    pub fn set_etcd_api_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etcd_api_ca = v.into();
        self
    }

    /// Sets the value of [etcd_peer_ca][crate::model::UserManagedKeysConfig::etcd_peer_ca].
    pub fn set_etcd_peer_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etcd_peer_ca = v.into();
        self
    }

    /// Sets the value of [service_account_signing_keys][crate::model::UserManagedKeysConfig::service_account_signing_keys].
    pub fn set_service_account_signing_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_account_signing_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account_verification_keys][crate::model::UserManagedKeysConfig::service_account_verification_keys].
    pub fn set_service_account_verification_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_account_verification_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [aggregation_ca][crate::model::UserManagedKeysConfig::aggregation_ca].
    pub fn set_aggregation_ca<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aggregation_ca = v.into();
        self
    }

    /// Sets the value of [control_plane_disk_encryption_key][crate::model::UserManagedKeysConfig::control_plane_disk_encryption_key].
    pub fn set_control_plane_disk_encryption_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_disk_encryption_key = v.into();
        self
    }

    /// Sets the value of [gkeops_etcd_backup_encryption_key][crate::model::UserManagedKeysConfig::gkeops_etcd_backup_encryption_key].
    pub fn set_gkeops_etcd_backup_encryption_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gkeops_etcd_backup_encryption_key = v.into();
        self
    }
}

impl wkt::message::Message for UserManagedKeysConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UserManagedKeysConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UserManagedKeysConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_ca,
            __etcd_api_ca,
            __etcd_peer_ca,
            __service_account_signing_keys,
            __service_account_verification_keys,
            __aggregation_ca,
            __control_plane_disk_encryption_key,
            __gkeops_etcd_backup_encryption_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserManagedKeysConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterCa" => Ok(__FieldTag::__cluster_ca),
                            "cluster_ca" => Ok(__FieldTag::__cluster_ca),
                            "etcdApiCa" => Ok(__FieldTag::__etcd_api_ca),
                            "etcd_api_ca" => Ok(__FieldTag::__etcd_api_ca),
                            "etcdPeerCa" => Ok(__FieldTag::__etcd_peer_ca),
                            "etcd_peer_ca" => Ok(__FieldTag::__etcd_peer_ca),
                            "serviceAccountSigningKeys" => {
                                Ok(__FieldTag::__service_account_signing_keys)
                            }
                            "service_account_signing_keys" => {
                                Ok(__FieldTag::__service_account_signing_keys)
                            }
                            "serviceAccountVerificationKeys" => {
                                Ok(__FieldTag::__service_account_verification_keys)
                            }
                            "service_account_verification_keys" => {
                                Ok(__FieldTag::__service_account_verification_keys)
                            }
                            "aggregationCa" => Ok(__FieldTag::__aggregation_ca),
                            "aggregation_ca" => Ok(__FieldTag::__aggregation_ca),
                            "controlPlaneDiskEncryptionKey" => {
                                Ok(__FieldTag::__control_plane_disk_encryption_key)
                            }
                            "control_plane_disk_encryption_key" => {
                                Ok(__FieldTag::__control_plane_disk_encryption_key)
                            }
                            "gkeopsEtcdBackupEncryptionKey" => {
                                Ok(__FieldTag::__gkeops_etcd_backup_encryption_key)
                            }
                            "gkeops_etcd_backup_encryption_key" => {
                                Ok(__FieldTag::__gkeops_etcd_backup_encryption_key)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UserManagedKeysConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserManagedKeysConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_ca => {
                            if !fields.insert(__FieldTag::__cluster_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ca",
                                ));
                            }
                            result.cluster_ca = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etcd_api_ca => {
                            if !fields.insert(__FieldTag::__etcd_api_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etcd_api_ca",
                                ));
                            }
                            result.etcd_api_ca = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etcd_peer_ca => {
                            if !fields.insert(__FieldTag::__etcd_peer_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etcd_peer_ca",
                                ));
                            }
                            result.etcd_peer_ca = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_signing_keys => {
                            if !fields.insert(__FieldTag::__service_account_signing_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_signing_keys",
                                ));
                            }
                            result.service_account_signing_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_account_verification_keys => {
                            if !fields.insert(__FieldTag::__service_account_verification_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_verification_keys",
                                ));
                            }
                            result.service_account_verification_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__aggregation_ca => {
                            if !fields.insert(__FieldTag::__aggregation_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation_ca",
                                ));
                            }
                            result.aggregation_ca = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_plane_disk_encryption_key => {
                            if !fields.insert(__FieldTag::__control_plane_disk_encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane_disk_encryption_key",
                                ));
                            }
                            result.control_plane_disk_encryption_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gkeops_etcd_backup_encryption_key => {
                            if !fields.insert(__FieldTag::__gkeops_etcd_backup_encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gkeops_etcd_backup_encryption_key",
                                ));
                            }
                            result.gkeops_etcd_backup_encryption_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UserManagedKeysConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster_ca.is_empty() {
            state.serialize_entry("clusterCa", &self.cluster_ca)?;
        }
        if !self.etcd_api_ca.is_empty() {
            state.serialize_entry("etcdApiCa", &self.etcd_api_ca)?;
        }
        if !self.etcd_peer_ca.is_empty() {
            state.serialize_entry("etcdPeerCa", &self.etcd_peer_ca)?;
        }
        if !self.service_account_signing_keys.is_empty() {
            state.serialize_entry(
                "serviceAccountSigningKeys",
                &self.service_account_signing_keys,
            )?;
        }
        if !self.service_account_verification_keys.is_empty() {
            state.serialize_entry(
                "serviceAccountVerificationKeys",
                &self.service_account_verification_keys,
            )?;
        }
        if !self.aggregation_ca.is_empty() {
            state.serialize_entry("aggregationCa", &self.aggregation_ca)?;
        }
        if !self.control_plane_disk_encryption_key.is_empty() {
            state.serialize_entry(
                "controlPlaneDiskEncryptionKey",
                &self.control_plane_disk_encryption_key,
            )?;
        }
        if !self.gkeops_etcd_backup_encryption_key.is_empty() {
            state.serialize_entry(
                "gkeopsEtcdBackupEncryptionKey",
                &self.gkeops_etcd_backup_encryption_key,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UserManagedKeysConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserManagedKeysConfig");
        debug_struct.field("cluster_ca", &self.cluster_ca);
        debug_struct.field("etcd_api_ca", &self.etcd_api_ca);
        debug_struct.field("etcd_peer_ca", &self.etcd_peer_ca);
        debug_struct.field(
            "service_account_signing_keys",
            &self.service_account_signing_keys,
        );
        debug_struct.field(
            "service_account_verification_keys",
            &self.service_account_verification_keys,
        );
        debug_struct.field("aggregation_ca", &self.aggregation_ca);
        debug_struct.field(
            "control_plane_disk_encryption_key",
            &self.control_plane_disk_encryption_key,
        );
        debug_struct.field(
            "gkeops_etcd_backup_encryption_key",
            &self.gkeops_etcd_backup_encryption_key,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AnonymousAuthenticationConfig defines the settings needed to limit endpoints
/// that allow anonymous authentication.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AnonymousAuthenticationConfig {
    /// Defines the mode of limiting anonymous access in the cluster.
    pub mode: crate::model::anonymous_authentication_config::Mode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AnonymousAuthenticationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::AnonymousAuthenticationConfig::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::anonymous_authentication_config::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for AnonymousAuthenticationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AnonymousAuthenticationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AnonymousAuthenticationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnonymousAuthenticationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AnonymousAuthenticationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnonymousAuthenticationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<
                                    crate::model::anonymous_authentication_config::Mode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AnonymousAuthenticationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AnonymousAuthenticationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnonymousAuthenticationConfig");
        debug_struct.field("mode", &self.mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AnonymousAuthenticationConfig].
pub mod anonymous_authentication_config {
    #[allow(unused_imports)]
    use super::*;

    /// Mode defines the mode of anonymous authentication
    /// allowed in the cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Default value not specified.
        Unspecified,
        /// Anonymous authentication is allowed for all endpoints.
        Enabled,
        /// Anonymous authentication is allowed for only health check endpoints.
        Limited,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::Limited => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::Limited => std::option::Option::Some("LIMITED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::Limited,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "LIMITED" => Self::Limited,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::Limited => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.container.v1.AnonymousAuthenticationConfig.Mode",
            ))
        }
    }
}

/// CompliancePostureConfig defines the settings needed to enable/disable
/// features for the Compliance Posture.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompliancePostureConfig {
    /// Defines the enablement mode for Compliance Posture.
    pub mode: std::option::Option<crate::model::compliance_posture_config::Mode>,

    /// List of enabled compliance standards.
    pub compliance_standards:
        std::vec::Vec<crate::model::compliance_posture_config::ComplianceStandard>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompliancePostureConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::CompliancePostureConfig::mode].
    pub fn set_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::compliance_posture_config::Mode>,
    {
        self.mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mode][crate::model::CompliancePostureConfig::mode].
    pub fn set_or_clear_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::compliance_posture_config::Mode>,
    {
        self.mode = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compliance_standards][crate::model::CompliancePostureConfig::compliance_standards].
    pub fn set_compliance_standards<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::compliance_posture_config::ComplianceStandard>,
    {
        use std::iter::Iterator;
        self.compliance_standards = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CompliancePostureConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CompliancePostureConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompliancePostureConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __compliance_standards,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompliancePostureConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "complianceStandards" => Ok(__FieldTag::__compliance_standards),
                            "compliance_standards" => Ok(__FieldTag::__compliance_standards),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompliancePostureConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompliancePostureConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<
                                crate::model::compliance_posture_config::Mode,
                            >>()?;
                        }
                        __FieldTag::__compliance_standards => {
                            if !fields.insert(__FieldTag::__compliance_standards) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance_standards",
                                ));
                            }
                            result.compliance_standards = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::compliance_posture_config::ComplianceStandard,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompliancePostureConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self.compliance_standards.is_empty() {
            state.serialize_entry("complianceStandards", &self.compliance_standards)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompliancePostureConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompliancePostureConfig");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("compliance_standards", &self.compliance_standards);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CompliancePostureConfig].
pub mod compliance_posture_config {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the details of a compliance standard.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ComplianceStandard {
        /// Name of the compliance standard.
        pub standard: std::option::Option<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ComplianceStandard {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [standard][crate::model::compliance_posture_config::ComplianceStandard::standard].
        pub fn set_standard<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.standard = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [standard][crate::model::compliance_posture_config::ComplianceStandard::standard].
        pub fn set_or_clear_standard<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.standard = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ComplianceStandard {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.CompliancePostureConfig.ComplianceStandard"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ComplianceStandard {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __standard,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ComplianceStandard")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "standard" => Ok(__FieldTag::__standard),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ComplianceStandard;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ComplianceStandard")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__standard => {
                                if !fields.insert(__FieldTag::__standard) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for standard",
                                    ));
                                }
                                result.standard =
                                    map.next_value::<std::option::Option<std::string::String>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ComplianceStandard {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.standard.is_some() {
                state.serialize_entry("standard", &self.standard)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ComplianceStandard {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ComplianceStandard");
            debug_struct.field("standard", &self.standard);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Mode defines enablement mode for Compliance Posture.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Default value not specified.
        Unspecified,
        /// Disables Compliance Posture features on the cluster.
        Disabled,
        /// Enables Compliance Posture features on the cluster.
        Enabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Enabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Enabled,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "ENABLED" => Self::Enabled,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Enabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.container.v1.CompliancePostureConfig.Mode",
            ))
        }
    }
}

/// K8sBetaAPIConfig , configuration for beta APIs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct K8sBetaAPIConfig {
    /// Enabled k8s beta APIs.
    pub enabled_apis: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl K8sBetaAPIConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled_apis][crate::model::K8sBetaAPIConfig::enabled_apis].
    pub fn set_enabled_apis<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.enabled_apis = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for K8sBetaAPIConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.K8sBetaAPIConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for K8sBetaAPIConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled_apis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for K8sBetaAPIConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabledApis" => Ok(__FieldTag::__enabled_apis),
                            "enabled_apis" => Ok(__FieldTag::__enabled_apis),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = K8sBetaAPIConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct K8sBetaAPIConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled_apis => {
                            if !fields.insert(__FieldTag::__enabled_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled_apis",
                                ));
                            }
                            result.enabled_apis = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for K8sBetaAPIConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.enabled_apis.is_empty() {
            state.serialize_entry("enabledApis", &self.enabled_apis)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for K8sBetaAPIConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("K8sBetaAPIConfig");
        debug_struct.field("enabled_apis", &self.enabled_apis);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SecurityPostureConfig defines the flags needed to enable/disable features for
/// the Security Posture API.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecurityPostureConfig {
    /// Sets which mode to use for Security Posture features.
    pub mode: std::option::Option<crate::model::security_posture_config::Mode>,

    /// Sets which mode to use for vulnerability scanning.
    pub vulnerability_mode:
        std::option::Option<crate::model::security_posture_config::VulnerabilityMode>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityPostureConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::SecurityPostureConfig::mode].
    pub fn set_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::security_posture_config::Mode>,
    {
        self.mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mode][crate::model::SecurityPostureConfig::mode].
    pub fn set_or_clear_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::security_posture_config::Mode>,
    {
        self.mode = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vulnerability_mode][crate::model::SecurityPostureConfig::vulnerability_mode].
    pub fn set_vulnerability_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::security_posture_config::VulnerabilityMode>,
    {
        self.vulnerability_mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vulnerability_mode][crate::model::SecurityPostureConfig::vulnerability_mode].
    pub fn set_or_clear_vulnerability_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::security_posture_config::VulnerabilityMode>,
    {
        self.vulnerability_mode = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SecurityPostureConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SecurityPostureConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecurityPostureConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __vulnerability_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecurityPostureConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "vulnerabilityMode" => Ok(__FieldTag::__vulnerability_mode),
                            "vulnerability_mode" => Ok(__FieldTag::__vulnerability_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecurityPostureConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecurityPostureConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode =
                                map.next_value::<std::option::Option<
                                    crate::model::security_posture_config::Mode,
                                >>()?;
                        }
                        __FieldTag::__vulnerability_mode => {
                            if !fields.insert(__FieldTag::__vulnerability_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability_mode",
                                ));
                            }
                            result.vulnerability_mode = map.next_value::<std::option::Option<
                                crate::model::security_posture_config::VulnerabilityMode,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecurityPostureConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.vulnerability_mode.is_some() {
            state.serialize_entry("vulnerabilityMode", &self.vulnerability_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SecurityPostureConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecurityPostureConfig");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("vulnerability_mode", &self.vulnerability_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SecurityPostureConfig].
pub mod security_posture_config {
    #[allow(unused_imports)]
    use super::*;

    /// Mode defines enablement mode for GKE Security posture features.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Default value not specified.
        Unspecified,
        /// Disables Security Posture features on the cluster.
        Disabled,
        /// Applies Security Posture features on the cluster.
        Basic,
        /// Applies the Security Posture off cluster Enterprise level features.
        Enterprise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Basic => std::option::Option::Some(2),
                Self::Enterprise => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Basic,
                3 => Self::Enterprise,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "BASIC" => Self::Basic,
                "ENTERPRISE" => Self::Enterprise,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Basic => serializer.serialize_i32(2),
                Self::Enterprise => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.container.v1.SecurityPostureConfig.Mode",
            ))
        }
    }

    /// VulnerabilityMode defines enablement mode for vulnerability scanning.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VulnerabilityMode {
        /// Default value not specified.
        Unspecified,
        /// Disables vulnerability scanning on the cluster.
        VulnerabilityDisabled,
        /// Applies basic vulnerability scanning on the cluster.
        VulnerabilityBasic,
        /// Applies the Security Posture's vulnerability on cluster Enterprise level
        /// features.
        VulnerabilityEnterprise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VulnerabilityMode::value] or
        /// [VulnerabilityMode::name].
        UnknownValue(vulnerability_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vulnerability_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VulnerabilityMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VulnerabilityDisabled => std::option::Option::Some(1),
                Self::VulnerabilityBasic => std::option::Option::Some(2),
                Self::VulnerabilityEnterprise => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VULNERABILITY_MODE_UNSPECIFIED"),
                Self::VulnerabilityDisabled => std::option::Option::Some("VULNERABILITY_DISABLED"),
                Self::VulnerabilityBasic => std::option::Option::Some("VULNERABILITY_BASIC"),
                Self::VulnerabilityEnterprise => {
                    std::option::Option::Some("VULNERABILITY_ENTERPRISE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VulnerabilityMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VulnerabilityMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VulnerabilityMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VulnerabilityDisabled,
                2 => Self::VulnerabilityBasic,
                3 => Self::VulnerabilityEnterprise,
                _ => Self::UnknownValue(vulnerability_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VulnerabilityMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VULNERABILITY_MODE_UNSPECIFIED" => Self::Unspecified,
                "VULNERABILITY_DISABLED" => Self::VulnerabilityDisabled,
                "VULNERABILITY_BASIC" => Self::VulnerabilityBasic,
                "VULNERABILITY_ENTERPRISE" => Self::VulnerabilityEnterprise,
                _ => Self::UnknownValue(vulnerability_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VulnerabilityMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VulnerabilityDisabled => serializer.serialize_i32(1),
                Self::VulnerabilityBasic => serializer.serialize_i32(2),
                Self::VulnerabilityEnterprise => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VulnerabilityMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VulnerabilityMode>::new(
                ".google.container.v1.SecurityPostureConfig.VulnerabilityMode",
            ))
        }
    }
}

/// Node pool configs that apply to all auto-provisioned node pools
/// in autopilot clusters and node auto-provisioning enabled clusters.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodePoolAutoConfig {
    /// The list of instance tags applied to all nodes. Tags are used to identify
    /// valid sources or targets for network firewalls and are specified by
    /// the client during cluster creation. Each tag within the list
    /// must comply with RFC1035.
    pub network_tags: std::option::Option<crate::model::NetworkTags>,

    /// Resource manager tag keys and values to be attached to the nodes
    /// for managing Compute Engine firewalls using Network Firewall Policies.
    pub resource_manager_tags: std::option::Option<crate::model::ResourceManagerTags>,

    /// NodeKubeletConfig controls the defaults for autoprovisioned node-pools.
    ///
    /// Currently only `insecure_kubelet_readonly_port_enabled` can be set here.
    pub node_kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    /// Output only. Configuration options for Linux nodes.
    pub linux_node_config: std::option::Option<crate::model::LinuxNodeConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePoolAutoConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_tags][crate::model::NodePoolAutoConfig::network_tags].
    pub fn set_network_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkTags>,
    {
        self.network_tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_tags][crate::model::NodePoolAutoConfig::network_tags].
    pub fn set_or_clear_network_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkTags>,
    {
        self.network_tags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::NodePoolAutoConfig::resource_manager_tags].
    pub fn set_resource_manager_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceManagerTags>,
    {
        self.resource_manager_tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_manager_tags][crate::model::NodePoolAutoConfig::resource_manager_tags].
    pub fn set_or_clear_resource_manager_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceManagerTags>,
    {
        self.resource_manager_tags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_kubelet_config][crate::model::NodePoolAutoConfig::node_kubelet_config].
    pub fn set_node_kubelet_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.node_kubelet_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_kubelet_config][crate::model::NodePoolAutoConfig::node_kubelet_config].
    pub fn set_or_clear_node_kubelet_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.node_kubelet_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [linux_node_config][crate::model::NodePoolAutoConfig::linux_node_config].
    pub fn set_linux_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LinuxNodeConfig>,
    {
        self.linux_node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [linux_node_config][crate::model::NodePoolAutoConfig::linux_node_config].
    pub fn set_or_clear_linux_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LinuxNodeConfig>,
    {
        self.linux_node_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodePoolAutoConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodePoolAutoConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodePoolAutoConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network_tags,
            __resource_manager_tags,
            __node_kubelet_config,
            __linux_node_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePoolAutoConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "resourceManagerTags" => Ok(__FieldTag::__resource_manager_tags),
                            "resource_manager_tags" => Ok(__FieldTag::__resource_manager_tags),
                            "nodeKubeletConfig" => Ok(__FieldTag::__node_kubelet_config),
                            "node_kubelet_config" => Ok(__FieldTag::__node_kubelet_config),
                            "linuxNodeConfig" => Ok(__FieldTag::__linux_node_config),
                            "linux_node_config" => Ok(__FieldTag::__linux_node_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodePoolAutoConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePoolAutoConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tags",
                                ));
                            }
                            result.network_tags =
                                map.next_value::<std::option::Option<crate::model::NetworkTags>>()?;
                        }
                        __FieldTag::__resource_manager_tags => {
                            if !fields.insert(__FieldTag::__resource_manager_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_manager_tags",
                                ));
                            }
                            result.resource_manager_tags = map.next_value::<std::option::Option<crate::model::ResourceManagerTags>>()?
                                ;
                        }
                        __FieldTag::__node_kubelet_config => {
                            if !fields.insert(__FieldTag::__node_kubelet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_kubelet_config",
                                ));
                            }
                            result.node_kubelet_config = map
                                .next_value::<std::option::Option<crate::model::NodeKubeletConfig>>(
                                )?;
                        }
                        __FieldTag::__linux_node_config => {
                            if !fields.insert(__FieldTag::__linux_node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linux_node_config",
                                ));
                            }
                            result.linux_node_config = map
                                .next_value::<std::option::Option<crate::model::LinuxNodeConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodePoolAutoConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.network_tags.is_some() {
            state.serialize_entry("networkTags", &self.network_tags)?;
        }
        if self.resource_manager_tags.is_some() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if self.node_kubelet_config.is_some() {
            state.serialize_entry("nodeKubeletConfig", &self.node_kubelet_config)?;
        }
        if self.linux_node_config.is_some() {
            state.serialize_entry("linuxNodeConfig", &self.linux_node_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodePoolAutoConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePoolAutoConfig");
        debug_struct.field("network_tags", &self.network_tags);
        debug_struct.field("resource_manager_tags", &self.resource_manager_tags);
        debug_struct.field("node_kubelet_config", &self.node_kubelet_config);
        debug_struct.field("linux_node_config", &self.linux_node_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Subset of Nodepool message that has defaults.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodePoolDefaults {
    /// Subset of NodeConfig message that has defaults.
    pub node_config_defaults: std::option::Option<crate::model::NodeConfigDefaults>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePoolDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_config_defaults][crate::model::NodePoolDefaults::node_config_defaults].
    pub fn set_node_config_defaults<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfigDefaults>,
    {
        self.node_config_defaults = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_config_defaults][crate::model::NodePoolDefaults::node_config_defaults].
    pub fn set_or_clear_node_config_defaults<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfigDefaults>,
    {
        self.node_config_defaults = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodePoolDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodePoolDefaults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodePoolDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_config_defaults,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePoolDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodeConfigDefaults" => Ok(__FieldTag::__node_config_defaults),
                            "node_config_defaults" => Ok(__FieldTag::__node_config_defaults),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodePoolDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePoolDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_config_defaults => {
                            if !fields.insert(__FieldTag::__node_config_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_config_defaults",
                                ));
                            }
                            result.node_config_defaults = map.next_value::<std::option::Option<crate::model::NodeConfigDefaults>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodePoolDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.node_config_defaults.is_some() {
            state.serialize_entry("nodeConfigDefaults", &self.node_config_defaults)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodePoolDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePoolDefaults");
        debug_struct.field("node_config_defaults", &self.node_config_defaults);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Subset of NodeConfig message that has defaults.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeConfigDefaults {
    /// GCFS (Google Container File System, also known as Riptide) options.
    pub gcfs_config: std::option::Option<crate::model::GcfsConfig>,

    /// Logging configuration for node pools.
    pub logging_config: std::option::Option<crate::model::NodePoolLoggingConfig>,

    /// Parameters for containerd customization.
    pub containerd_config: std::option::Option<crate::model::ContainerdConfig>,

    /// NodeKubeletConfig controls the defaults for new node-pools.
    ///
    /// Currently only `insecure_kubelet_readonly_port_enabled` can be set here.
    pub node_kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeConfigDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcfs_config][crate::model::NodeConfigDefaults::gcfs_config].
    pub fn set_gcfs_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcfsConfig>,
    {
        self.gcfs_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcfs_config][crate::model::NodeConfigDefaults::gcfs_config].
    pub fn set_or_clear_gcfs_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcfsConfig>,
    {
        self.gcfs_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::NodeConfigDefaults::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolLoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::NodeConfigDefaults::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolLoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [containerd_config][crate::model::NodeConfigDefaults::containerd_config].
    pub fn set_containerd_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContainerdConfig>,
    {
        self.containerd_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [containerd_config][crate::model::NodeConfigDefaults::containerd_config].
    pub fn set_or_clear_containerd_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContainerdConfig>,
    {
        self.containerd_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_kubelet_config][crate::model::NodeConfigDefaults::node_kubelet_config].
    pub fn set_node_kubelet_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.node_kubelet_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_kubelet_config][crate::model::NodeConfigDefaults::node_kubelet_config].
    pub fn set_or_clear_node_kubelet_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.node_kubelet_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodeConfigDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeConfigDefaults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeConfigDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcfs_config,
            __logging_config,
            __containerd_config,
            __node_kubelet_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeConfigDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcfsConfig" => Ok(__FieldTag::__gcfs_config),
                            "gcfs_config" => Ok(__FieldTag::__gcfs_config),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "containerdConfig" => Ok(__FieldTag::__containerd_config),
                            "containerd_config" => Ok(__FieldTag::__containerd_config),
                            "nodeKubeletConfig" => Ok(__FieldTag::__node_kubelet_config),
                            "node_kubelet_config" => Ok(__FieldTag::__node_kubelet_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeConfigDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeConfigDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcfs_config => {
                            if !fields.insert(__FieldTag::__gcfs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcfs_config",
                                ));
                            }
                            result.gcfs_config =
                                map.next_value::<std::option::Option<crate::model::GcfsConfig>>()?;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map.next_value::<std::option::Option<crate::model::NodePoolLoggingConfig>>()?
                                ;
                        }
                        __FieldTag::__containerd_config => {
                            if !fields.insert(__FieldTag::__containerd_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containerd_config",
                                ));
                            }
                            result.containerd_config = map
                                .next_value::<std::option::Option<crate::model::ContainerdConfig>>(
                                )?;
                        }
                        __FieldTag::__node_kubelet_config => {
                            if !fields.insert(__FieldTag::__node_kubelet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_kubelet_config",
                                ));
                            }
                            result.node_kubelet_config = map
                                .next_value::<std::option::Option<crate::model::NodeKubeletConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeConfigDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.gcfs_config.is_some() {
            state.serialize_entry("gcfsConfig", &self.gcfs_config)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.containerd_config.is_some() {
            state.serialize_entry("containerdConfig", &self.containerd_config)?;
        }
        if self.node_kubelet_config.is_some() {
            state.serialize_entry("nodeKubeletConfig", &self.node_kubelet_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodeConfigDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeConfigDefaults");
        debug_struct.field("gcfs_config", &self.gcfs_config);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("containerd_config", &self.containerd_config);
        debug_struct.field("node_kubelet_config", &self.node_kubelet_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ClusterUpdate describes an update to the cluster. Exactly one update can
/// be applied to a cluster with each request, so at most one field can be
/// provided.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterUpdate {
    /// The Kubernetes version to change the nodes to (typically an
    /// upgrade).
    ///
    /// Users may specify either explicit versions offered by
    /// Kubernetes Engine or version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the Kubernetes master version
    pub desired_node_version: std::string::String,

    /// The monitoring service the cluster should use to write metrics.
    /// Currently available options:
    ///
    /// * `monitoring.googleapis.com/kubernetes` - The Cloud Monitoring
    ///   service with a Kubernetes-native resource model
    /// * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
    ///   longer available as of GKE 1.15).
    /// * `none` - No metrics will be exported from the cluster.
    ///
    /// If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
    pub desired_monitoring_service: std::string::String,

    /// Configurations for the various addons available to run in the cluster.
    pub desired_addons_config: std::option::Option<crate::model::AddonsConfig>,

    /// The node pool to be upgraded. This field is mandatory if
    /// "desired_node_version", "desired_image_family" or
    /// "desired_node_pool_autoscaling" is specified and there is more than one
    /// node pool on the cluster.
    pub desired_node_pool_id: std::string::String,

    /// The desired image type for the node pool.
    /// NOTE: Set the "desired_node_pool" field as well.
    pub desired_image_type: std::string::String,

    /// Configuration of etcd encryption.
    pub desired_database_encryption: std::option::Option<crate::model::DatabaseEncryption>,

    /// Configuration for Workload Identity.
    pub desired_workload_identity_config: std::option::Option<crate::model::WorkloadIdentityConfig>,

    /// Configuration for issuance of mTLS keys and certificates to Kubernetes
    /// pods.
    pub desired_mesh_certificates: std::option::Option<crate::model::MeshCertificates>,

    /// Configuration for Shielded Nodes.
    pub desired_shielded_nodes: std::option::Option<crate::model::ShieldedNodes>,

    /// The desired configuration for the fine-grained cost management feature.
    pub desired_cost_management_config: std::option::Option<crate::model::CostManagementConfig>,

    /// DNSConfig contains clusterDNS config for this cluster.
    pub desired_dns_config: std::option::Option<crate::model::DNSConfig>,

    /// Autoscaler configuration for the node pool specified in
    /// desired_node_pool_id. If there is only one pool in the
    /// cluster and desired_node_pool_id is not provided then
    /// the change applies to that single node pool.
    pub desired_node_pool_autoscaling: std::option::Option<crate::model::NodePoolAutoscaling>,

    /// The desired list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster's nodes should be located.
    ///
    /// This list must always include the cluster's primary zone.
    ///
    /// Warning: changing cluster locations will update the locations of all node
    /// pools and will result in nodes being added and/or removed.
    pub desired_locations: std::vec::Vec<std::string::String>,

    /// The desired configuration options for master authorized networks feature.
    ///
    /// Deprecated: Use
    /// desired_control_plane_endpoints_config.ip_endpoints_config.authorized_networks_config
    /// instead.
    #[deprecated]
    pub desired_master_authorized_networks_config:
        std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,

    /// Cluster-level autoscaling configuration.
    pub desired_cluster_autoscaling: std::option::Option<crate::model::ClusterAutoscaling>,

    /// The desired configuration options for the Binary Authorization feature.
    pub desired_binary_authorization: std::option::Option<crate::model::BinaryAuthorization>,

    /// The logging service the cluster should use to write logs.
    /// Currently available options:
    ///
    /// * `logging.googleapis.com/kubernetes` - The Cloud Logging
    ///   service with a Kubernetes-native resource model
    /// * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
    ///   available as of GKE 1.15).
    /// * `none` - no logs will be exported from the cluster.
    ///
    /// If left as an empty string,`logging.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
    pub desired_logging_service: std::string::String,

    /// The desired configuration for exporting resource usage.
    pub desired_resource_usage_export_config:
        std::option::Option<crate::model::ResourceUsageExportConfig>,

    /// Cluster-level Vertical Pod Autoscaling configuration.
    pub desired_vertical_pod_autoscaling: std::option::Option<crate::model::VerticalPodAutoscaling>,

    /// The desired private cluster configuration. master_global_access_config is
    /// the only field that can be changed via this field.
    /// See also
    /// [ClusterUpdate.desired_enable_private_endpoint][google.container.v1.ClusterUpdate.desired_enable_private_endpoint]
    /// for modifying other fields within
    /// [PrivateClusterConfig][google.container.v1.PrivateClusterConfig].
    ///
    /// Deprecated: Use
    /// desired_control_plane_endpoints_config.ip_endpoints_config.global_access
    /// instead.
    ///
    /// [google.container.v1.ClusterUpdate.desired_enable_private_endpoint]: crate::model::ClusterUpdate::desired_enable_private_endpoint
    /// [google.container.v1.PrivateClusterConfig]: crate::model::PrivateClusterConfig
    #[deprecated]
    pub desired_private_cluster_config: std::option::Option<crate::model::PrivateClusterConfig>,

    /// The desired config of Intra-node visibility.
    pub desired_intra_node_visibility_config:
        std::option::Option<crate::model::IntraNodeVisibilityConfig>,

    /// The desired status of whether to disable default sNAT for this cluster.
    pub desired_default_snat_status: std::option::Option<crate::model::DefaultSnatStatus>,

    /// The desired release channel configuration.
    pub desired_release_channel: std::option::Option<crate::model::ReleaseChannel>,

    /// The desired L4 Internal Load Balancer Subsetting configuration.
    pub desired_l4ilb_subsetting_config: std::option::Option<crate::model::ILBSubsettingConfig>,

    /// The desired datapath provider for the cluster.
    pub desired_datapath_provider: crate::model::DatapathProvider,

    /// The desired state of IPv6 connectivity to Google Services.
    pub desired_private_ipv6_google_access: crate::model::PrivateIPv6GoogleAccess,

    /// The desired notification configuration.
    pub desired_notification_config: std::option::Option<crate::model::NotificationConfig>,

    /// The desired authenticator groups config for the cluster.
    pub desired_authenticator_groups_config:
        std::option::Option<crate::model::AuthenticatorGroupsConfig>,

    /// The desired logging configuration.
    pub desired_logging_config: std::option::Option<crate::model::LoggingConfig>,

    /// The desired monitoring configuration.
    pub desired_monitoring_config: std::option::Option<crate::model::MonitoringConfig>,

    /// The desired Identity Service component configuration.
    pub desired_identity_service_config: std::option::Option<crate::model::IdentityServiceConfig>,

    /// ServiceExternalIPsConfig specifies the config for the use of Services with
    /// ExternalIPs field.
    pub desired_service_external_ips_config:
        std::option::Option<crate::model::ServiceExternalIPsConfig>,

    /// Enable/Disable private endpoint for the cluster's master.
    ///
    /// Deprecated: Use
    /// desired_control_plane_endpoints_config.ip_endpoints_config.enable_public_endpoint
    /// instead. Note that the value of enable_public_endpoint is reversed: if
    /// enable_private_endpoint is false, then enable_public_endpoint will be true.
    #[deprecated]
    pub desired_enable_private_endpoint: std::option::Option<bool>,

    /// Override the default setting of whether future created
    /// nodes have private IP addresses only, namely
    /// [NetworkConfig.default_enable_private_nodes][google.container.v1.NetworkConfig.default_enable_private_nodes]
    ///
    /// [google.container.v1.NetworkConfig.default_enable_private_nodes]: crate::model::NetworkConfig::default_enable_private_nodes
    pub desired_default_enable_private_nodes: std::option::Option<bool>,

    /// [Control plane
    /// endpoints][google.container.v1.Cluster.control_plane_endpoints_config]
    /// configuration.
    ///
    /// [google.container.v1.Cluster.control_plane_endpoints_config]: crate::model::Cluster::control_plane_endpoints_config
    pub desired_control_plane_endpoints_config:
        std::option::Option<crate::model::ControlPlaneEndpointsConfig>,

    /// The Kubernetes version to change the master to.
    ///
    /// Users may specify either explicit versions offered by
    /// Kubernetes Engine or version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the default Kubernetes version
    pub desired_master_version: std::string::String,

    /// The desired GCFS config for the cluster
    pub desired_gcfs_config: std::option::Option<crate::model::GcfsConfig>,

    /// The desired network tags that apply to all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    pub desired_node_pool_auto_config_network_tags: std::option::Option<crate::model::NetworkTags>,

    /// The desired config for pod autoscaling.
    pub desired_pod_autoscaling: std::option::Option<crate::model::PodAutoscaling>,

    /// The desired config of Gateway API on this cluster.
    pub desired_gateway_api_config: std::option::Option<crate::model::GatewayAPIConfig>,

    /// The current etag of the cluster.
    /// If an etag is provided and does not match the current etag of the cluster,
    /// update will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    /// The desired node pool logging configuration defaults for the cluster.
    pub desired_node_pool_logging_config: std::option::Option<crate::model::NodePoolLoggingConfig>,

    /// The desired fleet configuration for the cluster.
    pub desired_fleet: std::option::Option<crate::model::Fleet>,

    /// The desired stack type of the cluster.
    /// If a stack type is provided and does not match the current stack type of
    /// the cluster, update will attempt to change the stack type to the new type.
    pub desired_stack_type: crate::model::StackType,

    /// The additional pod ranges to be added to the cluster. These pod ranges
    /// can be used by node pools to allocate pod IPs.
    pub additional_pod_ranges_config: std::option::Option<crate::model::AdditionalPodRangesConfig>,

    /// The additional pod ranges that are to be removed from the cluster.
    /// The pod ranges specified here must have been specified earlier in the
    /// 'additional_pod_ranges_config' argument.
    pub removed_additional_pod_ranges_config:
        std::option::Option<crate::model::AdditionalPodRangesConfig>,

    /// Kubernetes open source beta apis enabled on the cluster. Only beta apis
    pub enable_k8s_beta_apis: std::option::Option<crate::model::K8sBetaAPIConfig>,

    /// Enable/Disable Security Posture API features for the cluster.
    pub desired_security_posture_config: std::option::Option<crate::model::SecurityPostureConfig>,

    /// The desired network performance config.
    pub desired_network_performance_config:
        std::option::Option<crate::model::network_config::ClusterNetworkPerformanceConfig>,

    /// Enable/Disable FQDN Network Policy for the cluster.
    pub desired_enable_fqdn_network_policy: std::option::Option<bool>,

    /// WorkloadPolicyConfig is the configuration related to GCW workload policy
    pub desired_autopilot_workload_policy_config:
        std::option::Option<crate::model::WorkloadPolicyConfig>,

    /// Desired Beta APIs to be enabled for cluster.
    pub desired_k8s_beta_apis: std::option::Option<crate::model::K8sBetaAPIConfig>,

    /// The desired containerd config for the cluster.
    pub desired_containerd_config: std::option::Option<crate::model::ContainerdConfig>,

    /// Enable/Disable Multi-Networking for the cluster
    pub desired_enable_multi_networking: std::option::Option<bool>,

    /// The desired resource manager tags that apply to all auto-provisioned node
    /// pools in autopilot clusters and node auto-provisioning enabled clusters.
    pub desired_node_pool_auto_config_resource_manager_tags:
        std::option::Option<crate::model::ResourceManagerTags>,

    /// Specify the details of in-transit encryption.
    pub desired_in_transit_encryption_config:
        std::option::Option<crate::model::InTransitEncryptionConfig>,

    /// Enable/Disable Cilium Clusterwide Network Policy for the cluster.
    pub desired_enable_cilium_clusterwide_network_policy: std::option::Option<bool>,

    /// Enable/Disable Secret Manager Config.
    pub desired_secret_manager_config: std::option::Option<crate::model::SecretManagerConfig>,

    /// Enable/Disable Compliance Posture features for the cluster.
    pub desired_compliance_posture_config:
        std::option::Option<crate::model::CompliancePostureConfig>,

    /// The desired node kubelet config for the cluster.
    pub desired_node_kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    /// The desired node kubelet config for all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    pub desired_node_pool_auto_config_kubelet_config:
        std::option::Option<crate::model::NodeKubeletConfig>,

    /// The Custom keys configuration for the cluster.
    ///
    /// This field is deprecated.
    /// Use
    /// [ClusterUpdate.desired_user_managed_keys_config][google.container.v1.ClusterUpdate.desired_user_managed_keys_config]
    /// instead.
    ///
    /// [google.container.v1.ClusterUpdate.desired_user_managed_keys_config]: crate::model::ClusterUpdate::desired_user_managed_keys_config
    #[deprecated]
    pub user_managed_keys_config: std::option::Option<crate::model::UserManagedKeysConfig>,

    /// RBACBindingConfig allows user to restrict ClusterRoleBindings an
    /// RoleBindings that can be created.
    pub desired_rbac_binding_config: std::option::Option<crate::model::RBACBindingConfig>,

    /// The desired config for additional subnetworks attached to the cluster.
    pub desired_additional_ip_ranges_config:
        std::option::Option<crate::model::DesiredAdditionalIPRangesConfig>,

    /// The desired enterprise configuration for the cluster.
    pub desired_enterprise_config: std::option::Option<crate::model::DesiredEnterpriseConfig>,

    /// AutoIpamConfig contains all information related to Auto IPAM
    pub desired_auto_ipam_config: std::option::Option<crate::model::AutoIpamConfig>,

    /// Enable/Disable L4 LB VPC firewall reconciliation for the cluster.
    pub desired_disable_l4_lb_firewall_reconciliation: std::option::Option<bool>,

    /// The desired Linux node config for all auto-provisioned node pools
    /// in autopilot clusters and node auto-provisioning enabled clusters.
    ///
    /// Currently only `cgroup_mode` can be set here.
    pub desired_node_pool_auto_config_linux_node_config:
        std::option::Option<crate::model::LinuxNodeConfig>,

    /// The desired user managed keys config for the cluster.
    pub desired_user_managed_keys_config: std::option::Option<crate::model::UserManagedKeysConfig>,

    /// Configuration for limiting anonymous access to all endpoints except the
    /// health checks.
    pub desired_anonymous_authentication_config:
        std::option::Option<crate::model::AnonymousAuthenticationConfig>,

    /// Configuration for GKE auto upgrade.
    pub gke_auto_upgrade_config: std::option::Option<crate::model::GkeAutoUpgradeConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterUpdate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [desired_node_version][crate::model::ClusterUpdate::desired_node_version].
    pub fn set_desired_node_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_node_version = v.into();
        self
    }

    /// Sets the value of [desired_monitoring_service][crate::model::ClusterUpdate::desired_monitoring_service].
    pub fn set_desired_monitoring_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_monitoring_service = v.into();
        self
    }

    /// Sets the value of [desired_addons_config][crate::model::ClusterUpdate::desired_addons_config].
    pub fn set_desired_addons_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AddonsConfig>,
    {
        self.desired_addons_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_addons_config][crate::model::ClusterUpdate::desired_addons_config].
    pub fn set_or_clear_desired_addons_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AddonsConfig>,
    {
        self.desired_addons_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_node_pool_id][crate::model::ClusterUpdate::desired_node_pool_id].
    pub fn set_desired_node_pool_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_node_pool_id = v.into();
        self
    }

    /// Sets the value of [desired_image_type][crate::model::ClusterUpdate::desired_image_type].
    pub fn set_desired_image_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_image_type = v.into();
        self
    }

    /// Sets the value of [desired_database_encryption][crate::model::ClusterUpdate::desired_database_encryption].
    pub fn set_desired_database_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseEncryption>,
    {
        self.desired_database_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_database_encryption][crate::model::ClusterUpdate::desired_database_encryption].
    pub fn set_or_clear_desired_database_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatabaseEncryption>,
    {
        self.desired_database_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_workload_identity_config][crate::model::ClusterUpdate::desired_workload_identity_config].
    pub fn set_desired_workload_identity_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadIdentityConfig>,
    {
        self.desired_workload_identity_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_workload_identity_config][crate::model::ClusterUpdate::desired_workload_identity_config].
    pub fn set_or_clear_desired_workload_identity_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadIdentityConfig>,
    {
        self.desired_workload_identity_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_mesh_certificates][crate::model::ClusterUpdate::desired_mesh_certificates].
    pub fn set_desired_mesh_certificates<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MeshCertificates>,
    {
        self.desired_mesh_certificates = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_mesh_certificates][crate::model::ClusterUpdate::desired_mesh_certificates].
    pub fn set_or_clear_desired_mesh_certificates<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MeshCertificates>,
    {
        self.desired_mesh_certificates = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_shielded_nodes][crate::model::ClusterUpdate::desired_shielded_nodes].
    pub fn set_desired_shielded_nodes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedNodes>,
    {
        self.desired_shielded_nodes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_shielded_nodes][crate::model::ClusterUpdate::desired_shielded_nodes].
    pub fn set_or_clear_desired_shielded_nodes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedNodes>,
    {
        self.desired_shielded_nodes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_cost_management_config][crate::model::ClusterUpdate::desired_cost_management_config].
    pub fn set_desired_cost_management_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CostManagementConfig>,
    {
        self.desired_cost_management_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_cost_management_config][crate::model::ClusterUpdate::desired_cost_management_config].
    pub fn set_or_clear_desired_cost_management_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CostManagementConfig>,
    {
        self.desired_cost_management_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_dns_config][crate::model::ClusterUpdate::desired_dns_config].
    pub fn set_desired_dns_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DNSConfig>,
    {
        self.desired_dns_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_dns_config][crate::model::ClusterUpdate::desired_dns_config].
    pub fn set_or_clear_desired_dns_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DNSConfig>,
    {
        self.desired_dns_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_node_pool_autoscaling][crate::model::ClusterUpdate::desired_node_pool_autoscaling].
    pub fn set_desired_node_pool_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolAutoscaling>,
    {
        self.desired_node_pool_autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_node_pool_autoscaling][crate::model::ClusterUpdate::desired_node_pool_autoscaling].
    pub fn set_or_clear_desired_node_pool_autoscaling<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolAutoscaling>,
    {
        self.desired_node_pool_autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_locations][crate::model::ClusterUpdate::desired_locations].
    pub fn set_desired_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.desired_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [desired_master_authorized_networks_config][crate::model::ClusterUpdate::desired_master_authorized_networks_config].
    #[deprecated]
    pub fn set_desired_master_authorized_networks_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MasterAuthorizedNetworksConfig>,
    {
        self.desired_master_authorized_networks_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_master_authorized_networks_config][crate::model::ClusterUpdate::desired_master_authorized_networks_config].
    #[deprecated]
    pub fn set_or_clear_desired_master_authorized_networks_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::MasterAuthorizedNetworksConfig>,
    {
        self.desired_master_authorized_networks_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_cluster_autoscaling][crate::model::ClusterUpdate::desired_cluster_autoscaling].
    pub fn set_desired_cluster_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterAutoscaling>,
    {
        self.desired_cluster_autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_cluster_autoscaling][crate::model::ClusterUpdate::desired_cluster_autoscaling].
    pub fn set_or_clear_desired_cluster_autoscaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterAutoscaling>,
    {
        self.desired_cluster_autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_binary_authorization][crate::model::ClusterUpdate::desired_binary_authorization].
    pub fn set_desired_binary_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.desired_binary_authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_binary_authorization][crate::model::ClusterUpdate::desired_binary_authorization].
    pub fn set_or_clear_desired_binary_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BinaryAuthorization>,
    {
        self.desired_binary_authorization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_logging_service][crate::model::ClusterUpdate::desired_logging_service].
    pub fn set_desired_logging_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_logging_service = v.into();
        self
    }

    /// Sets the value of [desired_resource_usage_export_config][crate::model::ClusterUpdate::desired_resource_usage_export_config].
    pub fn set_desired_resource_usage_export_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceUsageExportConfig>,
    {
        self.desired_resource_usage_export_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_resource_usage_export_config][crate::model::ClusterUpdate::desired_resource_usage_export_config].
    pub fn set_or_clear_desired_resource_usage_export_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ResourceUsageExportConfig>,
    {
        self.desired_resource_usage_export_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_vertical_pod_autoscaling][crate::model::ClusterUpdate::desired_vertical_pod_autoscaling].
    pub fn set_desired_vertical_pod_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VerticalPodAutoscaling>,
    {
        self.desired_vertical_pod_autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_vertical_pod_autoscaling][crate::model::ClusterUpdate::desired_vertical_pod_autoscaling].
    pub fn set_or_clear_desired_vertical_pod_autoscaling<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::VerticalPodAutoscaling>,
    {
        self.desired_vertical_pod_autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_private_cluster_config][crate::model::ClusterUpdate::desired_private_cluster_config].
    #[deprecated]
    pub fn set_desired_private_cluster_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivateClusterConfig>,
    {
        self.desired_private_cluster_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_private_cluster_config][crate::model::ClusterUpdate::desired_private_cluster_config].
    #[deprecated]
    pub fn set_or_clear_desired_private_cluster_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::PrivateClusterConfig>,
    {
        self.desired_private_cluster_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_intra_node_visibility_config][crate::model::ClusterUpdate::desired_intra_node_visibility_config].
    pub fn set_desired_intra_node_visibility_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IntraNodeVisibilityConfig>,
    {
        self.desired_intra_node_visibility_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_intra_node_visibility_config][crate::model::ClusterUpdate::desired_intra_node_visibility_config].
    pub fn set_or_clear_desired_intra_node_visibility_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::IntraNodeVisibilityConfig>,
    {
        self.desired_intra_node_visibility_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_default_snat_status][crate::model::ClusterUpdate::desired_default_snat_status].
    pub fn set_desired_default_snat_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DefaultSnatStatus>,
    {
        self.desired_default_snat_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_default_snat_status][crate::model::ClusterUpdate::desired_default_snat_status].
    pub fn set_or_clear_desired_default_snat_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DefaultSnatStatus>,
    {
        self.desired_default_snat_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_release_channel][crate::model::ClusterUpdate::desired_release_channel].
    pub fn set_desired_release_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReleaseChannel>,
    {
        self.desired_release_channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_release_channel][crate::model::ClusterUpdate::desired_release_channel].
    pub fn set_or_clear_desired_release_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReleaseChannel>,
    {
        self.desired_release_channel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_l4ilb_subsetting_config][crate::model::ClusterUpdate::desired_l4ilb_subsetting_config].
    pub fn set_desired_l4ilb_subsetting_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ILBSubsettingConfig>,
    {
        self.desired_l4ilb_subsetting_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_l4ilb_subsetting_config][crate::model::ClusterUpdate::desired_l4ilb_subsetting_config].
    pub fn set_or_clear_desired_l4ilb_subsetting_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ILBSubsettingConfig>,
    {
        self.desired_l4ilb_subsetting_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_datapath_provider][crate::model::ClusterUpdate::desired_datapath_provider].
    pub fn set_desired_datapath_provider<T: std::convert::Into<crate::model::DatapathProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_datapath_provider = v.into();
        self
    }

    /// Sets the value of [desired_private_ipv6_google_access][crate::model::ClusterUpdate::desired_private_ipv6_google_access].
    pub fn set_desired_private_ipv6_google_access<
        T: std::convert::Into<crate::model::PrivateIPv6GoogleAccess>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.desired_private_ipv6_google_access = v.into();
        self
    }

    /// Sets the value of [desired_notification_config][crate::model::ClusterUpdate::desired_notification_config].
    pub fn set_desired_notification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.desired_notification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_notification_config][crate::model::ClusterUpdate::desired_notification_config].
    pub fn set_or_clear_desired_notification_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NotificationConfig>,
    {
        self.desired_notification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_authenticator_groups_config][crate::model::ClusterUpdate::desired_authenticator_groups_config].
    pub fn set_desired_authenticator_groups_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthenticatorGroupsConfig>,
    {
        self.desired_authenticator_groups_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_authenticator_groups_config][crate::model::ClusterUpdate::desired_authenticator_groups_config].
    pub fn set_or_clear_desired_authenticator_groups_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::AuthenticatorGroupsConfig>,
    {
        self.desired_authenticator_groups_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_logging_config][crate::model::ClusterUpdate::desired_logging_config].
    pub fn set_desired_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.desired_logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_logging_config][crate::model::ClusterUpdate::desired_logging_config].
    pub fn set_or_clear_desired_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingConfig>,
    {
        self.desired_logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_monitoring_config][crate::model::ClusterUpdate::desired_monitoring_config].
    pub fn set_desired_monitoring_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringConfig>,
    {
        self.desired_monitoring_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_monitoring_config][crate::model::ClusterUpdate::desired_monitoring_config].
    pub fn set_or_clear_desired_monitoring_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringConfig>,
    {
        self.desired_monitoring_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_identity_service_config][crate::model::ClusterUpdate::desired_identity_service_config].
    pub fn set_desired_identity_service_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::IdentityServiceConfig>,
    {
        self.desired_identity_service_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_identity_service_config][crate::model::ClusterUpdate::desired_identity_service_config].
    pub fn set_or_clear_desired_identity_service_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::IdentityServiceConfig>,
    {
        self.desired_identity_service_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_service_external_ips_config][crate::model::ClusterUpdate::desired_service_external_ips_config].
    pub fn set_desired_service_external_ips_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceExternalIPsConfig>,
    {
        self.desired_service_external_ips_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_service_external_ips_config][crate::model::ClusterUpdate::desired_service_external_ips_config].
    pub fn set_or_clear_desired_service_external_ips_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ServiceExternalIPsConfig>,
    {
        self.desired_service_external_ips_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_enable_private_endpoint][crate::model::ClusterUpdate::desired_enable_private_endpoint].
    #[deprecated]
    pub fn set_desired_enable_private_endpoint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_enable_private_endpoint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_enable_private_endpoint][crate::model::ClusterUpdate::desired_enable_private_endpoint].
    #[deprecated]
    pub fn set_or_clear_desired_enable_private_endpoint<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_enable_private_endpoint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_default_enable_private_nodes][crate::model::ClusterUpdate::desired_default_enable_private_nodes].
    pub fn set_desired_default_enable_private_nodes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_default_enable_private_nodes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_default_enable_private_nodes][crate::model::ClusterUpdate::desired_default_enable_private_nodes].
    pub fn set_or_clear_desired_default_enable_private_nodes<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_default_enable_private_nodes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_control_plane_endpoints_config][crate::model::ClusterUpdate::desired_control_plane_endpoints_config].
    pub fn set_desired_control_plane_endpoints_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ControlPlaneEndpointsConfig>,
    {
        self.desired_control_plane_endpoints_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_control_plane_endpoints_config][crate::model::ClusterUpdate::desired_control_plane_endpoints_config].
    pub fn set_or_clear_desired_control_plane_endpoints_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ControlPlaneEndpointsConfig>,
    {
        self.desired_control_plane_endpoints_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_master_version][crate::model::ClusterUpdate::desired_master_version].
    pub fn set_desired_master_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_master_version = v.into();
        self
    }

    /// Sets the value of [desired_gcfs_config][crate::model::ClusterUpdate::desired_gcfs_config].
    pub fn set_desired_gcfs_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcfsConfig>,
    {
        self.desired_gcfs_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_gcfs_config][crate::model::ClusterUpdate::desired_gcfs_config].
    pub fn set_or_clear_desired_gcfs_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcfsConfig>,
    {
        self.desired_gcfs_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_node_pool_auto_config_network_tags][crate::model::ClusterUpdate::desired_node_pool_auto_config_network_tags].
    pub fn set_desired_node_pool_auto_config_network_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkTags>,
    {
        self.desired_node_pool_auto_config_network_tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_node_pool_auto_config_network_tags][crate::model::ClusterUpdate::desired_node_pool_auto_config_network_tags].
    pub fn set_or_clear_desired_node_pool_auto_config_network_tags<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::NetworkTags>,
    {
        self.desired_node_pool_auto_config_network_tags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_pod_autoscaling][crate::model::ClusterUpdate::desired_pod_autoscaling].
    pub fn set_desired_pod_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PodAutoscaling>,
    {
        self.desired_pod_autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_pod_autoscaling][crate::model::ClusterUpdate::desired_pod_autoscaling].
    pub fn set_or_clear_desired_pod_autoscaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PodAutoscaling>,
    {
        self.desired_pod_autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_gateway_api_config][crate::model::ClusterUpdate::desired_gateway_api_config].
    pub fn set_desired_gateway_api_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GatewayAPIConfig>,
    {
        self.desired_gateway_api_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_gateway_api_config][crate::model::ClusterUpdate::desired_gateway_api_config].
    pub fn set_or_clear_desired_gateway_api_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GatewayAPIConfig>,
    {
        self.desired_gateway_api_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::ClusterUpdate::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [desired_node_pool_logging_config][crate::model::ClusterUpdate::desired_node_pool_logging_config].
    pub fn set_desired_node_pool_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolLoggingConfig>,
    {
        self.desired_node_pool_logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_node_pool_logging_config][crate::model::ClusterUpdate::desired_node_pool_logging_config].
    pub fn set_or_clear_desired_node_pool_logging_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolLoggingConfig>,
    {
        self.desired_node_pool_logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_fleet][crate::model::ClusterUpdate::desired_fleet].
    pub fn set_desired_fleet<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.desired_fleet = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_fleet][crate::model::ClusterUpdate::desired_fleet].
    pub fn set_or_clear_desired_fleet<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.desired_fleet = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_stack_type][crate::model::ClusterUpdate::desired_stack_type].
    pub fn set_desired_stack_type<T: std::convert::Into<crate::model::StackType>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_stack_type = v.into();
        self
    }

    /// Sets the value of [additional_pod_ranges_config][crate::model::ClusterUpdate::additional_pod_ranges_config].
    pub fn set_additional_pod_ranges_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdditionalPodRangesConfig>,
    {
        self.additional_pod_ranges_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [additional_pod_ranges_config][crate::model::ClusterUpdate::additional_pod_ranges_config].
    pub fn set_or_clear_additional_pod_ranges_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdditionalPodRangesConfig>,
    {
        self.additional_pod_ranges_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [removed_additional_pod_ranges_config][crate::model::ClusterUpdate::removed_additional_pod_ranges_config].
    pub fn set_removed_additional_pod_ranges_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdditionalPodRangesConfig>,
    {
        self.removed_additional_pod_ranges_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [removed_additional_pod_ranges_config][crate::model::ClusterUpdate::removed_additional_pod_ranges_config].
    pub fn set_or_clear_removed_additional_pod_ranges_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::AdditionalPodRangesConfig>,
    {
        self.removed_additional_pod_ranges_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_k8s_beta_apis][crate::model::ClusterUpdate::enable_k8s_beta_apis].
    pub fn set_enable_k8s_beta_apis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::K8sBetaAPIConfig>,
    {
        self.enable_k8s_beta_apis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_k8s_beta_apis][crate::model::ClusterUpdate::enable_k8s_beta_apis].
    pub fn set_or_clear_enable_k8s_beta_apis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::K8sBetaAPIConfig>,
    {
        self.enable_k8s_beta_apis = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_security_posture_config][crate::model::ClusterUpdate::desired_security_posture_config].
    pub fn set_desired_security_posture_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecurityPostureConfig>,
    {
        self.desired_security_posture_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_security_posture_config][crate::model::ClusterUpdate::desired_security_posture_config].
    pub fn set_or_clear_desired_security_posture_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::SecurityPostureConfig>,
    {
        self.desired_security_posture_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_network_performance_config][crate::model::ClusterUpdate::desired_network_performance_config].
    pub fn set_desired_network_performance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_config::ClusterNetworkPerformanceConfig>,
    {
        self.desired_network_performance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_network_performance_config][crate::model::ClusterUpdate::desired_network_performance_config].
    pub fn set_or_clear_desired_network_performance_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::network_config::ClusterNetworkPerformanceConfig>,
    {
        self.desired_network_performance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_enable_fqdn_network_policy][crate::model::ClusterUpdate::desired_enable_fqdn_network_policy].
    pub fn set_desired_enable_fqdn_network_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_enable_fqdn_network_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_enable_fqdn_network_policy][crate::model::ClusterUpdate::desired_enable_fqdn_network_policy].
    pub fn set_or_clear_desired_enable_fqdn_network_policy<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_enable_fqdn_network_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_autopilot_workload_policy_config][crate::model::ClusterUpdate::desired_autopilot_workload_policy_config].
    pub fn set_desired_autopilot_workload_policy_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadPolicyConfig>,
    {
        self.desired_autopilot_workload_policy_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_autopilot_workload_policy_config][crate::model::ClusterUpdate::desired_autopilot_workload_policy_config].
    pub fn set_or_clear_desired_autopilot_workload_policy_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadPolicyConfig>,
    {
        self.desired_autopilot_workload_policy_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_k8s_beta_apis][crate::model::ClusterUpdate::desired_k8s_beta_apis].
    pub fn set_desired_k8s_beta_apis<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::K8sBetaAPIConfig>,
    {
        self.desired_k8s_beta_apis = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_k8s_beta_apis][crate::model::ClusterUpdate::desired_k8s_beta_apis].
    pub fn set_or_clear_desired_k8s_beta_apis<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::K8sBetaAPIConfig>,
    {
        self.desired_k8s_beta_apis = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_containerd_config][crate::model::ClusterUpdate::desired_containerd_config].
    pub fn set_desired_containerd_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContainerdConfig>,
    {
        self.desired_containerd_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_containerd_config][crate::model::ClusterUpdate::desired_containerd_config].
    pub fn set_or_clear_desired_containerd_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContainerdConfig>,
    {
        self.desired_containerd_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_enable_multi_networking][crate::model::ClusterUpdate::desired_enable_multi_networking].
    pub fn set_desired_enable_multi_networking<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_enable_multi_networking = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_enable_multi_networking][crate::model::ClusterUpdate::desired_enable_multi_networking].
    pub fn set_or_clear_desired_enable_multi_networking<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_enable_multi_networking = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_node_pool_auto_config_resource_manager_tags][crate::model::ClusterUpdate::desired_node_pool_auto_config_resource_manager_tags].
    pub fn set_desired_node_pool_auto_config_resource_manager_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceManagerTags>,
    {
        self.desired_node_pool_auto_config_resource_manager_tags =
            std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_node_pool_auto_config_resource_manager_tags][crate::model::ClusterUpdate::desired_node_pool_auto_config_resource_manager_tags].
    pub fn set_or_clear_desired_node_pool_auto_config_resource_manager_tags<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ResourceManagerTags>,
    {
        self.desired_node_pool_auto_config_resource_manager_tags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_in_transit_encryption_config][crate::model::ClusterUpdate::desired_in_transit_encryption_config].
    pub fn set_desired_in_transit_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InTransitEncryptionConfig>,
    {
        self.desired_in_transit_encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_in_transit_encryption_config][crate::model::ClusterUpdate::desired_in_transit_encryption_config].
    pub fn set_or_clear_desired_in_transit_encryption_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::InTransitEncryptionConfig>,
    {
        self.desired_in_transit_encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_enable_cilium_clusterwide_network_policy][crate::model::ClusterUpdate::desired_enable_cilium_clusterwide_network_policy].
    pub fn set_desired_enable_cilium_clusterwide_network_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_enable_cilium_clusterwide_network_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_enable_cilium_clusterwide_network_policy][crate::model::ClusterUpdate::desired_enable_cilium_clusterwide_network_policy].
    pub fn set_or_clear_desired_enable_cilium_clusterwide_network_policy<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_enable_cilium_clusterwide_network_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_secret_manager_config][crate::model::ClusterUpdate::desired_secret_manager_config].
    pub fn set_desired_secret_manager_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SecretManagerConfig>,
    {
        self.desired_secret_manager_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_secret_manager_config][crate::model::ClusterUpdate::desired_secret_manager_config].
    pub fn set_or_clear_desired_secret_manager_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::SecretManagerConfig>,
    {
        self.desired_secret_manager_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_compliance_posture_config][crate::model::ClusterUpdate::desired_compliance_posture_config].
    pub fn set_desired_compliance_posture_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompliancePostureConfig>,
    {
        self.desired_compliance_posture_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_compliance_posture_config][crate::model::ClusterUpdate::desired_compliance_posture_config].
    pub fn set_or_clear_desired_compliance_posture_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CompliancePostureConfig>,
    {
        self.desired_compliance_posture_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_node_kubelet_config][crate::model::ClusterUpdate::desired_node_kubelet_config].
    pub fn set_desired_node_kubelet_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.desired_node_kubelet_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_node_kubelet_config][crate::model::ClusterUpdate::desired_node_kubelet_config].
    pub fn set_or_clear_desired_node_kubelet_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.desired_node_kubelet_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_node_pool_auto_config_kubelet_config][crate::model::ClusterUpdate::desired_node_pool_auto_config_kubelet_config].
    pub fn set_desired_node_pool_auto_config_kubelet_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.desired_node_pool_auto_config_kubelet_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_node_pool_auto_config_kubelet_config][crate::model::ClusterUpdate::desired_node_pool_auto_config_kubelet_config].
    pub fn set_or_clear_desired_node_pool_auto_config_kubelet_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.desired_node_pool_auto_config_kubelet_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user_managed_keys_config][crate::model::ClusterUpdate::user_managed_keys_config].
    #[deprecated]
    pub fn set_user_managed_keys_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserManagedKeysConfig>,
    {
        self.user_managed_keys_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user_managed_keys_config][crate::model::ClusterUpdate::user_managed_keys_config].
    #[deprecated]
    pub fn set_or_clear_user_managed_keys_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserManagedKeysConfig>,
    {
        self.user_managed_keys_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_rbac_binding_config][crate::model::ClusterUpdate::desired_rbac_binding_config].
    pub fn set_desired_rbac_binding_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RBACBindingConfig>,
    {
        self.desired_rbac_binding_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_rbac_binding_config][crate::model::ClusterUpdate::desired_rbac_binding_config].
    pub fn set_or_clear_desired_rbac_binding_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RBACBindingConfig>,
    {
        self.desired_rbac_binding_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_additional_ip_ranges_config][crate::model::ClusterUpdate::desired_additional_ip_ranges_config].
    pub fn set_desired_additional_ip_ranges_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DesiredAdditionalIPRangesConfig>,
    {
        self.desired_additional_ip_ranges_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_additional_ip_ranges_config][crate::model::ClusterUpdate::desired_additional_ip_ranges_config].
    pub fn set_or_clear_desired_additional_ip_ranges_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::DesiredAdditionalIPRangesConfig>,
    {
        self.desired_additional_ip_ranges_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_enterprise_config][crate::model::ClusterUpdate::desired_enterprise_config].
    pub fn set_desired_enterprise_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DesiredEnterpriseConfig>,
    {
        self.desired_enterprise_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_enterprise_config][crate::model::ClusterUpdate::desired_enterprise_config].
    pub fn set_or_clear_desired_enterprise_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DesiredEnterpriseConfig>,
    {
        self.desired_enterprise_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_auto_ipam_config][crate::model::ClusterUpdate::desired_auto_ipam_config].
    pub fn set_desired_auto_ipam_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoIpamConfig>,
    {
        self.desired_auto_ipam_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_auto_ipam_config][crate::model::ClusterUpdate::desired_auto_ipam_config].
    pub fn set_or_clear_desired_auto_ipam_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutoIpamConfig>,
    {
        self.desired_auto_ipam_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_disable_l4_lb_firewall_reconciliation][crate::model::ClusterUpdate::desired_disable_l4_lb_firewall_reconciliation].
    pub fn set_desired_disable_l4_lb_firewall_reconciliation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_disable_l4_lb_firewall_reconciliation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_disable_l4_lb_firewall_reconciliation][crate::model::ClusterUpdate::desired_disable_l4_lb_firewall_reconciliation].
    pub fn set_or_clear_desired_disable_l4_lb_firewall_reconciliation<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.desired_disable_l4_lb_firewall_reconciliation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_node_pool_auto_config_linux_node_config][crate::model::ClusterUpdate::desired_node_pool_auto_config_linux_node_config].
    pub fn set_desired_node_pool_auto_config_linux_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LinuxNodeConfig>,
    {
        self.desired_node_pool_auto_config_linux_node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_node_pool_auto_config_linux_node_config][crate::model::ClusterUpdate::desired_node_pool_auto_config_linux_node_config].
    pub fn set_or_clear_desired_node_pool_auto_config_linux_node_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::LinuxNodeConfig>,
    {
        self.desired_node_pool_auto_config_linux_node_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_user_managed_keys_config][crate::model::ClusterUpdate::desired_user_managed_keys_config].
    pub fn set_desired_user_managed_keys_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserManagedKeysConfig>,
    {
        self.desired_user_managed_keys_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_user_managed_keys_config][crate::model::ClusterUpdate::desired_user_managed_keys_config].
    pub fn set_or_clear_desired_user_managed_keys_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::UserManagedKeysConfig>,
    {
        self.desired_user_managed_keys_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [desired_anonymous_authentication_config][crate::model::ClusterUpdate::desired_anonymous_authentication_config].
    pub fn set_desired_anonymous_authentication_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AnonymousAuthenticationConfig>,
    {
        self.desired_anonymous_authentication_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [desired_anonymous_authentication_config][crate::model::ClusterUpdate::desired_anonymous_authentication_config].
    pub fn set_or_clear_desired_anonymous_authentication_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::AnonymousAuthenticationConfig>,
    {
        self.desired_anonymous_authentication_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gke_auto_upgrade_config][crate::model::ClusterUpdate::gke_auto_upgrade_config].
    pub fn set_gke_auto_upgrade_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GkeAutoUpgradeConfig>,
    {
        self.gke_auto_upgrade_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gke_auto_upgrade_config][crate::model::ClusterUpdate::gke_auto_upgrade_config].
    pub fn set_or_clear_gke_auto_upgrade_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GkeAutoUpgradeConfig>,
    {
        self.gke_auto_upgrade_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ClusterUpdate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ClusterUpdate"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterUpdate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __desired_node_version,
            __desired_monitoring_service,
            __desired_addons_config,
            __desired_node_pool_id,
            __desired_image_type,
            __desired_database_encryption,
            __desired_workload_identity_config,
            __desired_mesh_certificates,
            __desired_shielded_nodes,
            __desired_cost_management_config,
            __desired_dns_config,
            __desired_node_pool_autoscaling,
            __desired_locations,
            __desired_master_authorized_networks_config,
            __desired_cluster_autoscaling,
            __desired_binary_authorization,
            __desired_logging_service,
            __desired_resource_usage_export_config,
            __desired_vertical_pod_autoscaling,
            __desired_private_cluster_config,
            __desired_intra_node_visibility_config,
            __desired_default_snat_status,
            __desired_release_channel,
            __desired_l4ilb_subsetting_config,
            __desired_datapath_provider,
            __desired_private_ipv6_google_access,
            __desired_notification_config,
            __desired_authenticator_groups_config,
            __desired_logging_config,
            __desired_monitoring_config,
            __desired_identity_service_config,
            __desired_service_external_ips_config,
            __desired_enable_private_endpoint,
            __desired_default_enable_private_nodes,
            __desired_control_plane_endpoints_config,
            __desired_master_version,
            __desired_gcfs_config,
            __desired_node_pool_auto_config_network_tags,
            __desired_pod_autoscaling,
            __desired_gateway_api_config,
            __etag,
            __desired_node_pool_logging_config,
            __desired_fleet,
            __desired_stack_type,
            __additional_pod_ranges_config,
            __removed_additional_pod_ranges_config,
            __enable_k8s_beta_apis,
            __desired_security_posture_config,
            __desired_network_performance_config,
            __desired_enable_fqdn_network_policy,
            __desired_autopilot_workload_policy_config,
            __desired_k8s_beta_apis,
            __desired_containerd_config,
            __desired_enable_multi_networking,
            __desired_node_pool_auto_config_resource_manager_tags,
            __desired_in_transit_encryption_config,
            __desired_enable_cilium_clusterwide_network_policy,
            __desired_secret_manager_config,
            __desired_compliance_posture_config,
            __desired_node_kubelet_config,
            __desired_node_pool_auto_config_kubelet_config,
            __user_managed_keys_config,
            __desired_rbac_binding_config,
            __desired_additional_ip_ranges_config,
            __desired_enterprise_config,
            __desired_auto_ipam_config,
            __desired_disable_l4_lb_firewall_reconciliation,
            __desired_node_pool_auto_config_linux_node_config,
            __desired_user_managed_keys_config,
            __desired_anonymous_authentication_config,
            __gke_auto_upgrade_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterUpdate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "desiredNodeVersion" => Ok(__FieldTag::__desired_node_version),
                            "desired_node_version" => Ok(__FieldTag::__desired_node_version),
                            "desiredMonitoringService" => {
                                Ok(__FieldTag::__desired_monitoring_service)
                            }
                            "desired_monitoring_service" => {
                                Ok(__FieldTag::__desired_monitoring_service)
                            }
                            "desiredAddonsConfig" => Ok(__FieldTag::__desired_addons_config),
                            "desired_addons_config" => Ok(__FieldTag::__desired_addons_config),
                            "desiredNodePoolId" => Ok(__FieldTag::__desired_node_pool_id),
                            "desired_node_pool_id" => Ok(__FieldTag::__desired_node_pool_id),
                            "desiredImageType" => Ok(__FieldTag::__desired_image_type),
                            "desired_image_type" => Ok(__FieldTag::__desired_image_type),
                            "desiredDatabaseEncryption" => {
                                Ok(__FieldTag::__desired_database_encryption)
                            }
                            "desired_database_encryption" => {
                                Ok(__FieldTag::__desired_database_encryption)
                            }
                            "desiredWorkloadIdentityConfig" => {
                                Ok(__FieldTag::__desired_workload_identity_config)
                            }
                            "desired_workload_identity_config" => {
                                Ok(__FieldTag::__desired_workload_identity_config)
                            }
                            "desiredMeshCertificates" => {
                                Ok(__FieldTag::__desired_mesh_certificates)
                            }
                            "desired_mesh_certificates" => {
                                Ok(__FieldTag::__desired_mesh_certificates)
                            }
                            "desiredShieldedNodes" => Ok(__FieldTag::__desired_shielded_nodes),
                            "desired_shielded_nodes" => Ok(__FieldTag::__desired_shielded_nodes),
                            "desiredCostManagementConfig" => {
                                Ok(__FieldTag::__desired_cost_management_config)
                            }
                            "desired_cost_management_config" => {
                                Ok(__FieldTag::__desired_cost_management_config)
                            }
                            "desiredDnsConfig" => Ok(__FieldTag::__desired_dns_config),
                            "desired_dns_config" => Ok(__FieldTag::__desired_dns_config),
                            "desiredNodePoolAutoscaling" => {
                                Ok(__FieldTag::__desired_node_pool_autoscaling)
                            }
                            "desired_node_pool_autoscaling" => {
                                Ok(__FieldTag::__desired_node_pool_autoscaling)
                            }
                            "desiredLocations" => Ok(__FieldTag::__desired_locations),
                            "desired_locations" => Ok(__FieldTag::__desired_locations),
                            "desiredMasterAuthorizedNetworksConfig" => {
                                Ok(__FieldTag::__desired_master_authorized_networks_config)
                            }
                            "desired_master_authorized_networks_config" => {
                                Ok(__FieldTag::__desired_master_authorized_networks_config)
                            }
                            "desiredClusterAutoscaling" => {
                                Ok(__FieldTag::__desired_cluster_autoscaling)
                            }
                            "desired_cluster_autoscaling" => {
                                Ok(__FieldTag::__desired_cluster_autoscaling)
                            }
                            "desiredBinaryAuthorization" => {
                                Ok(__FieldTag::__desired_binary_authorization)
                            }
                            "desired_binary_authorization" => {
                                Ok(__FieldTag::__desired_binary_authorization)
                            }
                            "desiredLoggingService" => Ok(__FieldTag::__desired_logging_service),
                            "desired_logging_service" => Ok(__FieldTag::__desired_logging_service),
                            "desiredResourceUsageExportConfig" => {
                                Ok(__FieldTag::__desired_resource_usage_export_config)
                            }
                            "desired_resource_usage_export_config" => {
                                Ok(__FieldTag::__desired_resource_usage_export_config)
                            }
                            "desiredVerticalPodAutoscaling" => {
                                Ok(__FieldTag::__desired_vertical_pod_autoscaling)
                            }
                            "desired_vertical_pod_autoscaling" => {
                                Ok(__FieldTag::__desired_vertical_pod_autoscaling)
                            }
                            "desiredPrivateClusterConfig" => {
                                Ok(__FieldTag::__desired_private_cluster_config)
                            }
                            "desired_private_cluster_config" => {
                                Ok(__FieldTag::__desired_private_cluster_config)
                            }
                            "desiredIntraNodeVisibilityConfig" => {
                                Ok(__FieldTag::__desired_intra_node_visibility_config)
                            }
                            "desired_intra_node_visibility_config" => {
                                Ok(__FieldTag::__desired_intra_node_visibility_config)
                            }
                            "desiredDefaultSnatStatus" => {
                                Ok(__FieldTag::__desired_default_snat_status)
                            }
                            "desired_default_snat_status" => {
                                Ok(__FieldTag::__desired_default_snat_status)
                            }
                            "desiredReleaseChannel" => Ok(__FieldTag::__desired_release_channel),
                            "desired_release_channel" => Ok(__FieldTag::__desired_release_channel),
                            "desiredL4ilbSubsettingConfig" => {
                                Ok(__FieldTag::__desired_l4ilb_subsetting_config)
                            }
                            "desired_l4ilb_subsetting_config" => {
                                Ok(__FieldTag::__desired_l4ilb_subsetting_config)
                            }
                            "desiredDatapathProvider" => {
                                Ok(__FieldTag::__desired_datapath_provider)
                            }
                            "desired_datapath_provider" => {
                                Ok(__FieldTag::__desired_datapath_provider)
                            }
                            "desiredPrivateIpv6GoogleAccess" => {
                                Ok(__FieldTag::__desired_private_ipv6_google_access)
                            }
                            "desired_private_ipv6_google_access" => {
                                Ok(__FieldTag::__desired_private_ipv6_google_access)
                            }
                            "desiredNotificationConfig" => {
                                Ok(__FieldTag::__desired_notification_config)
                            }
                            "desired_notification_config" => {
                                Ok(__FieldTag::__desired_notification_config)
                            }
                            "desiredAuthenticatorGroupsConfig" => {
                                Ok(__FieldTag::__desired_authenticator_groups_config)
                            }
                            "desired_authenticator_groups_config" => {
                                Ok(__FieldTag::__desired_authenticator_groups_config)
                            }
                            "desiredLoggingConfig" => Ok(__FieldTag::__desired_logging_config),
                            "desired_logging_config" => Ok(__FieldTag::__desired_logging_config),
                            "desiredMonitoringConfig" => {
                                Ok(__FieldTag::__desired_monitoring_config)
                            }
                            "desired_monitoring_config" => {
                                Ok(__FieldTag::__desired_monitoring_config)
                            }
                            "desiredIdentityServiceConfig" => {
                                Ok(__FieldTag::__desired_identity_service_config)
                            }
                            "desired_identity_service_config" => {
                                Ok(__FieldTag::__desired_identity_service_config)
                            }
                            "desiredServiceExternalIpsConfig" => {
                                Ok(__FieldTag::__desired_service_external_ips_config)
                            }
                            "desired_service_external_ips_config" => {
                                Ok(__FieldTag::__desired_service_external_ips_config)
                            }
                            "desiredEnablePrivateEndpoint" => {
                                Ok(__FieldTag::__desired_enable_private_endpoint)
                            }
                            "desired_enable_private_endpoint" => {
                                Ok(__FieldTag::__desired_enable_private_endpoint)
                            }
                            "desiredDefaultEnablePrivateNodes" => {
                                Ok(__FieldTag::__desired_default_enable_private_nodes)
                            }
                            "desired_default_enable_private_nodes" => {
                                Ok(__FieldTag::__desired_default_enable_private_nodes)
                            }
                            "desiredControlPlaneEndpointsConfig" => {
                                Ok(__FieldTag::__desired_control_plane_endpoints_config)
                            }
                            "desired_control_plane_endpoints_config" => {
                                Ok(__FieldTag::__desired_control_plane_endpoints_config)
                            }
                            "desiredMasterVersion" => Ok(__FieldTag::__desired_master_version),
                            "desired_master_version" => Ok(__FieldTag::__desired_master_version),
                            "desiredGcfsConfig" => Ok(__FieldTag::__desired_gcfs_config),
                            "desired_gcfs_config" => Ok(__FieldTag::__desired_gcfs_config),
                            "desiredNodePoolAutoConfigNetworkTags" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_network_tags)
                            }
                            "desired_node_pool_auto_config_network_tags" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_network_tags)
                            }
                            "desiredPodAutoscaling" => Ok(__FieldTag::__desired_pod_autoscaling),
                            "desired_pod_autoscaling" => Ok(__FieldTag::__desired_pod_autoscaling),
                            "desiredGatewayApiConfig" => {
                                Ok(__FieldTag::__desired_gateway_api_config)
                            }
                            "desired_gateway_api_config" => {
                                Ok(__FieldTag::__desired_gateway_api_config)
                            }
                            "etag" => Ok(__FieldTag::__etag),
                            "desiredNodePoolLoggingConfig" => {
                                Ok(__FieldTag::__desired_node_pool_logging_config)
                            }
                            "desired_node_pool_logging_config" => {
                                Ok(__FieldTag::__desired_node_pool_logging_config)
                            }
                            "desiredFleet" => Ok(__FieldTag::__desired_fleet),
                            "desired_fleet" => Ok(__FieldTag::__desired_fleet),
                            "desiredStackType" => Ok(__FieldTag::__desired_stack_type),
                            "desired_stack_type" => Ok(__FieldTag::__desired_stack_type),
                            "additionalPodRangesConfig" => {
                                Ok(__FieldTag::__additional_pod_ranges_config)
                            }
                            "additional_pod_ranges_config" => {
                                Ok(__FieldTag::__additional_pod_ranges_config)
                            }
                            "removedAdditionalPodRangesConfig" => {
                                Ok(__FieldTag::__removed_additional_pod_ranges_config)
                            }
                            "removed_additional_pod_ranges_config" => {
                                Ok(__FieldTag::__removed_additional_pod_ranges_config)
                            }
                            "enableK8sBetaApis" => Ok(__FieldTag::__enable_k8s_beta_apis),
                            "enable_k8s_beta_apis" => Ok(__FieldTag::__enable_k8s_beta_apis),
                            "desiredSecurityPostureConfig" => {
                                Ok(__FieldTag::__desired_security_posture_config)
                            }
                            "desired_security_posture_config" => {
                                Ok(__FieldTag::__desired_security_posture_config)
                            }
                            "desiredNetworkPerformanceConfig" => {
                                Ok(__FieldTag::__desired_network_performance_config)
                            }
                            "desired_network_performance_config" => {
                                Ok(__FieldTag::__desired_network_performance_config)
                            }
                            "desiredEnableFqdnNetworkPolicy" => {
                                Ok(__FieldTag::__desired_enable_fqdn_network_policy)
                            }
                            "desired_enable_fqdn_network_policy" => {
                                Ok(__FieldTag::__desired_enable_fqdn_network_policy)
                            }
                            "desiredAutopilotWorkloadPolicyConfig" => {
                                Ok(__FieldTag::__desired_autopilot_workload_policy_config)
                            }
                            "desired_autopilot_workload_policy_config" => {
                                Ok(__FieldTag::__desired_autopilot_workload_policy_config)
                            }
                            "desiredK8sBetaApis" => Ok(__FieldTag::__desired_k8s_beta_apis),
                            "desired_k8s_beta_apis" => Ok(__FieldTag::__desired_k8s_beta_apis),
                            "desiredContainerdConfig" => {
                                Ok(__FieldTag::__desired_containerd_config)
                            }
                            "desired_containerd_config" => {
                                Ok(__FieldTag::__desired_containerd_config)
                            }
                            "desiredEnableMultiNetworking" => {
                                Ok(__FieldTag::__desired_enable_multi_networking)
                            }
                            "desired_enable_multi_networking" => {
                                Ok(__FieldTag::__desired_enable_multi_networking)
                            }
                            "desiredNodePoolAutoConfigResourceManagerTags" => Ok(
                                __FieldTag::__desired_node_pool_auto_config_resource_manager_tags,
                            ),
                            "desired_node_pool_auto_config_resource_manager_tags" => Ok(
                                __FieldTag::__desired_node_pool_auto_config_resource_manager_tags,
                            ),
                            "desiredInTransitEncryptionConfig" => {
                                Ok(__FieldTag::__desired_in_transit_encryption_config)
                            }
                            "desired_in_transit_encryption_config" => {
                                Ok(__FieldTag::__desired_in_transit_encryption_config)
                            }
                            "desiredEnableCiliumClusterwideNetworkPolicy" => {
                                Ok(__FieldTag::__desired_enable_cilium_clusterwide_network_policy)
                            }
                            "desired_enable_cilium_clusterwide_network_policy" => {
                                Ok(__FieldTag::__desired_enable_cilium_clusterwide_network_policy)
                            }
                            "desiredSecretManagerConfig" => {
                                Ok(__FieldTag::__desired_secret_manager_config)
                            }
                            "desired_secret_manager_config" => {
                                Ok(__FieldTag::__desired_secret_manager_config)
                            }
                            "desiredCompliancePostureConfig" => {
                                Ok(__FieldTag::__desired_compliance_posture_config)
                            }
                            "desired_compliance_posture_config" => {
                                Ok(__FieldTag::__desired_compliance_posture_config)
                            }
                            "desiredNodeKubeletConfig" => {
                                Ok(__FieldTag::__desired_node_kubelet_config)
                            }
                            "desired_node_kubelet_config" => {
                                Ok(__FieldTag::__desired_node_kubelet_config)
                            }
                            "desiredNodePoolAutoConfigKubeletConfig" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_kubelet_config)
                            }
                            "desired_node_pool_auto_config_kubelet_config" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_kubelet_config)
                            }
                            "userManagedKeysConfig" => Ok(__FieldTag::__user_managed_keys_config),
                            "user_managed_keys_config" => {
                                Ok(__FieldTag::__user_managed_keys_config)
                            }
                            "desiredRbacBindingConfig" => {
                                Ok(__FieldTag::__desired_rbac_binding_config)
                            }
                            "desired_rbac_binding_config" => {
                                Ok(__FieldTag::__desired_rbac_binding_config)
                            }
                            "desiredAdditionalIpRangesConfig" => {
                                Ok(__FieldTag::__desired_additional_ip_ranges_config)
                            }
                            "desired_additional_ip_ranges_config" => {
                                Ok(__FieldTag::__desired_additional_ip_ranges_config)
                            }
                            "desiredEnterpriseConfig" => {
                                Ok(__FieldTag::__desired_enterprise_config)
                            }
                            "desired_enterprise_config" => {
                                Ok(__FieldTag::__desired_enterprise_config)
                            }
                            "desiredAutoIpamConfig" => Ok(__FieldTag::__desired_auto_ipam_config),
                            "desired_auto_ipam_config" => {
                                Ok(__FieldTag::__desired_auto_ipam_config)
                            }
                            "desiredDisableL4LbFirewallReconciliation" => {
                                Ok(__FieldTag::__desired_disable_l4_lb_firewall_reconciliation)
                            }
                            "desired_disable_l4_lb_firewall_reconciliation" => {
                                Ok(__FieldTag::__desired_disable_l4_lb_firewall_reconciliation)
                            }
                            "desiredNodePoolAutoConfigLinuxNodeConfig" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_linux_node_config)
                            }
                            "desired_node_pool_auto_config_linux_node_config" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_linux_node_config)
                            }
                            "desiredUserManagedKeysConfig" => {
                                Ok(__FieldTag::__desired_user_managed_keys_config)
                            }
                            "desired_user_managed_keys_config" => {
                                Ok(__FieldTag::__desired_user_managed_keys_config)
                            }
                            "desiredAnonymousAuthenticationConfig" => {
                                Ok(__FieldTag::__desired_anonymous_authentication_config)
                            }
                            "desired_anonymous_authentication_config" => {
                                Ok(__FieldTag::__desired_anonymous_authentication_config)
                            }
                            "gkeAutoUpgradeConfig" => Ok(__FieldTag::__gke_auto_upgrade_config),
                            "gke_auto_upgrade_config" => Ok(__FieldTag::__gke_auto_upgrade_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterUpdate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterUpdate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__desired_node_version => {
                            if !fields.insert(__FieldTag::__desired_node_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_version",
                                ));
                            }
                            result.desired_node_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_monitoring_service => {
                            if !fields.insert(__FieldTag::__desired_monitoring_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_monitoring_service",
                                ));
                            }
                            result.desired_monitoring_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_addons_config => {
                            if !fields.insert(__FieldTag::__desired_addons_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_addons_config",
                                ));
                            }
                            result.desired_addons_config = map
                                .next_value::<std::option::Option<crate::model::AddonsConfig>>()?;
                        }
                        __FieldTag::__desired_node_pool_id => {
                            if !fields.insert(__FieldTag::__desired_node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_id",
                                ));
                            }
                            result.desired_node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_image_type => {
                            if !fields.insert(__FieldTag::__desired_image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_image_type",
                                ));
                            }
                            result.desired_image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_database_encryption => {
                            if !fields.insert(__FieldTag::__desired_database_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_database_encryption",
                                ));
                            }
                            result.desired_database_encryption = map.next_value::<std::option::Option<crate::model::DatabaseEncryption>>()?
                                ;
                        }
                        __FieldTag::__desired_workload_identity_config => {
                            if !fields.insert(__FieldTag::__desired_workload_identity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_workload_identity_config",
                                ));
                            }
                            result.desired_workload_identity_config = map.next_value::<std::option::Option<crate::model::WorkloadIdentityConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_mesh_certificates => {
                            if !fields.insert(__FieldTag::__desired_mesh_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_mesh_certificates",
                                ));
                            }
                            result.desired_mesh_certificates = map
                                .next_value::<std::option::Option<crate::model::MeshCertificates>>(
                                )?;
                        }
                        __FieldTag::__desired_shielded_nodes => {
                            if !fields.insert(__FieldTag::__desired_shielded_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_shielded_nodes",
                                ));
                            }
                            result.desired_shielded_nodes = map
                                .next_value::<std::option::Option<crate::model::ShieldedNodes>>()?;
                        }
                        __FieldTag::__desired_cost_management_config => {
                            if !fields.insert(__FieldTag::__desired_cost_management_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_cost_management_config",
                                ));
                            }
                            result.desired_cost_management_config = map.next_value::<std::option::Option<crate::model::CostManagementConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_dns_config => {
                            if !fields.insert(__FieldTag::__desired_dns_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_dns_config",
                                ));
                            }
                            result.desired_dns_config =
                                map.next_value::<std::option::Option<crate::model::DNSConfig>>()?;
                        }
                        __FieldTag::__desired_node_pool_autoscaling => {
                            if !fields.insert(__FieldTag::__desired_node_pool_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_autoscaling",
                                ));
                            }
                            result.desired_node_pool_autoscaling = map.next_value::<std::option::Option<crate::model::NodePoolAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__desired_locations => {
                            if !fields.insert(__FieldTag::__desired_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_locations",
                                ));
                            }
                            result.desired_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__desired_master_authorized_networks_config => {
                            if !fields
                                .insert(__FieldTag::__desired_master_authorized_networks_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_master_authorized_networks_config",
                                ));
                            }
                            result.desired_master_authorized_networks_config =
                                map.next_value::<std::option::Option<
                                    crate::model::MasterAuthorizedNetworksConfig,
                                >>()?;
                        }
                        __FieldTag::__desired_cluster_autoscaling => {
                            if !fields.insert(__FieldTag::__desired_cluster_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_cluster_autoscaling",
                                ));
                            }
                            result.desired_cluster_autoscaling = map.next_value::<std::option::Option<crate::model::ClusterAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__desired_binary_authorization => {
                            if !fields.insert(__FieldTag::__desired_binary_authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_binary_authorization",
                                ));
                            }
                            result.desired_binary_authorization = map.next_value::<std::option::Option<crate::model::BinaryAuthorization>>()?
                                ;
                        }
                        __FieldTag::__desired_logging_service => {
                            if !fields.insert(__FieldTag::__desired_logging_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_logging_service",
                                ));
                            }
                            result.desired_logging_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_resource_usage_export_config => {
                            if !fields.insert(__FieldTag::__desired_resource_usage_export_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_resource_usage_export_config",
                                ));
                            }
                            result.desired_resource_usage_export_config = map.next_value::<std::option::Option<crate::model::ResourceUsageExportConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_vertical_pod_autoscaling => {
                            if !fields.insert(__FieldTag::__desired_vertical_pod_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_vertical_pod_autoscaling",
                                ));
                            }
                            result.desired_vertical_pod_autoscaling = map.next_value::<std::option::Option<crate::model::VerticalPodAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__desired_private_cluster_config => {
                            if !fields.insert(__FieldTag::__desired_private_cluster_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_private_cluster_config",
                                ));
                            }
                            result.desired_private_cluster_config = map.next_value::<std::option::Option<crate::model::PrivateClusterConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_intra_node_visibility_config => {
                            if !fields.insert(__FieldTag::__desired_intra_node_visibility_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_intra_node_visibility_config",
                                ));
                            }
                            result.desired_intra_node_visibility_config = map.next_value::<std::option::Option<crate::model::IntraNodeVisibilityConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_default_snat_status => {
                            if !fields.insert(__FieldTag::__desired_default_snat_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_default_snat_status",
                                ));
                            }
                            result.desired_default_snat_status = map
                                .next_value::<std::option::Option<crate::model::DefaultSnatStatus>>(
                                )?;
                        }
                        __FieldTag::__desired_release_channel => {
                            if !fields.insert(__FieldTag::__desired_release_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_release_channel",
                                ));
                            }
                            result.desired_release_channel = map
                                .next_value::<std::option::Option<crate::model::ReleaseChannel>>(
                                )?;
                        }
                        __FieldTag::__desired_l4ilb_subsetting_config => {
                            if !fields.insert(__FieldTag::__desired_l4ilb_subsetting_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_l4ilb_subsetting_config",
                                ));
                            }
                            result.desired_l4ilb_subsetting_config = map.next_value::<std::option::Option<crate::model::ILBSubsettingConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_datapath_provider => {
                            if !fields.insert(__FieldTag::__desired_datapath_provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_datapath_provider",
                                ));
                            }
                            result.desired_datapath_provider = map
                                .next_value::<std::option::Option<crate::model::DatapathProvider>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_private_ipv6_google_access => {
                            if !fields.insert(__FieldTag::__desired_private_ipv6_google_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_private_ipv6_google_access",
                                ));
                            }
                            result.desired_private_ipv6_google_access = map.next_value::<std::option::Option<crate::model::PrivateIPv6GoogleAccess>>()?.unwrap_or_default();
                        }
                        __FieldTag::__desired_notification_config => {
                            if !fields.insert(__FieldTag::__desired_notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_notification_config",
                                ));
                            }
                            result.desired_notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_authenticator_groups_config => {
                            if !fields.insert(__FieldTag::__desired_authenticator_groups_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_authenticator_groups_config",
                                ));
                            }
                            result.desired_authenticator_groups_config = map.next_value::<std::option::Option<crate::model::AuthenticatorGroupsConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_logging_config => {
                            if !fields.insert(__FieldTag::__desired_logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_logging_config",
                                ));
                            }
                            result.desired_logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__desired_monitoring_config => {
                            if !fields.insert(__FieldTag::__desired_monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_monitoring_config",
                                ));
                            }
                            result.desired_monitoring_config = map
                                .next_value::<std::option::Option<crate::model::MonitoringConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_identity_service_config => {
                            if !fields.insert(__FieldTag::__desired_identity_service_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_identity_service_config",
                                ));
                            }
                            result.desired_identity_service_config = map.next_value::<std::option::Option<crate::model::IdentityServiceConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_service_external_ips_config => {
                            if !fields.insert(__FieldTag::__desired_service_external_ips_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_service_external_ips_config",
                                ));
                            }
                            result.desired_service_external_ips_config = map.next_value::<std::option::Option<crate::model::ServiceExternalIPsConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_enable_private_endpoint => {
                            if !fields.insert(__FieldTag::__desired_enable_private_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_enable_private_endpoint",
                                ));
                            }
                            result.desired_enable_private_endpoint =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_default_enable_private_nodes => {
                            if !fields.insert(__FieldTag::__desired_default_enable_private_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_default_enable_private_nodes",
                                ));
                            }
                            result.desired_default_enable_private_nodes =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_control_plane_endpoints_config => {
                            if !fields.insert(__FieldTag::__desired_control_plane_endpoints_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_control_plane_endpoints_config",
                                ));
                            }
                            result.desired_control_plane_endpoints_config = map
                                .next_value::<std::option::Option<
                                crate::model::ControlPlaneEndpointsConfig,
                            >>(
                            )?;
                        }
                        __FieldTag::__desired_master_version => {
                            if !fields.insert(__FieldTag::__desired_master_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_master_version",
                                ));
                            }
                            result.desired_master_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_gcfs_config => {
                            if !fields.insert(__FieldTag::__desired_gcfs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_gcfs_config",
                                ));
                            }
                            result.desired_gcfs_config =
                                map.next_value::<std::option::Option<crate::model::GcfsConfig>>()?;
                        }
                        __FieldTag::__desired_node_pool_auto_config_network_tags => {
                            if !fields
                                .insert(__FieldTag::__desired_node_pool_auto_config_network_tags)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_auto_config_network_tags",
                                ));
                            }
                            result.desired_node_pool_auto_config_network_tags =
                                map.next_value::<std::option::Option<crate::model::NetworkTags>>()?;
                        }
                        __FieldTag::__desired_pod_autoscaling => {
                            if !fields.insert(__FieldTag::__desired_pod_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_pod_autoscaling",
                                ));
                            }
                            result.desired_pod_autoscaling = map
                                .next_value::<std::option::Option<crate::model::PodAutoscaling>>(
                                )?;
                        }
                        __FieldTag::__desired_gateway_api_config => {
                            if !fields.insert(__FieldTag::__desired_gateway_api_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_gateway_api_config",
                                ));
                            }
                            result.desired_gateway_api_config = map
                                .next_value::<std::option::Option<crate::model::GatewayAPIConfig>>(
                                )?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_node_pool_logging_config => {
                            if !fields.insert(__FieldTag::__desired_node_pool_logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_logging_config",
                                ));
                            }
                            result.desired_node_pool_logging_config = map.next_value::<std::option::Option<crate::model::NodePoolLoggingConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_fleet => {
                            if !fields.insert(__FieldTag::__desired_fleet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_fleet",
                                ));
                            }
                            result.desired_fleet =
                                map.next_value::<std::option::Option<crate::model::Fleet>>()?;
                        }
                        __FieldTag::__desired_stack_type => {
                            if !fields.insert(__FieldTag::__desired_stack_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_stack_type",
                                ));
                            }
                            result.desired_stack_type = map
                                .next_value::<std::option::Option<crate::model::StackType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_pod_ranges_config => {
                            if !fields.insert(__FieldTag::__additional_pod_ranges_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_pod_ranges_config",
                                ));
                            }
                            result.additional_pod_ranges_config = map.next_value::<std::option::Option<crate::model::AdditionalPodRangesConfig>>()?
                                ;
                        }
                        __FieldTag::__removed_additional_pod_ranges_config => {
                            if !fields.insert(__FieldTag::__removed_additional_pod_ranges_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for removed_additional_pod_ranges_config",
                                ));
                            }
                            result.removed_additional_pod_ranges_config = map.next_value::<std::option::Option<crate::model::AdditionalPodRangesConfig>>()?
                                ;
                        }
                        __FieldTag::__enable_k8s_beta_apis => {
                            if !fields.insert(__FieldTag::__enable_k8s_beta_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_k8s_beta_apis",
                                ));
                            }
                            result.enable_k8s_beta_apis = map
                                .next_value::<std::option::Option<crate::model::K8sBetaAPIConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_security_posture_config => {
                            if !fields.insert(__FieldTag::__desired_security_posture_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_security_posture_config",
                                ));
                            }
                            result.desired_security_posture_config = map.next_value::<std::option::Option<crate::model::SecurityPostureConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_network_performance_config => {
                            if !fields.insert(__FieldTag::__desired_network_performance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_network_performance_config",
                                ));
                            }
                            result.desired_network_performance_config = map
                                .next_value::<std::option::Option<
                                    crate::model::network_config::ClusterNetworkPerformanceConfig,
                                >>()?;
                        }
                        __FieldTag::__desired_enable_fqdn_network_policy => {
                            if !fields.insert(__FieldTag::__desired_enable_fqdn_network_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_enable_fqdn_network_policy",
                                ));
                            }
                            result.desired_enable_fqdn_network_policy =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_autopilot_workload_policy_config => {
                            if !fields
                                .insert(__FieldTag::__desired_autopilot_workload_policy_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_autopilot_workload_policy_config",
                                ));
                            }
                            result.desired_autopilot_workload_policy_config = map
                                .next_value::<std::option::Option<
                                crate::model::WorkloadPolicyConfig,
                            >>(
                            )?;
                        }
                        __FieldTag::__desired_k8s_beta_apis => {
                            if !fields.insert(__FieldTag::__desired_k8s_beta_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_k8s_beta_apis",
                                ));
                            }
                            result.desired_k8s_beta_apis = map
                                .next_value::<std::option::Option<crate::model::K8sBetaAPIConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_containerd_config => {
                            if !fields.insert(__FieldTag::__desired_containerd_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_containerd_config",
                                ));
                            }
                            result.desired_containerd_config = map
                                .next_value::<std::option::Option<crate::model::ContainerdConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_enable_multi_networking => {
                            if !fields.insert(__FieldTag::__desired_enable_multi_networking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_enable_multi_networking",
                                ));
                            }
                            result.desired_enable_multi_networking =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_node_pool_auto_config_resource_manager_tags => {
                            if !fields.insert(
                                __FieldTag::__desired_node_pool_auto_config_resource_manager_tags,
                            ) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_auto_config_resource_manager_tags",
                                ));
                            }
                            result.desired_node_pool_auto_config_resource_manager_tags = map.next_value::<std::option::Option<crate::model::ResourceManagerTags>>()?
                                ;
                        }
                        __FieldTag::__desired_in_transit_encryption_config => {
                            if !fields.insert(__FieldTag::__desired_in_transit_encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_in_transit_encryption_config",
                                ));
                            }
                            result.desired_in_transit_encryption_config = map.next_value::<std::option::Option<crate::model::InTransitEncryptionConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_enable_cilium_clusterwide_network_policy => {
                            if !fields.insert(
                                __FieldTag::__desired_enable_cilium_clusterwide_network_policy,
                            ) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_enable_cilium_clusterwide_network_policy",
                                ));
                            }
                            result.desired_enable_cilium_clusterwide_network_policy =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_secret_manager_config => {
                            if !fields.insert(__FieldTag::__desired_secret_manager_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_secret_manager_config",
                                ));
                            }
                            result.desired_secret_manager_config = map.next_value::<std::option::Option<crate::model::SecretManagerConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_compliance_posture_config => {
                            if !fields.insert(__FieldTag::__desired_compliance_posture_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_compliance_posture_config",
                                ));
                            }
                            result.desired_compliance_posture_config = map.next_value::<std::option::Option<crate::model::CompliancePostureConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_node_kubelet_config => {
                            if !fields.insert(__FieldTag::__desired_node_kubelet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_kubelet_config",
                                ));
                            }
                            result.desired_node_kubelet_config = map
                                .next_value::<std::option::Option<crate::model::NodeKubeletConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_node_pool_auto_config_kubelet_config => {
                            if !fields
                                .insert(__FieldTag::__desired_node_pool_auto_config_kubelet_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_auto_config_kubelet_config",
                                ));
                            }
                            result.desired_node_pool_auto_config_kubelet_config = map.next_value::<std::option::Option<crate::model::NodeKubeletConfig>>()?
                                ;
                        }
                        __FieldTag::__user_managed_keys_config => {
                            if !fields.insert(__FieldTag::__user_managed_keys_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_managed_keys_config",
                                ));
                            }
                            result.user_managed_keys_config = map.next_value::<std::option::Option<crate::model::UserManagedKeysConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_rbac_binding_config => {
                            if !fields.insert(__FieldTag::__desired_rbac_binding_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_rbac_binding_config",
                                ));
                            }
                            result.desired_rbac_binding_config = map
                                .next_value::<std::option::Option<crate::model::RBACBindingConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_additional_ip_ranges_config => {
                            if !fields.insert(__FieldTag::__desired_additional_ip_ranges_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_additional_ip_ranges_config",
                                ));
                            }
                            result.desired_additional_ip_ranges_config = map
                                .next_value::<std::option::Option<
                                    crate::model::DesiredAdditionalIPRangesConfig,
                                >>()?;
                        }
                        __FieldTag::__desired_enterprise_config => {
                            if !fields.insert(__FieldTag::__desired_enterprise_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_enterprise_config",
                                ));
                            }
                            result.desired_enterprise_config = map.next_value::<std::option::Option<crate::model::DesiredEnterpriseConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_auto_ipam_config => {
                            if !fields.insert(__FieldTag::__desired_auto_ipam_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_auto_ipam_config",
                                ));
                            }
                            result.desired_auto_ipam_config = map
                                .next_value::<std::option::Option<crate::model::AutoIpamConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_disable_l4_lb_firewall_reconciliation => {
                            if !fields
                                .insert(__FieldTag::__desired_disable_l4_lb_firewall_reconciliation)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_disable_l4_lb_firewall_reconciliation",
                                ));
                            }
                            result.desired_disable_l4_lb_firewall_reconciliation =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_node_pool_auto_config_linux_node_config => {
                            if !fields.insert(
                                __FieldTag::__desired_node_pool_auto_config_linux_node_config,
                            ) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_auto_config_linux_node_config",
                                ));
                            }
                            result.desired_node_pool_auto_config_linux_node_config = map.next_value::<std::option::Option<crate::model::LinuxNodeConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_user_managed_keys_config => {
                            if !fields.insert(__FieldTag::__desired_user_managed_keys_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_user_managed_keys_config",
                                ));
                            }
                            result.desired_user_managed_keys_config = map.next_value::<std::option::Option<crate::model::UserManagedKeysConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_anonymous_authentication_config => {
                            if !fields.insert(__FieldTag::__desired_anonymous_authentication_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_anonymous_authentication_config",
                                ));
                            }
                            result.desired_anonymous_authentication_config =
                                map.next_value::<std::option::Option<
                                    crate::model::AnonymousAuthenticationConfig,
                                >>()?;
                        }
                        __FieldTag::__gke_auto_upgrade_config => {
                            if !fields.insert(__FieldTag::__gke_auto_upgrade_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_auto_upgrade_config",
                                ));
                            }
                            result.gke_auto_upgrade_config = map.next_value::<std::option::Option<crate::model::GkeAutoUpgradeConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterUpdate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.desired_node_version.is_empty() {
            state.serialize_entry("desiredNodeVersion", &self.desired_node_version)?;
        }
        if !self.desired_monitoring_service.is_empty() {
            state.serialize_entry("desiredMonitoringService", &self.desired_monitoring_service)?;
        }
        if self.desired_addons_config.is_some() {
            state.serialize_entry("desiredAddonsConfig", &self.desired_addons_config)?;
        }
        if !self.desired_node_pool_id.is_empty() {
            state.serialize_entry("desiredNodePoolId", &self.desired_node_pool_id)?;
        }
        if !self.desired_image_type.is_empty() {
            state.serialize_entry("desiredImageType", &self.desired_image_type)?;
        }
        if self.desired_database_encryption.is_some() {
            state.serialize_entry(
                "desiredDatabaseEncryption",
                &self.desired_database_encryption,
            )?;
        }
        if self.desired_workload_identity_config.is_some() {
            state.serialize_entry(
                "desiredWorkloadIdentityConfig",
                &self.desired_workload_identity_config,
            )?;
        }
        if self.desired_mesh_certificates.is_some() {
            state.serialize_entry("desiredMeshCertificates", &self.desired_mesh_certificates)?;
        }
        if self.desired_shielded_nodes.is_some() {
            state.serialize_entry("desiredShieldedNodes", &self.desired_shielded_nodes)?;
        }
        if self.desired_cost_management_config.is_some() {
            state.serialize_entry(
                "desiredCostManagementConfig",
                &self.desired_cost_management_config,
            )?;
        }
        if self.desired_dns_config.is_some() {
            state.serialize_entry("desiredDnsConfig", &self.desired_dns_config)?;
        }
        if self.desired_node_pool_autoscaling.is_some() {
            state.serialize_entry(
                "desiredNodePoolAutoscaling",
                &self.desired_node_pool_autoscaling,
            )?;
        }
        if !self.desired_locations.is_empty() {
            state.serialize_entry("desiredLocations", &self.desired_locations)?;
        }
        if self.desired_master_authorized_networks_config.is_some() {
            state.serialize_entry(
                "desiredMasterAuthorizedNetworksConfig",
                &self.desired_master_authorized_networks_config,
            )?;
        }
        if self.desired_cluster_autoscaling.is_some() {
            state.serialize_entry(
                "desiredClusterAutoscaling",
                &self.desired_cluster_autoscaling,
            )?;
        }
        if self.desired_binary_authorization.is_some() {
            state.serialize_entry(
                "desiredBinaryAuthorization",
                &self.desired_binary_authorization,
            )?;
        }
        if !self.desired_logging_service.is_empty() {
            state.serialize_entry("desiredLoggingService", &self.desired_logging_service)?;
        }
        if self.desired_resource_usage_export_config.is_some() {
            state.serialize_entry(
                "desiredResourceUsageExportConfig",
                &self.desired_resource_usage_export_config,
            )?;
        }
        if self.desired_vertical_pod_autoscaling.is_some() {
            state.serialize_entry(
                "desiredVerticalPodAutoscaling",
                &self.desired_vertical_pod_autoscaling,
            )?;
        }
        if self.desired_private_cluster_config.is_some() {
            state.serialize_entry(
                "desiredPrivateClusterConfig",
                &self.desired_private_cluster_config,
            )?;
        }
        if self.desired_intra_node_visibility_config.is_some() {
            state.serialize_entry(
                "desiredIntraNodeVisibilityConfig",
                &self.desired_intra_node_visibility_config,
            )?;
        }
        if self.desired_default_snat_status.is_some() {
            state.serialize_entry(
                "desiredDefaultSnatStatus",
                &self.desired_default_snat_status,
            )?;
        }
        if self.desired_release_channel.is_some() {
            state.serialize_entry("desiredReleaseChannel", &self.desired_release_channel)?;
        }
        if self.desired_l4ilb_subsetting_config.is_some() {
            state.serialize_entry(
                "desiredL4ilbSubsettingConfig",
                &self.desired_l4ilb_subsetting_config,
            )?;
        }
        if !wkt::internal::is_default(&self.desired_datapath_provider) {
            state.serialize_entry("desiredDatapathProvider", &self.desired_datapath_provider)?;
        }
        if !wkt::internal::is_default(&self.desired_private_ipv6_google_access) {
            state.serialize_entry(
                "desiredPrivateIpv6GoogleAccess",
                &self.desired_private_ipv6_google_access,
            )?;
        }
        if self.desired_notification_config.is_some() {
            state.serialize_entry(
                "desiredNotificationConfig",
                &self.desired_notification_config,
            )?;
        }
        if self.desired_authenticator_groups_config.is_some() {
            state.serialize_entry(
                "desiredAuthenticatorGroupsConfig",
                &self.desired_authenticator_groups_config,
            )?;
        }
        if self.desired_logging_config.is_some() {
            state.serialize_entry("desiredLoggingConfig", &self.desired_logging_config)?;
        }
        if self.desired_monitoring_config.is_some() {
            state.serialize_entry("desiredMonitoringConfig", &self.desired_monitoring_config)?;
        }
        if self.desired_identity_service_config.is_some() {
            state.serialize_entry(
                "desiredIdentityServiceConfig",
                &self.desired_identity_service_config,
            )?;
        }
        if self.desired_service_external_ips_config.is_some() {
            state.serialize_entry(
                "desiredServiceExternalIpsConfig",
                &self.desired_service_external_ips_config,
            )?;
        }
        if self.desired_enable_private_endpoint.is_some() {
            state.serialize_entry(
                "desiredEnablePrivateEndpoint",
                &self.desired_enable_private_endpoint,
            )?;
        }
        if self.desired_default_enable_private_nodes.is_some() {
            state.serialize_entry(
                "desiredDefaultEnablePrivateNodes",
                &self.desired_default_enable_private_nodes,
            )?;
        }
        if self.desired_control_plane_endpoints_config.is_some() {
            state.serialize_entry(
                "desiredControlPlaneEndpointsConfig",
                &self.desired_control_plane_endpoints_config,
            )?;
        }
        if !self.desired_master_version.is_empty() {
            state.serialize_entry("desiredMasterVersion", &self.desired_master_version)?;
        }
        if self.desired_gcfs_config.is_some() {
            state.serialize_entry("desiredGcfsConfig", &self.desired_gcfs_config)?;
        }
        if self.desired_node_pool_auto_config_network_tags.is_some() {
            state.serialize_entry(
                "desiredNodePoolAutoConfigNetworkTags",
                &self.desired_node_pool_auto_config_network_tags,
            )?;
        }
        if self.desired_pod_autoscaling.is_some() {
            state.serialize_entry("desiredPodAutoscaling", &self.desired_pod_autoscaling)?;
        }
        if self.desired_gateway_api_config.is_some() {
            state.serialize_entry("desiredGatewayApiConfig", &self.desired_gateway_api_config)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.desired_node_pool_logging_config.is_some() {
            state.serialize_entry(
                "desiredNodePoolLoggingConfig",
                &self.desired_node_pool_logging_config,
            )?;
        }
        if self.desired_fleet.is_some() {
            state.serialize_entry("desiredFleet", &self.desired_fleet)?;
        }
        if !wkt::internal::is_default(&self.desired_stack_type) {
            state.serialize_entry("desiredStackType", &self.desired_stack_type)?;
        }
        if self.additional_pod_ranges_config.is_some() {
            state.serialize_entry(
                "additionalPodRangesConfig",
                &self.additional_pod_ranges_config,
            )?;
        }
        if self.removed_additional_pod_ranges_config.is_some() {
            state.serialize_entry(
                "removedAdditionalPodRangesConfig",
                &self.removed_additional_pod_ranges_config,
            )?;
        }
        if self.enable_k8s_beta_apis.is_some() {
            state.serialize_entry("enableK8sBetaApis", &self.enable_k8s_beta_apis)?;
        }
        if self.desired_security_posture_config.is_some() {
            state.serialize_entry(
                "desiredSecurityPostureConfig",
                &self.desired_security_posture_config,
            )?;
        }
        if self.desired_network_performance_config.is_some() {
            state.serialize_entry(
                "desiredNetworkPerformanceConfig",
                &self.desired_network_performance_config,
            )?;
        }
        if self.desired_enable_fqdn_network_policy.is_some() {
            state.serialize_entry(
                "desiredEnableFqdnNetworkPolicy",
                &self.desired_enable_fqdn_network_policy,
            )?;
        }
        if self.desired_autopilot_workload_policy_config.is_some() {
            state.serialize_entry(
                "desiredAutopilotWorkloadPolicyConfig",
                &self.desired_autopilot_workload_policy_config,
            )?;
        }
        if self.desired_k8s_beta_apis.is_some() {
            state.serialize_entry("desiredK8sBetaApis", &self.desired_k8s_beta_apis)?;
        }
        if self.desired_containerd_config.is_some() {
            state.serialize_entry("desiredContainerdConfig", &self.desired_containerd_config)?;
        }
        if self.desired_enable_multi_networking.is_some() {
            state.serialize_entry(
                "desiredEnableMultiNetworking",
                &self.desired_enable_multi_networking,
            )?;
        }
        if self
            .desired_node_pool_auto_config_resource_manager_tags
            .is_some()
        {
            state.serialize_entry(
                "desiredNodePoolAutoConfigResourceManagerTags",
                &self.desired_node_pool_auto_config_resource_manager_tags,
            )?;
        }
        if self.desired_in_transit_encryption_config.is_some() {
            state.serialize_entry(
                "desiredInTransitEncryptionConfig",
                &self.desired_in_transit_encryption_config,
            )?;
        }
        if self
            .desired_enable_cilium_clusterwide_network_policy
            .is_some()
        {
            state.serialize_entry(
                "desiredEnableCiliumClusterwideNetworkPolicy",
                &self.desired_enable_cilium_clusterwide_network_policy,
            )?;
        }
        if self.desired_secret_manager_config.is_some() {
            state.serialize_entry(
                "desiredSecretManagerConfig",
                &self.desired_secret_manager_config,
            )?;
        }
        if self.desired_compliance_posture_config.is_some() {
            state.serialize_entry(
                "desiredCompliancePostureConfig",
                &self.desired_compliance_posture_config,
            )?;
        }
        if self.desired_node_kubelet_config.is_some() {
            state.serialize_entry(
                "desiredNodeKubeletConfig",
                &self.desired_node_kubelet_config,
            )?;
        }
        if self.desired_node_pool_auto_config_kubelet_config.is_some() {
            state.serialize_entry(
                "desiredNodePoolAutoConfigKubeletConfig",
                &self.desired_node_pool_auto_config_kubelet_config,
            )?;
        }
        if self.user_managed_keys_config.is_some() {
            state.serialize_entry("userManagedKeysConfig", &self.user_managed_keys_config)?;
        }
        if self.desired_rbac_binding_config.is_some() {
            state.serialize_entry(
                "desiredRbacBindingConfig",
                &self.desired_rbac_binding_config,
            )?;
        }
        if self.desired_additional_ip_ranges_config.is_some() {
            state.serialize_entry(
                "desiredAdditionalIpRangesConfig",
                &self.desired_additional_ip_ranges_config,
            )?;
        }
        if self.desired_enterprise_config.is_some() {
            state.serialize_entry("desiredEnterpriseConfig", &self.desired_enterprise_config)?;
        }
        if self.desired_auto_ipam_config.is_some() {
            state.serialize_entry("desiredAutoIpamConfig", &self.desired_auto_ipam_config)?;
        }
        if self.desired_disable_l4_lb_firewall_reconciliation.is_some() {
            state.serialize_entry(
                "desiredDisableL4LbFirewallReconciliation",
                &self.desired_disable_l4_lb_firewall_reconciliation,
            )?;
        }
        if self
            .desired_node_pool_auto_config_linux_node_config
            .is_some()
        {
            state.serialize_entry(
                "desiredNodePoolAutoConfigLinuxNodeConfig",
                &self.desired_node_pool_auto_config_linux_node_config,
            )?;
        }
        if self.desired_user_managed_keys_config.is_some() {
            state.serialize_entry(
                "desiredUserManagedKeysConfig",
                &self.desired_user_managed_keys_config,
            )?;
        }
        if self.desired_anonymous_authentication_config.is_some() {
            state.serialize_entry(
                "desiredAnonymousAuthenticationConfig",
                &self.desired_anonymous_authentication_config,
            )?;
        }
        if self.gke_auto_upgrade_config.is_some() {
            state.serialize_entry("gkeAutoUpgradeConfig", &self.gke_auto_upgrade_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClusterUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterUpdate");
        debug_struct.field("desired_node_version", &self.desired_node_version);
        debug_struct.field(
            "desired_monitoring_service",
            &self.desired_monitoring_service,
        );
        debug_struct.field("desired_addons_config", &self.desired_addons_config);
        debug_struct.field("desired_node_pool_id", &self.desired_node_pool_id);
        debug_struct.field("desired_image_type", &self.desired_image_type);
        debug_struct.field(
            "desired_database_encryption",
            &self.desired_database_encryption,
        );
        debug_struct.field(
            "desired_workload_identity_config",
            &self.desired_workload_identity_config,
        );
        debug_struct.field("desired_mesh_certificates", &self.desired_mesh_certificates);
        debug_struct.field("desired_shielded_nodes", &self.desired_shielded_nodes);
        debug_struct.field(
            "desired_cost_management_config",
            &self.desired_cost_management_config,
        );
        debug_struct.field("desired_dns_config", &self.desired_dns_config);
        debug_struct.field(
            "desired_node_pool_autoscaling",
            &self.desired_node_pool_autoscaling,
        );
        debug_struct.field("desired_locations", &self.desired_locations);
        debug_struct.field(
            "desired_master_authorized_networks_config",
            &self.desired_master_authorized_networks_config,
        );
        debug_struct.field(
            "desired_cluster_autoscaling",
            &self.desired_cluster_autoscaling,
        );
        debug_struct.field(
            "desired_binary_authorization",
            &self.desired_binary_authorization,
        );
        debug_struct.field("desired_logging_service", &self.desired_logging_service);
        debug_struct.field(
            "desired_resource_usage_export_config",
            &self.desired_resource_usage_export_config,
        );
        debug_struct.field(
            "desired_vertical_pod_autoscaling",
            &self.desired_vertical_pod_autoscaling,
        );
        debug_struct.field(
            "desired_private_cluster_config",
            &self.desired_private_cluster_config,
        );
        debug_struct.field(
            "desired_intra_node_visibility_config",
            &self.desired_intra_node_visibility_config,
        );
        debug_struct.field(
            "desired_default_snat_status",
            &self.desired_default_snat_status,
        );
        debug_struct.field("desired_release_channel", &self.desired_release_channel);
        debug_struct.field(
            "desired_l4ilb_subsetting_config",
            &self.desired_l4ilb_subsetting_config,
        );
        debug_struct.field("desired_datapath_provider", &self.desired_datapath_provider);
        debug_struct.field(
            "desired_private_ipv6_google_access",
            &self.desired_private_ipv6_google_access,
        );
        debug_struct.field(
            "desired_notification_config",
            &self.desired_notification_config,
        );
        debug_struct.field(
            "desired_authenticator_groups_config",
            &self.desired_authenticator_groups_config,
        );
        debug_struct.field("desired_logging_config", &self.desired_logging_config);
        debug_struct.field("desired_monitoring_config", &self.desired_monitoring_config);
        debug_struct.field(
            "desired_identity_service_config",
            &self.desired_identity_service_config,
        );
        debug_struct.field(
            "desired_service_external_ips_config",
            &self.desired_service_external_ips_config,
        );
        debug_struct.field(
            "desired_enable_private_endpoint",
            &self.desired_enable_private_endpoint,
        );
        debug_struct.field(
            "desired_default_enable_private_nodes",
            &self.desired_default_enable_private_nodes,
        );
        debug_struct.field(
            "desired_control_plane_endpoints_config",
            &self.desired_control_plane_endpoints_config,
        );
        debug_struct.field("desired_master_version", &self.desired_master_version);
        debug_struct.field("desired_gcfs_config", &self.desired_gcfs_config);
        debug_struct.field(
            "desired_node_pool_auto_config_network_tags",
            &self.desired_node_pool_auto_config_network_tags,
        );
        debug_struct.field("desired_pod_autoscaling", &self.desired_pod_autoscaling);
        debug_struct.field(
            "desired_gateway_api_config",
            &self.desired_gateway_api_config,
        );
        debug_struct.field("etag", &self.etag);
        debug_struct.field(
            "desired_node_pool_logging_config",
            &self.desired_node_pool_logging_config,
        );
        debug_struct.field("desired_fleet", &self.desired_fleet);
        debug_struct.field("desired_stack_type", &self.desired_stack_type);
        debug_struct.field(
            "additional_pod_ranges_config",
            &self.additional_pod_ranges_config,
        );
        debug_struct.field(
            "removed_additional_pod_ranges_config",
            &self.removed_additional_pod_ranges_config,
        );
        debug_struct.field("enable_k8s_beta_apis", &self.enable_k8s_beta_apis);
        debug_struct.field(
            "desired_security_posture_config",
            &self.desired_security_posture_config,
        );
        debug_struct.field(
            "desired_network_performance_config",
            &self.desired_network_performance_config,
        );
        debug_struct.field(
            "desired_enable_fqdn_network_policy",
            &self.desired_enable_fqdn_network_policy,
        );
        debug_struct.field(
            "desired_autopilot_workload_policy_config",
            &self.desired_autopilot_workload_policy_config,
        );
        debug_struct.field("desired_k8s_beta_apis", &self.desired_k8s_beta_apis);
        debug_struct.field("desired_containerd_config", &self.desired_containerd_config);
        debug_struct.field(
            "desired_enable_multi_networking",
            &self.desired_enable_multi_networking,
        );
        debug_struct.field(
            "desired_node_pool_auto_config_resource_manager_tags",
            &self.desired_node_pool_auto_config_resource_manager_tags,
        );
        debug_struct.field(
            "desired_in_transit_encryption_config",
            &self.desired_in_transit_encryption_config,
        );
        debug_struct.field(
            "desired_enable_cilium_clusterwide_network_policy",
            &self.desired_enable_cilium_clusterwide_network_policy,
        );
        debug_struct.field(
            "desired_secret_manager_config",
            &self.desired_secret_manager_config,
        );
        debug_struct.field(
            "desired_compliance_posture_config",
            &self.desired_compliance_posture_config,
        );
        debug_struct.field(
            "desired_node_kubelet_config",
            &self.desired_node_kubelet_config,
        );
        debug_struct.field(
            "desired_node_pool_auto_config_kubelet_config",
            &self.desired_node_pool_auto_config_kubelet_config,
        );
        debug_struct.field("user_managed_keys_config", &self.user_managed_keys_config);
        debug_struct.field(
            "desired_rbac_binding_config",
            &self.desired_rbac_binding_config,
        );
        debug_struct.field(
            "desired_additional_ip_ranges_config",
            &self.desired_additional_ip_ranges_config,
        );
        debug_struct.field("desired_enterprise_config", &self.desired_enterprise_config);
        debug_struct.field("desired_auto_ipam_config", &self.desired_auto_ipam_config);
        debug_struct.field(
            "desired_disable_l4_lb_firewall_reconciliation",
            &self.desired_disable_l4_lb_firewall_reconciliation,
        );
        debug_struct.field(
            "desired_node_pool_auto_config_linux_node_config",
            &self.desired_node_pool_auto_config_linux_node_config,
        );
        debug_struct.field(
            "desired_user_managed_keys_config",
            &self.desired_user_managed_keys_config,
        );
        debug_struct.field(
            "desired_anonymous_authentication_config",
            &self.desired_anonymous_authentication_config,
        );
        debug_struct.field("gke_auto_upgrade_config", &self.gke_auto_upgrade_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AdditionalPodRangesConfig is the configuration for additional pod secondary
/// ranges supporting the ClusterUpdate message.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdditionalPodRangesConfig {
    /// Name for pod secondary ipv4 range which has the actual range defined ahead.
    pub pod_range_names: std::vec::Vec<std::string::String>,

    /// Output only. Information for additional pod range.
    pub pod_range_info: std::vec::Vec<crate::model::RangeInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdditionalPodRangesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pod_range_names][crate::model::AdditionalPodRangesConfig::pod_range_names].
    pub fn set_pod_range_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pod_range_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pod_range_info][crate::model::AdditionalPodRangesConfig::pod_range_info].
    pub fn set_pod_range_info<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RangeInfo>,
    {
        use std::iter::Iterator;
        self.pod_range_info = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AdditionalPodRangesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AdditionalPodRangesConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdditionalPodRangesConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pod_range_names,
            __pod_range_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdditionalPodRangesConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "podRangeNames" => Ok(__FieldTag::__pod_range_names),
                            "pod_range_names" => Ok(__FieldTag::__pod_range_names),
                            "podRangeInfo" => Ok(__FieldTag::__pod_range_info),
                            "pod_range_info" => Ok(__FieldTag::__pod_range_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdditionalPodRangesConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdditionalPodRangesConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pod_range_names => {
                            if !fields.insert(__FieldTag::__pod_range_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_range_names",
                                ));
                            }
                            result.pod_range_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pod_range_info => {
                            if !fields.insert(__FieldTag::__pod_range_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_range_info",
                                ));
                            }
                            result.pod_range_info = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RangeInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdditionalPodRangesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pod_range_names.is_empty() {
            state.serialize_entry("podRangeNames", &self.pod_range_names)?;
        }
        if !self.pod_range_info.is_empty() {
            state.serialize_entry("podRangeInfo", &self.pod_range_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdditionalPodRangesConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdditionalPodRangesConfig");
        debug_struct.field("pod_range_names", &self.pod_range_names);
        debug_struct.field("pod_range_info", &self.pod_range_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AdditionalIPRangesConfig is the configuration for individual additional
/// subnetwork attached to the cluster
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdditionalIPRangesConfig {
    /// Name of the subnetwork. This can be the full path of the subnetwork or
    /// just the name.
    /// Example1: my-subnet
    /// Example2: projects/gke-project/regions/us-central1/subnetworks/my-subnet
    pub subnetwork: std::string::String,

    /// List of secondary ranges names within this subnetwork that can be used for
    /// pod IPs.
    /// Example1: gke-pod-range1
    /// Example2: gke-pod-range1,gke-pod-range2
    pub pod_ipv4_range_names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdditionalIPRangesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnetwork][crate::model::AdditionalIPRangesConfig::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [pod_ipv4_range_names][crate::model::AdditionalIPRangesConfig::pod_ipv4_range_names].
    pub fn set_pod_ipv4_range_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.pod_ipv4_range_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AdditionalIPRangesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AdditionalIPRangesConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdditionalIPRangesConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subnetwork,
            __pod_ipv4_range_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdditionalIPRangesConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "podIpv4RangeNames" => Ok(__FieldTag::__pod_ipv4_range_names),
                            "pod_ipv4_range_names" => Ok(__FieldTag::__pod_ipv4_range_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdditionalIPRangesConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdditionalIPRangesConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_ipv4_range_names => {
                            if !fields.insert(__FieldTag::__pod_ipv4_range_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_ipv4_range_names",
                                ));
                            }
                            result.pod_ipv4_range_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdditionalIPRangesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.pod_ipv4_range_names.is_empty() {
            state.serialize_entry("podIpv4RangeNames", &self.pod_ipv4_range_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdditionalIPRangesConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdditionalIPRangesConfig");
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("pod_ipv4_range_names", &self.pod_ipv4_range_names);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DesiredAdditionalIPRangesConfig is a wrapper used for cluster update
/// operation and contains multiple AdditionalIPRangesConfigs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DesiredAdditionalIPRangesConfig {
    /// List of additional IP ranges configs where each AdditionalIPRangesConfig
    /// corresponds to one subnetwork's IP ranges
    pub additional_ip_ranges_configs: std::vec::Vec<crate::model::AdditionalIPRangesConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DesiredAdditionalIPRangesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [additional_ip_ranges_configs][crate::model::DesiredAdditionalIPRangesConfig::additional_ip_ranges_configs].
    pub fn set_additional_ip_ranges_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AdditionalIPRangesConfig>,
    {
        use std::iter::Iterator;
        self.additional_ip_ranges_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DesiredAdditionalIPRangesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DesiredAdditionalIPRangesConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DesiredAdditionalIPRangesConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __additional_ip_ranges_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DesiredAdditionalIPRangesConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "additionalIpRangesConfigs" => {
                                Ok(__FieldTag::__additional_ip_ranges_configs)
                            }
                            "additional_ip_ranges_configs" => {
                                Ok(__FieldTag::__additional_ip_ranges_configs)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DesiredAdditionalIPRangesConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DesiredAdditionalIPRangesConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__additional_ip_ranges_configs => {
                            if !fields.insert(__FieldTag::__additional_ip_ranges_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_ip_ranges_configs",
                                ));
                            }
                            result.additional_ip_ranges_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdditionalIPRangesConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DesiredAdditionalIPRangesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.additional_ip_ranges_configs.is_empty() {
            state.serialize_entry(
                "additionalIpRangesConfigs",
                &self.additional_ip_ranges_configs,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DesiredAdditionalIPRangesConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DesiredAdditionalIPRangesConfig");
        debug_struct.field(
            "additional_ip_ranges_configs",
            &self.additional_ip_ranges_configs,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AutoIpamConfig contains all information related to Auto IPAM
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoIpamConfig {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoIpamConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AutoIpamConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AutoIpamConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutoIpamConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoIpamConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutoIpamConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoIpamConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutoIpamConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutoIpamConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoIpamConfig");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// RangeInfo contains the range name and the range utilization by this cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RangeInfo {
    /// Output only. Name of a range.
    pub range_name: std::string::String,

    /// Output only. The utilization of the range.
    pub utilization: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RangeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [range_name][crate::model::RangeInfo::range_name].
    pub fn set_range_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.range_name = v.into();
        self
    }

    /// Sets the value of [utilization][crate::model::RangeInfo::utilization].
    pub fn set_utilization<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.utilization = v.into();
        self
    }
}

impl wkt::message::Message for RangeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RangeInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RangeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __range_name,
            __utilization,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RangeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rangeName" => Ok(__FieldTag::__range_name),
                            "range_name" => Ok(__FieldTag::__range_name),
                            "utilization" => Ok(__FieldTag::__utilization),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RangeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RangeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__range_name => {
                            if !fields.insert(__FieldTag::__range_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_name",
                                ));
                            }
                            result.range_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__utilization => {
                            if !fields.insert(__FieldTag::__utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilization",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.utilization = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RangeInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.range_name.is_empty() {
            state.serialize_entry("rangeName", &self.range_name)?;
        }
        if !wkt::internal::is_default(&self.utilization) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("utilization", &__With(&self.utilization))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RangeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RangeInfo");
        debug_struct.field("range_name", &self.range_name);
        debug_struct.field("utilization", &self.utilization);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DesiredEnterpriseConfig is a wrapper used for updating enterprise_config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DesiredEnterpriseConfig {
    /// desired_tier specifies the desired tier of the cluster.
    pub desired_tier: crate::model::enterprise_config::ClusterTier,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DesiredEnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [desired_tier][crate::model::DesiredEnterpriseConfig::desired_tier].
    pub fn set_desired_tier<T: std::convert::Into<crate::model::enterprise_config::ClusterTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_tier = v.into();
        self
    }
}

impl wkt::message::Message for DesiredEnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DesiredEnterpriseConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DesiredEnterpriseConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __desired_tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DesiredEnterpriseConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "desiredTier" => Ok(__FieldTag::__desired_tier),
                            "desired_tier" => Ok(__FieldTag::__desired_tier),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DesiredEnterpriseConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DesiredEnterpriseConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__desired_tier => {
                            if !fields.insert(__FieldTag::__desired_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_tier",
                                ));
                            }
                            result.desired_tier =
                                map.next_value::<std::option::Option<
                                    crate::model::enterprise_config::ClusterTier,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DesiredEnterpriseConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.desired_tier) {
            state.serialize_entry("desiredTier", &self.desired_tier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DesiredEnterpriseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DesiredEnterpriseConfig");
        debug_struct.field("desired_tier", &self.desired_tier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// This operation resource represents operations that may have happened or are
/// happening on the cluster. All fields are output only.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Operation {
    /// Output only. The server-assigned ID for the operation.
    pub name: std::string::String,

    /// Output only. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the operation is taking place. This field is deprecated, use
    /// location instead.
    #[deprecated]
    pub zone: std::string::String,

    /// Output only. The operation type.
    pub operation_type: crate::model::operation::Type,

    /// Output only. The current status of the operation.
    pub status: crate::model::operation::Status,

    /// Output only. Detailed operation progress, if available.
    pub detail: std::string::String,

    /// Output only. If an error has occurred, a textual description of the error.
    /// Deprecated. Use the field error instead.
    #[deprecated]
    pub status_message: std::string::String,

    /// Output only. Server-defined URI for the operation. Example:
    /// `<https://container.googleapis.com/v1alpha1/projects/123/locations/us-central1/operations/operation-123>`.
    pub self_link: std::string::String,

    /// Output only. Server-defined URI for the target of the operation. The format
    /// of this is a URI to the resource being modified (such as a cluster, node
    /// pool, or node). For node pool repairs, there may be multiple nodes being
    /// repaired, but only one will be the target.
    ///
    /// Examples:
    ///
    ///
    /// ##
    ///
    /// `<https://container.googleapis.com/v1/projects/123/locations/us-central1/clusters/my-cluster>`
    ///
    /// ##
    ///
    /// `<https://container.googleapis.com/v1/projects/123/zones/us-central1-c/clusters/my-cluster/nodePools/my-np>`
    ///
    /// `<https://container.googleapis.com/v1/projects/123/zones/us-central1-c/clusters/my-cluster/nodePools/my-np/node/my-node>`
    pub target_link: std::string::String,

    /// Output only. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
    /// or
    /// [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available)
    /// in which the cluster resides.
    pub location: std::string::String,

    /// Output only. The time the operation started, in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    pub start_time: std::string::String,

    /// Output only. The time the operation completed, in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    pub end_time: std::string::String,

    /// Output only. Progress information for an operation.
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// Which conditions caused the current cluster state.
    /// Deprecated. Use field error instead.
    #[deprecated]
    pub cluster_conditions: std::vec::Vec<crate::model::StatusCondition>,

    /// Which conditions caused the current node pool state.
    /// Deprecated. Use field error instead.
    #[deprecated]
    pub nodepool_conditions: std::vec::Vec<crate::model::StatusCondition>,

    /// The error result of the operation in case of failure.
    pub error: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Operation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::Operation::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [operation_type][crate::model::Operation::operation_type].
    pub fn set_operation_type<T: std::convert::Into<crate::model::operation::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation_type = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Operation::status].
    pub fn set_status<T: std::convert::Into<crate::model::operation::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::Operation::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::Operation::status_message].
    #[deprecated]
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [self_link][crate::model::Operation::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [target_link][crate::model::Operation::target_link].
    pub fn set_target_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_link = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Operation::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Operation::start_time].
    pub fn set_start_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Operation::end_time].
    pub fn set_end_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::Operation::progress].
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::Operation::progress].
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster_conditions][crate::model::Operation::cluster_conditions].
    #[deprecated]
    pub fn set_cluster_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StatusCondition>,
    {
        use std::iter::Iterator;
        self.cluster_conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [nodepool_conditions][crate::model::Operation::nodepool_conditions].
    #[deprecated]
    pub fn set_nodepool_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StatusCondition>,
    {
        use std::iter::Iterator;
        self.nodepool_conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error][crate::model::Operation::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::Operation::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.Operation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Operation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __zone,
            __operation_type,
            __status,
            __detail,
            __status_message,
            __self_link,
            __target_link,
            __location,
            __start_time,
            __end_time,
            __progress,
            __cluster_conditions,
            __nodepool_conditions,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Operation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "zone" => Ok(__FieldTag::__zone),
                            "operationType" => Ok(__FieldTag::__operation_type),
                            "operation_type" => Ok(__FieldTag::__operation_type),
                            "status" => Ok(__FieldTag::__status),
                            "detail" => Ok(__FieldTag::__detail),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "targetLink" => Ok(__FieldTag::__target_link),
                            "target_link" => Ok(__FieldTag::__target_link),
                            "location" => Ok(__FieldTag::__location),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "progress" => Ok(__FieldTag::__progress),
                            "clusterConditions" => Ok(__FieldTag::__cluster_conditions),
                            "cluster_conditions" => Ok(__FieldTag::__cluster_conditions),
                            "nodepoolConditions" => Ok(__FieldTag::__nodepool_conditions),
                            "nodepool_conditions" => Ok(__FieldTag::__nodepool_conditions),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Operation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Operation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation_type => {
                            if !fields.insert(__FieldTag::__operation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_type",
                                ));
                            }
                            result.operation_type = map
                                .next_value::<std::option::Option<crate::model::operation::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::operation::Status>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detail => {
                            if !fields.insert(__FieldTag::__detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detail",
                                ));
                            }
                            result.detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_link => {
                            if !fields.insert(__FieldTag::__target_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_link",
                                ));
                            }
                            result.target_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress => {
                            if !fields.insert(__FieldTag::__progress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress",
                                ));
                            }
                            result.progress = map
                                .next_value::<std::option::Option<crate::model::OperationProgress>>(
                                )?;
                        }
                        __FieldTag::__cluster_conditions => {
                            if !fields.insert(__FieldTag::__cluster_conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_conditions",
                                ));
                            }
                            result.cluster_conditions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StatusCondition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodepool_conditions => {
                            if !fields.insert(__FieldTag::__nodepool_conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodepool_conditions",
                                ));
                            }
                            result.nodepool_conditions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StatusCondition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Operation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !wkt::internal::is_default(&self.operation_type) {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.detail.is_empty() {
            state.serialize_entry("detail", &self.detail)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.target_link.is_empty() {
            state.serialize_entry("targetLink", &self.target_link)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.start_time.is_empty() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self.end_time.is_empty() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.progress.is_some() {
            state.serialize_entry("progress", &self.progress)?;
        }
        if !self.cluster_conditions.is_empty() {
            state.serialize_entry("clusterConditions", &self.cluster_conditions)?;
        }
        if !self.nodepool_conditions.is_empty() {
            state.serialize_entry("nodepoolConditions", &self.nodepool_conditions)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Operation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Operation");
        debug_struct.field("name", &self.name);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("status", &self.status);
        debug_struct.field("detail", &self.detail);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("target_link", &self.target_link);
        debug_struct.field("location", &self.location);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("progress", &self.progress);
        debug_struct.field("cluster_conditions", &self.cluster_conditions);
        debug_struct.field("nodepool_conditions", &self.nodepool_conditions);
        debug_struct.field("error", &self.error);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Operation].
pub mod operation {
    #[allow(unused_imports)]
    use super::*;

    /// Current status of the operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Not set.
        Unspecified,
        /// The operation has been created.
        Pending,
        /// The operation is currently running.
        Running,
        /// The operation is done, either cancelled or completed.
        Done,
        /// The operation is aborting.
        Aborting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Done => std::option::Option::Some(3),
                Self::Aborting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::Aborting => std::option::Option::Some("ABORTING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Done,
                4 => Self::Aborting,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "DONE" => Self::Done,
                "ABORTING" => Self::Aborting,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Done => serializer.serialize_i32(3),
                Self::Aborting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.container.v1.Operation.Status",
            ))
        }
    }

    /// Operation type categorizes the operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Not set.
        Unspecified,
        /// The cluster is being created. The cluster should be assumed to be
        /// unusable until the operation finishes.
        ///
        /// In the event of the operation failing, the cluster will enter the
        /// [ERROR state][google.container.v1.Cluster.Status.ERROR] and eventually be
        /// deleted.
        ///
        /// [google.container.v1.Cluster.Status.ERROR]: crate::model::cluster::Status::Error
        CreateCluster,
        /// The cluster is being deleted. The cluster should be assumed to be
        /// unusable as soon as this operation starts.
        ///
        /// In the event of the operation failing, the cluster will enter the
        /// [ERROR state][google.container.v1.Cluster.Status.ERROR] and the deletion
        /// will be automatically retried until completed.
        ///
        /// [google.container.v1.Cluster.Status.ERROR]: crate::model::cluster::Status::Error
        DeleteCluster,
        /// The [cluster
        /// version][google.container.v1.ClusterUpdate.desired_master_version] is
        /// being updated. Note that this includes "upgrades" to the same version,
        /// which are simply a recreation. This also includes
        /// [auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#upgrading_automatically).
        /// For more details, see [documentation on cluster
        /// upgrades](https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-upgrades#cluster_upgrades).
        ///
        /// [google.container.v1.ClusterUpdate.desired_master_version]: crate::model::ClusterUpdate::desired_master_version
        UpgradeMaster,
        /// A node pool is being updated. Despite calling this an "upgrade", this
        /// includes most forms of updates to node pools. This also includes
        /// [auto-upgrades](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-upgrades).
        ///
        /// This operation sets the
        /// [progress][google.container.v1.Operation.progress] field and may be
        /// [canceled][google.container.v1.ClusterManager.CancelOperation].
        ///
        /// The upgrade strategy depends on [node pool
        /// configuration](https://cloud.google.com/kubernetes-engine/docs/concepts/node-pool-upgrade-strategies).
        /// The nodes are generally still usable during this operation.
        ///
        /// [google.container.v1.ClusterManager.CancelOperation]: crate::client::ClusterManager::cancel_operation
        /// [google.container.v1.Operation.progress]: crate::model::Operation::progress
        UpgradeNodes,
        /// A problem has been detected with the control plane and is being repaired.
        /// This operation type is initiated by GKE. For more details, see
        /// [documentation on
        /// repairs](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs).
        RepairCluster,
        /// The cluster is being updated. This is a broad category of operations and
        /// includes operations that only change metadata as well as those that must
        /// recreate the entire cluster. If the control plane must be recreated, this
        /// will cause temporary downtime for zonal clusters.
        ///
        /// Some features require recreating the nodes as well. Those will be
        /// recreated as separate operations and the update may not be completely
        /// functional until the node pools recreations finish. Node recreations will
        /// generally follow [maintenance
        /// policies](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions).
        ///
        /// Some GKE-initiated operations use this type. This includes certain types
        /// of auto-upgrades and incident mitigations.
        UpdateCluster,
        /// A node pool is being created. The node pool should be assumed to be
        /// unusable until this operation finishes. In the event of an error, the
        /// node pool may be partially created.
        ///
        /// If enabled, [node
        /// autoprovisioning](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-provisioning)
        /// may have automatically initiated such operations.
        CreateNodePool,
        /// The node pool is being deleted. The node pool should be assumed to be
        /// unusable as soon as this operation starts.
        DeleteNodePool,
        /// The node pool's [manamagent][google.container.v1.NodePool.management]
        /// field is being updated. These operations only update metadata and may be
        /// concurrent with most other operations.
        ///
        /// [google.container.v1.NodePool.management]: crate::model::NodePool::management
        SetNodePoolManagement,
        /// A problem has been detected with nodes and [they are being
        /// repaired](https://cloud.google.com/kubernetes-engine/docs/how-to/node-auto-repair).
        /// This operation type is initiated by GKE, typically automatically. This
        /// operation may be concurrent with other operations and there may be
        /// multiple repairs occurring on the same node pool.
        AutoRepairNodes,
        /// Unused. Automatic node upgrade uses
        /// [UPGRADE_NODES][google.container.v1.Operation.Type.UPGRADE_NODES].
        ///
        /// [google.container.v1.Operation.Type.UPGRADE_NODES]: crate::model::operation::Type::UpgradeNodes
        #[deprecated]
        AutoUpgradeNodes,
        /// Unused. Updating labels uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        ///
        /// [google.container.v1.Operation.Type.UPDATE_CLUSTER]: crate::model::operation::Type::UpdateCluster
        #[deprecated]
        SetLabels,
        /// Unused. Updating master auth uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        ///
        /// [google.container.v1.Operation.Type.UPDATE_CLUSTER]: crate::model::operation::Type::UpdateCluster
        #[deprecated]
        SetMasterAuth,
        /// The node pool is being resized. With the exception of resizing to or from
        /// size zero, the node pool is generally usable during this operation.
        SetNodePoolSize,
        /// Unused. Updating network policy uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        ///
        /// [google.container.v1.Operation.Type.UPDATE_CLUSTER]: crate::model::operation::Type::UpdateCluster
        #[deprecated]
        SetNetworkPolicy,
        /// Unused. Updating maintenance policy uses
        /// [UPDATE_CLUSTER][google.container.v1.Operation.Type.UPDATE_CLUSTER].
        ///
        /// [google.container.v1.Operation.Type.UPDATE_CLUSTER]: crate::model::operation::Type::UpdateCluster
        #[deprecated]
        SetMaintenancePolicy,
        /// The control plane is being resized. This operation type is initiated by
        /// GKE. These operations are often performed preemptively to ensure that the
        /// control plane has sufficient resources and is not typically an indication
        /// of issues. For more details, see
        /// [documentation on
        /// resizes](https://cloud.google.com/kubernetes-engine/docs/concepts/maintenance-windows-and-exclusions#repairs).
        ResizeCluster,
        /// Fleet features of GKE Enterprise are being upgraded. The cluster should
        /// be assumed to be blocked for other upgrades until the operation finishes.
        FleetFeatureUpgrade,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CreateCluster => std::option::Option::Some(1),
                Self::DeleteCluster => std::option::Option::Some(2),
                Self::UpgradeMaster => std::option::Option::Some(3),
                Self::UpgradeNodes => std::option::Option::Some(4),
                Self::RepairCluster => std::option::Option::Some(5),
                Self::UpdateCluster => std::option::Option::Some(6),
                Self::CreateNodePool => std::option::Option::Some(7),
                Self::DeleteNodePool => std::option::Option::Some(8),
                Self::SetNodePoolManagement => std::option::Option::Some(9),
                Self::AutoRepairNodes => std::option::Option::Some(10),
                Self::AutoUpgradeNodes => std::option::Option::Some(11),
                Self::SetLabels => std::option::Option::Some(12),
                Self::SetMasterAuth => std::option::Option::Some(13),
                Self::SetNodePoolSize => std::option::Option::Some(14),
                Self::SetNetworkPolicy => std::option::Option::Some(15),
                Self::SetMaintenancePolicy => std::option::Option::Some(16),
                Self::ResizeCluster => std::option::Option::Some(18),
                Self::FleetFeatureUpgrade => std::option::Option::Some(19),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::CreateCluster => std::option::Option::Some("CREATE_CLUSTER"),
                Self::DeleteCluster => std::option::Option::Some("DELETE_CLUSTER"),
                Self::UpgradeMaster => std::option::Option::Some("UPGRADE_MASTER"),
                Self::UpgradeNodes => std::option::Option::Some("UPGRADE_NODES"),
                Self::RepairCluster => std::option::Option::Some("REPAIR_CLUSTER"),
                Self::UpdateCluster => std::option::Option::Some("UPDATE_CLUSTER"),
                Self::CreateNodePool => std::option::Option::Some("CREATE_NODE_POOL"),
                Self::DeleteNodePool => std::option::Option::Some("DELETE_NODE_POOL"),
                Self::SetNodePoolManagement => {
                    std::option::Option::Some("SET_NODE_POOL_MANAGEMENT")
                }
                Self::AutoRepairNodes => std::option::Option::Some("AUTO_REPAIR_NODES"),
                Self::AutoUpgradeNodes => std::option::Option::Some("AUTO_UPGRADE_NODES"),
                Self::SetLabels => std::option::Option::Some("SET_LABELS"),
                Self::SetMasterAuth => std::option::Option::Some("SET_MASTER_AUTH"),
                Self::SetNodePoolSize => std::option::Option::Some("SET_NODE_POOL_SIZE"),
                Self::SetNetworkPolicy => std::option::Option::Some("SET_NETWORK_POLICY"),
                Self::SetMaintenancePolicy => std::option::Option::Some("SET_MAINTENANCE_POLICY"),
                Self::ResizeCluster => std::option::Option::Some("RESIZE_CLUSTER"),
                Self::FleetFeatureUpgrade => std::option::Option::Some("FLEET_FEATURE_UPGRADE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CreateCluster,
                2 => Self::DeleteCluster,
                3 => Self::UpgradeMaster,
                4 => Self::UpgradeNodes,
                5 => Self::RepairCluster,
                6 => Self::UpdateCluster,
                7 => Self::CreateNodePool,
                8 => Self::DeleteNodePool,
                9 => Self::SetNodePoolManagement,
                10 => Self::AutoRepairNodes,
                11 => Self::AutoUpgradeNodes,
                12 => Self::SetLabels,
                13 => Self::SetMasterAuth,
                14 => Self::SetNodePoolSize,
                15 => Self::SetNetworkPolicy,
                16 => Self::SetMaintenancePolicy,
                18 => Self::ResizeCluster,
                19 => Self::FleetFeatureUpgrade,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "CREATE_CLUSTER" => Self::CreateCluster,
                "DELETE_CLUSTER" => Self::DeleteCluster,
                "UPGRADE_MASTER" => Self::UpgradeMaster,
                "UPGRADE_NODES" => Self::UpgradeNodes,
                "REPAIR_CLUSTER" => Self::RepairCluster,
                "UPDATE_CLUSTER" => Self::UpdateCluster,
                "CREATE_NODE_POOL" => Self::CreateNodePool,
                "DELETE_NODE_POOL" => Self::DeleteNodePool,
                "SET_NODE_POOL_MANAGEMENT" => Self::SetNodePoolManagement,
                "AUTO_REPAIR_NODES" => Self::AutoRepairNodes,
                "AUTO_UPGRADE_NODES" => Self::AutoUpgradeNodes,
                "SET_LABELS" => Self::SetLabels,
                "SET_MASTER_AUTH" => Self::SetMasterAuth,
                "SET_NODE_POOL_SIZE" => Self::SetNodePoolSize,
                "SET_NETWORK_POLICY" => Self::SetNetworkPolicy,
                "SET_MAINTENANCE_POLICY" => Self::SetMaintenancePolicy,
                "RESIZE_CLUSTER" => Self::ResizeCluster,
                "FLEET_FEATURE_UPGRADE" => Self::FleetFeatureUpgrade,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CreateCluster => serializer.serialize_i32(1),
                Self::DeleteCluster => serializer.serialize_i32(2),
                Self::UpgradeMaster => serializer.serialize_i32(3),
                Self::UpgradeNodes => serializer.serialize_i32(4),
                Self::RepairCluster => serializer.serialize_i32(5),
                Self::UpdateCluster => serializer.serialize_i32(6),
                Self::CreateNodePool => serializer.serialize_i32(7),
                Self::DeleteNodePool => serializer.serialize_i32(8),
                Self::SetNodePoolManagement => serializer.serialize_i32(9),
                Self::AutoRepairNodes => serializer.serialize_i32(10),
                Self::AutoUpgradeNodes => serializer.serialize_i32(11),
                Self::SetLabels => serializer.serialize_i32(12),
                Self::SetMasterAuth => serializer.serialize_i32(13),
                Self::SetNodePoolSize => serializer.serialize_i32(14),
                Self::SetNetworkPolicy => serializer.serialize_i32(15),
                Self::SetMaintenancePolicy => serializer.serialize_i32(16),
                Self::ResizeCluster => serializer.serialize_i32(18),
                Self::FleetFeatureUpgrade => serializer.serialize_i32(19),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.container.v1.Operation.Type",
            ))
        }
    }
}

/// Information about operation (or operation stage) progress.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationProgress {
    /// A non-parameterized string describing an operation stage.
    /// Unset for single-stage operations.
    pub name: std::string::String,

    /// Status of an operation stage.
    /// Unset for single-stage operations.
    pub status: crate::model::operation::Status,

    /// Progress metric bundle, for example:
    /// metrics: [{name: "nodes done",     int_value: 15},
    /// {name: "nodes total",    int_value: 32}]
    /// or
    /// metrics: [{name: "progress",       double_value: 0.56},
    /// {name: "progress scale", double_value: 1.0}]
    pub metrics: std::vec::Vec<crate::model::operation_progress::Metric>,

    /// Substages of an operation or a stage.
    pub stages: std::vec::Vec<crate::model::OperationProgress>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationProgress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OperationProgress::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [status][crate::model::OperationProgress::status].
    pub fn set_status<T: std::convert::Into<crate::model::operation::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [metrics][crate::model::OperationProgress::metrics].
    pub fn set_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::operation_progress::Metric>,
    {
        use std::iter::Iterator;
        self.metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [stages][crate::model::OperationProgress::stages].
    pub fn set_stages<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OperationProgress>,
    {
        use std::iter::Iterator;
        self.stages = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationProgress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.OperationProgress"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationProgress {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __status,
            __metrics,
            __stages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationProgress")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "status" => Ok(__FieldTag::__status),
                            "metrics" => Ok(__FieldTag::__metrics),
                            "stages" => Ok(__FieldTag::__stages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationProgress;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationProgress")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::operation::Status>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metrics => {
                            if !fields.insert(__FieldTag::__metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics",
                                ));
                            }
                            result.metrics = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::operation_progress::Metric>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stages => {
                            if !fields.insert(__FieldTag::__stages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stages",
                                ));
                            }
                            result.stages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OperationProgress>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationProgress {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.metrics.is_empty() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if !self.stages.is_empty() {
            state.serialize_entry("stages", &self.stages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationProgress");
        debug_struct.field("name", &self.name);
        debug_struct.field("status", &self.status);
        debug_struct.field("metrics", &self.metrics);
        debug_struct.field("stages", &self.stages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OperationProgress].
pub mod operation_progress {
    #[allow(unused_imports)]
    use super::*;

    /// Progress metric is (string, int|float|string) pair.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Metric {
        /// Required. Metric name, e.g., "nodes total", "percent done".
        pub name: std::string::String,

        /// Strictly one of the values is required.
        pub value: std::option::Option<crate::model::operation_progress::metric::Value>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Metric {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::operation_progress::Metric::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [value][crate::model::operation_progress::Metric::value].
        ///
        /// Note that all the setters affecting `value` are mutually
        /// exclusive.
        pub fn set_value<
            T: std::convert::Into<
                    std::option::Option<crate::model::operation_progress::metric::Value>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value = v.into();
            self
        }

        /// The value of [value][crate::model::operation_progress::Metric::value]
        /// if it holds a `IntValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn int_value(&self) -> std::option::Option<&i64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::operation_progress::metric::Value::IntValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::operation_progress::Metric::value]
        /// to hold a `IntValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_int_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::operation_progress::metric::Value::IntValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::operation_progress::Metric::value]
        /// if it holds a `DoubleValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn double_value(&self) -> std::option::Option<&f64> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::operation_progress::metric::Value::DoubleValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::operation_progress::Metric::value]
        /// to hold a `DoubleValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.value = std::option::Option::Some(
                crate::model::operation_progress::metric::Value::DoubleValue(v.into()),
            );
            self
        }

        /// The value of [value][crate::model::operation_progress::Metric::value]
        /// if it holds a `StringValue`, `None` if the field is not set or
        /// holds a different branch.
        pub fn string_value(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.value.as_ref().and_then(|v| match v {
                crate::model::operation_progress::metric::Value::StringValue(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [value][crate::model::operation_progress::Metric::value]
        /// to hold a `StringValue`.
        ///
        /// Note that all the setters affecting `value` are
        /// mutually exclusive.
        pub fn set_string_value<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.value = std::option::Option::Some(
                crate::model::operation_progress::metric::Value::StringValue(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Metric {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.OperationProgress.Metric"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Metric {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __int_value,
                __double_value,
                __string_value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Metric")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "intValue" => Ok(__FieldTag::__int_value),
                                "int_value" => Ok(__FieldTag::__int_value),
                                "doubleValue" => Ok(__FieldTag::__double_value),
                                "double_value" => Ok(__FieldTag::__double_value),
                                "stringValue" => Ok(__FieldTag::__string_value),
                                "string_value" => Ok(__FieldTag::__string_value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Metric;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Metric")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__int_value => {
                                if !fields.insert(__FieldTag::__int_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for int_value",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.container.v1.OperationProgress.Metric.int_value, latest field was intValue",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::operation_progress::metric::Value::IntValue(
                                        map.next_value::<__With>()?.0.unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__double_value => {
                                if !fields.insert(__FieldTag::__double_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for double_value",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.container.v1.OperationProgress.Metric.double_value, latest field was doubleValue",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::operation_progress::metric::Value::DoubleValue(
                                        map.next_value::<__With>()?.0.unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__string_value => {
                                if !fields.insert(__FieldTag::__string_value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for string_value",
                                    ));
                                }
                                if result.value.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `value`, a oneof with full ID .google.container.v1.OperationProgress.Metric.string_value, latest field was stringValue",
                                    ));
                                }
                                result.value = std::option::Option::Some(
                                    crate::model::operation_progress::metric::Value::StringValue(
                                        map.next_value::<std::option::Option<std::string::String>>(
                                        )?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Metric {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if let Some(value) = self.int_value() {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("intValue", &__With(value))?;
            }
            if let Some(value) = self.double_value() {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("doubleValue", &__With(value))?;
            }
            if let Some(value) = self.string_value() {
                state.serialize_entry("stringValue", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Metric {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Metric");
            debug_struct.field("name", &self.name);
            debug_struct.field("value", &self.value);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Metric].
    pub mod metric {
        #[allow(unused_imports)]
        use super::*;

        /// Strictly one of the values is required.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Value {
            /// For metrics with integer value.
            IntValue(i64),
            /// For metrics with floating point value.
            DoubleValue(f64),
            /// For metrics with custom values (ratios, visual progress, etc.).
            StringValue(std::string::String),
        }
    }
}

/// CreateClusterRequest creates a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the parent field.
    #[deprecated]
    pub zone: std::string::String,

    /// Required. A [cluster
    /// resource](https://cloud.google.com/container-engine/reference/rest/v1/projects.locations.clusters)
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// The parent (project and location) where the cluster will be created.
    /// Specified in the format `projects/*/locations/*`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateClusterRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CreateClusterRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CreateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetClusterRequest gets the settings of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to retrieve.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// The name (project, location, cluster) of the cluster to retrieve.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetClusterRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::GetClusterRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::GetClusterRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateClusterRequest updates the settings of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. A description of the update.
    pub update: std::option::Option<crate::model::ClusterUpdate>,

    /// The name (project, location, cluster) of the cluster to update.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateClusterRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::UpdateClusterRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::UpdateClusterRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [update][crate::model::UpdateClusterRequest::update].
    pub fn set_update<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterUpdate>,
    {
        self.update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update][crate::model::UpdateClusterRequest::update].
    pub fn set_or_clear_update<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterUpdate>,
    {
        self.update = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::UpdateClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpdateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __update,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "update" => Ok(__FieldTag::__update),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update => {
                            if !fields.insert(__FieldTag::__update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update",
                                ));
                            }
                            result.update = map
                                .next_value::<std::option::Option<crate::model::ClusterUpdate>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.update.is_some() {
            state.serialize_entry("update", &self.update)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("update", &self.update);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateNodePoolRequests update a node pool's image and/or version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// Required. The Kubernetes version to change the nodes to (typically an
    /// upgrade).
    ///
    /// Users may specify either explicit versions offered by Kubernetes Engine or
    /// version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the Kubernetes master version
    pub node_version: std::string::String,

    /// Required. The desired image type for the node pool. Please see
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/node-images>
    /// for available image types.
    pub image_type: std::string::String,

    /// The name (project, location, cluster, node pool) of the node pool to
    /// update. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    pub name: std::string::String,

    /// The desired list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available)
    /// in which the node pool's nodes should be located. Changing the locations
    /// for a node pool will result in nodes being either created or removed from
    /// the node pool, depending on whether locations are being added or removed.
    pub locations: std::vec::Vec<std::string::String>,

    /// The desired workload metadata config for the node pool.
    pub workload_metadata_config: std::option::Option<crate::model::WorkloadMetadataConfig>,

    /// Upgrade settings control disruption and speed of the upgrade.
    pub upgrade_settings: std::option::Option<crate::model::node_pool::UpgradeSettings>,

    /// The desired network tags to be applied to all nodes in the node pool.
    /// If this field is not present, the tags will not be changed. Otherwise,
    /// the existing network tags will be *replaced* with the provided tags.
    pub tags: std::option::Option<crate::model::NetworkTags>,

    /// The desired node taints to be applied to all nodes in the node pool.
    /// If this field is not present, the taints will not be changed. Otherwise,
    /// the existing node taints will be *replaced* with the provided taints.
    pub taints: std::option::Option<crate::model::NodeTaints>,

    /// The desired node labels to be applied to all nodes in the node pool.
    /// If this field is not present, the labels will not be changed. Otherwise,
    /// the existing node labels will be *replaced* with the provided labels.
    pub labels: std::option::Option<crate::model::NodeLabels>,

    /// Parameters that can be configured on Linux nodes.
    pub linux_node_config: std::option::Option<crate::model::LinuxNodeConfig>,

    /// Node kubelet configs.
    pub kubelet_config: std::option::Option<crate::model::NodeKubeletConfig>,

    /// Node network config.
    pub node_network_config: std::option::Option<crate::model::NodeNetworkConfig>,

    /// GCFS config.
    pub gcfs_config: std::option::Option<crate::model::GcfsConfig>,

    /// Confidential nodes config.
    /// All the nodes in the node pool will be Confidential VM once enabled.
    pub confidential_nodes: std::option::Option<crate::model::ConfidentialNodes>,

    /// Enable or disable gvnic on the node pool.
    pub gvnic: std::option::Option<crate::model::VirtualNIC>,

    /// The current etag of the node pool.
    /// If an etag is provided and does not match the current etag of the node
    /// pool, update will be blocked and an ABORTED error will be returned.
    pub etag: std::string::String,

    /// Enable or disable NCCL fast socket for the node pool.
    pub fast_socket: std::option::Option<crate::model::FastSocket>,

    /// Logging configuration.
    pub logging_config: std::option::Option<crate::model::NodePoolLoggingConfig>,

    /// The resource labels for the node pool to use to annotate any related
    /// Google Compute Engine resources.
    pub resource_labels: std::option::Option<crate::model::ResourceLabels>,

    /// Parameters that can be configured on Windows nodes.
    pub windows_node_config: std::option::Option<crate::model::WindowsNodeConfig>,

    /// A list of hardware accelerators to be attached to each node.
    /// See
    /// <https://cloud.google.com/compute/docs/gpus>
    /// for more information about support for GPUs.
    pub accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Optional. The desired [Google Compute Engine machine
    /// type](https://cloud.google.com/compute/docs/machine-types)
    /// for nodes in the node pool. Initiates an upgrade operation that migrates
    /// the nodes in the node pool to the specified machine type.
    pub machine_type: std::string::String,

    /// Optional. The desired disk type (e.g. 'pd-standard', 'pd-ssd' or
    /// 'pd-balanced') for nodes in the node pool.
    /// Initiates an upgrade operation that migrates the nodes in the
    /// node pool to the specified disk type.
    pub disk_type: std::string::String,

    /// Optional. The desired disk size for nodes in the node pool specified in GB.
    /// The smallest allowed disk size is 10GB.
    /// Initiates an upgrade operation that migrates the nodes in the
    /// node pool to the specified disk size.
    pub disk_size_gb: i64,

    /// Desired resource manager tag keys and values to be attached to the nodes
    /// for managing Compute Engine firewalls using Network Firewall Policies.
    /// Existing tags will be replaced with new values.
    pub resource_manager_tags: std::option::Option<crate::model::ResourceManagerTags>,

    /// The desired containerd config for nodes in the node pool.
    /// Initiates an upgrade operation that recreates the nodes with the new
    /// config.
    pub containerd_config: std::option::Option<crate::model::ContainerdConfig>,

    /// Specifies the configuration of queued provisioning.
    pub queued_provisioning: std::option::Option<crate::model::node_pool::QueuedProvisioning>,

    /// List of Storage Pools where boot disks are provisioned.
    /// Existing Storage Pools will be replaced with storage-pools.
    pub storage_pools: std::vec::Vec<std::string::String>,

    /// The maximum duration for the nodes to exist.
    /// If unspecified, the nodes can exist indefinitely.
    pub max_run_duration: std::option::Option<wkt::Duration>,

    /// Flex Start flag for enabling Flex Start VM.
    pub flex_start: std::option::Option<bool>,

    /// The desired boot disk config for nodes in the node pool.
    /// Initiates an upgrade operation that migrates the nodes in the
    /// node pool to the specified boot disk config.
    pub boot_disk: std::option::Option<crate::model::BootDisk>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateNodePoolRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::UpdateNodePoolRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::UpdateNodePoolRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::UpdateNodePoolRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [node_version][crate::model::UpdateNodePoolRequest::node_version].
    pub fn set_node_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_version = v.into();
        self
    }

    /// Sets the value of [image_type][crate::model::UpdateNodePoolRequest::image_type].
    pub fn set_image_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_type = v.into();
        self
    }

    /// Sets the value of [name][crate::model::UpdateNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::UpdateNodePoolRequest::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [workload_metadata_config][crate::model::UpdateNodePoolRequest::workload_metadata_config].
    pub fn set_workload_metadata_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadMetadataConfig>,
    {
        self.workload_metadata_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workload_metadata_config][crate::model::UpdateNodePoolRequest::workload_metadata_config].
    pub fn set_or_clear_workload_metadata_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadMetadataConfig>,
    {
        self.workload_metadata_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [upgrade_settings][crate::model::UpdateNodePoolRequest::upgrade_settings].
    pub fn set_upgrade_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::UpgradeSettings>,
    {
        self.upgrade_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upgrade_settings][crate::model::UpdateNodePoolRequest::upgrade_settings].
    pub fn set_or_clear_upgrade_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::UpgradeSettings>,
    {
        self.upgrade_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::UpdateNodePoolRequest::tags].
    pub fn set_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkTags>,
    {
        self.tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tags][crate::model::UpdateNodePoolRequest::tags].
    pub fn set_or_clear_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkTags>,
    {
        self.tags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [taints][crate::model::UpdateNodePoolRequest::taints].
    pub fn set_taints<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeTaints>,
    {
        self.taints = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [taints][crate::model::UpdateNodePoolRequest::taints].
    pub fn set_or_clear_taints<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeTaints>,
    {
        self.taints = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::UpdateNodePoolRequest::labels].
    pub fn set_labels<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeLabels>,
    {
        self.labels = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [labels][crate::model::UpdateNodePoolRequest::labels].
    pub fn set_or_clear_labels<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeLabels>,
    {
        self.labels = v.map(|x| x.into());
        self
    }

    /// Sets the value of [linux_node_config][crate::model::UpdateNodePoolRequest::linux_node_config].
    pub fn set_linux_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LinuxNodeConfig>,
    {
        self.linux_node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [linux_node_config][crate::model::UpdateNodePoolRequest::linux_node_config].
    pub fn set_or_clear_linux_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LinuxNodeConfig>,
    {
        self.linux_node_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kubelet_config][crate::model::UpdateNodePoolRequest::kubelet_config].
    pub fn set_kubelet_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.kubelet_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kubelet_config][crate::model::UpdateNodePoolRequest::kubelet_config].
    pub fn set_or_clear_kubelet_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeKubeletConfig>,
    {
        self.kubelet_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_network_config][crate::model::UpdateNodePoolRequest::node_network_config].
    pub fn set_node_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeNetworkConfig>,
    {
        self.node_network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_network_config][crate::model::UpdateNodePoolRequest::node_network_config].
    pub fn set_or_clear_node_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeNetworkConfig>,
    {
        self.node_network_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gcfs_config][crate::model::UpdateNodePoolRequest::gcfs_config].
    pub fn set_gcfs_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcfsConfig>,
    {
        self.gcfs_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gcfs_config][crate::model::UpdateNodePoolRequest::gcfs_config].
    pub fn set_or_clear_gcfs_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcfsConfig>,
    {
        self.gcfs_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidential_nodes][crate::model::UpdateNodePoolRequest::confidential_nodes].
    pub fn set_confidential_nodes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialNodes>,
    {
        self.confidential_nodes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_nodes][crate::model::UpdateNodePoolRequest::confidential_nodes].
    pub fn set_or_clear_confidential_nodes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialNodes>,
    {
        self.confidential_nodes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gvnic][crate::model::UpdateNodePoolRequest::gvnic].
    pub fn set_gvnic<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VirtualNIC>,
    {
        self.gvnic = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gvnic][crate::model::UpdateNodePoolRequest::gvnic].
    pub fn set_or_clear_gvnic<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VirtualNIC>,
    {
        self.gvnic = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::UpdateNodePoolRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [fast_socket][crate::model::UpdateNodePoolRequest::fast_socket].
    pub fn set_fast_socket<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FastSocket>,
    {
        self.fast_socket = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fast_socket][crate::model::UpdateNodePoolRequest::fast_socket].
    pub fn set_or_clear_fast_socket<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FastSocket>,
    {
        self.fast_socket = v.map(|x| x.into());
        self
    }

    /// Sets the value of [logging_config][crate::model::UpdateNodePoolRequest::logging_config].
    pub fn set_logging_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolLoggingConfig>,
    {
        self.logging_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logging_config][crate::model::UpdateNodePoolRequest::logging_config].
    pub fn set_or_clear_logging_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolLoggingConfig>,
    {
        self.logging_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_labels][crate::model::UpdateNodePoolRequest::resource_labels].
    pub fn set_resource_labels<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceLabels>,
    {
        self.resource_labels = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_labels][crate::model::UpdateNodePoolRequest::resource_labels].
    pub fn set_or_clear_resource_labels<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceLabels>,
    {
        self.resource_labels = v.map(|x| x.into());
        self
    }

    /// Sets the value of [windows_node_config][crate::model::UpdateNodePoolRequest::windows_node_config].
    pub fn set_windows_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WindowsNodeConfig>,
    {
        self.windows_node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [windows_node_config][crate::model::UpdateNodePoolRequest::windows_node_config].
    pub fn set_or_clear_windows_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WindowsNodeConfig>,
    {
        self.windows_node_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [accelerators][crate::model::UpdateNodePoolRequest::accelerators].
    pub fn set_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [machine_type][crate::model::UpdateNodePoolRequest::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::UpdateNodePoolRequest::disk_type].
    pub fn set_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::UpdateNodePoolRequest::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::UpdateNodePoolRequest::resource_manager_tags].
    pub fn set_resource_manager_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceManagerTags>,
    {
        self.resource_manager_tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_manager_tags][crate::model::UpdateNodePoolRequest::resource_manager_tags].
    pub fn set_or_clear_resource_manager_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceManagerTags>,
    {
        self.resource_manager_tags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [containerd_config][crate::model::UpdateNodePoolRequest::containerd_config].
    pub fn set_containerd_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ContainerdConfig>,
    {
        self.containerd_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [containerd_config][crate::model::UpdateNodePoolRequest::containerd_config].
    pub fn set_or_clear_containerd_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ContainerdConfig>,
    {
        self.containerd_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [queued_provisioning][crate::model::UpdateNodePoolRequest::queued_provisioning].
    pub fn set_queued_provisioning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::QueuedProvisioning>,
    {
        self.queued_provisioning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [queued_provisioning][crate::model::UpdateNodePoolRequest::queued_provisioning].
    pub fn set_or_clear_queued_provisioning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::QueuedProvisioning>,
    {
        self.queued_provisioning = v.map(|x| x.into());
        self
    }

    /// Sets the value of [storage_pools][crate::model::UpdateNodePoolRequest::storage_pools].
    pub fn set_storage_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.storage_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [max_run_duration][crate::model::UpdateNodePoolRequest::max_run_duration].
    pub fn set_max_run_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_run_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_run_duration][crate::model::UpdateNodePoolRequest::max_run_duration].
    pub fn set_or_clear_max_run_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_run_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [flex_start][crate::model::UpdateNodePoolRequest::flex_start].
    pub fn set_flex_start<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.flex_start = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [flex_start][crate::model::UpdateNodePoolRequest::flex_start].
    pub fn set_or_clear_flex_start<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.flex_start = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boot_disk][crate::model::UpdateNodePoolRequest::boot_disk].
    pub fn set_boot_disk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BootDisk>,
    {
        self.boot_disk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boot_disk][crate::model::UpdateNodePoolRequest::boot_disk].
    pub fn set_or_clear_boot_disk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BootDisk>,
    {
        self.boot_disk = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpdateNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __node_version,
            __image_type,
            __name,
            __locations,
            __workload_metadata_config,
            __upgrade_settings,
            __tags,
            __taints,
            __labels,
            __linux_node_config,
            __kubelet_config,
            __node_network_config,
            __gcfs_config,
            __confidential_nodes,
            __gvnic,
            __etag,
            __fast_socket,
            __logging_config,
            __resource_labels,
            __windows_node_config,
            __accelerators,
            __machine_type,
            __disk_type,
            __disk_size_gb,
            __resource_manager_tags,
            __containerd_config,
            __queued_provisioning,
            __storage_pools,
            __max_run_duration,
            __flex_start,
            __boot_disk,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "nodeVersion" => Ok(__FieldTag::__node_version),
                            "node_version" => Ok(__FieldTag::__node_version),
                            "imageType" => Ok(__FieldTag::__image_type),
                            "image_type" => Ok(__FieldTag::__image_type),
                            "name" => Ok(__FieldTag::__name),
                            "locations" => Ok(__FieldTag::__locations),
                            "workloadMetadataConfig" => Ok(__FieldTag::__workload_metadata_config),
                            "workload_metadata_config" => {
                                Ok(__FieldTag::__workload_metadata_config)
                            }
                            "upgradeSettings" => Ok(__FieldTag::__upgrade_settings),
                            "upgrade_settings" => Ok(__FieldTag::__upgrade_settings),
                            "tags" => Ok(__FieldTag::__tags),
                            "taints" => Ok(__FieldTag::__taints),
                            "labels" => Ok(__FieldTag::__labels),
                            "linuxNodeConfig" => Ok(__FieldTag::__linux_node_config),
                            "linux_node_config" => Ok(__FieldTag::__linux_node_config),
                            "kubeletConfig" => Ok(__FieldTag::__kubelet_config),
                            "kubelet_config" => Ok(__FieldTag::__kubelet_config),
                            "nodeNetworkConfig" => Ok(__FieldTag::__node_network_config),
                            "node_network_config" => Ok(__FieldTag::__node_network_config),
                            "gcfsConfig" => Ok(__FieldTag::__gcfs_config),
                            "gcfs_config" => Ok(__FieldTag::__gcfs_config),
                            "confidentialNodes" => Ok(__FieldTag::__confidential_nodes),
                            "confidential_nodes" => Ok(__FieldTag::__confidential_nodes),
                            "gvnic" => Ok(__FieldTag::__gvnic),
                            "etag" => Ok(__FieldTag::__etag),
                            "fastSocket" => Ok(__FieldTag::__fast_socket),
                            "fast_socket" => Ok(__FieldTag::__fast_socket),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "resourceLabels" => Ok(__FieldTag::__resource_labels),
                            "resource_labels" => Ok(__FieldTag::__resource_labels),
                            "windowsNodeConfig" => Ok(__FieldTag::__windows_node_config),
                            "windows_node_config" => Ok(__FieldTag::__windows_node_config),
                            "accelerators" => Ok(__FieldTag::__accelerators),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "resourceManagerTags" => Ok(__FieldTag::__resource_manager_tags),
                            "resource_manager_tags" => Ok(__FieldTag::__resource_manager_tags),
                            "containerdConfig" => Ok(__FieldTag::__containerd_config),
                            "containerd_config" => Ok(__FieldTag::__containerd_config),
                            "queuedProvisioning" => Ok(__FieldTag::__queued_provisioning),
                            "queued_provisioning" => Ok(__FieldTag::__queued_provisioning),
                            "storagePools" => Ok(__FieldTag::__storage_pools),
                            "storage_pools" => Ok(__FieldTag::__storage_pools),
                            "maxRunDuration" => Ok(__FieldTag::__max_run_duration),
                            "max_run_duration" => Ok(__FieldTag::__max_run_duration),
                            "flexStart" => Ok(__FieldTag::__flex_start),
                            "flex_start" => Ok(__FieldTag::__flex_start),
                            "bootDisk" => Ok(__FieldTag::__boot_disk),
                            "boot_disk" => Ok(__FieldTag::__boot_disk),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_version => {
                            if !fields.insert(__FieldTag::__node_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_version",
                                ));
                            }
                            result.node_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_type => {
                            if !fields.insert(__FieldTag::__image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_type",
                                ));
                            }
                            result.image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__workload_metadata_config => {
                            if !fields.insert(__FieldTag::__workload_metadata_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_metadata_config",
                                ));
                            }
                            result.workload_metadata_config = map.next_value::<std::option::Option<crate::model::WorkloadMetadataConfig>>()?
                                ;
                        }
                        __FieldTag::__upgrade_settings => {
                            if !fields.insert(__FieldTag::__upgrade_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_settings",
                                ));
                            }
                            result.upgrade_settings = map.next_value::<std::option::Option<crate::model::node_pool::UpgradeSettings>>()?
                                ;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags =
                                map.next_value::<std::option::Option<crate::model::NetworkTags>>()?;
                        }
                        __FieldTag::__taints => {
                            if !fields.insert(__FieldTag::__taints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taints",
                                ));
                            }
                            result.taints =
                                map.next_value::<std::option::Option<crate::model::NodeTaints>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels =
                                map.next_value::<std::option::Option<crate::model::NodeLabels>>()?;
                        }
                        __FieldTag::__linux_node_config => {
                            if !fields.insert(__FieldTag::__linux_node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linux_node_config",
                                ));
                            }
                            result.linux_node_config = map
                                .next_value::<std::option::Option<crate::model::LinuxNodeConfig>>(
                                )?;
                        }
                        __FieldTag::__kubelet_config => {
                            if !fields.insert(__FieldTag::__kubelet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubelet_config",
                                ));
                            }
                            result.kubelet_config = map
                                .next_value::<std::option::Option<crate::model::NodeKubeletConfig>>(
                                )?;
                        }
                        __FieldTag::__node_network_config => {
                            if !fields.insert(__FieldTag::__node_network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_network_config",
                                ));
                            }
                            result.node_network_config = map
                                .next_value::<std::option::Option<crate::model::NodeNetworkConfig>>(
                                )?;
                        }
                        __FieldTag::__gcfs_config => {
                            if !fields.insert(__FieldTag::__gcfs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcfs_config",
                                ));
                            }
                            result.gcfs_config =
                                map.next_value::<std::option::Option<crate::model::GcfsConfig>>()?;
                        }
                        __FieldTag::__confidential_nodes => {
                            if !fields.insert(__FieldTag::__confidential_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidential_nodes",
                                ));
                            }
                            result.confidential_nodes = map
                                .next_value::<std::option::Option<crate::model::ConfidentialNodes>>(
                                )?;
                        }
                        __FieldTag::__gvnic => {
                            if !fields.insert(__FieldTag::__gvnic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gvnic",
                                ));
                            }
                            result.gvnic =
                                map.next_value::<std::option::Option<crate::model::VirtualNIC>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fast_socket => {
                            if !fields.insert(__FieldTag::__fast_socket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fast_socket",
                                ));
                            }
                            result.fast_socket =
                                map.next_value::<std::option::Option<crate::model::FastSocket>>()?;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map.next_value::<std::option::Option<crate::model::NodePoolLoggingConfig>>()?
                                ;
                        }
                        __FieldTag::__resource_labels => {
                            if !fields.insert(__FieldTag::__resource_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_labels",
                                ));
                            }
                            result.resource_labels = map
                                .next_value::<std::option::Option<crate::model::ResourceLabels>>(
                                )?;
                        }
                        __FieldTag::__windows_node_config => {
                            if !fields.insert(__FieldTag::__windows_node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_node_config",
                                ));
                            }
                            result.windows_node_config = map
                                .next_value::<std::option::Option<crate::model::WindowsNodeConfig>>(
                                )?;
                        }
                        __FieldTag::__accelerators => {
                            if !fields.insert(__FieldTag::__accelerators) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerators",
                                ));
                            }
                            result.accelerators =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AcceleratorConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__resource_manager_tags => {
                            if !fields.insert(__FieldTag::__resource_manager_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_manager_tags",
                                ));
                            }
                            result.resource_manager_tags = map.next_value::<std::option::Option<crate::model::ResourceManagerTags>>()?
                                ;
                        }
                        __FieldTag::__containerd_config => {
                            if !fields.insert(__FieldTag::__containerd_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containerd_config",
                                ));
                            }
                            result.containerd_config = map
                                .next_value::<std::option::Option<crate::model::ContainerdConfig>>(
                                )?;
                        }
                        __FieldTag::__queued_provisioning => {
                            if !fields.insert(__FieldTag::__queued_provisioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queued_provisioning",
                                ));
                            }
                            result.queued_provisioning =
                                map.next_value::<std::option::Option<
                                    crate::model::node_pool::QueuedProvisioning,
                                >>()?;
                        }
                        __FieldTag::__storage_pools => {
                            if !fields.insert(__FieldTag::__storage_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_pools",
                                ));
                            }
                            result.storage_pools = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__max_run_duration => {
                            if !fields.insert(__FieldTag::__max_run_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_run_duration",
                                ));
                            }
                            result.max_run_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__flex_start => {
                            if !fields.insert(__FieldTag::__flex_start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flex_start",
                                ));
                            }
                            result.flex_start = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__boot_disk => {
                            if !fields.insert(__FieldTag::__boot_disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk",
                                ));
                            }
                            result.boot_disk =
                                map.next_value::<std::option::Option<crate::model::BootDisk>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !self.node_version.is_empty() {
            state.serialize_entry("nodeVersion", &self.node_version)?;
        }
        if !self.image_type.is_empty() {
            state.serialize_entry("imageType", &self.image_type)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if self.workload_metadata_config.is_some() {
            state.serialize_entry("workloadMetadataConfig", &self.workload_metadata_config)?;
        }
        if self.upgrade_settings.is_some() {
            state.serialize_entry("upgradeSettings", &self.upgrade_settings)?;
        }
        if self.tags.is_some() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if self.taints.is_some() {
            state.serialize_entry("taints", &self.taints)?;
        }
        if self.labels.is_some() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.linux_node_config.is_some() {
            state.serialize_entry("linuxNodeConfig", &self.linux_node_config)?;
        }
        if self.kubelet_config.is_some() {
            state.serialize_entry("kubeletConfig", &self.kubelet_config)?;
        }
        if self.node_network_config.is_some() {
            state.serialize_entry("nodeNetworkConfig", &self.node_network_config)?;
        }
        if self.gcfs_config.is_some() {
            state.serialize_entry("gcfsConfig", &self.gcfs_config)?;
        }
        if self.confidential_nodes.is_some() {
            state.serialize_entry("confidentialNodes", &self.confidential_nodes)?;
        }
        if self.gvnic.is_some() {
            state.serialize_entry("gvnic", &self.gvnic)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.fast_socket.is_some() {
            state.serialize_entry("fastSocket", &self.fast_socket)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.resource_labels.is_some() {
            state.serialize_entry("resourceLabels", &self.resource_labels)?;
        }
        if self.windows_node_config.is_some() {
            state.serialize_entry("windowsNodeConfig", &self.windows_node_config)?;
        }
        if !self.accelerators.is_empty() {
            state.serialize_entry("accelerators", &self.accelerators)?;
        }
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self.disk_type.is_empty() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !wkt::internal::is_default(&self.disk_size_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.resource_manager_tags.is_some() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if self.containerd_config.is_some() {
            state.serialize_entry("containerdConfig", &self.containerd_config)?;
        }
        if self.queued_provisioning.is_some() {
            state.serialize_entry("queuedProvisioning", &self.queued_provisioning)?;
        }
        if !self.storage_pools.is_empty() {
            state.serialize_entry("storagePools", &self.storage_pools)?;
        }
        if self.max_run_duration.is_some() {
            state.serialize_entry("maxRunDuration", &self.max_run_duration)?;
        }
        if self.flex_start.is_some() {
            state.serialize_entry("flexStart", &self.flex_start)?;
        }
        if self.boot_disk.is_some() {
            state.serialize_entry("bootDisk", &self.boot_disk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateNodePoolRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("node_version", &self.node_version);
        debug_struct.field("image_type", &self.image_type);
        debug_struct.field("name", &self.name);
        debug_struct.field("locations", &self.locations);
        debug_struct.field("workload_metadata_config", &self.workload_metadata_config);
        debug_struct.field("upgrade_settings", &self.upgrade_settings);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("taints", &self.taints);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("linux_node_config", &self.linux_node_config);
        debug_struct.field("kubelet_config", &self.kubelet_config);
        debug_struct.field("node_network_config", &self.node_network_config);
        debug_struct.field("gcfs_config", &self.gcfs_config);
        debug_struct.field("confidential_nodes", &self.confidential_nodes);
        debug_struct.field("gvnic", &self.gvnic);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("fast_socket", &self.fast_socket);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("resource_labels", &self.resource_labels);
        debug_struct.field("windows_node_config", &self.windows_node_config);
        debug_struct.field("accelerators", &self.accelerators);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field("resource_manager_tags", &self.resource_manager_tags);
        debug_struct.field("containerd_config", &self.containerd_config);
        debug_struct.field("queued_provisioning", &self.queued_provisioning);
        debug_struct.field("storage_pools", &self.storage_pools);
        debug_struct.field("max_run_duration", &self.max_run_duration);
        debug_struct.field("flex_start", &self.flex_start);
        debug_struct.field("boot_disk", &self.boot_disk);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SetNodePoolAutoscalingRequest sets the autoscaler settings of a node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetNodePoolAutoscalingRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// Required. Autoscaling configuration for the node pool.
    pub autoscaling: std::option::Option<crate::model::NodePoolAutoscaling>,

    /// The name (project, location, cluster, node pool) of the node pool to set
    /// autoscaler settings. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetNodePoolAutoscalingRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetNodePoolAutoscalingRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetNodePoolAutoscalingRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetNodePoolAutoscalingRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::SetNodePoolAutoscalingRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [autoscaling][crate::model::SetNodePoolAutoscalingRequest::autoscaling].
    pub fn set_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolAutoscaling>,
    {
        self.autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling][crate::model::SetNodePoolAutoscalingRequest::autoscaling].
    pub fn set_or_clear_autoscaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolAutoscaling>,
    {
        self.autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::SetNodePoolAutoscalingRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetNodePoolAutoscalingRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetNodePoolAutoscalingRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetNodePoolAutoscalingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __autoscaling,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetNodePoolAutoscalingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "autoscaling" => Ok(__FieldTag::__autoscaling),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetNodePoolAutoscalingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetNodePoolAutoscalingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autoscaling => {
                            if !fields.insert(__FieldTag::__autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling",
                                ));
                            }
                            result.autoscaling = map.next_value::<std::option::Option<crate::model::NodePoolAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetNodePoolAutoscalingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if self.autoscaling.is_some() {
            state.serialize_entry("autoscaling", &self.autoscaling)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetNodePoolAutoscalingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetNodePoolAutoscalingRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("autoscaling", &self.autoscaling);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SetLoggingServiceRequest sets the logging service of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetLoggingServiceRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The logging service the cluster should use to write logs.
    /// Currently available options:
    ///
    /// * `logging.googleapis.com/kubernetes` - The Cloud Logging
    ///   service with a Kubernetes-native resource model
    /// * `logging.googleapis.com` - The legacy Cloud Logging service (no longer
    ///   available as of GKE 1.15).
    /// * `none` - no logs will be exported from the cluster.
    ///
    /// If left as an empty string,`logging.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `logging.googleapis.com` for earlier versions.
    pub logging_service: std::string::String,

    /// The name (project, location, cluster) of the cluster to set logging.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetLoggingServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetLoggingServiceRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetLoggingServiceRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetLoggingServiceRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [logging_service][crate::model::SetLoggingServiceRequest::logging_service].
    pub fn set_logging_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.logging_service = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetLoggingServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetLoggingServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetLoggingServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetLoggingServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __logging_service,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetLoggingServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "loggingService" => Ok(__FieldTag::__logging_service),
                            "logging_service" => Ok(__FieldTag::__logging_service),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetLoggingServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetLoggingServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_service => {
                            if !fields.insert(__FieldTag::__logging_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_service",
                                ));
                            }
                            result.logging_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetLoggingServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.logging_service.is_empty() {
            state.serialize_entry("loggingService", &self.logging_service)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetLoggingServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetLoggingServiceRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("logging_service", &self.logging_service);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SetMonitoringServiceRequest sets the monitoring service of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetMonitoringServiceRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The monitoring service the cluster should use to write metrics.
    /// Currently available options:
    ///
    /// * `monitoring.googleapis.com/kubernetes` - The Cloud Monitoring
    ///   service with a Kubernetes-native resource model
    /// * `monitoring.googleapis.com` - The legacy Cloud Monitoring service (no
    ///   longer available as of GKE 1.15).
    /// * `none` - No metrics will be exported from the cluster.
    ///
    /// If left as an empty string,`monitoring.googleapis.com/kubernetes` will be
    /// used for GKE 1.14+ or `monitoring.googleapis.com` for earlier versions.
    pub monitoring_service: std::string::String,

    /// The name (project, location, cluster) of the cluster to set monitoring.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetMonitoringServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetMonitoringServiceRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetMonitoringServiceRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetMonitoringServiceRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [monitoring_service][crate::model::SetMonitoringServiceRequest::monitoring_service].
    pub fn set_monitoring_service<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.monitoring_service = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetMonitoringServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetMonitoringServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetMonitoringServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetMonitoringServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __monitoring_service,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetMonitoringServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "monitoringService" => Ok(__FieldTag::__monitoring_service),
                            "monitoring_service" => Ok(__FieldTag::__monitoring_service),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetMonitoringServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetMonitoringServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monitoring_service => {
                            if !fields.insert(__FieldTag::__monitoring_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitoring_service",
                                ));
                            }
                            result.monitoring_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetMonitoringServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.monitoring_service.is_empty() {
            state.serialize_entry("monitoringService", &self.monitoring_service)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetMonitoringServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetMonitoringServiceRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("monitoring_service", &self.monitoring_service);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SetAddonsConfigRequest sets the addons associated with the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetAddonsConfigRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The desired configurations for the various addons available to
    /// run in the cluster.
    pub addons_config: std::option::Option<crate::model::AddonsConfig>,

    /// The name (project, location, cluster) of the cluster to set addons.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetAddonsConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetAddonsConfigRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetAddonsConfigRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetAddonsConfigRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [addons_config][crate::model::SetAddonsConfigRequest::addons_config].
    pub fn set_addons_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AddonsConfig>,
    {
        self.addons_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [addons_config][crate::model::SetAddonsConfigRequest::addons_config].
    pub fn set_or_clear_addons_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AddonsConfig>,
    {
        self.addons_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::SetAddonsConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetAddonsConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetAddonsConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetAddonsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __addons_config,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetAddonsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "addonsConfig" => Ok(__FieldTag::__addons_config),
                            "addons_config" => Ok(__FieldTag::__addons_config),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetAddonsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetAddonsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__addons_config => {
                            if !fields.insert(__FieldTag::__addons_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for addons_config",
                                ));
                            }
                            result.addons_config = map
                                .next_value::<std::option::Option<crate::model::AddonsConfig>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetAddonsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.addons_config.is_some() {
            state.serialize_entry("addonsConfig", &self.addons_config)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetAddonsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetAddonsConfigRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("addons_config", &self.addons_config);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SetLocationsRequest sets the locations of the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetLocationsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The desired list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster's nodes should be located. Changing the locations a
    /// cluster is in will result in nodes being either created or removed from the
    /// cluster, depending on whether locations are being added or removed.
    ///
    /// This list must always include the cluster's primary zone.
    pub locations: std::vec::Vec<std::string::String>,

    /// The name (project, location, cluster) of the cluster to set locations.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetLocationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetLocationsRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetLocationsRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetLocationsRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::SetLocationsRequest::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [name][crate::model::SetLocationsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetLocationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetLocationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetLocationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __locations,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetLocationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "locations" => Ok(__FieldTag::__locations),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetLocationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetLocationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetLocationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetLocationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetLocationsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("locations", &self.locations);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpdateMasterRequest updates the master of the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateMasterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The Kubernetes version to change the master to.
    ///
    /// Users may specify either explicit versions offered by Kubernetes Engine or
    /// version aliases, which have the following behavior:
    ///
    /// - "latest": picks the highest valid Kubernetes version
    /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
    /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
    /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
    /// - "-": picks the default Kubernetes version
    pub master_version: std::string::String,

    /// The name (project, location, cluster) of the cluster to update.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMasterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::UpdateMasterRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::UpdateMasterRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::UpdateMasterRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [master_version][crate::model::UpdateMasterRequest::master_version].
    pub fn set_master_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.master_version = v.into();
        self
    }

    /// Sets the value of [name][crate::model::UpdateMasterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UpdateMasterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpdateMasterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateMasterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __master_version,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateMasterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "masterVersion" => Ok(__FieldTag::__master_version),
                            "master_version" => Ok(__FieldTag::__master_version),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateMasterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateMasterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__master_version => {
                            if !fields.insert(__FieldTag::__master_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_version",
                                ));
                            }
                            result.master_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateMasterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.master_version.is_empty() {
            state.serialize_entry("masterVersion", &self.master_version)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateMasterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateMasterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("master_version", &self.master_version);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SetMasterAuthRequest updates the admin password of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetMasterAuthRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to upgrade.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The exact form of action to be taken on the master auth.
    pub action: crate::model::set_master_auth_request::Action,

    /// Required. A description of the update.
    pub update: std::option::Option<crate::model::MasterAuth>,

    /// The name (project, location, cluster) of the cluster to set auth.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetMasterAuthRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetMasterAuthRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetMasterAuthRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetMasterAuthRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [action][crate::model::SetMasterAuthRequest::action].
    pub fn set_action<T: std::convert::Into<crate::model::set_master_auth_request::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [update][crate::model::SetMasterAuthRequest::update].
    pub fn set_update<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MasterAuth>,
    {
        self.update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update][crate::model::SetMasterAuthRequest::update].
    pub fn set_or_clear_update<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MasterAuth>,
    {
        self.update = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::SetMasterAuthRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetMasterAuthRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetMasterAuthRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetMasterAuthRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __action,
            __update,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetMasterAuthRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "action" => Ok(__FieldTag::__action),
                            "update" => Ok(__FieldTag::__update),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetMasterAuthRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetMasterAuthRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action =
                                map.next_value::<std::option::Option<
                                    crate::model::set_master_auth_request::Action,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update => {
                            if !fields.insert(__FieldTag::__update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update",
                                ));
                            }
                            result.update =
                                map.next_value::<std::option::Option<crate::model::MasterAuth>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetMasterAuthRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !wkt::internal::is_default(&self.action) {
            state.serialize_entry("action", &self.action)?;
        }
        if self.update.is_some() {
            state.serialize_entry("update", &self.update)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetMasterAuthRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetMasterAuthRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("action", &self.action);
        debug_struct.field("update", &self.update);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SetMasterAuthRequest].
pub mod set_master_auth_request {
    #[allow(unused_imports)]
    use super::*;

    /// Operation type: what type update to perform.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// Operation is unknown and will error out.
        Unknown,
        /// Set the password to a user generated value.
        SetPassword,
        /// Generate a new password and set it to that.
        GeneratePassword,
        /// Set the username.  If an empty username is provided, basic authentication
        /// is disabled for the cluster.  If a non-empty username is provided, basic
        /// authentication is enabled, with either a provided password or a generated
        /// one.
        SetUsername,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Action::value] or
        /// [Action::name].
        UnknownValue(action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Action {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::SetPassword => std::option::Option::Some(1),
                Self::GeneratePassword => std::option::Option::Some(2),
                Self::SetUsername => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::SetPassword => std::option::Option::Some("SET_PASSWORD"),
                Self::GeneratePassword => std::option::Option::Some("GENERATE_PASSWORD"),
                Self::SetUsername => std::option::Option::Some("SET_USERNAME"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Action {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::SetPassword,
                2 => Self::GeneratePassword,
                3 => Self::SetUsername,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Action {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "SET_PASSWORD" => Self::SetPassword,
                "GENERATE_PASSWORD" => Self::GeneratePassword,
                "SET_USERNAME" => Self::SetUsername,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::SetPassword => serializer.serialize_i32(1),
                Self::GeneratePassword => serializer.serialize_i32(2),
                Self::SetUsername => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
                ".google.container.v1.SetMasterAuthRequest.Action",
            ))
        }
    }
}

/// DeleteClusterRequest deletes a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to delete.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// The name (project, location, cluster) of the cluster to delete.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteClusterRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::DeleteClusterRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::DeleteClusterRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DeleteClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListClustersRequest lists clusters.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides, or "-" for all zones. This field has been
    /// deprecated and replaced by the parent field.
    #[deprecated]
    pub zone: std::string::String,

    /// The parent (project and location) where the clusters will be listed.
    /// Specified in the format `projects/*/locations/*`.
    /// Location "-" matches all zones and all regions.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListClustersRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ListClustersRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListClustersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListClustersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListClustersRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListClustersResponse is the result of ListClustersRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// A list of clusters in the project in the specified zone, or
    /// across all ones.
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// If any zones are listed here, the list of clusters returned
    /// may be missing those zones.
    pub missing_zones: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [missing_zones][crate::model::ListClustersResponse::missing_zones].
    pub fn set_missing_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.missing_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListClustersResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clusters,
            __missing_zones,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusters" => Ok(__FieldTag::__clusters),
                            "missingZones" => Ok(__FieldTag::__missing_zones),
                            "missing_zones" => Ok(__FieldTag::__missing_zones),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clusters => {
                            if !fields.insert(__FieldTag::__clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clusters",
                                ));
                            }
                            result.clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Cluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__missing_zones => {
                            if !fields.insert(__FieldTag::__missing_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for missing_zones",
                                ));
                            }
                            result.missing_zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.clusters.is_empty() {
            state.serialize_entry("clusters", &self.clusters)?;
        }
        if !self.missing_zones.is_empty() {
            state.serialize_entry("missingZones", &self.missing_zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListClustersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListClustersResponse");
        debug_struct.field("clusters", &self.clusters);
        debug_struct.field("missing_zones", &self.missing_zones);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetOperationRequest gets a single operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOperationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The server-assigned `name` of the operation.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub operation_id: std::string::String,

    /// The name (project, location, operation id) of the operation to get.
    /// Specified in the format `projects/*/locations/*/operations/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetOperationRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::GetOperationRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [operation_id][crate::model::GetOperationRequest::operation_id].
    #[deprecated]
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::GetOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __operation_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "operationId" => Ok(__FieldTag::__operation_id),
                            "operation_id" => Ok(__FieldTag::__operation_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation_id => {
                            if !fields.insert(__FieldTag::__operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_id",
                                ));
                            }
                            result.operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.operation_id.is_empty() {
            state.serialize_entry("operationId", &self.operation_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetOperationRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("operation_id", &self.operation_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListOperationsRequest lists operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOperationsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// to return operations for, or `-` for all zones. This field has been
    /// deprecated and replaced by the parent field.
    #[deprecated]
    pub zone: std::string::String,

    /// The parent (project and location) where the operations will be listed.
    /// Specified in the format `projects/*/locations/*`.
    /// Location "-" matches all zones and all regions.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOperationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListOperationsRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ListOperationsRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::ListOperationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListOperationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListOperationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOperationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOperationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOperationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOperationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOperationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListOperationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOperationsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CancelOperationRequest cancels a single operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelOperationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the operation resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The server-assigned `name` of the operation.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub operation_id: std::string::String,

    /// The name (project, location, operation id) of the operation to cancel.
    /// Specified in the format `projects/*/locations/*/operations/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelOperationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CancelOperationRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CancelOperationRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [operation_id][crate::model::CancelOperationRequest::operation_id].
    #[deprecated]
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::CancelOperationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelOperationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CancelOperationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __operation_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "operationId" => Ok(__FieldTag::__operation_id),
                            "operation_id" => Ok(__FieldTag::__operation_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation_id => {
                            if !fields.insert(__FieldTag::__operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_id",
                                ));
                            }
                            result.operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.operation_id.is_empty() {
            state.serialize_entry("operationId", &self.operation_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelOperationRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("operation_id", &self.operation_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListOperationsResponse is the result of ListOperationsRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListOperationsResponse {
    /// A list of operations in the project in the specified zone.
    pub operations: std::vec::Vec<crate::model::Operation>,

    /// If any zones are listed here, the list of operations returned
    /// may be missing the operations from those zones.
    pub missing_zones: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListOperationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operations][crate::model::ListOperationsResponse::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [missing_zones][crate::model::ListOperationsResponse::missing_zones].
    pub fn set_missing_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.missing_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListOperationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListOperationsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListOperationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operations,
            __missing_zones,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOperationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operations" => Ok(__FieldTag::__operations),
                            "missingZones" => Ok(__FieldTag::__missing_zones),
                            "missing_zones" => Ok(__FieldTag::__missing_zones),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListOperationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOperationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operations => {
                            if !fields.insert(__FieldTag::__operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations",
                                ));
                            }
                            result.operations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Operation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__missing_zones => {
                            if !fields.insert(__FieldTag::__missing_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for missing_zones",
                                ));
                            }
                            result.missing_zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListOperationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operations.is_empty() {
            state.serialize_entry("operations", &self.operations)?;
        }
        if !self.missing_zones.is_empty() {
            state.serialize_entry("missingZones", &self.missing_zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListOperationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOperationsResponse");
        debug_struct.field("operations", &self.operations);
        debug_struct.field("missing_zones", &self.missing_zones);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Gets the current Kubernetes Engine service configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServerConfigRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// to return operations for. This field has been deprecated and replaced by
    /// the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// The name (project and location) of the server config to get,
    /// specified in the format `projects/*/locations/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServerConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetServerConfigRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::GetServerConfigRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [name][crate::model::GetServerConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServerConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetServerConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServerConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServerConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServerConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServerConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServerConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetServerConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetServerConfigRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Kubernetes Engine service configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServerConfig {
    /// Version of Kubernetes the service deploys by default.
    pub default_cluster_version: std::string::String,

    /// List of valid node upgrade target versions, in descending order.
    pub valid_node_versions: std::vec::Vec<std::string::String>,

    /// Default image type.
    pub default_image_type: std::string::String,

    /// List of valid image types.
    pub valid_image_types: std::vec::Vec<std::string::String>,

    /// List of valid master versions, in descending order.
    pub valid_master_versions: std::vec::Vec<std::string::String>,

    /// List of release channel configurations.
    pub channels: std::vec::Vec<crate::model::server_config::ReleaseChannelConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_cluster_version][crate::model::ServerConfig::default_cluster_version].
    pub fn set_default_cluster_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_cluster_version = v.into();
        self
    }

    /// Sets the value of [valid_node_versions][crate::model::ServerConfig::valid_node_versions].
    pub fn set_valid_node_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.valid_node_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_image_type][crate::model::ServerConfig::default_image_type].
    pub fn set_default_image_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_image_type = v.into();
        self
    }

    /// Sets the value of [valid_image_types][crate::model::ServerConfig::valid_image_types].
    pub fn set_valid_image_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.valid_image_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [valid_master_versions][crate::model::ServerConfig::valid_master_versions].
    pub fn set_valid_master_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.valid_master_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [channels][crate::model::ServerConfig::channels].
    pub fn set_channels<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::server_config::ReleaseChannelConfig>,
    {
        use std::iter::Iterator;
        self.channels = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ServerConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __default_cluster_version,
            __valid_node_versions,
            __default_image_type,
            __valid_image_types,
            __valid_master_versions,
            __channels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "defaultClusterVersion" => Ok(__FieldTag::__default_cluster_version),
                            "default_cluster_version" => Ok(__FieldTag::__default_cluster_version),
                            "validNodeVersions" => Ok(__FieldTag::__valid_node_versions),
                            "valid_node_versions" => Ok(__FieldTag::__valid_node_versions),
                            "defaultImageType" => Ok(__FieldTag::__default_image_type),
                            "default_image_type" => Ok(__FieldTag::__default_image_type),
                            "validImageTypes" => Ok(__FieldTag::__valid_image_types),
                            "valid_image_types" => Ok(__FieldTag::__valid_image_types),
                            "validMasterVersions" => Ok(__FieldTag::__valid_master_versions),
                            "valid_master_versions" => Ok(__FieldTag::__valid_master_versions),
                            "channels" => Ok(__FieldTag::__channels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__default_cluster_version => {
                            if !fields.insert(__FieldTag::__default_cluster_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_cluster_version",
                                ));
                            }
                            result.default_cluster_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__valid_node_versions => {
                            if !fields.insert(__FieldTag::__valid_node_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid_node_versions",
                                ));
                            }
                            result.valid_node_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_image_type => {
                            if !fields.insert(__FieldTag::__default_image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_image_type",
                                ));
                            }
                            result.default_image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__valid_image_types => {
                            if !fields.insert(__FieldTag::__valid_image_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid_image_types",
                                ));
                            }
                            result.valid_image_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__valid_master_versions => {
                            if !fields.insert(__FieldTag::__valid_master_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid_master_versions",
                                ));
                            }
                            result.valid_master_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__channels => {
                            if !fields.insert(__FieldTag::__channels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channels",
                                ));
                            }
                            result.channels = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::server_config::ReleaseChannelConfig,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.default_cluster_version.is_empty() {
            state.serialize_entry("defaultClusterVersion", &self.default_cluster_version)?;
        }
        if !self.valid_node_versions.is_empty() {
            state.serialize_entry("validNodeVersions", &self.valid_node_versions)?;
        }
        if !self.default_image_type.is_empty() {
            state.serialize_entry("defaultImageType", &self.default_image_type)?;
        }
        if !self.valid_image_types.is_empty() {
            state.serialize_entry("validImageTypes", &self.valid_image_types)?;
        }
        if !self.valid_master_versions.is_empty() {
            state.serialize_entry("validMasterVersions", &self.valid_master_versions)?;
        }
        if !self.channels.is_empty() {
            state.serialize_entry("channels", &self.channels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ServerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServerConfig");
        debug_struct.field("default_cluster_version", &self.default_cluster_version);
        debug_struct.field("valid_node_versions", &self.valid_node_versions);
        debug_struct.field("default_image_type", &self.default_image_type);
        debug_struct.field("valid_image_types", &self.valid_image_types);
        debug_struct.field("valid_master_versions", &self.valid_master_versions);
        debug_struct.field("channels", &self.channels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ServerConfig].
pub mod server_config {
    #[allow(unused_imports)]
    use super::*;

    /// ReleaseChannelConfig exposes configuration for a release channel.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReleaseChannelConfig {
        /// The release channel this configuration applies to.
        pub channel: crate::model::release_channel::Channel,

        /// The default version for newly created clusters on the channel.
        pub default_version: std::string::String,

        /// List of valid versions for the channel.
        pub valid_versions: std::vec::Vec<std::string::String>,

        /// The auto upgrade target version for clusters on the channel.
        pub upgrade_target_version: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReleaseChannelConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [channel][crate::model::server_config::ReleaseChannelConfig::channel].
        pub fn set_channel<T: std::convert::Into<crate::model::release_channel::Channel>>(
            mut self,
            v: T,
        ) -> Self {
            self.channel = v.into();
            self
        }

        /// Sets the value of [default_version][crate::model::server_config::ReleaseChannelConfig::default_version].
        pub fn set_default_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.default_version = v.into();
            self
        }

        /// Sets the value of [valid_versions][crate::model::server_config::ReleaseChannelConfig::valid_versions].
        pub fn set_valid_versions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.valid_versions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [upgrade_target_version][crate::model::server_config::ReleaseChannelConfig::upgrade_target_version].
        pub fn set_upgrade_target_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.upgrade_target_version = v.into();
            self
        }
    }

    impl wkt::message::Message for ReleaseChannelConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ServerConfig.ReleaseChannelConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReleaseChannelConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __channel,
                __default_version,
                __valid_versions,
                __upgrade_target_version,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReleaseChannelConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "channel" => Ok(__FieldTag::__channel),
                                "defaultVersion" => Ok(__FieldTag::__default_version),
                                "default_version" => Ok(__FieldTag::__default_version),
                                "validVersions" => Ok(__FieldTag::__valid_versions),
                                "valid_versions" => Ok(__FieldTag::__valid_versions),
                                "upgradeTargetVersion" => Ok(__FieldTag::__upgrade_target_version),
                                "upgrade_target_version" => {
                                    Ok(__FieldTag::__upgrade_target_version)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReleaseChannelConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReleaseChannelConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__channel => {
                                if !fields.insert(__FieldTag::__channel) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for channel",
                                    ));
                                }
                                result.channel = map.next_value::<std::option::Option<crate::model::release_channel::Channel>>()?.unwrap_or_default();
                            }
                            __FieldTag::__default_version => {
                                if !fields.insert(__FieldTag::__default_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for default_version",
                                    ));
                                }
                                result.default_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__valid_versions => {
                                if !fields.insert(__FieldTag::__valid_versions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for valid_versions",
                                    ));
                                }
                                result.valid_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__upgrade_target_version => {
                                if !fields.insert(__FieldTag::__upgrade_target_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for upgrade_target_version",
                                    ));
                                }
                                result.upgrade_target_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReleaseChannelConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.channel) {
                state.serialize_entry("channel", &self.channel)?;
            }
            if !self.default_version.is_empty() {
                state.serialize_entry("defaultVersion", &self.default_version)?;
            }
            if !self.valid_versions.is_empty() {
                state.serialize_entry("validVersions", &self.valid_versions)?;
            }
            if !self.upgrade_target_version.is_empty() {
                state.serialize_entry("upgradeTargetVersion", &self.upgrade_target_version)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ReleaseChannelConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ReleaseChannelConfig");
            debug_struct.field("channel", &self.channel);
            debug_struct.field("default_version", &self.default_version);
            debug_struct.field("valid_versions", &self.valid_versions);
            debug_struct.field("upgrade_target_version", &self.upgrade_target_version);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// CreateNodePoolRequest creates a node pool for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the parent field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The node pool to create.
    pub node_pool: std::option::Option<crate::model::NodePool>,

    /// The parent (project, location, cluster name) where the node pool will be
    /// created. Specified in the format
    /// `projects/*/locations/*/clusters/*`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CreateNodePoolRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CreateNodePoolRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateNodePoolRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool][crate::model::CreateNodePoolRequest::node_pool].
    pub fn set_node_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePool>,
    {
        self.node_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_pool][crate::model::CreateNodePoolRequest::node_pool].
    pub fn set_or_clear_node_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodePool>,
    {
        self.node_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parent][crate::model::CreateNodePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CreateNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CreateNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePool" => Ok(__FieldTag::__node_pool),
                            "node_pool" => Ok(__FieldTag::__node_pool),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool => {
                            if !fields.insert(__FieldTag::__node_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool",
                                ));
                            }
                            result.node_pool =
                                map.next_value::<std::option::Option<crate::model::NodePool>>()?;
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.node_pool.is_some() {
            state.serialize_entry("nodePool", &self.node_pool)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateNodePoolRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool", &self.node_pool);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DeleteNodePoolRequest deletes a node pool for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to delete.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// The name (project, location, cluster, node pool id) of the node pool to
    /// delete. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::DeleteNodePoolRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::DeleteNodePoolRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::DeleteNodePoolRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::DeleteNodePoolRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::DeleteNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DeleteNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteNodePoolRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListNodePoolsRequest lists the node pool(s) for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNodePoolsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the parent field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the parent field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// The parent (project, location, cluster name) where the node pools will be
    /// listed. Specified in the format `projects/*/locations/*/clusters/*`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::ListNodePoolsRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ListNodePoolsRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::ListNodePoolsRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::ListNodePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for ListNodePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListNodePoolsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNodePoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNodePoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNodePoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNodePoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNodePoolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListNodePoolsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNodePoolsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetNodePoolRequest retrieves a node pool for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNodePoolRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// The name (project, location, cluster, node pool id) of the node pool to
    /// get. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::GetNodePoolRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::GetNodePoolRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::GetNodePoolRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::GetNodePoolRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::GetNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetNodePoolRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Settings for blue-green upgrade.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BlueGreenSettings {
    /// Time needed after draining entire blue pool. After this period, blue pool
    /// will be cleaned up.
    pub node_pool_soak_duration: std::option::Option<wkt::Duration>,

    /// The rollout policy controls the general rollout progress of blue-green.
    pub rollout_policy: std::option::Option<crate::model::blue_green_settings::RolloutPolicy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BlueGreenSettings {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_pool_soak_duration][crate::model::BlueGreenSettings::node_pool_soak_duration].
    pub fn set_node_pool_soak_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.node_pool_soak_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_pool_soak_duration][crate::model::BlueGreenSettings::node_pool_soak_duration].
    pub fn set_or_clear_node_pool_soak_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.node_pool_soak_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout_policy][crate::model::BlueGreenSettings::rollout_policy].
    ///
    /// Note that all the setters affecting `rollout_policy` are mutually
    /// exclusive.
    pub fn set_rollout_policy<
        T: std::convert::Into<std::option::Option<crate::model::blue_green_settings::RolloutPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_policy = v.into();
        self
    }

    /// The value of [rollout_policy][crate::model::BlueGreenSettings::rollout_policy]
    /// if it holds a `StandardRolloutPolicy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn standard_rollout_policy(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::blue_green_settings::StandardRolloutPolicy>,
    > {
        #[allow(unreachable_patterns)]
        self.rollout_policy.as_ref().and_then(|v| match v {
            crate::model::blue_green_settings::RolloutPolicy::StandardRolloutPolicy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rollout_policy][crate::model::BlueGreenSettings::rollout_policy]
    /// to hold a `StandardRolloutPolicy`.
    ///
    /// Note that all the setters affecting `rollout_policy` are
    /// mutually exclusive.
    pub fn set_standard_rollout_policy<
        T: std::convert::Into<
                std::boxed::Box<crate::model::blue_green_settings::StandardRolloutPolicy>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rollout_policy = std::option::Option::Some(
            crate::model::blue_green_settings::RolloutPolicy::StandardRolloutPolicy(v.into()),
        );
        self
    }
}

impl wkt::message::Message for BlueGreenSettings {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.BlueGreenSettings"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BlueGreenSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __standard_rollout_policy,
            __node_pool_soak_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BlueGreenSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "standardRolloutPolicy" => Ok(__FieldTag::__standard_rollout_policy),
                            "standard_rollout_policy" => Ok(__FieldTag::__standard_rollout_policy),
                            "nodePoolSoakDuration" => Ok(__FieldTag::__node_pool_soak_duration),
                            "node_pool_soak_duration" => Ok(__FieldTag::__node_pool_soak_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BlueGreenSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BlueGreenSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__standard_rollout_policy => {
                            if !fields.insert(__FieldTag::__standard_rollout_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard_rollout_policy",
                                ));
                            }
                            if result.rollout_policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rollout_policy`, a oneof with full ID .google.container.v1.BlueGreenSettings.standard_rollout_policy, latest field was standardRolloutPolicy",
                                ));
                            }
                            result.rollout_policy = std::option::Option::Some(
                                crate::model::blue_green_settings::RolloutPolicy::StandardRolloutPolicy(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::blue_green_settings::StandardRolloutPolicy>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__node_pool_soak_duration => {
                            if !fields.insert(__FieldTag::__node_pool_soak_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_soak_duration",
                                ));
                            }
                            result.node_pool_soak_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BlueGreenSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.standard_rollout_policy() {
            state.serialize_entry("standardRolloutPolicy", value)?;
        }
        if self.node_pool_soak_duration.is_some() {
            state.serialize_entry("nodePoolSoakDuration", &self.node_pool_soak_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BlueGreenSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BlueGreenSettings");
        debug_struct.field("node_pool_soak_duration", &self.node_pool_soak_duration);
        debug_struct.field("rollout_policy", &self.rollout_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BlueGreenSettings].
pub mod blue_green_settings {
    #[allow(unused_imports)]
    use super::*;

    /// Standard rollout policy is the default policy for blue-green.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StandardRolloutPolicy {
        /// Soak time after each batch gets drained. Default to zero.
        pub batch_soak_duration: std::option::Option<wkt::Duration>,

        /// Blue pool size to drain in a batch.
        pub update_batch_size: std::option::Option<
            crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StandardRolloutPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [batch_soak_duration][crate::model::blue_green_settings::StandardRolloutPolicy::batch_soak_duration].
        pub fn set_batch_soak_duration<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.batch_soak_duration = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [batch_soak_duration][crate::model::blue_green_settings::StandardRolloutPolicy::batch_soak_duration].
        pub fn set_or_clear_batch_soak_duration<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.batch_soak_duration = v.map(|x| x.into());
            self
        }

        /// Sets the value of [update_batch_size][crate::model::blue_green_settings::StandardRolloutPolicy::update_batch_size].
        ///
        /// Note that all the setters affecting `update_batch_size` are mutually
        /// exclusive.
        pub fn set_update_batch_size<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.update_batch_size = v.into();
            self
        }

        /// The value of [update_batch_size][crate::model::blue_green_settings::StandardRolloutPolicy::update_batch_size]
        /// if it holds a `BatchPercentage`, `None` if the field is not set or
        /// holds a different branch.
        pub fn batch_percentage(&self) -> std::option::Option<&f32> {
            #[allow(unreachable_patterns)]
            self.update_batch_size.as_ref().and_then(|v| match v {
                crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchPercentage(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [update_batch_size][crate::model::blue_green_settings::StandardRolloutPolicy::update_batch_size]
        /// to hold a `BatchPercentage`.
        ///
        /// Note that all the setters affecting `update_batch_size` are
        /// mutually exclusive.
        pub fn set_batch_percentage<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
            self.update_batch_size = std::option::Option::Some(
                crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchPercentage(
                    v.into()
                )
            );
            self
        }

        /// The value of [update_batch_size][crate::model::blue_green_settings::StandardRolloutPolicy::update_batch_size]
        /// if it holds a `BatchNodeCount`, `None` if the field is not set or
        /// holds a different branch.
        pub fn batch_node_count(&self) -> std::option::Option<&i32> {
            #[allow(unreachable_patterns)]
            self.update_batch_size.as_ref().and_then(|v| match v {
                crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchNodeCount(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [update_batch_size][crate::model::blue_green_settings::StandardRolloutPolicy::update_batch_size]
        /// to hold a `BatchNodeCount`.
        ///
        /// Note that all the setters affecting `update_batch_size` are
        /// mutually exclusive.
        pub fn set_batch_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.update_batch_size = std::option::Option::Some(
                crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchNodeCount(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for StandardRolloutPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.BlueGreenSettings.StandardRolloutPolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StandardRolloutPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __batch_percentage,
                __batch_node_count,
                __batch_soak_duration,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StandardRolloutPolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "batchPercentage" => Ok(__FieldTag::__batch_percentage),
                                "batch_percentage" => Ok(__FieldTag::__batch_percentage),
                                "batchNodeCount" => Ok(__FieldTag::__batch_node_count),
                                "batch_node_count" => Ok(__FieldTag::__batch_node_count),
                                "batchSoakDuration" => Ok(__FieldTag::__batch_soak_duration),
                                "batch_soak_duration" => Ok(__FieldTag::__batch_soak_duration),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StandardRolloutPolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StandardRolloutPolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__batch_percentage => {
                                if !fields.insert(__FieldTag::__batch_percentage) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for batch_percentage",
                                    ));
                                }
                                struct __With(std::option::Option<f32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.update_batch_size.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `update_batch_size`, a oneof with full ID .google.container.v1.BlueGreenSettings.StandardRolloutPolicy.batch_percentage, latest field was batchPercentage",
                                    ));
                                }
                                result.update_batch_size = std::option::Option::Some(
                                    crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchPercentage(
                                        map.next_value::<__With>()?.0.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__batch_node_count => {
                                if !fields.insert(__FieldTag::__batch_node_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for batch_node_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                if result.update_batch_size.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `update_batch_size`, a oneof with full ID .google.container.v1.BlueGreenSettings.StandardRolloutPolicy.batch_node_count, latest field was batchNodeCount",
                                    ));
                                }
                                result.update_batch_size = std::option::Option::Some(
                                    crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchNodeCount(
                                        map.next_value::<__With>()?.0.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__batch_soak_duration => {
                                if !fields.insert(__FieldTag::__batch_soak_duration) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for batch_soak_duration",
                                    ));
                                }
                                result.batch_soak_duration =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StandardRolloutPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.batch_percentage() {
                struct __With<'a>(&'a f32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("batchPercentage", &__With(value))?;
            }
            if let Some(value) = self.batch_node_count() {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("batchNodeCount", &__With(value))?;
            }
            if self.batch_soak_duration.is_some() {
                state.serialize_entry("batchSoakDuration", &self.batch_soak_duration)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for StandardRolloutPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("StandardRolloutPolicy");
            debug_struct.field("batch_soak_duration", &self.batch_soak_duration);
            debug_struct.field("update_batch_size", &self.update_batch_size);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [StandardRolloutPolicy].
    pub mod standard_rollout_policy {
        #[allow(unused_imports)]
        use super::*;

        /// Blue pool size to drain in a batch.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum UpdateBatchSize {
            /// Percentage of the blue pool nodes to drain in a batch.
            /// The range of this field should be (0.0, 1.0].
            BatchPercentage(f32),
            /// Number of blue nodes to drain in a batch.
            BatchNodeCount(i32),
        }
    }

    /// The rollout policy controls the general rollout progress of blue-green.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutPolicy {
        /// Standard policy for the blue-green upgrade.
        StandardRolloutPolicy(
            std::boxed::Box<crate::model::blue_green_settings::StandardRolloutPolicy>,
        ),
    }
}

/// NodePool contains the name and configuration for a cluster's node pool.
/// Node pools are a set of nodes (i.e. VM's), with a common configuration and
/// specification, under the control of the cluster master. They may have a set
/// of Kubernetes labels applied to them, which may be used to reference them
/// during pod scheduling. They may also be resized up or down, to accommodate
/// the workload.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodePool {
    /// The name of the node pool.
    pub name: std::string::String,

    /// The node configuration of the pool.
    pub config: std::option::Option<crate::model::NodeConfig>,

    /// The initial node count for the pool. You must ensure that your
    /// Compute Engine [resource
    /// quota](https://cloud.google.com/compute/quotas)
    /// is sufficient for this number of instances. You must also have available
    /// firewall and routes quota.
    pub initial_node_count: i32,

    /// The list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available)
    /// in which the NodePool's nodes should be located.
    ///
    /// If this value is unspecified during node pool creation, the
    /// [Cluster.Locations](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.locations.clusters#Cluster.FIELDS.locations)
    /// value will be used, instead.
    ///
    /// Warning: changing node pool locations will result in nodes being added
    /// and/or removed.
    pub locations: std::vec::Vec<std::string::String>,

    /// Networking configuration for this NodePool. If specified, it overrides the
    /// cluster-level defaults.
    pub network_config: std::option::Option<crate::model::NodeNetworkConfig>,

    /// Output only. Server-defined URL for the resource.
    pub self_link: std::string::String,

    /// The version of Kubernetes running on this NodePool's nodes. If unspecified,
    /// it defaults as described
    /// [here](https://cloud.google.com/kubernetes-engine/versioning#specifying_node_version).
    pub version: std::string::String,

    /// Output only. The resource URLs of the [managed instance
    /// groups](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances)
    /// associated with this node pool.
    /// During the node pool blue-green upgrade operation, the URLs contain both
    /// blue and green resources.
    pub instance_group_urls: std::vec::Vec<std::string::String>,

    /// Output only. The status of the nodes in this pool instance.
    pub status: crate::model::node_pool::Status,

    /// Output only. Deprecated. Use conditions instead.
    /// Additional information about the current status of this
    /// node pool instance, if available.
    #[deprecated]
    pub status_message: std::string::String,

    /// Autoscaler configuration for this NodePool. Autoscaler is enabled
    /// only if a valid configuration is present.
    pub autoscaling: std::option::Option<crate::model::NodePoolAutoscaling>,

    /// NodeManagement configuration for this NodePool.
    pub management: std::option::Option<crate::model::NodeManagement>,

    /// The constraint on the maximum number of pods that can be run
    /// simultaneously on a node in the node pool.
    pub max_pods_constraint: std::option::Option<crate::model::MaxPodsConstraint>,

    /// Which conditions caused the current node pool state.
    pub conditions: std::vec::Vec<crate::model::StatusCondition>,

    /// Output only. The pod CIDR block size per node in this node pool.
    pub pod_ipv4_cidr_size: i32,

    /// Upgrade settings control disruption and speed of the upgrade.
    pub upgrade_settings: std::option::Option<crate::model::node_pool::UpgradeSettings>,

    /// Specifies the node placement policy.
    pub placement_policy: std::option::Option<crate::model::node_pool::PlacementPolicy>,

    /// Output only. Update info contains relevant information during a node
    /// pool update.
    pub update_info: std::option::Option<crate::model::node_pool::UpdateInfo>,

    /// This checksum is computed by the server based on the value of node pool
    /// fields, and may be sent on update requests to ensure the client has an
    /// up-to-date value before proceeding.
    pub etag: std::string::String,

    /// Specifies the configuration of queued provisioning.
    pub queued_provisioning: std::option::Option<crate::model::node_pool::QueuedProvisioning>,

    /// Enable best effort provisioning for nodes
    pub best_effort_provisioning: std::option::Option<crate::model::BestEffortProvisioning>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NodePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [config][crate::model::NodePool::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::NodePool::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initial_node_count][crate::model::NodePool::initial_node_count].
    pub fn set_initial_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.initial_node_count = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::NodePool::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_config][crate::model::NodePool::network_config].
    pub fn set_network_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeNetworkConfig>,
    {
        self.network_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_config][crate::model::NodePool::network_config].
    pub fn set_or_clear_network_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeNetworkConfig>,
    {
        self.network_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::NodePool::self_link].
    pub fn set_self_link<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.self_link = v.into();
        self
    }

    /// Sets the value of [version][crate::model::NodePool::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [instance_group_urls][crate::model::NodePool::instance_group_urls].
    pub fn set_instance_group_urls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_group_urls = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [status][crate::model::NodePool::status].
    pub fn set_status<T: std::convert::Into<crate::model::node_pool::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::NodePool::status_message].
    #[deprecated]
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [autoscaling][crate::model::NodePool::autoscaling].
    pub fn set_autoscaling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolAutoscaling>,
    {
        self.autoscaling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaling][crate::model::NodePool::autoscaling].
    pub fn set_or_clear_autoscaling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodePoolAutoscaling>,
    {
        self.autoscaling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [management][crate::model::NodePool::management].
    pub fn set_management<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeManagement>,
    {
        self.management = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [management][crate::model::NodePool::management].
    pub fn set_or_clear_management<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeManagement>,
    {
        self.management = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_pods_constraint][crate::model::NodePool::max_pods_constraint].
    pub fn set_max_pods_constraint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaxPodsConstraint>,
    {
        self.max_pods_constraint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_pods_constraint][crate::model::NodePool::max_pods_constraint].
    pub fn set_or_clear_max_pods_constraint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaxPodsConstraint>,
    {
        self.max_pods_constraint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [conditions][crate::model::NodePool::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::StatusCondition>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pod_ipv4_cidr_size][crate::model::NodePool::pod_ipv4_cidr_size].
    pub fn set_pod_ipv4_cidr_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.pod_ipv4_cidr_size = v.into();
        self
    }

    /// Sets the value of [upgrade_settings][crate::model::NodePool::upgrade_settings].
    pub fn set_upgrade_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::UpgradeSettings>,
    {
        self.upgrade_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upgrade_settings][crate::model::NodePool::upgrade_settings].
    pub fn set_or_clear_upgrade_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::UpgradeSettings>,
    {
        self.upgrade_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [placement_policy][crate::model::NodePool::placement_policy].
    pub fn set_placement_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::PlacementPolicy>,
    {
        self.placement_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [placement_policy][crate::model::NodePool::placement_policy].
    pub fn set_or_clear_placement_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::PlacementPolicy>,
    {
        self.placement_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_info][crate::model::NodePool::update_info].
    pub fn set_update_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::UpdateInfo>,
    {
        self.update_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_info][crate::model::NodePool::update_info].
    pub fn set_or_clear_update_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::UpdateInfo>,
    {
        self.update_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::NodePool::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [queued_provisioning][crate::model::NodePool::queued_provisioning].
    pub fn set_queued_provisioning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::QueuedProvisioning>,
    {
        self.queued_provisioning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [queued_provisioning][crate::model::NodePool::queued_provisioning].
    pub fn set_or_clear_queued_provisioning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::QueuedProvisioning>,
    {
        self.queued_provisioning = v.map(|x| x.into());
        self
    }

    /// Sets the value of [best_effort_provisioning][crate::model::NodePool::best_effort_provisioning].
    pub fn set_best_effort_provisioning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BestEffortProvisioning>,
    {
        self.best_effort_provisioning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [best_effort_provisioning][crate::model::NodePool::best_effort_provisioning].
    pub fn set_or_clear_best_effort_provisioning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BestEffortProvisioning>,
    {
        self.best_effort_provisioning = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodePool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodePool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __config,
            __initial_node_count,
            __locations,
            __network_config,
            __self_link,
            __version,
            __instance_group_urls,
            __status,
            __status_message,
            __autoscaling,
            __management,
            __max_pods_constraint,
            __conditions,
            __pod_ipv4_cidr_size,
            __upgrade_settings,
            __placement_policy,
            __update_info,
            __etag,
            __queued_provisioning,
            __best_effort_provisioning,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "config" => Ok(__FieldTag::__config),
                            "initialNodeCount" => Ok(__FieldTag::__initial_node_count),
                            "initial_node_count" => Ok(__FieldTag::__initial_node_count),
                            "locations" => Ok(__FieldTag::__locations),
                            "networkConfig" => Ok(__FieldTag::__network_config),
                            "network_config" => Ok(__FieldTag::__network_config),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "version" => Ok(__FieldTag::__version),
                            "instanceGroupUrls" => Ok(__FieldTag::__instance_group_urls),
                            "instance_group_urls" => Ok(__FieldTag::__instance_group_urls),
                            "status" => Ok(__FieldTag::__status),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "autoscaling" => Ok(__FieldTag::__autoscaling),
                            "management" => Ok(__FieldTag::__management),
                            "maxPodsConstraint" => Ok(__FieldTag::__max_pods_constraint),
                            "max_pods_constraint" => Ok(__FieldTag::__max_pods_constraint),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "podIpv4CidrSize" => Ok(__FieldTag::__pod_ipv4_cidr_size),
                            "pod_ipv4_cidr_size" => Ok(__FieldTag::__pod_ipv4_cidr_size),
                            "upgradeSettings" => Ok(__FieldTag::__upgrade_settings),
                            "upgrade_settings" => Ok(__FieldTag::__upgrade_settings),
                            "placementPolicy" => Ok(__FieldTag::__placement_policy),
                            "placement_policy" => Ok(__FieldTag::__placement_policy),
                            "updateInfo" => Ok(__FieldTag::__update_info),
                            "update_info" => Ok(__FieldTag::__update_info),
                            "etag" => Ok(__FieldTag::__etag),
                            "queuedProvisioning" => Ok(__FieldTag::__queued_provisioning),
                            "queued_provisioning" => Ok(__FieldTag::__queued_provisioning),
                            "bestEffortProvisioning" => Ok(__FieldTag::__best_effort_provisioning),
                            "best_effort_provisioning" => {
                                Ok(__FieldTag::__best_effort_provisioning)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodePool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config =
                                map.next_value::<std::option::Option<crate::model::NodeConfig>>()?;
                        }
                        __FieldTag::__initial_node_count => {
                            if !fields.insert(__FieldTag::__initial_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initial_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__network_config => {
                            if !fields.insert(__FieldTag::__network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_config",
                                ));
                            }
                            result.network_config = map
                                .next_value::<std::option::Option<crate::model::NodeNetworkConfig>>(
                                )?;
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_group_urls => {
                            if !fields.insert(__FieldTag::__instance_group_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_group_urls",
                                ));
                            }
                            result.instance_group_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::node_pool::Status>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autoscaling => {
                            if !fields.insert(__FieldTag::__autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling",
                                ));
                            }
                            result.autoscaling = map.next_value::<std::option::Option<crate::model::NodePoolAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__management => {
                            if !fields.insert(__FieldTag::__management) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management",
                                ));
                            }
                            result.management = map
                                .next_value::<std::option::Option<crate::model::NodeManagement>>(
                                )?;
                        }
                        __FieldTag::__max_pods_constraint => {
                            if !fields.insert(__FieldTag::__max_pods_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_pods_constraint",
                                ));
                            }
                            result.max_pods_constraint = map
                                .next_value::<std::option::Option<crate::model::MaxPodsConstraint>>(
                                )?;
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StatusCondition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_ipv4_cidr_size => {
                            if !fields.insert(__FieldTag::__pod_ipv4_cidr_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_ipv4_cidr_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pod_ipv4_cidr_size =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__upgrade_settings => {
                            if !fields.insert(__FieldTag::__upgrade_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_settings",
                                ));
                            }
                            result.upgrade_settings = map.next_value::<std::option::Option<crate::model::node_pool::UpgradeSettings>>()?
                                ;
                        }
                        __FieldTag::__placement_policy => {
                            if !fields.insert(__FieldTag::__placement_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for placement_policy",
                                ));
                            }
                            result.placement_policy = map.next_value::<std::option::Option<crate::model::node_pool::PlacementPolicy>>()?
                                ;
                        }
                        __FieldTag::__update_info => {
                            if !fields.insert(__FieldTag::__update_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_info",
                                ));
                            }
                            result.update_info = map.next_value::<std::option::Option<crate::model::node_pool::UpdateInfo>>()?
                                ;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__queued_provisioning => {
                            if !fields.insert(__FieldTag::__queued_provisioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queued_provisioning",
                                ));
                            }
                            result.queued_provisioning =
                                map.next_value::<std::option::Option<
                                    crate::model::node_pool::QueuedProvisioning,
                                >>()?;
                        }
                        __FieldTag::__best_effort_provisioning => {
                            if !fields.insert(__FieldTag::__best_effort_provisioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for best_effort_provisioning",
                                ));
                            }
                            result.best_effort_provisioning = map.next_value::<std::option::Option<crate::model::BestEffortProvisioning>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodePool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !wkt::internal::is_default(&self.initial_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("initialNodeCount", &__With(&self.initial_node_count))?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if self.network_config.is_some() {
            state.serialize_entry("networkConfig", &self.network_config)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.instance_group_urls.is_empty() {
            state.serialize_entry("instanceGroupUrls", &self.instance_group_urls)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if self.autoscaling.is_some() {
            state.serialize_entry("autoscaling", &self.autoscaling)?;
        }
        if self.management.is_some() {
            state.serialize_entry("management", &self.management)?;
        }
        if self.max_pods_constraint.is_some() {
            state.serialize_entry("maxPodsConstraint", &self.max_pods_constraint)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !wkt::internal::is_default(&self.pod_ipv4_cidr_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("podIpv4CidrSize", &__With(&self.pod_ipv4_cidr_size))?;
        }
        if self.upgrade_settings.is_some() {
            state.serialize_entry("upgradeSettings", &self.upgrade_settings)?;
        }
        if self.placement_policy.is_some() {
            state.serialize_entry("placementPolicy", &self.placement_policy)?;
        }
        if self.update_info.is_some() {
            state.serialize_entry("updateInfo", &self.update_info)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.queued_provisioning.is_some() {
            state.serialize_entry("queuedProvisioning", &self.queued_provisioning)?;
        }
        if self.best_effort_provisioning.is_some() {
            state.serialize_entry("bestEffortProvisioning", &self.best_effort_provisioning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodePool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePool");
        debug_struct.field("name", &self.name);
        debug_struct.field("config", &self.config);
        debug_struct.field("initial_node_count", &self.initial_node_count);
        debug_struct.field("locations", &self.locations);
        debug_struct.field("network_config", &self.network_config);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("version", &self.version);
        debug_struct.field("instance_group_urls", &self.instance_group_urls);
        debug_struct.field("status", &self.status);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("autoscaling", &self.autoscaling);
        debug_struct.field("management", &self.management);
        debug_struct.field("max_pods_constraint", &self.max_pods_constraint);
        debug_struct.field("conditions", &self.conditions);
        debug_struct.field("pod_ipv4_cidr_size", &self.pod_ipv4_cidr_size);
        debug_struct.field("upgrade_settings", &self.upgrade_settings);
        debug_struct.field("placement_policy", &self.placement_policy);
        debug_struct.field("update_info", &self.update_info);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("queued_provisioning", &self.queued_provisioning);
        debug_struct.field("best_effort_provisioning", &self.best_effort_provisioning);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NodePool].
pub mod node_pool {
    #[allow(unused_imports)]
    use super::*;

    /// These upgrade settings control the level of parallelism and the level of
    /// disruption caused by an upgrade.
    ///
    /// maxUnavailable controls the number of nodes that can be simultaneously
    /// unavailable.
    ///
    /// maxSurge controls the number of additional nodes that can be added to the
    /// node pool temporarily for the time of the upgrade to increase the number of
    /// available nodes.
    ///
    /// (maxUnavailable + maxSurge) determines the level of parallelism (how many
    /// nodes are being upgraded at the same time).
    ///
    /// Note: upgrades inevitably introduce some disruption since workloads need to
    /// be moved from old nodes to new, upgraded ones. Even if maxUnavailable=0,
    /// this holds true. (Disruption stays within the limits of
    /// PodDisruptionBudget, if it is configured.)
    ///
    /// Consider a hypothetical node pool with 5 nodes having maxSurge=2,
    /// maxUnavailable=1. This means the upgrade process upgrades 3 nodes
    /// simultaneously. It creates 2 additional (upgraded) nodes, then it brings
    /// down 3 old (not yet upgraded) nodes at the same time. This ensures that
    /// there are always at least 4 nodes available.
    ///
    /// These upgrade settings configure the upgrade strategy for the node pool.
    /// Use strategy to switch between the strategies applied to the node pool.
    ///
    /// If the strategy is ROLLING, use max_surge and max_unavailable to control
    /// the level of parallelism and the level of disruption caused by upgrade.
    ///
    /// 1. maxSurge controls the number of additional nodes that can be added to
    ///    the node pool temporarily for the time of the upgrade to increase the
    ///    number of available nodes.
    /// 1. maxUnavailable controls the number of nodes that can be simultaneously
    ///    unavailable.
    /// 1. (maxUnavailable + maxSurge) determines the level of parallelism (how
    ///    many nodes are being upgraded at the same time).
    ///
    /// If the strategy is BLUE_GREEN, use blue_green_settings to configure the
    /// blue-green upgrade related settings.
    ///
    /// 1. standard_rollout_policy is the default policy. The policy is used to
    ///    control the way blue pool gets drained. The draining is executed in the
    ///    batch mode. The batch size could be specified as either percentage of the
    ///    node pool size or the number of nodes. batch_soak_duration is the soak
    ///    time after each batch gets drained.
    /// 1. node_pool_soak_duration is the soak time after all blue nodes are
    ///    drained. After this period, the blue pool nodes will be deleted.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpgradeSettings {
        /// The maximum number of nodes that can be created beyond the current size
        /// of the node pool during the upgrade process.
        pub max_surge: i32,

        /// The maximum number of nodes that can be simultaneously unavailable during
        /// the upgrade process. A node is considered available if its status is
        /// Ready.
        pub max_unavailable: i32,

        /// Update strategy of the node pool.
        pub strategy: std::option::Option<crate::model::NodePoolUpdateStrategy>,

        /// Settings for blue-green upgrade strategy.
        pub blue_green_settings: std::option::Option<crate::model::BlueGreenSettings>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UpgradeSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [max_surge][crate::model::node_pool::UpgradeSettings::max_surge].
        pub fn set_max_surge<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_surge = v.into();
            self
        }

        /// Sets the value of [max_unavailable][crate::model::node_pool::UpgradeSettings::max_unavailable].
        pub fn set_max_unavailable<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.max_unavailable = v.into();
            self
        }

        /// Sets the value of [strategy][crate::model::node_pool::UpgradeSettings::strategy].
        pub fn set_strategy<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::NodePoolUpdateStrategy>,
        {
            self.strategy = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [strategy][crate::model::node_pool::UpgradeSettings::strategy].
        pub fn set_or_clear_strategy<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::NodePoolUpdateStrategy>,
        {
            self.strategy = v.map(|x| x.into());
            self
        }

        /// Sets the value of [blue_green_settings][crate::model::node_pool::UpgradeSettings::blue_green_settings].
        pub fn set_blue_green_settings<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::BlueGreenSettings>,
        {
            self.blue_green_settings = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [blue_green_settings][crate::model::node_pool::UpgradeSettings::blue_green_settings].
        pub fn set_or_clear_blue_green_settings<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::BlueGreenSettings>,
        {
            self.blue_green_settings = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for UpgradeSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NodePool.UpgradeSettings"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UpgradeSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __max_surge,
                __max_unavailable,
                __strategy,
                __blue_green_settings,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UpgradeSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "maxSurge" => Ok(__FieldTag::__max_surge),
                                "max_surge" => Ok(__FieldTag::__max_surge),
                                "maxUnavailable" => Ok(__FieldTag::__max_unavailable),
                                "max_unavailable" => Ok(__FieldTag::__max_unavailable),
                                "strategy" => Ok(__FieldTag::__strategy),
                                "blueGreenSettings" => Ok(__FieldTag::__blue_green_settings),
                                "blue_green_settings" => Ok(__FieldTag::__blue_green_settings),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UpgradeSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UpgradeSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__max_surge => {
                                if !fields.insert(__FieldTag::__max_surge) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_surge",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_surge =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__max_unavailable => {
                                if !fields.insert(__FieldTag::__max_unavailable) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max_unavailable",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.max_unavailable =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__strategy => {
                                if !fields.insert(__FieldTag::__strategy) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for strategy",
                                    ));
                                }
                                result.strategy = map.next_value::<std::option::Option<crate::model::NodePoolUpdateStrategy>>()?
                                    ;
                            }
                            __FieldTag::__blue_green_settings => {
                                if !fields.insert(__FieldTag::__blue_green_settings) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for blue_green_settings",
                                    ));
                                }
                                result.blue_green_settings = map.next_value::<std::option::Option<crate::model::BlueGreenSettings>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UpgradeSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.max_surge) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxSurge", &__With(&self.max_surge))?;
            }
            if !wkt::internal::is_default(&self.max_unavailable) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("maxUnavailable", &__With(&self.max_unavailable))?;
            }
            if self.strategy.is_some() {
                state.serialize_entry("strategy", &self.strategy)?;
            }
            if self.blue_green_settings.is_some() {
                state.serialize_entry("blueGreenSettings", &self.blue_green_settings)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for UpgradeSettings {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("UpgradeSettings");
            debug_struct.field("max_surge", &self.max_surge);
            debug_struct.field("max_unavailable", &self.max_unavailable);
            debug_struct.field("strategy", &self.strategy);
            debug_struct.field("blue_green_settings", &self.blue_green_settings);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// UpdateInfo contains resource (instance groups, etc), status and other
    /// intermediate information relevant to a node pool upgrade.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdateInfo {
        /// Information of a blue-green upgrade.
        pub blue_green_info:
            std::option::Option<crate::model::node_pool::update_info::BlueGreenInfo>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UpdateInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [blue_green_info][crate::model::node_pool::UpdateInfo::blue_green_info].
        pub fn set_blue_green_info<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::node_pool::update_info::BlueGreenInfo>,
        {
            self.blue_green_info = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [blue_green_info][crate::model::node_pool::UpdateInfo::blue_green_info].
        pub fn set_or_clear_blue_green_info<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::node_pool::update_info::BlueGreenInfo>,
        {
            self.blue_green_info = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for UpdateInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NodePool.UpdateInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UpdateInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __blue_green_info,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UpdateInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "blueGreenInfo" => Ok(__FieldTag::__blue_green_info),
                                "blue_green_info" => Ok(__FieldTag::__blue_green_info),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UpdateInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UpdateInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__blue_green_info => {
                                if !fields.insert(__FieldTag::__blue_green_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for blue_green_info",
                                    ));
                                }
                                result.blue_green_info = map.next_value::<std::option::Option<
                                    crate::model::node_pool::update_info::BlueGreenInfo,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UpdateInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.blue_green_info.is_some() {
                state.serialize_entry("blueGreenInfo", &self.blue_green_info)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for UpdateInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("UpdateInfo");
            debug_struct.field("blue_green_info", &self.blue_green_info);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [UpdateInfo].
    pub mod update_info {
        #[allow(unused_imports)]
        use super::*;

        /// Information relevant to blue-green upgrade.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct BlueGreenInfo {
            /// Current blue-green upgrade phase.
            pub phase: crate::model::node_pool::update_info::blue_green_info::Phase,

            /// The resource URLs of the [managed instance groups]
            /// (/compute/docs/instance-groups/creating-groups-of-managed-instances)
            /// associated with blue pool.
            pub blue_instance_group_urls: std::vec::Vec<std::string::String>,

            /// The resource URLs of the [managed instance groups]
            /// (/compute/docs/instance-groups/creating-groups-of-managed-instances)
            /// associated with green pool.
            pub green_instance_group_urls: std::vec::Vec<std::string::String>,

            /// Time to start deleting blue pool to complete blue-green upgrade,
            /// in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
            pub blue_pool_deletion_start_time: std::string::String,

            /// Version of green pool.
            pub green_pool_version: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl BlueGreenInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [phase][crate::model::node_pool::update_info::BlueGreenInfo::phase].
            pub fn set_phase<
                T: std::convert::Into<crate::model::node_pool::update_info::blue_green_info::Phase>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.phase = v.into();
                self
            }

            /// Sets the value of [blue_instance_group_urls][crate::model::node_pool::update_info::BlueGreenInfo::blue_instance_group_urls].
            pub fn set_blue_instance_group_urls<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.blue_instance_group_urls = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [green_instance_group_urls][crate::model::node_pool::update_info::BlueGreenInfo::green_instance_group_urls].
            pub fn set_green_instance_group_urls<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.green_instance_group_urls = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [blue_pool_deletion_start_time][crate::model::node_pool::update_info::BlueGreenInfo::blue_pool_deletion_start_time].
            pub fn set_blue_pool_deletion_start_time<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.blue_pool_deletion_start_time = v.into();
                self
            }

            /// Sets the value of [green_pool_version][crate::model::node_pool::update_info::BlueGreenInfo::green_pool_version].
            pub fn set_green_pool_version<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.green_pool_version = v.into();
                self
            }
        }

        impl wkt::message::Message for BlueGreenInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.container.v1.NodePool.UpdateInfo.BlueGreenInfo"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for BlueGreenInfo {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __phase,
                    __blue_instance_group_urls,
                    __green_instance_group_urls,
                    __blue_pool_deletion_start_time,
                    __green_pool_version,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for BlueGreenInfo")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "phase" => Ok(__FieldTag::__phase),
                                    "blueInstanceGroupUrls" => {
                                        Ok(__FieldTag::__blue_instance_group_urls)
                                    }
                                    "blue_instance_group_urls" => {
                                        Ok(__FieldTag::__blue_instance_group_urls)
                                    }
                                    "greenInstanceGroupUrls" => {
                                        Ok(__FieldTag::__green_instance_group_urls)
                                    }
                                    "green_instance_group_urls" => {
                                        Ok(__FieldTag::__green_instance_group_urls)
                                    }
                                    "bluePoolDeletionStartTime" => {
                                        Ok(__FieldTag::__blue_pool_deletion_start_time)
                                    }
                                    "blue_pool_deletion_start_time" => {
                                        Ok(__FieldTag::__blue_pool_deletion_start_time)
                                    }
                                    "greenPoolVersion" => Ok(__FieldTag::__green_pool_version),
                                    "green_pool_version" => Ok(__FieldTag::__green_pool_version),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = BlueGreenInfo;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct BlueGreenInfo")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__phase => {
                                    if !fields.insert(__FieldTag::__phase) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for phase"),
                                        );
                                    }
                                    result.phase = map.next_value::<std::option::Option<crate::model::node_pool::update_info::blue_green_info::Phase>>()?.unwrap_or_default();
                                }
                                __FieldTag::__blue_instance_group_urls => {
                                    if !fields.insert(__FieldTag::__blue_instance_group_urls) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for blue_instance_group_urls",
                                            ),
                                        );
                                    }
                                    result.blue_instance_group_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__green_instance_group_urls => {
                                    if !fields.insert(__FieldTag::__green_instance_group_urls) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for green_instance_group_urls",
                                            ),
                                        );
                                    }
                                    result.green_instance_group_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__blue_pool_deletion_start_time => {
                                    if !fields.insert(__FieldTag::__blue_pool_deletion_start_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for blue_pool_deletion_start_time",
                                            ),
                                        );
                                    }
                                    result.blue_pool_deletion_start_time = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__green_pool_version => {
                                    if !fields.insert(__FieldTag::__green_pool_version) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for green_pool_version",
                                            ),
                                        );
                                    }
                                    result.green_pool_version = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for BlueGreenInfo {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.phase) {
                    state.serialize_entry("phase", &self.phase)?;
                }
                if !self.blue_instance_group_urls.is_empty() {
                    state
                        .serialize_entry("blueInstanceGroupUrls", &self.blue_instance_group_urls)?;
                }
                if !self.green_instance_group_urls.is_empty() {
                    state.serialize_entry(
                        "greenInstanceGroupUrls",
                        &self.green_instance_group_urls,
                    )?;
                }
                if !self.blue_pool_deletion_start_time.is_empty() {
                    state.serialize_entry(
                        "bluePoolDeletionStartTime",
                        &self.blue_pool_deletion_start_time,
                    )?;
                }
                if !self.green_pool_version.is_empty() {
                    state.serialize_entry("greenPoolVersion", &self.green_pool_version)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for BlueGreenInfo {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("BlueGreenInfo");
                debug_struct.field("phase", &self.phase);
                debug_struct.field("blue_instance_group_urls", &self.blue_instance_group_urls);
                debug_struct.field("green_instance_group_urls", &self.green_instance_group_urls);
                debug_struct.field(
                    "blue_pool_deletion_start_time",
                    &self.blue_pool_deletion_start_time,
                );
                debug_struct.field("green_pool_version", &self.green_pool_version);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [BlueGreenInfo].
        pub mod blue_green_info {
            #[allow(unused_imports)]
            use super::*;

            /// Phase represents the different stages blue-green upgrade is running in.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Phase {
                /// Unspecified phase.
                Unspecified,
                /// blue-green upgrade has been initiated.
                UpdateStarted,
                /// Start creating green pool nodes.
                CreatingGreenPool,
                /// Start cordoning blue pool nodes.
                CordoningBluePool,
                /// Start draining blue pool nodes.
                DrainingBluePool,
                /// Start soaking time after draining entire blue pool.
                NodePoolSoaking,
                /// Start deleting blue nodes.
                DeletingBluePool,
                /// Rollback has been initiated.
                RollbackStarted,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [Phase::value] or
                /// [Phase::name].
                UnknownValue(phase::UnknownValue),
            }

            #[doc(hidden)]
            pub mod phase {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl Phase {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::UpdateStarted => std::option::Option::Some(1),
                        Self::CreatingGreenPool => std::option::Option::Some(2),
                        Self::CordoningBluePool => std::option::Option::Some(3),
                        Self::DrainingBluePool => std::option::Option::Some(4),
                        Self::NodePoolSoaking => std::option::Option::Some(5),
                        Self::DeletingBluePool => std::option::Option::Some(6),
                        Self::RollbackStarted => std::option::Option::Some(7),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => std::option::Option::Some("PHASE_UNSPECIFIED"),
                        Self::UpdateStarted => std::option::Option::Some("UPDATE_STARTED"),
                        Self::CreatingGreenPool => std::option::Option::Some("CREATING_GREEN_POOL"),
                        Self::CordoningBluePool => std::option::Option::Some("CORDONING_BLUE_POOL"),
                        Self::DrainingBluePool => std::option::Option::Some("DRAINING_BLUE_POOL"),
                        Self::NodePoolSoaking => std::option::Option::Some("NODE_POOL_SOAKING"),
                        Self::DeletingBluePool => std::option::Option::Some("DELETING_BLUE_POOL"),
                        Self::RollbackStarted => std::option::Option::Some("ROLLBACK_STARTED"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for Phase {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for Phase {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for Phase {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::UpdateStarted,
                        2 => Self::CreatingGreenPool,
                        3 => Self::CordoningBluePool,
                        4 => Self::DrainingBluePool,
                        5 => Self::NodePoolSoaking,
                        6 => Self::DeletingBluePool,
                        7 => Self::RollbackStarted,
                        _ => Self::UnknownValue(phase::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for Phase {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "PHASE_UNSPECIFIED" => Self::Unspecified,
                        "UPDATE_STARTED" => Self::UpdateStarted,
                        "CREATING_GREEN_POOL" => Self::CreatingGreenPool,
                        "CORDONING_BLUE_POOL" => Self::CordoningBluePool,
                        "DRAINING_BLUE_POOL" => Self::DrainingBluePool,
                        "NODE_POOL_SOAKING" => Self::NodePoolSoaking,
                        "DELETING_BLUE_POOL" => Self::DeletingBluePool,
                        "ROLLBACK_STARTED" => Self::RollbackStarted,
                        _ => Self::UnknownValue(phase::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for Phase {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::UpdateStarted => serializer.serialize_i32(1),
                        Self::CreatingGreenPool => serializer.serialize_i32(2),
                        Self::CordoningBluePool => serializer.serialize_i32(3),
                        Self::DrainingBluePool => serializer.serialize_i32(4),
                        Self::NodePoolSoaking => serializer.serialize_i32(5),
                        Self::DeletingBluePool => serializer.serialize_i32(6),
                        Self::RollbackStarted => serializer.serialize_i32(7),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for Phase {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<Phase>::new(
                        ".google.container.v1.NodePool.UpdateInfo.BlueGreenInfo.Phase",
                    ))
                }
            }
        }
    }

    /// PlacementPolicy defines the placement policy used by the node pool.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PlacementPolicy {
        /// The type of placement.
        pub r#type: crate::model::node_pool::placement_policy::Type,

        /// Optional. TPU placement topology for pod slice node pool.
        /// <https://cloud.google.com/tpu/docs/types-topologies#tpu_topologies>
        pub tpu_topology: std::string::String,

        /// If set, refers to the name of a custom resource policy supplied by the
        /// user. The resource policy must be in the same project and region as the
        /// node pool. If not found, InvalidArgument error is returned.
        pub policy_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PlacementPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::node_pool::PlacementPolicy::type].
        pub fn set_type<T: std::convert::Into<crate::model::node_pool::placement_policy::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [tpu_topology][crate::model::node_pool::PlacementPolicy::tpu_topology].
        pub fn set_tpu_topology<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.tpu_topology = v.into();
            self
        }

        /// Sets the value of [policy_name][crate::model::node_pool::PlacementPolicy::policy_name].
        pub fn set_policy_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.policy_name = v.into();
            self
        }
    }

    impl wkt::message::Message for PlacementPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NodePool.PlacementPolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PlacementPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                __tpu_topology,
                __policy_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PlacementPolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                "tpuTopology" => Ok(__FieldTag::__tpu_topology),
                                "tpu_topology" => Ok(__FieldTag::__tpu_topology),
                                "policyName" => Ok(__FieldTag::__policy_name),
                                "policy_name" => Ok(__FieldTag::__policy_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PlacementPolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PlacementPolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::node_pool::placement_policy::Type,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tpu_topology => {
                                if !fields.insert(__FieldTag::__tpu_topology) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tpu_topology",
                                    ));
                                }
                                result.tpu_topology = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__policy_name => {
                                if !fields.insert(__FieldTag::__policy_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for policy_name",
                                    ));
                                }
                                result.policy_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PlacementPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.tpu_topology.is_empty() {
                state.serialize_entry("tpuTopology", &self.tpu_topology)?;
            }
            if !self.policy_name.is_empty() {
                state.serialize_entry("policyName", &self.policy_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PlacementPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PlacementPolicy");
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("tpu_topology", &self.tpu_topology);
            debug_struct.field("policy_name", &self.policy_name);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [PlacementPolicy].
    pub mod placement_policy {
        #[allow(unused_imports)]
        use super::*;

        /// Type defines the type of placement policy.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// TYPE_UNSPECIFIED specifies no requirements on nodes
            /// placement.
            Unspecified,
            /// COMPACT specifies node placement in the same availability domain to
            /// ensure low communication latency.
            Compact,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Compact => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::Compact => std::option::Option::Some("COMPACT"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Compact,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "COMPACT" => Self::Compact,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Compact => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.container.v1.NodePool.PlacementPolicy.Type",
                ))
            }
        }
    }

    /// QueuedProvisioning defines the queued provisioning used by the node pool.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct QueuedProvisioning {
        /// Denotes that this nodepool is QRM specific, meaning nodes can be only
        /// obtained through queuing via the Cluster Autoscaler ProvisioningRequest
        /// API.
        pub enabled: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl QueuedProvisioning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::node_pool::QueuedProvisioning::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for QueuedProvisioning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NodePool.QueuedProvisioning"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for QueuedProvisioning {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for QueuedProvisioning")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = QueuedProvisioning;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct QueuedProvisioning")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for QueuedProvisioning {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for QueuedProvisioning {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("QueuedProvisioning");
            debug_struct.field("enabled", &self.enabled);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The current status of the node pool instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Not set.
        Unspecified,
        /// The PROVISIONING state indicates the node pool is being created.
        Provisioning,
        /// The RUNNING state indicates the node pool has been created
        /// and is fully usable.
        Running,
        /// The RUNNING_WITH_ERROR state indicates the node pool has been created
        /// and is partially usable. Some error state has occurred and some
        /// functionality may be impaired. Customer may need to reissue a request
        /// or trigger a new update.
        RunningWithError,
        /// The RECONCILING state indicates that some work is actively being done on
        /// the node pool, such as upgrading node software. Details can
        /// be found in the `statusMessage` field.
        Reconciling,
        /// The STOPPING state indicates the node pool is being deleted.
        Stopping,
        /// The ERROR state indicates the node pool may be unusable. Details
        /// can be found in the `statusMessage` field.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::RunningWithError => std::option::Option::Some(3),
                Self::Reconciling => std::option::Option::Some(4),
                Self::Stopping => std::option::Option::Some(5),
                Self::Error => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::RunningWithError => std::option::Option::Some("RUNNING_WITH_ERROR"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::RunningWithError,
                4 => Self::Reconciling,
                5 => Self::Stopping,
                6 => Self::Error,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "RUNNING_WITH_ERROR" => Self::RunningWithError,
                "RECONCILING" => Self::Reconciling,
                "STOPPING" => Self::Stopping,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::RunningWithError => serializer.serialize_i32(3),
                Self::Reconciling => serializer.serialize_i32(4),
                Self::Stopping => serializer.serialize_i32(5),
                Self::Error => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.container.v1.NodePool.Status",
            ))
        }
    }
}

/// NodeManagement defines the set of node management services turned on for the
/// node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodeManagement {
    /// A flag that specifies whether node auto-upgrade is enabled for the node
    /// pool. If enabled, node auto-upgrade helps keep the nodes in your node pool
    /// up to date with the latest release version of Kubernetes.
    pub auto_upgrade: bool,

    /// A flag that specifies whether the node auto-repair is enabled for the node
    /// pool. If enabled, the nodes in this node pool will be monitored and, if
    /// they fail health checks too many times, an automatic repair action will be
    /// triggered.
    pub auto_repair: bool,

    /// Specifies the Auto Upgrade knobs for the node pool.
    pub upgrade_options: std::option::Option<crate::model::AutoUpgradeOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodeManagement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_upgrade][crate::model::NodeManagement::auto_upgrade].
    pub fn set_auto_upgrade<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_upgrade = v.into();
        self
    }

    /// Sets the value of [auto_repair][crate::model::NodeManagement::auto_repair].
    pub fn set_auto_repair<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.auto_repair = v.into();
        self
    }

    /// Sets the value of [upgrade_options][crate::model::NodeManagement::upgrade_options].
    pub fn set_upgrade_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoUpgradeOptions>,
    {
        self.upgrade_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upgrade_options][crate::model::NodeManagement::upgrade_options].
    pub fn set_or_clear_upgrade_options<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutoUpgradeOptions>,
    {
        self.upgrade_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodeManagement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodeManagement"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodeManagement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auto_upgrade,
            __auto_repair,
            __upgrade_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeManagement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autoUpgrade" => Ok(__FieldTag::__auto_upgrade),
                            "auto_upgrade" => Ok(__FieldTag::__auto_upgrade),
                            "autoRepair" => Ok(__FieldTag::__auto_repair),
                            "auto_repair" => Ok(__FieldTag::__auto_repair),
                            "upgradeOptions" => Ok(__FieldTag::__upgrade_options),
                            "upgrade_options" => Ok(__FieldTag::__upgrade_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodeManagement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeManagement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auto_upgrade => {
                            if !fields.insert(__FieldTag::__auto_upgrade) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_upgrade",
                                ));
                            }
                            result.auto_upgrade = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_repair => {
                            if !fields.insert(__FieldTag::__auto_repair) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_repair",
                                ));
                            }
                            result.auto_repair = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgrade_options => {
                            if !fields.insert(__FieldTag::__upgrade_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_options",
                                ));
                            }
                            result.upgrade_options = map.next_value::<std::option::Option<crate::model::AutoUpgradeOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodeManagement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.auto_upgrade) {
            state.serialize_entry("autoUpgrade", &self.auto_upgrade)?;
        }
        if !wkt::internal::is_default(&self.auto_repair) {
            state.serialize_entry("autoRepair", &self.auto_repair)?;
        }
        if self.upgrade_options.is_some() {
            state.serialize_entry("upgradeOptions", &self.upgrade_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodeManagement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeManagement");
        debug_struct.field("auto_upgrade", &self.auto_upgrade);
        debug_struct.field("auto_repair", &self.auto_repair);
        debug_struct.field("upgrade_options", &self.upgrade_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Best effort provisioning.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BestEffortProvisioning {
    /// When this is enabled, cluster/node pool creations will ignore non-fatal
    /// errors like stockout to best provision as many nodes as possible right now
    /// and eventually bring up all target number of nodes
    pub enabled: bool,

    /// Minimum number of nodes to be provisioned to be considered as succeeded,
    /// and the rest of nodes will be provisioned gradually and eventually when
    /// stockout issue has been resolved.
    pub min_provision_nodes: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BestEffortProvisioning {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::BestEffortProvisioning::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [min_provision_nodes][crate::model::BestEffortProvisioning::min_provision_nodes].
    pub fn set_min_provision_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_provision_nodes = v.into();
        self
    }
}

impl wkt::message::Message for BestEffortProvisioning {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.BestEffortProvisioning"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BestEffortProvisioning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __min_provision_nodes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BestEffortProvisioning")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "minProvisionNodes" => Ok(__FieldTag::__min_provision_nodes),
                            "min_provision_nodes" => Ok(__FieldTag::__min_provision_nodes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BestEffortProvisioning;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BestEffortProvisioning")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_provision_nodes => {
                            if !fields.insert(__FieldTag::__min_provision_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_provision_nodes",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_provision_nodes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BestEffortProvisioning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.min_provision_nodes) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minProvisionNodes", &__With(&self.min_provision_nodes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BestEffortProvisioning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BestEffortProvisioning");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("min_provision_nodes", &self.min_provision_nodes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AutoUpgradeOptions defines the set of options for the user to control how
/// the Auto Upgrades will proceed.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoUpgradeOptions {
    /// Output only. This field is set when upgrades are about to commence
    /// with the approximate start time for the upgrades, in
    /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
    pub auto_upgrade_start_time: std::string::String,

    /// Output only. This field is set when upgrades are about to commence
    /// with the description of the upgrade.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoUpgradeOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_upgrade_start_time][crate::model::AutoUpgradeOptions::auto_upgrade_start_time].
    pub fn set_auto_upgrade_start_time<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.auto_upgrade_start_time = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AutoUpgradeOptions::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for AutoUpgradeOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AutoUpgradeOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutoUpgradeOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auto_upgrade_start_time,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoUpgradeOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autoUpgradeStartTime" => Ok(__FieldTag::__auto_upgrade_start_time),
                            "auto_upgrade_start_time" => Ok(__FieldTag::__auto_upgrade_start_time),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutoUpgradeOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoUpgradeOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auto_upgrade_start_time => {
                            if !fields.insert(__FieldTag::__auto_upgrade_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_upgrade_start_time",
                                ));
                            }
                            result.auto_upgrade_start_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutoUpgradeOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.auto_upgrade_start_time.is_empty() {
            state.serialize_entry("autoUpgradeStartTime", &self.auto_upgrade_start_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutoUpgradeOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoUpgradeOptions");
        debug_struct.field("auto_upgrade_start_time", &self.auto_upgrade_start_time);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MaintenancePolicy defines the maintenance policy to be used for the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenancePolicy {
    /// Specifies the maintenance window in which maintenance may be performed.
    pub window: std::option::Option<crate::model::MaintenanceWindow>,

    /// A hash identifying the version of this policy, so that updates to fields of
    /// the policy won't accidentally undo intermediate changes (and so that users
    /// of the API unaware of some fields won't accidentally remove other fields).
    /// Make a `get()` request to the cluster to get the current
    /// resource version and include it with requests to set the policy.
    pub resource_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenancePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::MaintenancePolicy::window].
    pub fn set_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window][crate::model::MaintenancePolicy::window].
    pub fn set_or_clear_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_version][crate::model::MaintenancePolicy::resource_version].
    pub fn set_resource_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_version = v.into();
        self
    }
}

impl wkt::message::Message for MaintenancePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MaintenancePolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaintenancePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __window,
            __resource_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenancePolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "window" => Ok(__FieldTag::__window),
                            "resourceVersion" => Ok(__FieldTag::__resource_version),
                            "resource_version" => Ok(__FieldTag::__resource_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaintenancePolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenancePolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__window => {
                            if !fields.insert(__FieldTag::__window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for window",
                                ));
                            }
                            result.window = map
                                .next_value::<std::option::Option<crate::model::MaintenanceWindow>>(
                                )?;
                        }
                        __FieldTag::__resource_version => {
                            if !fields.insert(__FieldTag::__resource_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_version",
                                ));
                            }
                            result.resource_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaintenancePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.window.is_some() {
            state.serialize_entry("window", &self.window)?;
        }
        if !self.resource_version.is_empty() {
            state.serialize_entry("resourceVersion", &self.resource_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaintenancePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenancePolicy");
        debug_struct.field("window", &self.window);
        debug_struct.field("resource_version", &self.resource_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MaintenanceWindow defines the maintenance window to be used for the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceWindow {
    /// Exceptions to maintenance window. Non-emergency maintenance should not
    /// occur in these windows.
    pub maintenance_exclusions:
        std::collections::HashMap<std::string::String, crate::model::TimeWindow>,

    pub policy: std::option::Option<crate::model::maintenance_window::Policy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [maintenance_exclusions][crate::model::MaintenanceWindow::maintenance_exclusions].
    pub fn set_maintenance_exclusions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::TimeWindow>,
    {
        use std::iter::Iterator;
        self.maintenance_exclusions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [policy][crate::model::MaintenanceWindow::policy].
    ///
    /// Note that all the setters affecting `policy` are mutually
    /// exclusive.
    pub fn set_policy<
        T: std::convert::Into<std::option::Option<crate::model::maintenance_window::Policy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }

    /// The value of [policy][crate::model::MaintenanceWindow::policy]
    /// if it holds a `DailyMaintenanceWindow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn daily_maintenance_window(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DailyMaintenanceWindow>> {
        #[allow(unreachable_patterns)]
        self.policy.as_ref().and_then(|v| match v {
            crate::model::maintenance_window::Policy::DailyMaintenanceWindow(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [policy][crate::model::MaintenanceWindow::policy]
    /// to hold a `DailyMaintenanceWindow`.
    ///
    /// Note that all the setters affecting `policy` are
    /// mutually exclusive.
    pub fn set_daily_maintenance_window<
        T: std::convert::Into<std::boxed::Box<crate::model::DailyMaintenanceWindow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy = std::option::Option::Some(
            crate::model::maintenance_window::Policy::DailyMaintenanceWindow(v.into()),
        );
        self
    }

    /// The value of [policy][crate::model::MaintenanceWindow::policy]
    /// if it holds a `RecurringWindow`, `None` if the field is not set or
    /// holds a different branch.
    pub fn recurring_window(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::RecurringTimeWindow>> {
        #[allow(unreachable_patterns)]
        self.policy.as_ref().and_then(|v| match v {
            crate::model::maintenance_window::Policy::RecurringWindow(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [policy][crate::model::MaintenanceWindow::policy]
    /// to hold a `RecurringWindow`.
    ///
    /// Note that all the setters affecting `policy` are
    /// mutually exclusive.
    pub fn set_recurring_window<
        T: std::convert::Into<std::boxed::Box<crate::model::RecurringTimeWindow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.policy = std::option::Option::Some(
            crate::model::maintenance_window::Policy::RecurringWindow(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MaintenanceWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaintenanceWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __daily_maintenance_window,
            __recurring_window,
            __maintenance_exclusions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dailyMaintenanceWindow" => Ok(__FieldTag::__daily_maintenance_window),
                            "daily_maintenance_window" => {
                                Ok(__FieldTag::__daily_maintenance_window)
                            }
                            "recurringWindow" => Ok(__FieldTag::__recurring_window),
                            "recurring_window" => Ok(__FieldTag::__recurring_window),
                            "maintenanceExclusions" => Ok(__FieldTag::__maintenance_exclusions),
                            "maintenance_exclusions" => Ok(__FieldTag::__maintenance_exclusions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaintenanceWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__daily_maintenance_window => {
                            if !fields.insert(__FieldTag::__daily_maintenance_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for daily_maintenance_window",
                                ));
                            }
                            if result.policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `policy`, a oneof with full ID .google.container.v1.MaintenanceWindow.daily_maintenance_window, latest field was dailyMaintenanceWindow",
                                ));
                            }
                            result.policy = std::option::Option::Some(
                                crate::model::maintenance_window::Policy::DailyMaintenanceWindow(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DailyMaintenanceWindow>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__recurring_window => {
                            if !fields.insert(__FieldTag::__recurring_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurring_window",
                                ));
                            }
                            if result.policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `policy`, a oneof with full ID .google.container.v1.MaintenanceWindow.recurring_window, latest field was recurringWindow",
                                ));
                            }
                            result.policy = std::option::Option::Some(
                                crate::model::maintenance_window::Policy::RecurringWindow(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RecurringTimeWindow>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__maintenance_exclusions => {
                            if !fields.insert(__FieldTag::__maintenance_exclusions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_exclusions",
                                ));
                            }
                            result.maintenance_exclusions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::TimeWindow,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaintenanceWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.daily_maintenance_window() {
            state.serialize_entry("dailyMaintenanceWindow", value)?;
        }
        if let Some(value) = self.recurring_window() {
            state.serialize_entry("recurringWindow", value)?;
        }
        if !self.maintenance_exclusions.is_empty() {
            state.serialize_entry("maintenanceExclusions", &self.maintenance_exclusions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenanceWindow");
        debug_struct.field("maintenance_exclusions", &self.maintenance_exclusions);
        debug_struct.field("policy", &self.policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MaintenanceWindow].
pub mod maintenance_window {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Policy {
        /// DailyMaintenanceWindow specifies a daily maintenance operation window.
        DailyMaintenanceWindow(std::boxed::Box<crate::model::DailyMaintenanceWindow>),
        /// RecurringWindow specifies some number of recurring time periods for
        /// maintenance to occur. The time windows may be overlapping. If no
        /// maintenance windows are set, maintenance can occur at any time.
        RecurringWindow(std::boxed::Box<crate::model::RecurringTimeWindow>),
    }
}

/// Represents an arbitrary window of time.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeWindow {
    /// The time that the window first starts.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time that the window ends. The end time should take place after the
    /// start time.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub options: std::option::Option<crate::model::time_window::Options>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimeWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TimeWindow::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimeWindow::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [options][crate::model::TimeWindow::options].
    ///
    /// Note that all the setters affecting `options` are mutually
    /// exclusive.
    pub fn set_options<
        T: std::convert::Into<std::option::Option<crate::model::time_window::Options>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options = v.into();
        self
    }

    /// The value of [options][crate::model::TimeWindow::options]
    /// if it holds a `MaintenanceExclusionOptions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn maintenance_exclusion_options(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MaintenanceExclusionOptions>> {
        #[allow(unreachable_patterns)]
        self.options.as_ref().and_then(|v| match v {
            crate::model::time_window::Options::MaintenanceExclusionOptions(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [options][crate::model::TimeWindow::options]
    /// to hold a `MaintenanceExclusionOptions`.
    ///
    /// Note that all the setters affecting `options` are
    /// mutually exclusive.
    pub fn set_maintenance_exclusion_options<
        T: std::convert::Into<std::boxed::Box<crate::model::MaintenanceExclusionOptions>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.options = std::option::Option::Some(
            crate::model::time_window::Options::MaintenanceExclusionOptions(v.into()),
        );
        self
    }
}

impl wkt::message::Message for TimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.TimeWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __maintenance_exclusion_options,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maintenanceExclusionOptions" => {
                                Ok(__FieldTag::__maintenance_exclusion_options)
                            }
                            "maintenance_exclusion_options" => {
                                Ok(__FieldTag::__maintenance_exclusion_options)
                            }
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__maintenance_exclusion_options => {
                            if !fields.insert(__FieldTag::__maintenance_exclusion_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_exclusion_options",
                                ));
                            }
                            if result.options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `options`, a oneof with full ID .google.container.v1.TimeWindow.maintenance_exclusion_options, latest field was maintenanceExclusionOptions",
                                ));
                            }
                            result.options = std::option::Option::Some(
                                crate::model::time_window::Options::MaintenanceExclusionOptions(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MaintenanceExclusionOptions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.maintenance_exclusion_options() {
            state.serialize_entry("maintenanceExclusionOptions", value)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeWindow");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("options", &self.options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [TimeWindow].
pub mod time_window {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Options {
        /// MaintenanceExclusionOptions provides maintenance exclusion related
        /// options.
        MaintenanceExclusionOptions(std::boxed::Box<crate::model::MaintenanceExclusionOptions>),
    }
}

/// Represents the Maintenance exclusion option.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceExclusionOptions {
    /// Scope specifies the upgrade scope which upgrades are blocked by the
    /// exclusion.
    pub scope: crate::model::maintenance_exclusion_options::Scope,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceExclusionOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::MaintenanceExclusionOptions::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::maintenance_exclusion_options::Scope>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceExclusionOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MaintenanceExclusionOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaintenanceExclusionOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceExclusionOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaintenanceExclusionOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceExclusionOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<
                                    crate::model::maintenance_exclusion_options::Scope,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaintenanceExclusionOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaintenanceExclusionOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenanceExclusionOptions");
        debug_struct.field("scope", &self.scope);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MaintenanceExclusionOptions].
pub mod maintenance_exclusion_options {
    #[allow(unused_imports)]
    use super::*;

    /// Scope of exclusion.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// NO_UPGRADES excludes all upgrades, including patch upgrades and minor
        /// upgrades across control planes and nodes. This is the default exclusion
        /// behavior.
        NoUpgrades,
        /// NO_MINOR_UPGRADES excludes all minor upgrades for the cluster, only
        /// patches are allowed.
        NoMinorUpgrades,
        /// NO_MINOR_OR_NODE_UPGRADES excludes all minor upgrades for the cluster,
        /// and also exclude all node pool upgrades. Only control
        /// plane patches are allowed.
        NoMinorOrNodeUpgrades,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::NoUpgrades => std::option::Option::Some(0),
                Self::NoMinorUpgrades => std::option::Option::Some(1),
                Self::NoMinorOrNodeUpgrades => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::NoUpgrades => std::option::Option::Some("NO_UPGRADES"),
                Self::NoMinorUpgrades => std::option::Option::Some("NO_MINOR_UPGRADES"),
                Self::NoMinorOrNodeUpgrades => {
                    std::option::Option::Some("NO_MINOR_OR_NODE_UPGRADES")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::NoUpgrades,
                1 => Self::NoMinorUpgrades,
                2 => Self::NoMinorOrNodeUpgrades,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NO_UPGRADES" => Self::NoUpgrades,
                "NO_MINOR_UPGRADES" => Self::NoMinorUpgrades,
                "NO_MINOR_OR_NODE_UPGRADES" => Self::NoMinorOrNodeUpgrades,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::NoUpgrades => serializer.serialize_i32(0),
                Self::NoMinorUpgrades => serializer.serialize_i32(1),
                Self::NoMinorOrNodeUpgrades => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.container.v1.MaintenanceExclusionOptions.Scope",
            ))
        }
    }
}

/// Represents an arbitrary window of time that recurs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RecurringTimeWindow {
    /// The window of the first recurrence.
    pub window: std::option::Option<crate::model::TimeWindow>,

    /// An RRULE (<https://tools.ietf.org/html/rfc5545#section-3.8.5.3>) for how
    /// this window reccurs. They go on for the span of time between the start and
    /// end time.
    ///
    /// For example, to have something repeat every weekday, you'd use:
    /// `FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR`
    ///
    /// To repeat some window daily (equivalent to the DailyMaintenanceWindow):
    /// `FREQ=DAILY`
    ///
    /// For the first weekend of every month:
    /// `FREQ=MONTHLY;BYSETPOS=1;BYDAY=SA,SU`
    ///
    /// This specifies how frequently the window starts. Eg, if you wanted to have
    /// a 9-5 UTC-4 window every weekday, you'd use something like:
    ///
    /// ```norust
    /// start time = 2019-01-01T09:00:00-0400
    /// end time = 2019-01-01T17:00:00-0400
    /// recurrence = FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR
    /// ```
    ///
    /// Windows can span multiple days. Eg, to make the window encompass every
    /// weekend from midnight Saturday till the last minute of Sunday UTC:
    ///
    /// ```norust
    /// start time = 2019-01-05T00:00:00Z
    /// end time = 2019-01-07T23:59:00Z
    /// recurrence = FREQ=WEEKLY;BYDAY=SA
    /// ```
    ///
    /// Note the start and end time's specific dates are largely arbitrary except
    /// to specify duration of the window and when it first starts.
    /// The FREQ values of HOURLY, MINUTELY, and SECONDLY are not supported.
    pub recurrence: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecurringTimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::RecurringTimeWindow::window].
    pub fn set_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindow>,
    {
        self.window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window][crate::model::RecurringTimeWindow::window].
    pub fn set_or_clear_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindow>,
    {
        self.window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recurrence][crate::model::RecurringTimeWindow::recurrence].
    pub fn set_recurrence<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recurrence = v.into();
        self
    }
}

impl wkt::message::Message for RecurringTimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RecurringTimeWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecurringTimeWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __window,
            __recurrence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecurringTimeWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "window" => Ok(__FieldTag::__window),
                            "recurrence" => Ok(__FieldTag::__recurrence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecurringTimeWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecurringTimeWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__window => {
                            if !fields.insert(__FieldTag::__window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for window",
                                ));
                            }
                            result.window =
                                map.next_value::<std::option::Option<crate::model::TimeWindow>>()?;
                        }
                        __FieldTag::__recurrence => {
                            if !fields.insert(__FieldTag::__recurrence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurrence",
                                ));
                            }
                            result.recurrence = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecurringTimeWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.window.is_some() {
            state.serialize_entry("window", &self.window)?;
        }
        if !self.recurrence.is_empty() {
            state.serialize_entry("recurrence", &self.recurrence)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RecurringTimeWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecurringTimeWindow");
        debug_struct.field("window", &self.window);
        debug_struct.field("recurrence", &self.recurrence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Time window specified for daily maintenance operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DailyMaintenanceWindow {
    /// Time within the maintenance window to start the maintenance operations.
    /// Time format should be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
    /// format "HH:MM", where HH : [00-23] and MM : [00-59] GMT.
    pub start_time: std::string::String,

    /// Output only. Duration of the time window, automatically chosen to be
    /// smallest possible in the given scenario.
    /// Duration will be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
    /// format "PTnHnMnS".
    pub duration: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DailyMaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::DailyMaintenanceWindow::start_time].
    pub fn set_start_time<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [duration][crate::model::DailyMaintenanceWindow::duration].
    pub fn set_duration<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.duration = v.into();
        self
    }
}

impl wkt::message::Message for DailyMaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DailyMaintenanceWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DailyMaintenanceWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DailyMaintenanceWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "duration" => Ok(__FieldTag::__duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DailyMaintenanceWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DailyMaintenanceWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DailyMaintenanceWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.start_time.is_empty() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self.duration.is_empty() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DailyMaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DailyMaintenanceWindow");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("duration", &self.duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SetNodePoolManagementRequest sets the node management properties of a node
/// pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetNodePoolManagementRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to update.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to update.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// Required. NodeManagement configuration for the node pool.
    pub management: std::option::Option<crate::model::NodeManagement>,

    /// The name (project, location, cluster, node pool id) of the node pool to set
    /// management properties. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetNodePoolManagementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetNodePoolManagementRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetNodePoolManagementRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetNodePoolManagementRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::SetNodePoolManagementRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [management][crate::model::SetNodePoolManagementRequest::management].
    pub fn set_management<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeManagement>,
    {
        self.management = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [management][crate::model::SetNodePoolManagementRequest::management].
    pub fn set_or_clear_management<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeManagement>,
    {
        self.management = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::SetNodePoolManagementRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetNodePoolManagementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetNodePoolManagementRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetNodePoolManagementRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __management,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetNodePoolManagementRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "management" => Ok(__FieldTag::__management),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetNodePoolManagementRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetNodePoolManagementRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__management => {
                            if !fields.insert(__FieldTag::__management) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management",
                                ));
                            }
                            result.management = map
                                .next_value::<std::option::Option<crate::model::NodeManagement>>(
                                )?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetNodePoolManagementRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if self.management.is_some() {
            state.serialize_entry("management", &self.management)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetNodePoolManagementRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetNodePoolManagementRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("management", &self.management);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SetNodePoolSizeRequest sets the size of a node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetNodePoolSizeRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to update.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to update.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// Required. The desired node count for the pool.
    pub node_count: i32,

    /// The name (project, location, cluster, node pool id) of the node pool to set
    /// size.
    /// Specified in the format `projects/*/locations/*/clusters/*/nodePools/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetNodePoolSizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetNodePoolSizeRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetNodePoolSizeRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetNodePoolSizeRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::SetNodePoolSizeRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::SetNodePoolSizeRequest::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetNodePoolSizeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetNodePoolSizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetNodePoolSizeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetNodePoolSizeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __node_count,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetNodePoolSizeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "nodeCount" => Ok(__FieldTag::__node_count),
                            "node_count" => Ok(__FieldTag::__node_count),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetNodePoolSizeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetNodePoolSizeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_count => {
                            if !fields.insert(__FieldTag::__node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.node_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetNodePoolSizeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !wkt::internal::is_default(&self.node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nodeCount", &__With(&self.node_count))?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetNodePoolSizeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetNodePoolSizeRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("node_count", &self.node_count);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CompleteNodePoolUpgradeRequest sets the name of target node pool to complete
/// upgrade.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompleteNodePoolUpgradeRequest {
    /// The name (project, location, cluster, node pool id) of the node pool to
    /// complete upgrade.
    /// Specified in the format `projects/*/locations/*/clusters/*/nodePools/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompleteNodePoolUpgradeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CompleteNodePoolUpgradeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CompleteNodePoolUpgradeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CompleteNodePoolUpgradeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompleteNodePoolUpgradeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompleteNodePoolUpgradeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompleteNodePoolUpgradeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompleteNodePoolUpgradeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompleteNodePoolUpgradeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompleteNodePoolUpgradeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompleteNodePoolUpgradeRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// RollbackNodePoolUpgradeRequest rollbacks the previously Aborted or Failed
/// NodePool upgrade. This will be an no-op if the last upgrade successfully
/// completed.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RollbackNodePoolUpgradeRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to rollback.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Deprecated. The name of the node pool to rollback.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub node_pool_id: std::string::String,

    /// The name (project, location, cluster, node pool id) of the node poll to
    /// rollback upgrade.
    /// Specified in the format `projects/*/locations/*/clusters/*/nodePools/*`.
    pub name: std::string::String,

    /// Option for rollback to ignore the PodDisruptionBudget.
    /// Default value is false.
    pub respect_pdb: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackNodePoolUpgradeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::RollbackNodePoolUpgradeRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::RollbackNodePoolUpgradeRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::RollbackNodePoolUpgradeRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::RollbackNodePoolUpgradeRequest::node_pool_id].
    #[deprecated]
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::RollbackNodePoolUpgradeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [respect_pdb][crate::model::RollbackNodePoolUpgradeRequest::respect_pdb].
    pub fn set_respect_pdb<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.respect_pdb = v.into();
        self
    }
}

impl wkt::message::Message for RollbackNodePoolUpgradeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RollbackNodePoolUpgradeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RollbackNodePoolUpgradeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __name,
            __respect_pdb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RollbackNodePoolUpgradeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "name" => Ok(__FieldTag::__name),
                            "respectPdb" => Ok(__FieldTag::__respect_pdb),
                            "respect_pdb" => Ok(__FieldTag::__respect_pdb),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RollbackNodePoolUpgradeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RollbackNodePoolUpgradeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__respect_pdb => {
                            if !fields.insert(__FieldTag::__respect_pdb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for respect_pdb",
                                ));
                            }
                            result.respect_pdb = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RollbackNodePoolUpgradeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.respect_pdb) {
            state.serialize_entry("respectPdb", &self.respect_pdb)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RollbackNodePoolUpgradeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RollbackNodePoolUpgradeRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("name", &self.name);
        debug_struct.field("respect_pdb", &self.respect_pdb);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListNodePoolsResponse is the result of ListNodePoolsRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNodePoolsResponse {
    /// A list of node pools for a cluster.
    pub node_pools: std::vec::Vec<crate::model::NodePool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_pools][crate::model::ListNodePoolsResponse::node_pools].
    pub fn set_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodePool>,
    {
        use std::iter::Iterator;
        self.node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNodePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListNodePoolsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNodePoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_pools,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNodePoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodePools" => Ok(__FieldTag::__node_pools),
                            "node_pools" => Ok(__FieldTag::__node_pools),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNodePoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNodePoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_pools => {
                            if !fields.insert(__FieldTag::__node_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pools",
                                ));
                            }
                            result.node_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NodePool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNodePoolsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_pools.is_empty() {
            state.serialize_entry("nodePools", &self.node_pools)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListNodePoolsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNodePoolsResponse");
        debug_struct.field("node_pools", &self.node_pools);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ClusterAutoscaling contains global, per-cluster information
/// required by Cluster Autoscaler to automatically adjust
/// the size of the cluster and create/delete
/// node pools based on the current needs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterAutoscaling {
    /// Enables automatic node pool creation and deletion.
    pub enable_node_autoprovisioning: bool,

    /// Contains global constraints regarding minimum and maximum
    /// amount of resources in the cluster.
    pub resource_limits: std::vec::Vec<crate::model::ResourceLimit>,

    /// Defines autoscaling behaviour.
    pub autoscaling_profile: crate::model::cluster_autoscaling::AutoscalingProfile,

    /// AutoprovisioningNodePoolDefaults contains defaults for a node pool
    /// created by NAP.
    pub autoprovisioning_node_pool_defaults:
        std::option::Option<crate::model::AutoprovisioningNodePoolDefaults>,

    /// The list of Google Compute Engine
    /// [zones](https://cloud.google.com/compute/docs/zones#available)
    /// in which the NodePool's nodes can be created by NAP.
    pub autoprovisioning_locations: std::vec::Vec<std::string::String>,

    /// Default compute class is a configuration for default compute class.
    pub default_compute_class_config: std::option::Option<crate::model::DefaultComputeClassConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_node_autoprovisioning][crate::model::ClusterAutoscaling::enable_node_autoprovisioning].
    pub fn set_enable_node_autoprovisioning<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_node_autoprovisioning = v.into();
        self
    }

    /// Sets the value of [resource_limits][crate::model::ClusterAutoscaling::resource_limits].
    pub fn set_resource_limits<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ResourceLimit>,
    {
        use std::iter::Iterator;
        self.resource_limits = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [autoscaling_profile][crate::model::ClusterAutoscaling::autoscaling_profile].
    pub fn set_autoscaling_profile<
        T: std::convert::Into<crate::model::cluster_autoscaling::AutoscalingProfile>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.autoscaling_profile = v.into();
        self
    }

    /// Sets the value of [autoprovisioning_node_pool_defaults][crate::model::ClusterAutoscaling::autoprovisioning_node_pool_defaults].
    pub fn set_autoprovisioning_node_pool_defaults<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoprovisioningNodePoolDefaults>,
    {
        self.autoprovisioning_node_pool_defaults = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoprovisioning_node_pool_defaults][crate::model::ClusterAutoscaling::autoprovisioning_node_pool_defaults].
    pub fn set_or_clear_autoprovisioning_node_pool_defaults<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::AutoprovisioningNodePoolDefaults>,
    {
        self.autoprovisioning_node_pool_defaults = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autoprovisioning_locations][crate::model::ClusterAutoscaling::autoprovisioning_locations].
    pub fn set_autoprovisioning_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.autoprovisioning_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_compute_class_config][crate::model::ClusterAutoscaling::default_compute_class_config].
    pub fn set_default_compute_class_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DefaultComputeClassConfig>,
    {
        self.default_compute_class_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_compute_class_config][crate::model::ClusterAutoscaling::default_compute_class_config].
    pub fn set_or_clear_default_compute_class_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DefaultComputeClassConfig>,
    {
        self.default_compute_class_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ClusterAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ClusterAutoscaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_node_autoprovisioning,
            __resource_limits,
            __autoscaling_profile,
            __autoprovisioning_node_pool_defaults,
            __autoprovisioning_locations,
            __default_compute_class_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableNodeAutoprovisioning" => {
                                Ok(__FieldTag::__enable_node_autoprovisioning)
                            }
                            "enable_node_autoprovisioning" => {
                                Ok(__FieldTag::__enable_node_autoprovisioning)
                            }
                            "resourceLimits" => Ok(__FieldTag::__resource_limits),
                            "resource_limits" => Ok(__FieldTag::__resource_limits),
                            "autoscalingProfile" => Ok(__FieldTag::__autoscaling_profile),
                            "autoscaling_profile" => Ok(__FieldTag::__autoscaling_profile),
                            "autoprovisioningNodePoolDefaults" => {
                                Ok(__FieldTag::__autoprovisioning_node_pool_defaults)
                            }
                            "autoprovisioning_node_pool_defaults" => {
                                Ok(__FieldTag::__autoprovisioning_node_pool_defaults)
                            }
                            "autoprovisioningLocations" => {
                                Ok(__FieldTag::__autoprovisioning_locations)
                            }
                            "autoprovisioning_locations" => {
                                Ok(__FieldTag::__autoprovisioning_locations)
                            }
                            "defaultComputeClassConfig" => {
                                Ok(__FieldTag::__default_compute_class_config)
                            }
                            "default_compute_class_config" => {
                                Ok(__FieldTag::__default_compute_class_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_node_autoprovisioning => {
                            if !fields.insert(__FieldTag::__enable_node_autoprovisioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_node_autoprovisioning",
                                ));
                            }
                            result.enable_node_autoprovisioning = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_limits => {
                            if !fields.insert(__FieldTag::__resource_limits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_limits",
                                ));
                            }
                            result.resource_limits = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ResourceLimit>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__autoscaling_profile => {
                            if !fields.insert(__FieldTag::__autoscaling_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling_profile",
                                ));
                            }
                            result.autoscaling_profile = map
                                .next_value::<std::option::Option<
                                    crate::model::cluster_autoscaling::AutoscalingProfile,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autoprovisioning_node_pool_defaults => {
                            if !fields.insert(__FieldTag::__autoprovisioning_node_pool_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoprovisioning_node_pool_defaults",
                                ));
                            }
                            result.autoprovisioning_node_pool_defaults = map
                                .next_value::<std::option::Option<
                                    crate::model::AutoprovisioningNodePoolDefaults,
                                >>()?;
                        }
                        __FieldTag::__autoprovisioning_locations => {
                            if !fields.insert(__FieldTag::__autoprovisioning_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoprovisioning_locations",
                                ));
                            }
                            result.autoprovisioning_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_compute_class_config => {
                            if !fields.insert(__FieldTag::__default_compute_class_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_compute_class_config",
                                ));
                            }
                            result.default_compute_class_config = map.next_value::<std::option::Option<crate::model::DefaultComputeClassConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_node_autoprovisioning) {
            state.serialize_entry(
                "enableNodeAutoprovisioning",
                &self.enable_node_autoprovisioning,
            )?;
        }
        if !self.resource_limits.is_empty() {
            state.serialize_entry("resourceLimits", &self.resource_limits)?;
        }
        if !wkt::internal::is_default(&self.autoscaling_profile) {
            state.serialize_entry("autoscalingProfile", &self.autoscaling_profile)?;
        }
        if self.autoprovisioning_node_pool_defaults.is_some() {
            state.serialize_entry(
                "autoprovisioningNodePoolDefaults",
                &self.autoprovisioning_node_pool_defaults,
            )?;
        }
        if !self.autoprovisioning_locations.is_empty() {
            state.serialize_entry(
                "autoprovisioningLocations",
                &self.autoprovisioning_locations,
            )?;
        }
        if self.default_compute_class_config.is_some() {
            state.serialize_entry(
                "defaultComputeClassConfig",
                &self.default_compute_class_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClusterAutoscaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterAutoscaling");
        debug_struct.field(
            "enable_node_autoprovisioning",
            &self.enable_node_autoprovisioning,
        );
        debug_struct.field("resource_limits", &self.resource_limits);
        debug_struct.field("autoscaling_profile", &self.autoscaling_profile);
        debug_struct.field(
            "autoprovisioning_node_pool_defaults",
            &self.autoprovisioning_node_pool_defaults,
        );
        debug_struct.field(
            "autoprovisioning_locations",
            &self.autoprovisioning_locations,
        );
        debug_struct.field(
            "default_compute_class_config",
            &self.default_compute_class_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ClusterAutoscaling].
pub mod cluster_autoscaling {
    #[allow(unused_imports)]
    use super::*;

    /// Defines possible options for autoscaling_profile field.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoscalingProfile {
        /// No change to autoscaling configuration.
        ProfileUnspecified,
        /// Prioritize optimizing utilization of resources.
        OptimizeUtilization,
        /// Use default (balanced) autoscaling configuration.
        Balanced,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoscalingProfile::value] or
        /// [AutoscalingProfile::name].
        UnknownValue(autoscaling_profile::UnknownValue),
    }

    #[doc(hidden)]
    pub mod autoscaling_profile {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AutoscalingProfile {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ProfileUnspecified => std::option::Option::Some(0),
                Self::OptimizeUtilization => std::option::Option::Some(1),
                Self::Balanced => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ProfileUnspecified => std::option::Option::Some("PROFILE_UNSPECIFIED"),
                Self::OptimizeUtilization => std::option::Option::Some("OPTIMIZE_UTILIZATION"),
                Self::Balanced => std::option::Option::Some("BALANCED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AutoscalingProfile {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AutoscalingProfile {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AutoscalingProfile {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ProfileUnspecified,
                1 => Self::OptimizeUtilization,
                2 => Self::Balanced,
                _ => Self::UnknownValue(autoscaling_profile::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AutoscalingProfile {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROFILE_UNSPECIFIED" => Self::ProfileUnspecified,
                "OPTIMIZE_UTILIZATION" => Self::OptimizeUtilization,
                "BALANCED" => Self::Balanced,
                _ => Self::UnknownValue(autoscaling_profile::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AutoscalingProfile {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ProfileUnspecified => serializer.serialize_i32(0),
                Self::OptimizeUtilization => serializer.serialize_i32(1),
                Self::Balanced => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AutoscalingProfile {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoscalingProfile>::new(
                ".google.container.v1.ClusterAutoscaling.AutoscalingProfile",
            ))
        }
    }
}

/// AutoprovisioningNodePoolDefaults contains defaults for a node pool created
/// by NAP.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoprovisioningNodePoolDefaults {
    /// Scopes that are used by NAP when creating node pools.
    pub oauth_scopes: std::vec::Vec<std::string::String>,

    /// The Google Cloud Platform Service Account to be used by the node VMs.
    pub service_account: std::string::String,

    /// Specifies the upgrade settings for NAP created node pools
    pub upgrade_settings: std::option::Option<crate::model::node_pool::UpgradeSettings>,

    /// Specifies the node management options for NAP created node-pools.
    pub management: std::option::Option<crate::model::NodeManagement>,

    /// Deprecated. Minimum CPU platform to be used for NAP created node pools.
    /// The instance may be scheduled on the specified or newer CPU platform.
    /// Applicable values are the friendly names of CPU platforms, such as
    /// minCpuPlatform: Intel Haswell or
    /// minCpuPlatform: Intel Sandy Bridge. For more
    /// information, read [how to specify min CPU
    /// platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform).
    /// This field is deprecated, min_cpu_platform should be specified using
    /// `cloud.google.com/requested-min-cpu-platform` label selector on the pod.
    /// To unset the min cpu platform field pass "automatic"
    /// as field value.
    #[deprecated]
    pub min_cpu_platform: std::string::String,

    /// Size of the disk attached to each node, specified in GB.
    /// The smallest allowed disk size is 10GB.
    ///
    /// If unspecified, the default disk size is 100GB.
    pub disk_size_gb: i32,

    /// Type of the disk attached to each node (e.g. 'pd-standard', 'pd-ssd' or
    /// 'pd-balanced')
    ///
    /// If unspecified, the default disk type is 'pd-standard'
    pub disk_type: std::string::String,

    /// Shielded Instance options.
    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    /// The Customer Managed Encryption Key used to encrypt the boot disk attached
    /// to each node in the node pool. This should be of the form
    /// projects/[KEY_PROJECT_ID]/locations/[LOCATION]/keyRings/[RING_NAME]/cryptoKeys/[KEY_NAME].
    /// For more information about protecting resources with Cloud KMS Keys please
    /// see:
    /// <https://cloud.google.com/compute/docs/disks/customer-managed-encryption>
    pub boot_disk_kms_key: std::string::String,

    /// The image type to use for NAP created node. Please see
    /// <https://cloud.google.com/kubernetes-engine/docs/concepts/node-images>
    /// for available image types.
    pub image_type: std::string::String,

    /// DEPRECATED. Use NodePoolAutoConfig.NodeKubeletConfig instead.
    pub insecure_kubelet_readonly_port_enabled: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoprovisioningNodePoolDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oauth_scopes][crate::model::AutoprovisioningNodePoolDefaults::oauth_scopes].
    pub fn set_oauth_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.oauth_scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::AutoprovisioningNodePoolDefaults::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [upgrade_settings][crate::model::AutoprovisioningNodePoolDefaults::upgrade_settings].
    pub fn set_upgrade_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::UpgradeSettings>,
    {
        self.upgrade_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upgrade_settings][crate::model::AutoprovisioningNodePoolDefaults::upgrade_settings].
    pub fn set_or_clear_upgrade_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::UpgradeSettings>,
    {
        self.upgrade_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [management][crate::model::AutoprovisioningNodePoolDefaults::management].
    pub fn set_management<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodeManagement>,
    {
        self.management = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [management][crate::model::AutoprovisioningNodePoolDefaults::management].
    pub fn set_or_clear_management<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodeManagement>,
    {
        self.management = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::AutoprovisioningNodePoolDefaults::min_cpu_platform].
    #[deprecated]
    pub fn set_min_cpu_platform<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.min_cpu_platform = v.into();
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::AutoprovisioningNodePoolDefaults::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::AutoprovisioningNodePoolDefaults::disk_type].
    pub fn set_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::AutoprovisioningNodePoolDefaults::shielded_instance_config].
    pub fn set_shielded_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_config][crate::model::AutoprovisioningNodePoolDefaults::shielded_instance_config].
    pub fn set_or_clear_shielded_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boot_disk_kms_key][crate::model::AutoprovisioningNodePoolDefaults::boot_disk_kms_key].
    pub fn set_boot_disk_kms_key<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_disk_kms_key = v.into();
        self
    }

    /// Sets the value of [image_type][crate::model::AutoprovisioningNodePoolDefaults::image_type].
    pub fn set_image_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_type = v.into();
        self
    }

    /// Sets the value of [insecure_kubelet_readonly_port_enabled][crate::model::AutoprovisioningNodePoolDefaults::insecure_kubelet_readonly_port_enabled].
    pub fn set_insecure_kubelet_readonly_port_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.insecure_kubelet_readonly_port_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insecure_kubelet_readonly_port_enabled][crate::model::AutoprovisioningNodePoolDefaults::insecure_kubelet_readonly_port_enabled].
    pub fn set_or_clear_insecure_kubelet_readonly_port_enabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.insecure_kubelet_readonly_port_enabled = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AutoprovisioningNodePoolDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AutoprovisioningNodePoolDefaults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutoprovisioningNodePoolDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __oauth_scopes,
            __service_account,
            __upgrade_settings,
            __management,
            __min_cpu_platform,
            __disk_size_gb,
            __disk_type,
            __shielded_instance_config,
            __boot_disk_kms_key,
            __image_type,
            __insecure_kubelet_readonly_port_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoprovisioningNodePoolDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "oauthScopes" => Ok(__FieldTag::__oauth_scopes),
                            "oauth_scopes" => Ok(__FieldTag::__oauth_scopes),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "upgradeSettings" => Ok(__FieldTag::__upgrade_settings),
                            "upgrade_settings" => Ok(__FieldTag::__upgrade_settings),
                            "management" => Ok(__FieldTag::__management),
                            "minCpuPlatform" => Ok(__FieldTag::__min_cpu_platform),
                            "min_cpu_platform" => Ok(__FieldTag::__min_cpu_platform),
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "shieldedInstanceConfig" => Ok(__FieldTag::__shielded_instance_config),
                            "shielded_instance_config" => {
                                Ok(__FieldTag::__shielded_instance_config)
                            }
                            "bootDiskKmsKey" => Ok(__FieldTag::__boot_disk_kms_key),
                            "boot_disk_kms_key" => Ok(__FieldTag::__boot_disk_kms_key),
                            "imageType" => Ok(__FieldTag::__image_type),
                            "image_type" => Ok(__FieldTag::__image_type),
                            "insecureKubeletReadonlyPortEnabled" => {
                                Ok(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            }
                            "insecure_kubelet_readonly_port_enabled" => {
                                Ok(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutoprovisioningNodePoolDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoprovisioningNodePoolDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__oauth_scopes => {
                            if !fields.insert(__FieldTag::__oauth_scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_scopes",
                                ));
                            }
                            result.oauth_scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgrade_settings => {
                            if !fields.insert(__FieldTag::__upgrade_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_settings",
                                ));
                            }
                            result.upgrade_settings = map.next_value::<std::option::Option<crate::model::node_pool::UpgradeSettings>>()?
                                ;
                        }
                        __FieldTag::__management => {
                            if !fields.insert(__FieldTag::__management) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management",
                                ));
                            }
                            result.management = map
                                .next_value::<std::option::Option<crate::model::NodeManagement>>(
                                )?;
                        }
                        __FieldTag::__min_cpu_platform => {
                            if !fields.insert(__FieldTag::__min_cpu_platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_cpu_platform",
                                ));
                            }
                            result.min_cpu_platform = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shielded_instance_config => {
                            if !fields.insert(__FieldTag::__shielded_instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shielded_instance_config",
                                ));
                            }
                            result.shielded_instance_config = map.next_value::<std::option::Option<crate::model::ShieldedInstanceConfig>>()?
                                ;
                        }
                        __FieldTag::__boot_disk_kms_key => {
                            if !fields.insert(__FieldTag::__boot_disk_kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk_kms_key",
                                ));
                            }
                            result.boot_disk_kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_type => {
                            if !fields.insert(__FieldTag::__image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_type",
                                ));
                            }
                            result.image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__insecure_kubelet_readonly_port_enabled => {
                            if !fields.insert(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insecure_kubelet_readonly_port_enabled",
                                ));
                            }
                            result.insecure_kubelet_readonly_port_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutoprovisioningNodePoolDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.oauth_scopes.is_empty() {
            state.serialize_entry("oauthScopes", &self.oauth_scopes)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.upgrade_settings.is_some() {
            state.serialize_entry("upgradeSettings", &self.upgrade_settings)?;
        }
        if self.management.is_some() {
            state.serialize_entry("management", &self.management)?;
        }
        if !self.min_cpu_platform.is_empty() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if !wkt::internal::is_default(&self.disk_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if !self.disk_type.is_empty() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if self.shielded_instance_config.is_some() {
            state.serialize_entry("shieldedInstanceConfig", &self.shielded_instance_config)?;
        }
        if !self.boot_disk_kms_key.is_empty() {
            state.serialize_entry("bootDiskKmsKey", &self.boot_disk_kms_key)?;
        }
        if !self.image_type.is_empty() {
            state.serialize_entry("imageType", &self.image_type)?;
        }
        if self.insecure_kubelet_readonly_port_enabled.is_some() {
            state.serialize_entry(
                "insecureKubeletReadonlyPortEnabled",
                &self.insecure_kubelet_readonly_port_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutoprovisioningNodePoolDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoprovisioningNodePoolDefaults");
        debug_struct.field("oauth_scopes", &self.oauth_scopes);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("upgrade_settings", &self.upgrade_settings);
        debug_struct.field("management", &self.management);
        debug_struct.field("min_cpu_platform", &self.min_cpu_platform);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("shielded_instance_config", &self.shielded_instance_config);
        debug_struct.field("boot_disk_kms_key", &self.boot_disk_kms_key);
        debug_struct.field("image_type", &self.image_type);
        debug_struct.field(
            "insecure_kubelet_readonly_port_enabled",
            &self.insecure_kubelet_readonly_port_enabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Contains information about amount of some resource in the cluster.
/// For memory, value should be in GB.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceLimit {
    /// Resource name "cpu", "memory" or gpu-specific string.
    pub resource_type: std::string::String,

    /// Minimum amount of the resource in the cluster.
    pub minimum: i64,

    /// Maximum amount of the resource in the cluster.
    pub maximum: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceLimit {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_type][crate::model::ResourceLimit::resource_type].
    pub fn set_resource_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [minimum][crate::model::ResourceLimit::minimum].
    pub fn set_minimum<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.minimum = v.into();
        self
    }

    /// Sets the value of [maximum][crate::model::ResourceLimit::maximum].
    pub fn set_maximum<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.maximum = v.into();
        self
    }
}

impl wkt::message::Message for ResourceLimit {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ResourceLimit"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceLimit {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_type,
            __minimum,
            __maximum,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceLimit")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "minimum" => Ok(__FieldTag::__minimum),
                            "maximum" => Ok(__FieldTag::__maximum),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceLimit;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceLimit")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__minimum => {
                            if !fields.insert(__FieldTag::__minimum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minimum",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.minimum = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__maximum => {
                            if !fields.insert(__FieldTag::__maximum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maximum",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.maximum = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceLimit {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_type.is_empty() {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !wkt::internal::is_default(&self.minimum) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minimum", &__With(&self.minimum))?;
        }
        if !wkt::internal::is_default(&self.maximum) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maximum", &__With(&self.maximum))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResourceLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceLimit");
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("minimum", &self.minimum);
        debug_struct.field("maximum", &self.maximum);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DefaultComputeClassConfig defines default compute class
/// configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DefaultComputeClassConfig {
    /// Enables default compute class.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DefaultComputeClassConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::DefaultComputeClassConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for DefaultComputeClassConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DefaultComputeClassConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DefaultComputeClassConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DefaultComputeClassConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DefaultComputeClassConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DefaultComputeClassConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DefaultComputeClassConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DefaultComputeClassConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DefaultComputeClassConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// NodePoolAutoscaling contains information required by cluster autoscaler to
/// adjust the size of the node pool to the current cluster usage.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodePoolAutoscaling {
    /// Is autoscaling enabled for this node pool.
    pub enabled: bool,

    /// Minimum number of nodes for one location in the node pool. Must be greater
    /// than or equal to 0 and less than or equal to max_node_count.
    pub min_node_count: i32,

    /// Maximum number of nodes for one location in the node pool. Must be >=
    /// min_node_count. There has to be enough quota to scale up the cluster.
    pub max_node_count: i32,

    /// Can this node pool be deleted automatically.
    pub autoprovisioned: bool,

    /// Location policy used when scaling up a nodepool.
    pub location_policy: crate::model::node_pool_autoscaling::LocationPolicy,

    /// Minimum number of nodes in the node pool. Must be greater than or equal
    /// to 0 and less than or equal to total_max_node_count.
    /// The total_*_node_count fields are mutually exclusive with the *_node_count
    /// fields.
    pub total_min_node_count: i32,

    /// Maximum number of nodes in the node pool. Must be greater than or equal to
    /// total_min_node_count. There has to be enough quota to scale up the cluster.
    /// The total_*_node_count fields are mutually exclusive with the *_node_count
    /// fields.
    pub total_max_node_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePoolAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::NodePoolAutoscaling::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [min_node_count][crate::model::NodePoolAutoscaling::min_node_count].
    pub fn set_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_count = v.into();
        self
    }

    /// Sets the value of [max_node_count][crate::model::NodePoolAutoscaling::max_node_count].
    pub fn set_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_node_count = v.into();
        self
    }

    /// Sets the value of [autoprovisioned][crate::model::NodePoolAutoscaling::autoprovisioned].
    pub fn set_autoprovisioned<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.autoprovisioned = v.into();
        self
    }

    /// Sets the value of [location_policy][crate::model::NodePoolAutoscaling::location_policy].
    pub fn set_location_policy<
        T: std::convert::Into<crate::model::node_pool_autoscaling::LocationPolicy>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location_policy = v.into();
        self
    }

    /// Sets the value of [total_min_node_count][crate::model::NodePoolAutoscaling::total_min_node_count].
    pub fn set_total_min_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_min_node_count = v.into();
        self
    }

    /// Sets the value of [total_max_node_count][crate::model::NodePoolAutoscaling::total_max_node_count].
    pub fn set_total_max_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.total_max_node_count = v.into();
        self
    }
}

impl wkt::message::Message for NodePoolAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodePoolAutoscaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodePoolAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __min_node_count,
            __max_node_count,
            __autoprovisioned,
            __location_policy,
            __total_min_node_count,
            __total_max_node_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePoolAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "minNodeCount" => Ok(__FieldTag::__min_node_count),
                            "min_node_count" => Ok(__FieldTag::__min_node_count),
                            "maxNodeCount" => Ok(__FieldTag::__max_node_count),
                            "max_node_count" => Ok(__FieldTag::__max_node_count),
                            "autoprovisioned" => Ok(__FieldTag::__autoprovisioned),
                            "locationPolicy" => Ok(__FieldTag::__location_policy),
                            "location_policy" => Ok(__FieldTag::__location_policy),
                            "totalMinNodeCount" => Ok(__FieldTag::__total_min_node_count),
                            "total_min_node_count" => Ok(__FieldTag::__total_min_node_count),
                            "totalMaxNodeCount" => Ok(__FieldTag::__total_max_node_count),
                            "total_max_node_count" => Ok(__FieldTag::__total_max_node_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodePoolAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePoolAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_node_count => {
                            if !fields.insert(__FieldTag::__min_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_node_count => {
                            if !fields.insert(__FieldTag::__max_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__autoprovisioned => {
                            if !fields.insert(__FieldTag::__autoprovisioned) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoprovisioned",
                                ));
                            }
                            result.autoprovisioned = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_policy => {
                            if !fields.insert(__FieldTag::__location_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_policy",
                                ));
                            }
                            result.location_policy = map
                                .next_value::<std::option::Option<
                                    crate::model::node_pool_autoscaling::LocationPolicy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_min_node_count => {
                            if !fields.insert(__FieldTag::__total_min_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_min_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_min_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_max_node_count => {
                            if !fields.insert(__FieldTag::__total_max_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_max_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_max_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodePoolAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.min_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minNodeCount", &__With(&self.min_node_count))?;
        }
        if !wkt::internal::is_default(&self.max_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxNodeCount", &__With(&self.max_node_count))?;
        }
        if !wkt::internal::is_default(&self.autoprovisioned) {
            state.serialize_entry("autoprovisioned", &self.autoprovisioned)?;
        }
        if !wkt::internal::is_default(&self.location_policy) {
            state.serialize_entry("locationPolicy", &self.location_policy)?;
        }
        if !wkt::internal::is_default(&self.total_min_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalMinNodeCount", &__With(&self.total_min_node_count))?;
        }
        if !wkt::internal::is_default(&self.total_max_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalMaxNodeCount", &__With(&self.total_max_node_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodePoolAutoscaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePoolAutoscaling");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("min_node_count", &self.min_node_count);
        debug_struct.field("max_node_count", &self.max_node_count);
        debug_struct.field("autoprovisioned", &self.autoprovisioned);
        debug_struct.field("location_policy", &self.location_policy);
        debug_struct.field("total_min_node_count", &self.total_min_node_count);
        debug_struct.field("total_max_node_count", &self.total_max_node_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NodePoolAutoscaling].
pub mod node_pool_autoscaling {
    #[allow(unused_imports)]
    use super::*;

    /// Location policy specifies how zones are picked when scaling up the
    /// nodepool.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LocationPolicy {
        /// Not set.
        Unspecified,
        /// BALANCED is a best effort policy that aims to balance the sizes of
        /// different zones.
        Balanced,
        /// ANY policy picks zones that have the highest capacity available.
        Any,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LocationPolicy::value] or
        /// [LocationPolicy::name].
        UnknownValue(location_policy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod location_policy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LocationPolicy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Balanced => std::option::Option::Some(1),
                Self::Any => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LOCATION_POLICY_UNSPECIFIED"),
                Self::Balanced => std::option::Option::Some("BALANCED"),
                Self::Any => std::option::Option::Some("ANY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LocationPolicy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LocationPolicy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LocationPolicy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Balanced,
                2 => Self::Any,
                _ => Self::UnknownValue(location_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LocationPolicy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOCATION_POLICY_UNSPECIFIED" => Self::Unspecified,
                "BALANCED" => Self::Balanced,
                "ANY" => Self::Any,
                _ => Self::UnknownValue(location_policy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LocationPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Balanced => serializer.serialize_i32(1),
                Self::Any => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LocationPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LocationPolicy>::new(
                ".google.container.v1.NodePoolAutoscaling.LocationPolicy",
            ))
        }
    }
}

/// SetLabelsRequest sets the Google Cloud Platform labels on a Google Container
/// Engine cluster, which will in turn set them for Google Compute Engine
/// resources used by that cluster
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetLabelsRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. The labels to set for that cluster.
    pub resource_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The fingerprint of the previous set of labels for this resource,
    /// used to detect conflicts. The fingerprint is initially generated by
    /// Kubernetes Engine and changes after every request to modify or update
    /// labels. You must always provide an up-to-date fingerprint hash when
    /// updating or changing labels. Make a `get()` request to the
    /// resource to get the latest fingerprint.
    pub label_fingerprint: std::string::String,

    /// The name (project, location, cluster name) of the cluster to set labels.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetLabelsRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetLabelsRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetLabelsRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [resource_labels][crate::model::SetLabelsRequest::resource_labels].
    pub fn set_resource_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [label_fingerprint][crate::model::SetLabelsRequest::label_fingerprint].
    pub fn set_label_fingerprint<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.label_fingerprint = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetLabelsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetLabelsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetLabelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __resource_labels,
            __label_fingerprint,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetLabelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "resourceLabels" => Ok(__FieldTag::__resource_labels),
                            "resource_labels" => Ok(__FieldTag::__resource_labels),
                            "labelFingerprint" => Ok(__FieldTag::__label_fingerprint),
                            "label_fingerprint" => Ok(__FieldTag::__label_fingerprint),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetLabelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetLabelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_labels => {
                            if !fields.insert(__FieldTag::__resource_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_labels",
                                ));
                            }
                            result.resource_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__label_fingerprint => {
                            if !fields.insert(__FieldTag::__label_fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_fingerprint",
                                ));
                            }
                            result.label_fingerprint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.resource_labels.is_empty() {
            state.serialize_entry("resourceLabels", &self.resource_labels)?;
        }
        if !self.label_fingerprint.is_empty() {
            state.serialize_entry("labelFingerprint", &self.label_fingerprint)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetLabelsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetLabelsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("resource_labels", &self.resource_labels);
        debug_struct.field("label_fingerprint", &self.label_fingerprint);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SetLegacyAbacRequest enables or disables the ABAC authorization mechanism for
/// a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetLegacyAbacRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster to update.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. Whether ABAC authorization will be enabled in the cluster.
    pub enabled: bool,

    /// The name (project, location, cluster name) of the cluster to set legacy
    /// abac. Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetLegacyAbacRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetLegacyAbacRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetLegacyAbacRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetLegacyAbacRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [enabled][crate::model::SetLegacyAbacRequest::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [name][crate::model::SetLegacyAbacRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetLegacyAbacRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetLegacyAbacRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetLegacyAbacRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __enabled,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetLegacyAbacRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetLegacyAbacRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetLegacyAbacRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetLegacyAbacRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetLegacyAbacRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetLegacyAbacRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// StartIPRotationRequest creates a new IP for the cluster and then performs
/// a node upgrade on each node pool to point to the new IP.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartIPRotationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// The name (project, location, cluster name) of the cluster to start IP
    /// rotation. Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    /// Whether to rotate credentials during IP rotation.
    pub rotate_credentials: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartIPRotationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::StartIPRotationRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::StartIPRotationRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::StartIPRotationRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::StartIPRotationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rotate_credentials][crate::model::StartIPRotationRequest::rotate_credentials].
    pub fn set_rotate_credentials<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.rotate_credentials = v.into();
        self
    }
}

impl wkt::message::Message for StartIPRotationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.StartIPRotationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartIPRotationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __name,
            __rotate_credentials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartIPRotationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "name" => Ok(__FieldTag::__name),
                            "rotateCredentials" => Ok(__FieldTag::__rotate_credentials),
                            "rotate_credentials" => Ok(__FieldTag::__rotate_credentials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartIPRotationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartIPRotationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rotate_credentials => {
                            if !fields.insert(__FieldTag::__rotate_credentials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rotate_credentials",
                                ));
                            }
                            result.rotate_credentials = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartIPRotationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.rotate_credentials) {
            state.serialize_entry("rotateCredentials", &self.rotate_credentials)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StartIPRotationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartIPRotationRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("name", &self.name);
        debug_struct.field("rotate_credentials", &self.rotate_credentials);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CompleteIPRotationRequest moves the cluster master back into single-IP mode.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CompleteIPRotationRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// The name (project, location, cluster name) of the cluster to complete IP
    /// rotation. Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompleteIPRotationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::CompleteIPRotationRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::CompleteIPRotationRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CompleteIPRotationRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::CompleteIPRotationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CompleteIPRotationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CompleteIPRotationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompleteIPRotationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompleteIPRotationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompleteIPRotationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompleteIPRotationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompleteIPRotationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CompleteIPRotationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompleteIPRotationRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AcceleratorConfig represents a Hardware Accelerator request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AcceleratorConfig {
    /// The number of the accelerator cards exposed to an instance.
    pub accelerator_count: i64,

    /// The accelerator type resource name. List of supported accelerators
    /// [here](https://cloud.google.com/compute/docs/gpus)
    pub accelerator_type: std::string::String,

    /// Size of partitions to create on the GPU. Valid values are described in the
    /// NVIDIA [mig user
    /// guide](https://docs.nvidia.com/datacenter/tesla/mig-user-guide/#partitioning).
    pub gpu_partition_size: std::string::String,

    /// The configuration for GPU sharing options.
    pub gpu_sharing_config: std::option::Option<crate::model::GPUSharingConfig>,

    /// The configuration for auto installation of GPU driver.
    pub gpu_driver_installation_config:
        std::option::Option<crate::model::GPUDriverInstallationConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AcceleratorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerator_count][crate::model::AcceleratorConfig::accelerator_count].
    pub fn set_accelerator_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.accelerator_count = v.into();
        self
    }

    /// Sets the value of [accelerator_type][crate::model::AcceleratorConfig::accelerator_type].
    pub fn set_accelerator_type<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.accelerator_type = v.into();
        self
    }

    /// Sets the value of [gpu_partition_size][crate::model::AcceleratorConfig::gpu_partition_size].
    pub fn set_gpu_partition_size<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.gpu_partition_size = v.into();
        self
    }

    /// Sets the value of [gpu_sharing_config][crate::model::AcceleratorConfig::gpu_sharing_config].
    pub fn set_gpu_sharing_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GPUSharingConfig>,
    {
        self.gpu_sharing_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gpu_sharing_config][crate::model::AcceleratorConfig::gpu_sharing_config].
    pub fn set_or_clear_gpu_sharing_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GPUSharingConfig>,
    {
        self.gpu_sharing_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gpu_driver_installation_config][crate::model::AcceleratorConfig::gpu_driver_installation_config].
    pub fn set_gpu_driver_installation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GPUDriverInstallationConfig>,
    {
        self.gpu_driver_installation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gpu_driver_installation_config][crate::model::AcceleratorConfig::gpu_driver_installation_config].
    pub fn set_or_clear_gpu_driver_installation_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::GPUDriverInstallationConfig>,
    {
        self.gpu_driver_installation_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AcceleratorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AcceleratorConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AcceleratorConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __accelerator_count,
            __accelerator_type,
            __gpu_partition_size,
            __gpu_sharing_config,
            __gpu_driver_installation_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AcceleratorConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "acceleratorCount" => Ok(__FieldTag::__accelerator_count),
                            "accelerator_count" => Ok(__FieldTag::__accelerator_count),
                            "acceleratorType" => Ok(__FieldTag::__accelerator_type),
                            "accelerator_type" => Ok(__FieldTag::__accelerator_type),
                            "gpuPartitionSize" => Ok(__FieldTag::__gpu_partition_size),
                            "gpu_partition_size" => Ok(__FieldTag::__gpu_partition_size),
                            "gpuSharingConfig" => Ok(__FieldTag::__gpu_sharing_config),
                            "gpu_sharing_config" => Ok(__FieldTag::__gpu_sharing_config),
                            "gpuDriverInstallationConfig" => {
                                Ok(__FieldTag::__gpu_driver_installation_config)
                            }
                            "gpu_driver_installation_config" => {
                                Ok(__FieldTag::__gpu_driver_installation_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AcceleratorConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AcceleratorConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__accelerator_count => {
                            if !fields.insert(__FieldTag::__accelerator_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.accelerator_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__accelerator_type => {
                            if !fields.insert(__FieldTag::__accelerator_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_type",
                                ));
                            }
                            result.accelerator_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gpu_partition_size => {
                            if !fields.insert(__FieldTag::__gpu_partition_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_partition_size",
                                ));
                            }
                            result.gpu_partition_size = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gpu_sharing_config => {
                            if !fields.insert(__FieldTag::__gpu_sharing_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_sharing_config",
                                ));
                            }
                            result.gpu_sharing_config = map
                                .next_value::<std::option::Option<crate::model::GPUSharingConfig>>(
                                )?;
                        }
                        __FieldTag::__gpu_driver_installation_config => {
                            if !fields.insert(__FieldTag::__gpu_driver_installation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_driver_installation_config",
                                ));
                            }
                            result.gpu_driver_installation_config = map.next_value::<std::option::Option<crate::model::GPUDriverInstallationConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AcceleratorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.accelerator_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("acceleratorCount", &__With(&self.accelerator_count))?;
        }
        if !self.accelerator_type.is_empty() {
            state.serialize_entry("acceleratorType", &self.accelerator_type)?;
        }
        if !self.gpu_partition_size.is_empty() {
            state.serialize_entry("gpuPartitionSize", &self.gpu_partition_size)?;
        }
        if self.gpu_sharing_config.is_some() {
            state.serialize_entry("gpuSharingConfig", &self.gpu_sharing_config)?;
        }
        if self.gpu_driver_installation_config.is_some() {
            state.serialize_entry(
                "gpuDriverInstallationConfig",
                &self.gpu_driver_installation_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AcceleratorConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AcceleratorConfig");
        debug_struct.field("accelerator_count", &self.accelerator_count);
        debug_struct.field("accelerator_type", &self.accelerator_type);
        debug_struct.field("gpu_partition_size", &self.gpu_partition_size);
        debug_struct.field("gpu_sharing_config", &self.gpu_sharing_config);
        debug_struct.field(
            "gpu_driver_installation_config",
            &self.gpu_driver_installation_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GPUSharingConfig represents the GPU sharing configuration for Hardware
/// Accelerators.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GPUSharingConfig {
    /// The max number of containers that can share a physical GPU.
    pub max_shared_clients_per_gpu: i64,

    /// The type of GPU sharing strategy to enable on the GPU node.
    pub gpu_sharing_strategy:
        std::option::Option<crate::model::gpu_sharing_config::GPUSharingStrategy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GPUSharingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_shared_clients_per_gpu][crate::model::GPUSharingConfig::max_shared_clients_per_gpu].
    pub fn set_max_shared_clients_per_gpu<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_shared_clients_per_gpu = v.into();
        self
    }

    /// Sets the value of [gpu_sharing_strategy][crate::model::GPUSharingConfig::gpu_sharing_strategy].
    pub fn set_gpu_sharing_strategy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::gpu_sharing_config::GPUSharingStrategy>,
    {
        self.gpu_sharing_strategy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gpu_sharing_strategy][crate::model::GPUSharingConfig::gpu_sharing_strategy].
    pub fn set_or_clear_gpu_sharing_strategy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::gpu_sharing_config::GPUSharingStrategy>,
    {
        self.gpu_sharing_strategy = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GPUSharingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GPUSharingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GPUSharingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_shared_clients_per_gpu,
            __gpu_sharing_strategy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GPUSharingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxSharedClientsPerGpu" => {
                                Ok(__FieldTag::__max_shared_clients_per_gpu)
                            }
                            "max_shared_clients_per_gpu" => {
                                Ok(__FieldTag::__max_shared_clients_per_gpu)
                            }
                            "gpuSharingStrategy" => Ok(__FieldTag::__gpu_sharing_strategy),
                            "gpu_sharing_strategy" => Ok(__FieldTag::__gpu_sharing_strategy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GPUSharingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GPUSharingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_shared_clients_per_gpu => {
                            if !fields.insert(__FieldTag::__max_shared_clients_per_gpu) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_shared_clients_per_gpu",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_shared_clients_per_gpu =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__gpu_sharing_strategy => {
                            if !fields.insert(__FieldTag::__gpu_sharing_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_sharing_strategy",
                                ));
                            }
                            result.gpu_sharing_strategy = map.next_value::<std::option::Option<
                                crate::model::gpu_sharing_config::GPUSharingStrategy,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GPUSharingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_shared_clients_per_gpu) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxSharedClientsPerGpu",
                &__With(&self.max_shared_clients_per_gpu),
            )?;
        }
        if self.gpu_sharing_strategy.is_some() {
            state.serialize_entry("gpuSharingStrategy", &self.gpu_sharing_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GPUSharingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GPUSharingConfig");
        debug_struct.field(
            "max_shared_clients_per_gpu",
            &self.max_shared_clients_per_gpu,
        );
        debug_struct.field("gpu_sharing_strategy", &self.gpu_sharing_strategy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GPUSharingConfig].
pub mod gpu_sharing_config {
    #[allow(unused_imports)]
    use super::*;

    /// The type of GPU sharing strategy currently provided.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GPUSharingStrategy {
        /// Default value.
        Unspecified,
        /// GPUs are time-shared between containers.
        TimeSharing,
        /// GPUs are shared between containers with NVIDIA MPS.
        Mps,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [GPUSharingStrategy::value] or
        /// [GPUSharingStrategy::name].
        UnknownValue(gpu_sharing_strategy::UnknownValue),
    }

    #[doc(hidden)]
    pub mod gpu_sharing_strategy {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl GPUSharingStrategy {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::TimeSharing => std::option::Option::Some(1),
                Self::Mps => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("GPU_SHARING_STRATEGY_UNSPECIFIED"),
                Self::TimeSharing => std::option::Option::Some("TIME_SHARING"),
                Self::Mps => std::option::Option::Some("MPS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for GPUSharingStrategy {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for GPUSharingStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for GPUSharingStrategy {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::TimeSharing,
                2 => Self::Mps,
                _ => Self::UnknownValue(gpu_sharing_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for GPUSharingStrategy {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GPU_SHARING_STRATEGY_UNSPECIFIED" => Self::Unspecified,
                "TIME_SHARING" => Self::TimeSharing,
                "MPS" => Self::Mps,
                _ => Self::UnknownValue(gpu_sharing_strategy::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for GPUSharingStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::TimeSharing => serializer.serialize_i32(1),
                Self::Mps => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for GPUSharingStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<GPUSharingStrategy>::new(
                ".google.container.v1.GPUSharingConfig.GPUSharingStrategy",
            ))
        }
    }
}

/// GPUDriverInstallationConfig specifies the version of GPU driver to be auto
/// installed.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GPUDriverInstallationConfig {
    /// Mode for how the GPU driver is installed.
    pub gpu_driver_version:
        std::option::Option<crate::model::gpu_driver_installation_config::GPUDriverVersion>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GPUDriverInstallationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gpu_driver_version][crate::model::GPUDriverInstallationConfig::gpu_driver_version].
    pub fn set_gpu_driver_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::gpu_driver_installation_config::GPUDriverVersion>,
    {
        self.gpu_driver_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gpu_driver_version][crate::model::GPUDriverInstallationConfig::gpu_driver_version].
    pub fn set_or_clear_gpu_driver_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::gpu_driver_installation_config::GPUDriverVersion>,
    {
        self.gpu_driver_version = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GPUDriverInstallationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GPUDriverInstallationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GPUDriverInstallationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gpu_driver_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GPUDriverInstallationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gpuDriverVersion" => Ok(__FieldTag::__gpu_driver_version),
                            "gpu_driver_version" => Ok(__FieldTag::__gpu_driver_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GPUDriverInstallationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GPUDriverInstallationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gpu_driver_version => {
                            if !fields.insert(__FieldTag::__gpu_driver_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_driver_version",
                                ));
                            }
                            result.gpu_driver_version = map.next_value::<std::option::Option<
                                crate::model::gpu_driver_installation_config::GPUDriverVersion,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GPUDriverInstallationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.gpu_driver_version.is_some() {
            state.serialize_entry("gpuDriverVersion", &self.gpu_driver_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GPUDriverInstallationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GPUDriverInstallationConfig");
        debug_struct.field("gpu_driver_version", &self.gpu_driver_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GPUDriverInstallationConfig].
pub mod gpu_driver_installation_config {
    #[allow(unused_imports)]
    use super::*;

    /// The GPU driver version to install.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GPUDriverVersion {
        /// Default value is to not install any GPU driver.
        Unspecified,
        /// Disable GPU driver auto installation and needs manual installation
        InstallationDisabled,
        /// "Default" GPU driver in COS and Ubuntu.
        Default,
        /// "Latest" GPU driver in COS.
        Latest,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [GPUDriverVersion::value] or
        /// [GPUDriverVersion::name].
        UnknownValue(gpu_driver_version::UnknownValue),
    }

    #[doc(hidden)]
    pub mod gpu_driver_version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl GPUDriverVersion {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InstallationDisabled => std::option::Option::Some(1),
                Self::Default => std::option::Option::Some(2),
                Self::Latest => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("GPU_DRIVER_VERSION_UNSPECIFIED"),
                Self::InstallationDisabled => std::option::Option::Some("INSTALLATION_DISABLED"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::Latest => std::option::Option::Some("LATEST"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for GPUDriverVersion {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for GPUDriverVersion {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for GPUDriverVersion {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InstallationDisabled,
                2 => Self::Default,
                3 => Self::Latest,
                _ => Self::UnknownValue(gpu_driver_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for GPUDriverVersion {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GPU_DRIVER_VERSION_UNSPECIFIED" => Self::Unspecified,
                "INSTALLATION_DISABLED" => Self::InstallationDisabled,
                "DEFAULT" => Self::Default,
                "LATEST" => Self::Latest,
                _ => Self::UnknownValue(gpu_driver_version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for GPUDriverVersion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InstallationDisabled => serializer.serialize_i32(1),
                Self::Default => serializer.serialize_i32(2),
                Self::Latest => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for GPUDriverVersion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<GPUDriverVersion>::new(
                ".google.container.v1.GPUDriverInstallationConfig.GPUDriverVersion",
            ))
        }
    }
}

/// WorkloadMetadataConfig defines the metadata configuration to expose to
/// workloads on the node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkloadMetadataConfig {
    /// Mode is the configuration for how to expose metadata to workloads running
    /// on the node pool.
    pub mode: crate::model::workload_metadata_config::Mode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadMetadataConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::WorkloadMetadataConfig::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::workload_metadata_config::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadMetadataConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.WorkloadMetadataConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkloadMetadataConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkloadMetadataConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkloadMetadataConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkloadMetadataConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode =
                                map.next_value::<std::option::Option<
                                    crate::model::workload_metadata_config::Mode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkloadMetadataConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WorkloadMetadataConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkloadMetadataConfig");
        debug_struct.field("mode", &self.mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [WorkloadMetadataConfig].
pub mod workload_metadata_config {
    #[allow(unused_imports)]
    use super::*;

    /// Mode is the configuration for how to expose metadata to workloads running
    /// on the node.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Not set.
        Unspecified,
        /// Expose all Compute Engine metadata to pods.
        GceMetadata,
        /// Run the GKE Metadata Server on this node. The GKE Metadata Server exposes
        /// a metadata API to workloads that is compatible with the V1 Compute
        /// Metadata APIs exposed by the Compute Engine and App Engine Metadata
        /// Servers. This feature can only be enabled if Workload Identity is enabled
        /// at the cluster level.
        GkeMetadata,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GceMetadata => std::option::Option::Some(1),
                Self::GkeMetadata => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::GceMetadata => std::option::Option::Some("GCE_METADATA"),
                Self::GkeMetadata => std::option::Option::Some("GKE_METADATA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GceMetadata,
                2 => Self::GkeMetadata,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "GCE_METADATA" => Self::GceMetadata,
                "GKE_METADATA" => Self::GkeMetadata,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GceMetadata => serializer.serialize_i32(1),
                Self::GkeMetadata => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.container.v1.WorkloadMetadataConfig.Mode",
            ))
        }
    }
}

/// SetNetworkPolicyRequest enables/disables network policy for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetNetworkPolicyRequest {
    /// Deprecated. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub project_id: std::string::String,

    /// Deprecated. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides. This field has been deprecated and replaced
    /// by the name field.
    #[deprecated]
    pub zone: std::string::String,

    /// Deprecated. The name of the cluster.
    /// This field has been deprecated and replaced by the name field.
    #[deprecated]
    pub cluster_id: std::string::String,

    /// Required. Configuration options for the NetworkPolicy feature.
    pub network_policy: std::option::Option<crate::model::NetworkPolicy>,

    /// The name (project, location, cluster name) of the cluster to set networking
    /// policy. Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetNetworkPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetNetworkPolicyRequest::project_id].
    #[deprecated]
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetNetworkPolicyRequest::zone].
    #[deprecated]
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetNetworkPolicyRequest::cluster_id].
    #[deprecated]
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [network_policy][crate::model::SetNetworkPolicyRequest::network_policy].
    pub fn set_network_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPolicy>,
    {
        self.network_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_policy][crate::model::SetNetworkPolicyRequest::network_policy].
    pub fn set_or_clear_network_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPolicy>,
    {
        self.network_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::SetNetworkPolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetNetworkPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetNetworkPolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetNetworkPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __network_policy,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetNetworkPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "networkPolicy" => Ok(__FieldTag::__network_policy),
                            "network_policy" => Ok(__FieldTag::__network_policy),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetNetworkPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetNetworkPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_policy => {
                            if !fields.insert(__FieldTag::__network_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_policy",
                                ));
                            }
                            result.network_policy = map
                                .next_value::<std::option::Option<crate::model::NetworkPolicy>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetNetworkPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.network_policy.is_some() {
            state.serialize_entry("networkPolicy", &self.network_policy)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetNetworkPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetNetworkPolicyRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("network_policy", &self.network_policy);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SetMaintenancePolicyRequest sets the maintenance policy for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetMaintenancePolicyRequest {
    /// Required. The Google Developers Console [project ID or project
    /// number](https://cloud.google.com/resource-manager/docs/creating-managing-projects).
    pub project_id: std::string::String,

    /// Required. The name of the Google Compute Engine
    /// [zone](https://cloud.google.com/compute/docs/zones#available)
    /// in which the cluster resides.
    pub zone: std::string::String,

    /// Required. The name of the cluster to update.
    pub cluster_id: std::string::String,

    /// Required. The maintenance policy to be set for the cluster. An empty field
    /// clears the existing maintenance policy.
    pub maintenance_policy: std::option::Option<crate::model::MaintenancePolicy>,

    /// The name (project, location, cluster name) of the cluster to set
    /// maintenance policy.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetMaintenancePolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project_id][crate::model::SetMaintenancePolicyRequest::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::SetMaintenancePolicyRequest::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::SetMaintenancePolicyRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [maintenance_policy][crate::model::SetMaintenancePolicyRequest::maintenance_policy].
    pub fn set_maintenance_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenancePolicy>,
    {
        self.maintenance_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_policy][crate::model::SetMaintenancePolicyRequest::maintenance_policy].
    pub fn set_or_clear_maintenance_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenancePolicy>,
    {
        self.maintenance_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::SetMaintenancePolicyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for SetMaintenancePolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SetMaintenancePolicyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SetMaintenancePolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __maintenance_policy,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetMaintenancePolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "maintenancePolicy" => Ok(__FieldTag::__maintenance_policy),
                            "maintenance_policy" => Ok(__FieldTag::__maintenance_policy),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SetMaintenancePolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetMaintenancePolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maintenance_policy => {
                            if !fields.insert(__FieldTag::__maintenance_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_policy",
                                ));
                            }
                            result.maintenance_policy = map
                                .next_value::<std::option::Option<crate::model::MaintenancePolicy>>(
                                )?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SetMaintenancePolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.maintenance_policy.is_some() {
            state.serialize_entry("maintenancePolicy", &self.maintenance_policy)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SetMaintenancePolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetMaintenancePolicyRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("maintenance_policy", &self.maintenance_policy);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// StatusCondition describes why a cluster or a node pool has a certain status
/// (e.g., ERROR or DEGRADED).
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StatusCondition {
    /// Machine-friendly representation of the condition
    /// Deprecated. Use canonical_code instead.
    #[deprecated]
    pub code: crate::model::status_condition::Code,

    /// Human-friendly representation of the condition
    pub message: std::string::String,

    /// Canonical code of the condition.
    pub canonical_code: rpc::model::Code,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StatusCondition {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::StatusCondition::code].
    #[deprecated]
    pub fn set_code<T: std::convert::Into<crate::model::status_condition::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [message][crate::model::StatusCondition::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [canonical_code][crate::model::StatusCondition::canonical_code].
    pub fn set_canonical_code<T: std::convert::Into<rpc::model::Code>>(mut self, v: T) -> Self {
        self.canonical_code = v.into();
        self
    }
}

impl wkt::message::Message for StatusCondition {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.StatusCondition"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StatusCondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __message,
            __canonical_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StatusCondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "message" => Ok(__FieldTag::__message),
                            "canonicalCode" => Ok(__FieldTag::__canonical_code),
                            "canonical_code" => Ok(__FieldTag::__canonical_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StatusCondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StatusCondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::status_condition::Code>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__canonical_code => {
                            if !fields.insert(__FieldTag::__canonical_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for canonical_code",
                                ));
                            }
                            result.canonical_code = map
                                .next_value::<std::option::Option<rpc::model::Code>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StatusCondition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !wkt::internal::is_default(&self.canonical_code) {
            state.serialize_entry("canonicalCode", &self.canonical_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StatusCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StatusCondition");
        debug_struct.field("code", &self.code);
        debug_struct.field("message", &self.message);
        debug_struct.field("canonical_code", &self.canonical_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [StatusCondition].
pub mod status_condition {
    #[allow(unused_imports)]
    use super::*;

    /// Code for each condition
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Code {
        /// UNKNOWN indicates a generic condition.
        Unknown,
        /// GCE_STOCKOUT indicates that Google Compute Engine resources are
        /// temporarily unavailable.
        GceStockout,
        /// GKE_SERVICE_ACCOUNT_DELETED indicates that the user deleted their robot
        /// service account.
        GkeServiceAccountDeleted,
        /// Google Compute Engine quota was exceeded.
        GceQuotaExceeded,
        /// Cluster state was manually changed by an SRE due to a system logic error.
        SetByOperator,
        /// Unable to perform an encrypt operation against the CloudKMS key used for
        /// etcd level encryption.
        CloudKmsKeyError,
        /// Cluster CA is expiring soon.
        CaExpiring,
        /// Node service account is missing permissions.
        NodeServiceAccountMissingPermissions,
        /// Cloud KMS key version used for etcd level encryption has been destroyed.
        /// This is a permanent error.
        CloudKmsKeyDestroyed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Code::value] or
        /// [Code::name].
        UnknownValue(code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Code {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::GceStockout => std::option::Option::Some(1),
                Self::GkeServiceAccountDeleted => std::option::Option::Some(2),
                Self::GceQuotaExceeded => std::option::Option::Some(3),
                Self::SetByOperator => std::option::Option::Some(4),
                Self::CloudKmsKeyError => std::option::Option::Some(7),
                Self::CaExpiring => std::option::Option::Some(9),
                Self::NodeServiceAccountMissingPermissions => std::option::Option::Some(10),
                Self::CloudKmsKeyDestroyed => std::option::Option::Some(11),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::GceStockout => std::option::Option::Some("GCE_STOCKOUT"),
                Self::GkeServiceAccountDeleted => {
                    std::option::Option::Some("GKE_SERVICE_ACCOUNT_DELETED")
                }
                Self::GceQuotaExceeded => std::option::Option::Some("GCE_QUOTA_EXCEEDED"),
                Self::SetByOperator => std::option::Option::Some("SET_BY_OPERATOR"),
                Self::CloudKmsKeyError => std::option::Option::Some("CLOUD_KMS_KEY_ERROR"),
                Self::CaExpiring => std::option::Option::Some("CA_EXPIRING"),
                Self::NodeServiceAccountMissingPermissions => {
                    std::option::Option::Some("NODE_SERVICE_ACCOUNT_MISSING_PERMISSIONS")
                }
                Self::CloudKmsKeyDestroyed => std::option::Option::Some("CLOUD_KMS_KEY_DESTROYED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Code {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::GceStockout,
                2 => Self::GkeServiceAccountDeleted,
                3 => Self::GceQuotaExceeded,
                4 => Self::SetByOperator,
                7 => Self::CloudKmsKeyError,
                9 => Self::CaExpiring,
                10 => Self::NodeServiceAccountMissingPermissions,
                11 => Self::CloudKmsKeyDestroyed,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Code {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "GCE_STOCKOUT" => Self::GceStockout,
                "GKE_SERVICE_ACCOUNT_DELETED" => Self::GkeServiceAccountDeleted,
                "GCE_QUOTA_EXCEEDED" => Self::GceQuotaExceeded,
                "SET_BY_OPERATOR" => Self::SetByOperator,
                "CLOUD_KMS_KEY_ERROR" => Self::CloudKmsKeyError,
                "CA_EXPIRING" => Self::CaExpiring,
                "NODE_SERVICE_ACCOUNT_MISSING_PERMISSIONS" => {
                    Self::NodeServiceAccountMissingPermissions
                }
                "CLOUD_KMS_KEY_DESTROYED" => Self::CloudKmsKeyDestroyed,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Code {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::GceStockout => serializer.serialize_i32(1),
                Self::GkeServiceAccountDeleted => serializer.serialize_i32(2),
                Self::GceQuotaExceeded => serializer.serialize_i32(3),
                Self::SetByOperator => serializer.serialize_i32(4),
                Self::CloudKmsKeyError => serializer.serialize_i32(7),
                Self::CaExpiring => serializer.serialize_i32(9),
                Self::NodeServiceAccountMissingPermissions => serializer.serialize_i32(10),
                Self::CloudKmsKeyDestroyed => serializer.serialize_i32(11),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Code {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                ".google.container.v1.StatusCondition.Code",
            ))
        }
    }
}

/// NetworkConfig reports the relative names of network & subnetwork.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkConfig {
    /// Output only. The relative name of the Google Compute Engine
    /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
    /// to which the cluster is connected. Example:
    /// projects/my-project/global/networks/my-network
    pub network: std::string::String,

    /// Output only. The relative name of the Google Compute Engine
    /// [subnetwork](https://cloud.google.com/compute/docs/vpc)
    /// to which the cluster is connected. Example:
    /// projects/my-project/regions/us-central1/subnetworks/my-subnet
    pub subnetwork: std::string::String,

    /// Whether Intra-node visibility is enabled for this cluster.
    /// This makes same node pod to pod traffic visible for VPC network.
    pub enable_intra_node_visibility: bool,

    /// Whether the cluster disables default in-node sNAT rules. In-node sNAT rules
    /// will be disabled when default_snat_status is disabled. When disabled is set
    /// to false, default IP masquerade rules will be applied to the nodes to
    /// prevent sNAT on cluster internal traffic.
    pub default_snat_status: std::option::Option<crate::model::DefaultSnatStatus>,

    /// Whether L4ILB Subsetting is enabled for this cluster.
    pub enable_l4ilb_subsetting: bool,

    /// The desired datapath provider for this cluster. By default, uses the
    /// IPTables-based kube-proxy implementation.
    pub datapath_provider: crate::model::DatapathProvider,

    /// The desired state of IPv6 connectivity to Google Services.
    /// By default, no private IPv6 access to or from Google Services (all access
    /// will be via IPv4)
    pub private_ipv6_google_access: crate::model::PrivateIPv6GoogleAccess,

    /// DNSConfig contains clusterDNS config for this cluster.
    pub dns_config: std::option::Option<crate::model::DNSConfig>,

    /// ServiceExternalIPsConfig specifies if services with externalIPs field are
    /// blocked or not.
    pub service_external_ips_config: std::option::Option<crate::model::ServiceExternalIPsConfig>,

    /// GatewayAPIConfig contains the desired config of Gateway API on this
    /// cluster.
    pub gateway_api_config: std::option::Option<crate::model::GatewayAPIConfig>,

    /// Whether multi-networking is enabled for this cluster.
    pub enable_multi_networking: bool,

    /// Network bandwidth tier configuration.
    pub network_performance_config:
        std::option::Option<crate::model::network_config::ClusterNetworkPerformanceConfig>,

    /// Whether FQDN Network Policy is enabled on this cluster.
    pub enable_fqdn_network_policy: std::option::Option<bool>,

    /// Specify the details of in-transit encryption.
    /// Now named inter-node transparent encryption.
    pub in_transit_encryption_config: std::option::Option<crate::model::InTransitEncryptionConfig>,

    /// Whether CiliumClusterwideNetworkPolicy is enabled on this cluster.
    pub enable_cilium_clusterwide_network_policy: std::option::Option<bool>,

    /// Controls whether by default nodes have private IP addresses only.
    /// It is invalid to specify both [PrivateClusterConfig.enablePrivateNodes][]
    /// and this field at the same time.
    /// To update the default setting, use
    /// [ClusterUpdate.desired_default_enable_private_nodes][google.container.v1.ClusterUpdate.desired_default_enable_private_nodes]
    ///
    /// [google.container.v1.ClusterUpdate.desired_default_enable_private_nodes]: crate::model::ClusterUpdate::desired_default_enable_private_nodes
    pub default_enable_private_nodes: std::option::Option<bool>,

    /// Disable L4 load balancer VPC firewalls to enable firewall policies.
    pub disable_l4_lb_firewall_reconciliation: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::NetworkConfig::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [enable_intra_node_visibility][crate::model::NetworkConfig::enable_intra_node_visibility].
    pub fn set_enable_intra_node_visibility<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_intra_node_visibility = v.into();
        self
    }

    /// Sets the value of [default_snat_status][crate::model::NetworkConfig::default_snat_status].
    pub fn set_default_snat_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DefaultSnatStatus>,
    {
        self.default_snat_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_snat_status][crate::model::NetworkConfig::default_snat_status].
    pub fn set_or_clear_default_snat_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DefaultSnatStatus>,
    {
        self.default_snat_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_l4ilb_subsetting][crate::model::NetworkConfig::enable_l4ilb_subsetting].
    pub fn set_enable_l4ilb_subsetting<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_l4ilb_subsetting = v.into();
        self
    }

    /// Sets the value of [datapath_provider][crate::model::NetworkConfig::datapath_provider].
    pub fn set_datapath_provider<T: std::convert::Into<crate::model::DatapathProvider>>(
        mut self,
        v: T,
    ) -> Self {
        self.datapath_provider = v.into();
        self
    }

    /// Sets the value of [private_ipv6_google_access][crate::model::NetworkConfig::private_ipv6_google_access].
    pub fn set_private_ipv6_google_access<
        T: std::convert::Into<crate::model::PrivateIPv6GoogleAccess>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_ipv6_google_access = v.into();
        self
    }

    /// Sets the value of [dns_config][crate::model::NetworkConfig::dns_config].
    pub fn set_dns_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DNSConfig>,
    {
        self.dns_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dns_config][crate::model::NetworkConfig::dns_config].
    pub fn set_or_clear_dns_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DNSConfig>,
    {
        self.dns_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_external_ips_config][crate::model::NetworkConfig::service_external_ips_config].
    pub fn set_service_external_ips_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceExternalIPsConfig>,
    {
        self.service_external_ips_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_external_ips_config][crate::model::NetworkConfig::service_external_ips_config].
    pub fn set_or_clear_service_external_ips_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceExternalIPsConfig>,
    {
        self.service_external_ips_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [gateway_api_config][crate::model::NetworkConfig::gateway_api_config].
    pub fn set_gateway_api_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GatewayAPIConfig>,
    {
        self.gateway_api_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gateway_api_config][crate::model::NetworkConfig::gateway_api_config].
    pub fn set_or_clear_gateway_api_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GatewayAPIConfig>,
    {
        self.gateway_api_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_multi_networking][crate::model::NetworkConfig::enable_multi_networking].
    pub fn set_enable_multi_networking<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_multi_networking = v.into();
        self
    }

    /// Sets the value of [network_performance_config][crate::model::NetworkConfig::network_performance_config].
    pub fn set_network_performance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_config::ClusterNetworkPerformanceConfig>,
    {
        self.network_performance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_performance_config][crate::model::NetworkConfig::network_performance_config].
    pub fn set_or_clear_network_performance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_config::ClusterNetworkPerformanceConfig>,
    {
        self.network_performance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_fqdn_network_policy][crate::model::NetworkConfig::enable_fqdn_network_policy].
    pub fn set_enable_fqdn_network_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_fqdn_network_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_fqdn_network_policy][crate::model::NetworkConfig::enable_fqdn_network_policy].
    pub fn set_or_clear_enable_fqdn_network_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_fqdn_network_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [in_transit_encryption_config][crate::model::NetworkConfig::in_transit_encryption_config].
    pub fn set_in_transit_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InTransitEncryptionConfig>,
    {
        self.in_transit_encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [in_transit_encryption_config][crate::model::NetworkConfig::in_transit_encryption_config].
    pub fn set_or_clear_in_transit_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InTransitEncryptionConfig>,
    {
        self.in_transit_encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_cilium_clusterwide_network_policy][crate::model::NetworkConfig::enable_cilium_clusterwide_network_policy].
    pub fn set_enable_cilium_clusterwide_network_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_cilium_clusterwide_network_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_cilium_clusterwide_network_policy][crate::model::NetworkConfig::enable_cilium_clusterwide_network_policy].
    pub fn set_or_clear_enable_cilium_clusterwide_network_policy<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_cilium_clusterwide_network_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_enable_private_nodes][crate::model::NetworkConfig::default_enable_private_nodes].
    pub fn set_default_enable_private_nodes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.default_enable_private_nodes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_enable_private_nodes][crate::model::NetworkConfig::default_enable_private_nodes].
    pub fn set_or_clear_default_enable_private_nodes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.default_enable_private_nodes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disable_l4_lb_firewall_reconciliation][crate::model::NetworkConfig::disable_l4_lb_firewall_reconciliation].
    pub fn set_disable_l4_lb_firewall_reconciliation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disable_l4_lb_firewall_reconciliation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disable_l4_lb_firewall_reconciliation][crate::model::NetworkConfig::disable_l4_lb_firewall_reconciliation].
    pub fn set_or_clear_disable_l4_lb_firewall_reconciliation<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disable_l4_lb_firewall_reconciliation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NetworkConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NetworkConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __subnetwork,
            __enable_intra_node_visibility,
            __default_snat_status,
            __enable_l4ilb_subsetting,
            __datapath_provider,
            __private_ipv6_google_access,
            __dns_config,
            __service_external_ips_config,
            __gateway_api_config,
            __enable_multi_networking,
            __network_performance_config,
            __enable_fqdn_network_policy,
            __in_transit_encryption_config,
            __enable_cilium_clusterwide_network_policy,
            __default_enable_private_nodes,
            __disable_l4_lb_firewall_reconciliation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "enableIntraNodeVisibility" => {
                                Ok(__FieldTag::__enable_intra_node_visibility)
                            }
                            "enable_intra_node_visibility" => {
                                Ok(__FieldTag::__enable_intra_node_visibility)
                            }
                            "defaultSnatStatus" => Ok(__FieldTag::__default_snat_status),
                            "default_snat_status" => Ok(__FieldTag::__default_snat_status),
                            "enableL4ilbSubsetting" => Ok(__FieldTag::__enable_l4ilb_subsetting),
                            "enable_l4ilb_subsetting" => Ok(__FieldTag::__enable_l4ilb_subsetting),
                            "datapathProvider" => Ok(__FieldTag::__datapath_provider),
                            "datapath_provider" => Ok(__FieldTag::__datapath_provider),
                            "privateIpv6GoogleAccess" => {
                                Ok(__FieldTag::__private_ipv6_google_access)
                            }
                            "private_ipv6_google_access" => {
                                Ok(__FieldTag::__private_ipv6_google_access)
                            }
                            "dnsConfig" => Ok(__FieldTag::__dns_config),
                            "dns_config" => Ok(__FieldTag::__dns_config),
                            "serviceExternalIpsConfig" => {
                                Ok(__FieldTag::__service_external_ips_config)
                            }
                            "service_external_ips_config" => {
                                Ok(__FieldTag::__service_external_ips_config)
                            }
                            "gatewayApiConfig" => Ok(__FieldTag::__gateway_api_config),
                            "gateway_api_config" => Ok(__FieldTag::__gateway_api_config),
                            "enableMultiNetworking" => Ok(__FieldTag::__enable_multi_networking),
                            "enable_multi_networking" => Ok(__FieldTag::__enable_multi_networking),
                            "networkPerformanceConfig" => {
                                Ok(__FieldTag::__network_performance_config)
                            }
                            "network_performance_config" => {
                                Ok(__FieldTag::__network_performance_config)
                            }
                            "enableFqdnNetworkPolicy" => {
                                Ok(__FieldTag::__enable_fqdn_network_policy)
                            }
                            "enable_fqdn_network_policy" => {
                                Ok(__FieldTag::__enable_fqdn_network_policy)
                            }
                            "inTransitEncryptionConfig" => {
                                Ok(__FieldTag::__in_transit_encryption_config)
                            }
                            "in_transit_encryption_config" => {
                                Ok(__FieldTag::__in_transit_encryption_config)
                            }
                            "enableCiliumClusterwideNetworkPolicy" => {
                                Ok(__FieldTag::__enable_cilium_clusterwide_network_policy)
                            }
                            "enable_cilium_clusterwide_network_policy" => {
                                Ok(__FieldTag::__enable_cilium_clusterwide_network_policy)
                            }
                            "defaultEnablePrivateNodes" => {
                                Ok(__FieldTag::__default_enable_private_nodes)
                            }
                            "default_enable_private_nodes" => {
                                Ok(__FieldTag::__default_enable_private_nodes)
                            }
                            "disableL4LbFirewallReconciliation" => {
                                Ok(__FieldTag::__disable_l4_lb_firewall_reconciliation)
                            }
                            "disable_l4_lb_firewall_reconciliation" => {
                                Ok(__FieldTag::__disable_l4_lb_firewall_reconciliation)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_intra_node_visibility => {
                            if !fields.insert(__FieldTag::__enable_intra_node_visibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_intra_node_visibility",
                                ));
                            }
                            result.enable_intra_node_visibility = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_snat_status => {
                            if !fields.insert(__FieldTag::__default_snat_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_snat_status",
                                ));
                            }
                            result.default_snat_status = map
                                .next_value::<std::option::Option<crate::model::DefaultSnatStatus>>(
                                )?;
                        }
                        __FieldTag::__enable_l4ilb_subsetting => {
                            if !fields.insert(__FieldTag::__enable_l4ilb_subsetting) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_l4ilb_subsetting",
                                ));
                            }
                            result.enable_l4ilb_subsetting = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datapath_provider => {
                            if !fields.insert(__FieldTag::__datapath_provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datapath_provider",
                                ));
                            }
                            result.datapath_provider = map
                                .next_value::<std::option::Option<crate::model::DatapathProvider>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_ipv6_google_access => {
                            if !fields.insert(__FieldTag::__private_ipv6_google_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_ipv6_google_access",
                                ));
                            }
                            result.private_ipv6_google_access = map.next_value::<std::option::Option<crate::model::PrivateIPv6GoogleAccess>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dns_config => {
                            if !fields.insert(__FieldTag::__dns_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_config",
                                ));
                            }
                            result.dns_config =
                                map.next_value::<std::option::Option<crate::model::DNSConfig>>()?;
                        }
                        __FieldTag::__service_external_ips_config => {
                            if !fields.insert(__FieldTag::__service_external_ips_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_external_ips_config",
                                ));
                            }
                            result.service_external_ips_config = map.next_value::<std::option::Option<crate::model::ServiceExternalIPsConfig>>()?
                                ;
                        }
                        __FieldTag::__gateway_api_config => {
                            if !fields.insert(__FieldTag::__gateway_api_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gateway_api_config",
                                ));
                            }
                            result.gateway_api_config = map
                                .next_value::<std::option::Option<crate::model::GatewayAPIConfig>>(
                                )?;
                        }
                        __FieldTag::__enable_multi_networking => {
                            if !fields.insert(__FieldTag::__enable_multi_networking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_multi_networking",
                                ));
                            }
                            result.enable_multi_networking = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_performance_config => {
                            if !fields.insert(__FieldTag::__network_performance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_performance_config",
                                ));
                            }
                            result.network_performance_config = map
                                .next_value::<std::option::Option<
                                    crate::model::network_config::ClusterNetworkPerformanceConfig,
                                >>()?;
                        }
                        __FieldTag::__enable_fqdn_network_policy => {
                            if !fields.insert(__FieldTag::__enable_fqdn_network_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_fqdn_network_policy",
                                ));
                            }
                            result.enable_fqdn_network_policy =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__in_transit_encryption_config => {
                            if !fields.insert(__FieldTag::__in_transit_encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for in_transit_encryption_config",
                                ));
                            }
                            result.in_transit_encryption_config = map.next_value::<std::option::Option<crate::model::InTransitEncryptionConfig>>()?
                                ;
                        }
                        __FieldTag::__enable_cilium_clusterwide_network_policy => {
                            if !fields
                                .insert(__FieldTag::__enable_cilium_clusterwide_network_policy)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_cilium_clusterwide_network_policy",
                                ));
                            }
                            result.enable_cilium_clusterwide_network_policy =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__default_enable_private_nodes => {
                            if !fields.insert(__FieldTag::__default_enable_private_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_enable_private_nodes",
                                ));
                            }
                            result.default_enable_private_nodes =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__disable_l4_lb_firewall_reconciliation => {
                            if !fields.insert(__FieldTag::__disable_l4_lb_firewall_reconciliation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_l4_lb_firewall_reconciliation",
                                ));
                            }
                            result.disable_l4_lb_firewall_reconciliation =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !wkt::internal::is_default(&self.enable_intra_node_visibility) {
            state.serialize_entry(
                "enableIntraNodeVisibility",
                &self.enable_intra_node_visibility,
            )?;
        }
        if self.default_snat_status.is_some() {
            state.serialize_entry("defaultSnatStatus", &self.default_snat_status)?;
        }
        if !wkt::internal::is_default(&self.enable_l4ilb_subsetting) {
            state.serialize_entry("enableL4ilbSubsetting", &self.enable_l4ilb_subsetting)?;
        }
        if !wkt::internal::is_default(&self.datapath_provider) {
            state.serialize_entry("datapathProvider", &self.datapath_provider)?;
        }
        if !wkt::internal::is_default(&self.private_ipv6_google_access) {
            state.serialize_entry("privateIpv6GoogleAccess", &self.private_ipv6_google_access)?;
        }
        if self.dns_config.is_some() {
            state.serialize_entry("dnsConfig", &self.dns_config)?;
        }
        if self.service_external_ips_config.is_some() {
            state.serialize_entry(
                "serviceExternalIpsConfig",
                &self.service_external_ips_config,
            )?;
        }
        if self.gateway_api_config.is_some() {
            state.serialize_entry("gatewayApiConfig", &self.gateway_api_config)?;
        }
        if !wkt::internal::is_default(&self.enable_multi_networking) {
            state.serialize_entry("enableMultiNetworking", &self.enable_multi_networking)?;
        }
        if self.network_performance_config.is_some() {
            state.serialize_entry("networkPerformanceConfig", &self.network_performance_config)?;
        }
        if self.enable_fqdn_network_policy.is_some() {
            state.serialize_entry("enableFqdnNetworkPolicy", &self.enable_fqdn_network_policy)?;
        }
        if self.in_transit_encryption_config.is_some() {
            state.serialize_entry(
                "inTransitEncryptionConfig",
                &self.in_transit_encryption_config,
            )?;
        }
        if self.enable_cilium_clusterwide_network_policy.is_some() {
            state.serialize_entry(
                "enableCiliumClusterwideNetworkPolicy",
                &self.enable_cilium_clusterwide_network_policy,
            )?;
        }
        if self.default_enable_private_nodes.is_some() {
            state.serialize_entry(
                "defaultEnablePrivateNodes",
                &self.default_enable_private_nodes,
            )?;
        }
        if self.disable_l4_lb_firewall_reconciliation.is_some() {
            state.serialize_entry(
                "disableL4LbFirewallReconciliation",
                &self.disable_l4_lb_firewall_reconciliation,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkConfig");
        debug_struct.field("network", &self.network);
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field(
            "enable_intra_node_visibility",
            &self.enable_intra_node_visibility,
        );
        debug_struct.field("default_snat_status", &self.default_snat_status);
        debug_struct.field("enable_l4ilb_subsetting", &self.enable_l4ilb_subsetting);
        debug_struct.field("datapath_provider", &self.datapath_provider);
        debug_struct.field(
            "private_ipv6_google_access",
            &self.private_ipv6_google_access,
        );
        debug_struct.field("dns_config", &self.dns_config);
        debug_struct.field(
            "service_external_ips_config",
            &self.service_external_ips_config,
        );
        debug_struct.field("gateway_api_config", &self.gateway_api_config);
        debug_struct.field("enable_multi_networking", &self.enable_multi_networking);
        debug_struct.field(
            "network_performance_config",
            &self.network_performance_config,
        );
        debug_struct.field(
            "enable_fqdn_network_policy",
            &self.enable_fqdn_network_policy,
        );
        debug_struct.field(
            "in_transit_encryption_config",
            &self.in_transit_encryption_config,
        );
        debug_struct.field(
            "enable_cilium_clusterwide_network_policy",
            &self.enable_cilium_clusterwide_network_policy,
        );
        debug_struct.field(
            "default_enable_private_nodes",
            &self.default_enable_private_nodes,
        );
        debug_struct.field(
            "disable_l4_lb_firewall_reconciliation",
            &self.disable_l4_lb_firewall_reconciliation,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NetworkConfig].
pub mod network_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of network bandwidth tiers
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClusterNetworkPerformanceConfig {
        /// Specifies the total network bandwidth tier for NodePools in the cluster.
        pub total_egress_bandwidth_tier: std::option::Option<
            crate::model::network_config::cluster_network_performance_config::Tier,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClusterNetworkPerformanceConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [total_egress_bandwidth_tier][crate::model::network_config::ClusterNetworkPerformanceConfig::total_egress_bandwidth_tier].
        pub fn set_total_egress_bandwidth_tier<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::network_config::cluster_network_performance_config::Tier,
                >,
        {
            self.total_egress_bandwidth_tier = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [total_egress_bandwidth_tier][crate::model::network_config::ClusterNetworkPerformanceConfig::total_egress_bandwidth_tier].
        pub fn set_or_clear_total_egress_bandwidth_tier<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<
                    crate::model::network_config::cluster_network_performance_config::Tier,
                >,
        {
            self.total_egress_bandwidth_tier = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ClusterNetworkPerformanceConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NetworkConfig.ClusterNetworkPerformanceConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClusterNetworkPerformanceConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __total_egress_bandwidth_tier,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClusterNetworkPerformanceConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "totalEgressBandwidthTier" => {
                                    Ok(__FieldTag::__total_egress_bandwidth_tier)
                                }
                                "total_egress_bandwidth_tier" => {
                                    Ok(__FieldTag::__total_egress_bandwidth_tier)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClusterNetworkPerformanceConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClusterNetworkPerformanceConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__total_egress_bandwidth_tier => {
                                if !fields.insert(__FieldTag::__total_egress_bandwidth_tier) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for total_egress_bandwidth_tier",
                                    ));
                                }
                                result.total_egress_bandwidth_tier = map.next_value::<std::option::Option<crate::model::network_config::cluster_network_performance_config::Tier>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClusterNetworkPerformanceConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.total_egress_bandwidth_tier.is_some() {
                state.serialize_entry(
                    "totalEgressBandwidthTier",
                    &self.total_egress_bandwidth_tier,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ClusterNetworkPerformanceConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ClusterNetworkPerformanceConfig");
            debug_struct.field(
                "total_egress_bandwidth_tier",
                &self.total_egress_bandwidth_tier,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ClusterNetworkPerformanceConfig].
    pub mod cluster_network_performance_config {
        #[allow(unused_imports)]
        use super::*;

        /// Node network tier
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Tier {
            /// Default value
            Unspecified,
            /// Higher bandwidth, actual values based on VM size.
            Tier1,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Tier::value] or
            /// [Tier::name].
            UnknownValue(tier::UnknownValue),
        }

        #[doc(hidden)]
        pub mod tier {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Tier {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Tier1 => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TIER_UNSPECIFIED"),
                    Self::Tier1 => std::option::Option::Some("TIER_1"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Tier {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Tier {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Tier {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Tier1,
                    _ => Self::UnknownValue(tier::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Tier {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TIER_UNSPECIFIED" => Self::Unspecified,
                    "TIER_1" => Self::Tier1,
                    _ => Self::UnknownValue(tier::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Tier {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Tier1 => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Tier {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Tier>::new(
                    ".google.container.v1.NetworkConfig.ClusterNetworkPerformanceConfig.Tier",
                ))
            }
        }
    }
}

/// GatewayAPIConfig contains the desired config of Gateway API on this cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GatewayAPIConfig {
    /// The Gateway API release channel to use for Gateway API.
    pub channel: crate::model::gateway_api_config::Channel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GatewayAPIConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel][crate::model::GatewayAPIConfig::channel].
    pub fn set_channel<T: std::convert::Into<crate::model::gateway_api_config::Channel>>(
        mut self,
        v: T,
    ) -> Self {
        self.channel = v.into();
        self
    }
}

impl wkt::message::Message for GatewayAPIConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GatewayAPIConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GatewayAPIConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channel,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GatewayAPIConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channel" => Ok(__FieldTag::__channel),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GatewayAPIConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GatewayAPIConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel = map.next_value::<std::option::Option<crate::model::gateway_api_config::Channel>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GatewayAPIConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.channel) {
            state.serialize_entry("channel", &self.channel)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GatewayAPIConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GatewayAPIConfig");
        debug_struct.field("channel", &self.channel);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GatewayAPIConfig].
pub mod gateway_api_config {
    #[allow(unused_imports)]
    use super::*;

    /// Channel describes if/how Gateway API should be installed and implemented in
    /// a cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Channel {
        /// Default value.
        Unspecified,
        /// Gateway API support is disabled
        Disabled,
        /// Deprecated: use CHANNEL_STANDARD instead.
        /// Gateway API support is enabled, experimental CRDs are installed
        #[deprecated]
        Experimental,
        /// Gateway API support is enabled, standard CRDs are installed
        Standard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Channel::value] or
        /// [Channel::name].
        UnknownValue(channel::UnknownValue),
    }

    #[doc(hidden)]
    pub mod channel {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Channel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Experimental => std::option::Option::Some(3),
                Self::Standard => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CHANNEL_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("CHANNEL_DISABLED"),
                Self::Experimental => std::option::Option::Some("CHANNEL_EXPERIMENTAL"),
                Self::Standard => std::option::Option::Some("CHANNEL_STANDARD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Channel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Channel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Channel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                3 => Self::Experimental,
                4 => Self::Standard,
                _ => Self::UnknownValue(channel::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Channel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHANNEL_UNSPECIFIED" => Self::Unspecified,
                "CHANNEL_DISABLED" => Self::Disabled,
                "CHANNEL_EXPERIMENTAL" => Self::Experimental,
                "CHANNEL_STANDARD" => Self::Standard,
                _ => Self::UnknownValue(channel::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Channel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Experimental => serializer.serialize_i32(3),
                Self::Standard => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Channel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Channel>::new(
                ".google.container.v1.GatewayAPIConfig.Channel",
            ))
        }
    }
}

/// Config to block services with externalIPs field.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceExternalIPsConfig {
    /// Whether Services with ExternalIPs field are allowed or not.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceExternalIPsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ServiceExternalIPsConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ServiceExternalIPsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ServiceExternalIPsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceExternalIPsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceExternalIPsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceExternalIPsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceExternalIPsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceExternalIPsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ServiceExternalIPsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceExternalIPsConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetOpenIDConfigRequest gets the OIDC discovery document for the
/// cluster. See the OpenID Connect Discovery 1.0 specification for details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOpenIDConfigRequest {
    /// The cluster (project, location, cluster name) to get the discovery document
    /// for. Specified in the format `projects/*/locations/*/clusters/*`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOpenIDConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetOpenIDConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for GetOpenIDConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetOpenIDConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetOpenIDConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOpenIDConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetOpenIDConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOpenIDConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetOpenIDConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetOpenIDConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetOpenIDConfigRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetOpenIDConfigResponse is an OIDC discovery document for the cluster.
/// See the OpenID Connect Discovery 1.0 specification for details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetOpenIDConfigResponse {
    /// OIDC Issuer.
    pub issuer: std::string::String,

    /// JSON Web Key uri.
    pub jwks_uri: std::string::String,

    /// Supported response types.
    pub response_types_supported: std::vec::Vec<std::string::String>,

    /// Supported subject types.
    pub subject_types_supported: std::vec::Vec<std::string::String>,

    /// supported ID Token signing Algorithms.
    pub id_token_signing_alg_values_supported: std::vec::Vec<std::string::String>,

    /// Supported claims.
    pub claims_supported: std::vec::Vec<std::string::String>,

    /// Supported grant types.
    pub grant_types: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetOpenIDConfigResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issuer][crate::model::GetOpenIDConfigResponse::issuer].
    pub fn set_issuer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.issuer = v.into();
        self
    }

    /// Sets the value of [jwks_uri][crate::model::GetOpenIDConfigResponse::jwks_uri].
    pub fn set_jwks_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.jwks_uri = v.into();
        self
    }

    /// Sets the value of [response_types_supported][crate::model::GetOpenIDConfigResponse::response_types_supported].
    pub fn set_response_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.response_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [subject_types_supported][crate::model::GetOpenIDConfigResponse::subject_types_supported].
    pub fn set_subject_types_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subject_types_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [id_token_signing_alg_values_supported][crate::model::GetOpenIDConfigResponse::id_token_signing_alg_values_supported].
    pub fn set_id_token_signing_alg_values_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.id_token_signing_alg_values_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [claims_supported][crate::model::GetOpenIDConfigResponse::claims_supported].
    pub fn set_claims_supported<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.claims_supported = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [grant_types][crate::model::GetOpenIDConfigResponse::grant_types].
    pub fn set_grant_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.grant_types = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GetOpenIDConfigResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetOpenIDConfigResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetOpenIDConfigResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issuer,
            __jwks_uri,
            __response_types_supported,
            __subject_types_supported,
            __id_token_signing_alg_values_supported,
            __claims_supported,
            __grant_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOpenIDConfigResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issuer" => Ok(__FieldTag::__issuer),
                            "jwks_uri" => Ok(__FieldTag::__jwks_uri),
                            "response_types_supported" => {
                                Ok(__FieldTag::__response_types_supported)
                            }
                            "subject_types_supported" => Ok(__FieldTag::__subject_types_supported),
                            "id_token_signing_alg_values_supported" => {
                                Ok(__FieldTag::__id_token_signing_alg_values_supported)
                            }
                            "claims_supported" => Ok(__FieldTag::__claims_supported),
                            "grant_types" => Ok(__FieldTag::__grant_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetOpenIDConfigResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOpenIDConfigResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issuer => {
                            if !fields.insert(__FieldTag::__issuer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuer",
                                ));
                            }
                            result.issuer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jwks_uri => {
                            if !fields.insert(__FieldTag::__jwks_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jwks_uri",
                                ));
                            }
                            result.jwks_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__response_types_supported => {
                            if !fields.insert(__FieldTag::__response_types_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_types_supported",
                                ));
                            }
                            result.response_types_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__subject_types_supported => {
                            if !fields.insert(__FieldTag::__subject_types_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_types_supported",
                                ));
                            }
                            result.subject_types_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__id_token_signing_alg_values_supported => {
                            if !fields.insert(__FieldTag::__id_token_signing_alg_values_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id_token_signing_alg_values_supported",
                                ));
                            }
                            result.id_token_signing_alg_values_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__claims_supported => {
                            if !fields.insert(__FieldTag::__claims_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for claims_supported",
                                ));
                            }
                            result.claims_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__grant_types => {
                            if !fields.insert(__FieldTag::__grant_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grant_types",
                                ));
                            }
                            result.grant_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetOpenIDConfigResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issuer.is_empty() {
            state.serialize_entry("issuer", &self.issuer)?;
        }
        if !self.jwks_uri.is_empty() {
            state.serialize_entry("jwks_uri", &self.jwks_uri)?;
        }
        if !self.response_types_supported.is_empty() {
            state.serialize_entry("response_types_supported", &self.response_types_supported)?;
        }
        if !self.subject_types_supported.is_empty() {
            state.serialize_entry("subject_types_supported", &self.subject_types_supported)?;
        }
        if !self.id_token_signing_alg_values_supported.is_empty() {
            state.serialize_entry(
                "id_token_signing_alg_values_supported",
                &self.id_token_signing_alg_values_supported,
            )?;
        }
        if !self.claims_supported.is_empty() {
            state.serialize_entry("claims_supported", &self.claims_supported)?;
        }
        if !self.grant_types.is_empty() {
            state.serialize_entry("grant_types", &self.grant_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetOpenIDConfigResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetOpenIDConfigResponse");
        debug_struct.field("issuer", &self.issuer);
        debug_struct.field("jwks_uri", &self.jwks_uri);
        debug_struct.field("response_types_supported", &self.response_types_supported);
        debug_struct.field("subject_types_supported", &self.subject_types_supported);
        debug_struct.field(
            "id_token_signing_alg_values_supported",
            &self.id_token_signing_alg_values_supported,
        );
        debug_struct.field("claims_supported", &self.claims_supported);
        debug_struct.field("grant_types", &self.grant_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetJSONWebKeysRequest gets the public component of the keys used by the
/// cluster to sign token requests. This will be the jwks_uri for the discover
/// document returned by getOpenIDConfig. See the OpenID Connect
/// Discovery 1.0 specification for details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetJSONWebKeysRequest {
    /// The cluster (project, location, cluster name) to get keys for. Specified in
    /// the format `projects/*/locations/*/clusters/*`.
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJSONWebKeysRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::GetJSONWebKeysRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for GetJSONWebKeysRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetJSONWebKeysRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetJSONWebKeysRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJSONWebKeysRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetJSONWebKeysRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJSONWebKeysRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetJSONWebKeysRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetJSONWebKeysRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetJSONWebKeysRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Jwk is a JSON Web Key as specified in RFC 7517
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Jwk {
    /// Key Type.
    pub kty: std::string::String,

    /// Algorithm.
    pub alg: std::string::String,

    /// Permitted uses for the public keys.
    pub r#use: std::string::String,

    /// Key ID.
    pub kid: std::string::String,

    /// Used for RSA keys.
    pub n: std::string::String,

    /// Used for RSA keys.
    pub e: std::string::String,

    /// Used for ECDSA keys.
    pub x: std::string::String,

    /// Used for ECDSA keys.
    pub y: std::string::String,

    /// Used for ECDSA keys.
    pub crv: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Jwk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kty][crate::model::Jwk::kty].
    pub fn set_kty<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kty = v.into();
        self
    }

    /// Sets the value of [alg][crate::model::Jwk::alg].
    pub fn set_alg<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.alg = v.into();
        self
    }

    /// Sets the value of [r#use][crate::model::Jwk::use].
    pub fn set_use<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.r#use = v.into();
        self
    }

    /// Sets the value of [kid][crate::model::Jwk::kid].
    pub fn set_kid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kid = v.into();
        self
    }

    /// Sets the value of [n][crate::model::Jwk::n].
    pub fn set_n<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.n = v.into();
        self
    }

    /// Sets the value of [e][crate::model::Jwk::e].
    pub fn set_e<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.e = v.into();
        self
    }

    /// Sets the value of [x][crate::model::Jwk::x].
    pub fn set_x<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.x = v.into();
        self
    }

    /// Sets the value of [y][crate::model::Jwk::y].
    pub fn set_y<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.y = v.into();
        self
    }

    /// Sets the value of [crv][crate::model::Jwk::crv].
    pub fn set_crv<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.crv = v.into();
        self
    }
}

impl wkt::message::Message for Jwk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.Jwk"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Jwk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kty,
            __alg,
            __use,
            __kid,
            __n,
            __e,
            __x,
            __y,
            __crv,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Jwk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kty" => Ok(__FieldTag::__kty),
                            "alg" => Ok(__FieldTag::__alg),
                            "use" => Ok(__FieldTag::__use),
                            "kid" => Ok(__FieldTag::__kid),
                            "n" => Ok(__FieldTag::__n),
                            "e" => Ok(__FieldTag::__e),
                            "x" => Ok(__FieldTag::__x),
                            "y" => Ok(__FieldTag::__y),
                            "crv" => Ok(__FieldTag::__crv),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Jwk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Jwk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kty => {
                            if !fields.insert(__FieldTag::__kty) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kty",
                                ));
                            }
                            result.kty = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__alg => {
                            if !fields.insert(__FieldTag::__alg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alg",
                                ));
                            }
                            result.alg = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use => {
                            if !fields.insert(__FieldTag::__use) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use",
                                ));
                            }
                            result.r#use = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kid => {
                            if !fields.insert(__FieldTag::__kid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kid",
                                ));
                            }
                            result.kid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__n => {
                            if !fields.insert(__FieldTag::__n) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for n",
                                ));
                            }
                            result.n = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__e => {
                            if !fields.insert(__FieldTag::__e) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for e",
                                ));
                            }
                            result.e = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__x => {
                            if !fields.insert(__FieldTag::__x) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x",
                                ));
                            }
                            result.x = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__y => {
                            if !fields.insert(__FieldTag::__y) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y",
                                ));
                            }
                            result.y = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crv => {
                            if !fields.insert(__FieldTag::__crv) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crv",
                                ));
                            }
                            result.crv = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Jwk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kty.is_empty() {
            state.serialize_entry("kty", &self.kty)?;
        }
        if !self.alg.is_empty() {
            state.serialize_entry("alg", &self.alg)?;
        }
        if !self.r#use.is_empty() {
            state.serialize_entry("use", &self.r#use)?;
        }
        if !self.kid.is_empty() {
            state.serialize_entry("kid", &self.kid)?;
        }
        if !self.n.is_empty() {
            state.serialize_entry("n", &self.n)?;
        }
        if !self.e.is_empty() {
            state.serialize_entry("e", &self.e)?;
        }
        if !self.x.is_empty() {
            state.serialize_entry("x", &self.x)?;
        }
        if !self.y.is_empty() {
            state.serialize_entry("y", &self.y)?;
        }
        if !self.crv.is_empty() {
            state.serialize_entry("crv", &self.crv)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Jwk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Jwk");
        debug_struct.field("kty", &self.kty);
        debug_struct.field("alg", &self.alg);
        debug_struct.field("r#use", &self.r#use);
        debug_struct.field("kid", &self.kid);
        debug_struct.field("n", &self.n);
        debug_struct.field("e", &self.e);
        debug_struct.field("x", &self.x);
        debug_struct.field("y", &self.y);
        debug_struct.field("crv", &self.crv);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// GetJSONWebKeysResponse is a valid JSON Web Key Set as specified in rfc 7517
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetJSONWebKeysResponse {
    /// The public component of the keys used by the cluster to sign token
    /// requests.
    pub keys: std::vec::Vec<crate::model::Jwk>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetJSONWebKeysResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [keys][crate::model::GetJSONWebKeysResponse::keys].
    pub fn set_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Jwk>,
    {
        use std::iter::Iterator;
        self.keys = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GetJSONWebKeysResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GetJSONWebKeysResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetJSONWebKeysResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __keys,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJSONWebKeysResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keys" => Ok(__FieldTag::__keys),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetJSONWebKeysResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJSONWebKeysResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__keys => {
                            if !fields.insert(__FieldTag::__keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keys",
                                ));
                            }
                            result.keys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Jwk>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetJSONWebKeysResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.keys.is_empty() {
            state.serialize_entry("keys", &self.keys)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetJSONWebKeysResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetJSONWebKeysResponse");
        debug_struct.field("keys", &self.keys);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CheckAutopilotCompatibilityRequest requests getting the blockers for the
/// given operation in the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckAutopilotCompatibilityRequest {
    /// The name (project, location, cluster) of the cluster to retrieve.
    /// Specified in the format `projects/*/locations/*/clusters/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckAutopilotCompatibilityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CheckAutopilotCompatibilityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CheckAutopilotCompatibilityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CheckAutopilotCompatibilityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckAutopilotCompatibilityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckAutopilotCompatibilityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckAutopilotCompatibilityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckAutopilotCompatibilityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckAutopilotCompatibilityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CheckAutopilotCompatibilityRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckAutopilotCompatibilityRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AutopilotCompatibilityIssue contains information about a specific
/// compatibility issue with Autopilot mode.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutopilotCompatibilityIssue {
    /// The last time when this issue was observed.
    pub last_observation: std::option::Option<wkt::Timestamp>,

    /// The constraint type of the issue.
    pub constraint_type: std::string::String,

    /// The incompatibility type of this issue.
    pub incompatibility_type: crate::model::autopilot_compatibility_issue::IssueType,

    /// The name of the resources which are subject to this issue.
    pub subjects: std::vec::Vec<std::string::String>,

    /// A URL to a public documentation, which addresses resolving this issue.
    pub documentation_url: std::string::String,

    /// The description of the issue.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutopilotCompatibilityIssue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_observation][crate::model::AutopilotCompatibilityIssue::last_observation].
    pub fn set_last_observation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_observation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_observation][crate::model::AutopilotCompatibilityIssue::last_observation].
    pub fn set_or_clear_last_observation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_observation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [constraint_type][crate::model::AutopilotCompatibilityIssue::constraint_type].
    pub fn set_constraint_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.constraint_type = v.into();
        self
    }

    /// Sets the value of [incompatibility_type][crate::model::AutopilotCompatibilityIssue::incompatibility_type].
    pub fn set_incompatibility_type<
        T: std::convert::Into<crate::model::autopilot_compatibility_issue::IssueType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.incompatibility_type = v.into();
        self
    }

    /// Sets the value of [subjects][crate::model::AutopilotCompatibilityIssue::subjects].
    pub fn set_subjects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.subjects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [documentation_url][crate::model::AutopilotCompatibilityIssue::documentation_url].
    pub fn set_documentation_url<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.documentation_url = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AutopilotCompatibilityIssue::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for AutopilotCompatibilityIssue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AutopilotCompatibilityIssue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutopilotCompatibilityIssue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __last_observation,
            __constraint_type,
            __incompatibility_type,
            __subjects,
            __documentation_url,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutopilotCompatibilityIssue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lastObservation" => Ok(__FieldTag::__last_observation),
                            "last_observation" => Ok(__FieldTag::__last_observation),
                            "constraintType" => Ok(__FieldTag::__constraint_type),
                            "constraint_type" => Ok(__FieldTag::__constraint_type),
                            "incompatibilityType" => Ok(__FieldTag::__incompatibility_type),
                            "incompatibility_type" => Ok(__FieldTag::__incompatibility_type),
                            "subjects" => Ok(__FieldTag::__subjects),
                            "documentationUrl" => Ok(__FieldTag::__documentation_url),
                            "documentation_url" => Ok(__FieldTag::__documentation_url),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutopilotCompatibilityIssue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutopilotCompatibilityIssue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__last_observation => {
                            if !fields.insert(__FieldTag::__last_observation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_observation",
                                ));
                            }
                            result.last_observation =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__constraint_type => {
                            if !fields.insert(__FieldTag::__constraint_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraint_type",
                                ));
                            }
                            result.constraint_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__incompatibility_type => {
                            if !fields.insert(__FieldTag::__incompatibility_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for incompatibility_type",
                                ));
                            }
                            result.incompatibility_type = map
                                .next_value::<std::option::Option<
                                    crate::model::autopilot_compatibility_issue::IssueType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subjects => {
                            if !fields.insert(__FieldTag::__subjects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subjects",
                                ));
                            }
                            result.subjects = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__documentation_url => {
                            if !fields.insert(__FieldTag::__documentation_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation_url",
                                ));
                            }
                            result.documentation_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutopilotCompatibilityIssue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.last_observation.is_some() {
            state.serialize_entry("lastObservation", &self.last_observation)?;
        }
        if !self.constraint_type.is_empty() {
            state.serialize_entry("constraintType", &self.constraint_type)?;
        }
        if !wkt::internal::is_default(&self.incompatibility_type) {
            state.serialize_entry("incompatibilityType", &self.incompatibility_type)?;
        }
        if !self.subjects.is_empty() {
            state.serialize_entry("subjects", &self.subjects)?;
        }
        if !self.documentation_url.is_empty() {
            state.serialize_entry("documentationUrl", &self.documentation_url)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutopilotCompatibilityIssue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutopilotCompatibilityIssue");
        debug_struct.field("last_observation", &self.last_observation);
        debug_struct.field("constraint_type", &self.constraint_type);
        debug_struct.field("incompatibility_type", &self.incompatibility_type);
        debug_struct.field("subjects", &self.subjects);
        debug_struct.field("documentation_url", &self.documentation_url);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AutopilotCompatibilityIssue].
pub mod autopilot_compatibility_issue {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the reported issue.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IssueType {
        /// Default value, should not be used.
        Unspecified,
        /// Indicates that the issue is a known incompatibility between the
        /// cluster and Autopilot mode.
        Incompatibility,
        /// Indicates the issue is an incompatibility if customers take no further
        /// action to resolve.
        AdditionalConfigRequired,
        /// Indicates the issue is not an incompatibility, but depending on the
        /// workloads business logic, there is a potential that they won't work on
        /// Autopilot.
        PassedWithOptionalConfig,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IssueType::value] or
        /// [IssueType::name].
        UnknownValue(issue_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod issue_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IssueType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Incompatibility => std::option::Option::Some(1),
                Self::AdditionalConfigRequired => std::option::Option::Some(2),
                Self::PassedWithOptionalConfig => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Incompatibility => std::option::Option::Some("INCOMPATIBILITY"),
                Self::AdditionalConfigRequired => {
                    std::option::Option::Some("ADDITIONAL_CONFIG_REQUIRED")
                }
                Self::PassedWithOptionalConfig => {
                    std::option::Option::Some("PASSED_WITH_OPTIONAL_CONFIG")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IssueType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IssueType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IssueType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Incompatibility,
                2 => Self::AdditionalConfigRequired,
                3 => Self::PassedWithOptionalConfig,
                _ => Self::UnknownValue(issue_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IssueType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "INCOMPATIBILITY" => Self::Incompatibility,
                "ADDITIONAL_CONFIG_REQUIRED" => Self::AdditionalConfigRequired,
                "PASSED_WITH_OPTIONAL_CONFIG" => Self::PassedWithOptionalConfig,
                _ => Self::UnknownValue(issue_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IssueType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Incompatibility => serializer.serialize_i32(1),
                Self::AdditionalConfigRequired => serializer.serialize_i32(2),
                Self::PassedWithOptionalConfig => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IssueType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IssueType>::new(
                ".google.container.v1.AutopilotCompatibilityIssue.IssueType",
            ))
        }
    }
}

/// CheckAutopilotCompatibilityResponse has a list of compatibility issues.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckAutopilotCompatibilityResponse {
    /// The list of issues for the given operation.
    pub issues: std::vec::Vec<crate::model::AutopilotCompatibilityIssue>,

    /// The summary of the autopilot compatibility response.
    pub summary: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckAutopilotCompatibilityResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issues][crate::model::CheckAutopilotCompatibilityResponse::issues].
    pub fn set_issues<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AutopilotCompatibilityIssue>,
    {
        use std::iter::Iterator;
        self.issues = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [summary][crate::model::CheckAutopilotCompatibilityResponse::summary].
    pub fn set_summary<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.summary = v.into();
        self
    }
}

impl wkt::message::Message for CheckAutopilotCompatibilityResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CheckAutopilotCompatibilityResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckAutopilotCompatibilityResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issues,
            __summary,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckAutopilotCompatibilityResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issues" => Ok(__FieldTag::__issues),
                            "summary" => Ok(__FieldTag::__summary),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckAutopilotCompatibilityResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckAutopilotCompatibilityResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issues => {
                            if !fields.insert(__FieldTag::__issues) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issues",
                                ));
                            }
                            result.issues = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutopilotCompatibilityIssue>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summary",
                                ));
                            }
                            result.summary = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckAutopilotCompatibilityResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issues.is_empty() {
            state.serialize_entry("issues", &self.issues)?;
        }
        if !self.summary.is_empty() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CheckAutopilotCompatibilityResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckAutopilotCompatibilityResponse");
        debug_struct.field("issues", &self.issues);
        debug_struct.field("summary", &self.summary);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ReleaseChannel indicates which release channel a cluster is
/// subscribed to. Release channels are arranged in order of risk.
///
/// When a cluster is subscribed to a release channel, Google maintains
/// both the master version and the node version. Node auto-upgrade
/// defaults to true and cannot be disabled.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReleaseChannel {
    /// channel specifies which release channel the cluster is subscribed to.
    pub channel: crate::model::release_channel::Channel,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReleaseChannel {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channel][crate::model::ReleaseChannel::channel].
    pub fn set_channel<T: std::convert::Into<crate::model::release_channel::Channel>>(
        mut self,
        v: T,
    ) -> Self {
        self.channel = v.into();
        self
    }
}

impl wkt::message::Message for ReleaseChannel {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ReleaseChannel"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReleaseChannel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channel,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReleaseChannel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channel" => Ok(__FieldTag::__channel),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReleaseChannel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReleaseChannel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel = map.next_value::<std::option::Option<crate::model::release_channel::Channel>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReleaseChannel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.channel) {
            state.serialize_entry("channel", &self.channel)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReleaseChannel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReleaseChannel");
        debug_struct.field("channel", &self.channel);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReleaseChannel].
pub mod release_channel {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for 'channel'.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Channel {
        /// No channel specified.
        Unspecified,
        /// RAPID channel is offered on an early access basis for customers who want
        /// to test new releases.
        ///
        /// WARNING: Versions available in the RAPID Channel may be subject to
        /// unresolved issues with no known workaround and are not subject to any
        /// SLAs.
        Rapid,
        /// Clusters subscribed to REGULAR receive versions that are considered GA
        /// quality. REGULAR is intended for production users who want to take
        /// advantage of new features.
        Regular,
        /// Clusters subscribed to STABLE receive versions that are known to be
        /// stable and reliable in production.
        Stable,
        /// Clusters subscribed to EXTENDED receive extended support and availability
        /// for versions which are known to be stable and reliable in production.
        Extended,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Channel::value] or
        /// [Channel::name].
        UnknownValue(channel::UnknownValue),
    }

    #[doc(hidden)]
    pub mod channel {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Channel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Rapid => std::option::Option::Some(1),
                Self::Regular => std::option::Option::Some(2),
                Self::Stable => std::option::Option::Some(3),
                Self::Extended => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Rapid => std::option::Option::Some("RAPID"),
                Self::Regular => std::option::Option::Some("REGULAR"),
                Self::Stable => std::option::Option::Some("STABLE"),
                Self::Extended => std::option::Option::Some("EXTENDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Channel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Channel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Channel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Rapid,
                2 => Self::Regular,
                3 => Self::Stable,
                4 => Self::Extended,
                _ => Self::UnknownValue(channel::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Channel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "RAPID" => Self::Rapid,
                "REGULAR" => Self::Regular,
                "STABLE" => Self::Stable,
                "EXTENDED" => Self::Extended,
                _ => Self::UnknownValue(channel::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Channel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Rapid => serializer.serialize_i32(1),
                Self::Regular => serializer.serialize_i32(2),
                Self::Stable => serializer.serialize_i32(3),
                Self::Extended => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Channel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Channel>::new(
                ".google.container.v1.ReleaseChannel.Channel",
            ))
        }
    }
}

/// Configuration for fine-grained cost management feature.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CostManagementConfig {
    /// Whether the feature is enabled or not.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CostManagementConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::CostManagementConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for CostManagementConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.CostManagementConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CostManagementConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CostManagementConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CostManagementConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CostManagementConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CostManagementConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CostManagementConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CostManagementConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// IntraNodeVisibilityConfig contains the desired config of the intra-node
/// visibility on this cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IntraNodeVisibilityConfig {
    /// Enables intra node visibility for this cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IntraNodeVisibilityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::IntraNodeVisibilityConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for IntraNodeVisibilityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.IntraNodeVisibilityConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IntraNodeVisibilityConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntraNodeVisibilityConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IntraNodeVisibilityConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntraNodeVisibilityConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IntraNodeVisibilityConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IntraNodeVisibilityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntraNodeVisibilityConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ILBSubsettingConfig contains the desired config of L4 Internal LoadBalancer
/// subsetting on this cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ILBSubsettingConfig {
    /// Enables l4 ILB subsetting for this cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ILBSubsettingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ILBSubsettingConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ILBSubsettingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ILBSubsettingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ILBSubsettingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ILBSubsettingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ILBSubsettingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ILBSubsettingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ILBSubsettingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ILBSubsettingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ILBSubsettingConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DNSConfig contains the desired set of options for configuring clusterDNS.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DNSConfig {
    /// cluster_dns indicates which in-cluster DNS provider should be used.
    pub cluster_dns: crate::model::dns_config::Provider,

    /// cluster_dns_scope indicates the scope of access to cluster DNS records.
    pub cluster_dns_scope: crate::model::dns_config::DNSScope,

    /// cluster_dns_domain is the suffix used for all cluster service records.
    pub cluster_dns_domain: std::string::String,

    /// Optional. The domain used in Additive VPC scope.
    pub additive_vpc_scope_dns_domain: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DNSConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_dns][crate::model::DNSConfig::cluster_dns].
    pub fn set_cluster_dns<T: std::convert::Into<crate::model::dns_config::Provider>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_dns = v.into();
        self
    }

    /// Sets the value of [cluster_dns_scope][crate::model::DNSConfig::cluster_dns_scope].
    pub fn set_cluster_dns_scope<T: std::convert::Into<crate::model::dns_config::DNSScope>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_dns_scope = v.into();
        self
    }

    /// Sets the value of [cluster_dns_domain][crate::model::DNSConfig::cluster_dns_domain].
    pub fn set_cluster_dns_domain<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_dns_domain = v.into();
        self
    }

    /// Sets the value of [additive_vpc_scope_dns_domain][crate::model::DNSConfig::additive_vpc_scope_dns_domain].
    pub fn set_additive_vpc_scope_dns_domain<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.additive_vpc_scope_dns_domain = v.into();
        self
    }
}

impl wkt::message::Message for DNSConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DNSConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DNSConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_dns,
            __cluster_dns_scope,
            __cluster_dns_domain,
            __additive_vpc_scope_dns_domain,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DNSConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterDns" => Ok(__FieldTag::__cluster_dns),
                            "cluster_dns" => Ok(__FieldTag::__cluster_dns),
                            "clusterDnsScope" => Ok(__FieldTag::__cluster_dns_scope),
                            "cluster_dns_scope" => Ok(__FieldTag::__cluster_dns_scope),
                            "clusterDnsDomain" => Ok(__FieldTag::__cluster_dns_domain),
                            "cluster_dns_domain" => Ok(__FieldTag::__cluster_dns_domain),
                            "additiveVpcScopeDnsDomain" => {
                                Ok(__FieldTag::__additive_vpc_scope_dns_domain)
                            }
                            "additive_vpc_scope_dns_domain" => {
                                Ok(__FieldTag::__additive_vpc_scope_dns_domain)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DNSConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DNSConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_dns => {
                            if !fields.insert(__FieldTag::__cluster_dns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_dns",
                                ));
                            }
                            result.cluster_dns = map.next_value::<std::option::Option<crate::model::dns_config::Provider>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cluster_dns_scope => {
                            if !fields.insert(__FieldTag::__cluster_dns_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_dns_scope",
                                ));
                            }
                            result.cluster_dns_scope = map.next_value::<std::option::Option<crate::model::dns_config::DNSScope>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cluster_dns_domain => {
                            if !fields.insert(__FieldTag::__cluster_dns_domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_dns_domain",
                                ));
                            }
                            result.cluster_dns_domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additive_vpc_scope_dns_domain => {
                            if !fields.insert(__FieldTag::__additive_vpc_scope_dns_domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additive_vpc_scope_dns_domain",
                                ));
                            }
                            result.additive_vpc_scope_dns_domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DNSConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cluster_dns) {
            state.serialize_entry("clusterDns", &self.cluster_dns)?;
        }
        if !wkt::internal::is_default(&self.cluster_dns_scope) {
            state.serialize_entry("clusterDnsScope", &self.cluster_dns_scope)?;
        }
        if !self.cluster_dns_domain.is_empty() {
            state.serialize_entry("clusterDnsDomain", &self.cluster_dns_domain)?;
        }
        if !self.additive_vpc_scope_dns_domain.is_empty() {
            state.serialize_entry(
                "additiveVpcScopeDnsDomain",
                &self.additive_vpc_scope_dns_domain,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DNSConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DNSConfig");
        debug_struct.field("cluster_dns", &self.cluster_dns);
        debug_struct.field("cluster_dns_scope", &self.cluster_dns_scope);
        debug_struct.field("cluster_dns_domain", &self.cluster_dns_domain);
        debug_struct.field(
            "additive_vpc_scope_dns_domain",
            &self.additive_vpc_scope_dns_domain,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DNSConfig].
pub mod dns_config {
    #[allow(unused_imports)]
    use super::*;

    /// Provider lists the various in-cluster DNS providers.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Provider {
        /// Default value
        Unspecified,
        /// Use GKE default DNS provider(kube-dns) for DNS resolution.
        PlatformDefault,
        /// Use CloudDNS for DNS resolution.
        CloudDns,
        /// Use KubeDNS for DNS resolution.
        KubeDns,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Provider::value] or
        /// [Provider::name].
        UnknownValue(provider::UnknownValue),
    }

    #[doc(hidden)]
    pub mod provider {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Provider {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PlatformDefault => std::option::Option::Some(1),
                Self::CloudDns => std::option::Option::Some(2),
                Self::KubeDns => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PROVIDER_UNSPECIFIED"),
                Self::PlatformDefault => std::option::Option::Some("PLATFORM_DEFAULT"),
                Self::CloudDns => std::option::Option::Some("CLOUD_DNS"),
                Self::KubeDns => std::option::Option::Some("KUBE_DNS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Provider {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Provider {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Provider {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PlatformDefault,
                2 => Self::CloudDns,
                3 => Self::KubeDns,
                _ => Self::UnknownValue(provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Provider {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PROVIDER_UNSPECIFIED" => Self::Unspecified,
                "PLATFORM_DEFAULT" => Self::PlatformDefault,
                "CLOUD_DNS" => Self::CloudDns,
                "KUBE_DNS" => Self::KubeDns,
                _ => Self::UnknownValue(provider::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Provider {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PlatformDefault => serializer.serialize_i32(1),
                Self::CloudDns => serializer.serialize_i32(2),
                Self::KubeDns => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Provider {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Provider>::new(
                ".google.container.v1.DNSConfig.Provider",
            ))
        }
    }

    /// DNSScope lists the various scopes of access to cluster DNS records.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DNSScope {
        /// Default value, will be inferred as cluster scope.
        Unspecified,
        /// DNS records are accessible from within the cluster.
        ClusterScope,
        /// DNS records are accessible from within the VPC.
        VpcScope,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DNSScope::value] or
        /// [DNSScope::name].
        UnknownValue(dns_scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod dns_scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl DNSScope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ClusterScope => std::option::Option::Some(1),
                Self::VpcScope => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DNS_SCOPE_UNSPECIFIED"),
                Self::ClusterScope => std::option::Option::Some("CLUSTER_SCOPE"),
                Self::VpcScope => std::option::Option::Some("VPC_SCOPE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for DNSScope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for DNSScope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for DNSScope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ClusterScope,
                2 => Self::VpcScope,
                _ => Self::UnknownValue(dns_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for DNSScope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DNS_SCOPE_UNSPECIFIED" => Self::Unspecified,
                "CLUSTER_SCOPE" => Self::ClusterScope,
                "VPC_SCOPE" => Self::VpcScope,
                _ => Self::UnknownValue(dns_scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for DNSScope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ClusterScope => serializer.serialize_i32(1),
                Self::VpcScope => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for DNSScope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DNSScope>::new(
                ".google.container.v1.DNSConfig.DNSScope",
            ))
        }
    }
}

/// Constraints applied to pods.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaxPodsConstraint {
    /// Constraint enforced on the max num of pods per node.
    pub max_pods_per_node: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaxPodsConstraint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_pods_per_node][crate::model::MaxPodsConstraint::max_pods_per_node].
    pub fn set_max_pods_per_node<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.max_pods_per_node = v.into();
        self
    }
}

impl wkt::message::Message for MaxPodsConstraint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MaxPodsConstraint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaxPodsConstraint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_pods_per_node,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaxPodsConstraint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxPodsPerNode" => Ok(__FieldTag::__max_pods_per_node),
                            "max_pods_per_node" => Ok(__FieldTag::__max_pods_per_node),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaxPodsConstraint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaxPodsConstraint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_pods_per_node => {
                            if !fields.insert(__FieldTag::__max_pods_per_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_pods_per_node",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_pods_per_node =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaxPodsConstraint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_pods_per_node) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxPodsPerNode", &__With(&self.max_pods_per_node))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaxPodsConstraint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaxPodsConstraint");
        debug_struct.field("max_pods_per_node", &self.max_pods_per_node);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for the use of Kubernetes Service Accounts in GCP IAM
/// policies.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkloadIdentityConfig {
    /// The workload pool to attach all Kubernetes service accounts to.
    pub workload_pool: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadIdentityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workload_pool][crate::model::WorkloadIdentityConfig::workload_pool].
    pub fn set_workload_pool<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workload_pool = v.into();
        self
    }
}

impl wkt::message::Message for WorkloadIdentityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.WorkloadIdentityConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkloadIdentityConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workload_pool,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkloadIdentityConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workloadPool" => Ok(__FieldTag::__workload_pool),
                            "workload_pool" => Ok(__FieldTag::__workload_pool),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkloadIdentityConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkloadIdentityConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workload_pool => {
                            if !fields.insert(__FieldTag::__workload_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_pool",
                                ));
                            }
                            result.workload_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkloadIdentityConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workload_pool.is_empty() {
            state.serialize_entry("workloadPool", &self.workload_pool)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WorkloadIdentityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkloadIdentityConfig");
        debug_struct.field("workload_pool", &self.workload_pool);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// IdentityServiceConfig is configuration for Identity Service which allows
/// customers to use external identity providers with the K8S API
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct IdentityServiceConfig {
    /// Whether to enable the Identity Service component
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl IdentityServiceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::IdentityServiceConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for IdentityServiceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.IdentityServiceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for IdentityServiceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IdentityServiceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = IdentityServiceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IdentityServiceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for IdentityServiceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for IdentityServiceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IdentityServiceConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for issuance of mTLS keys and certificates to Kubernetes pods.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MeshCertificates {
    /// enable_certificates controls issuance of workload mTLS certificates.
    ///
    /// If set, the GKE Workload Identity Certificates controller and node agent
    /// will be deployed in the cluster, which can then be configured by creating a
    /// WorkloadCertificateConfig Custom Resource.
    ///
    /// Requires Workload Identity
    /// ([workload_pool][google.container.v1.WorkloadIdentityConfig.workload_pool]
    /// must be non-empty).
    ///
    /// [google.container.v1.WorkloadIdentityConfig.workload_pool]: crate::model::WorkloadIdentityConfig::workload_pool
    pub enable_certificates: std::option::Option<wkt::BoolValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MeshCertificates {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_certificates][crate::model::MeshCertificates::enable_certificates].
    pub fn set_enable_certificates<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_certificates = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_certificates][crate::model::MeshCertificates::enable_certificates].
    pub fn set_or_clear_enable_certificates<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::BoolValue>,
    {
        self.enable_certificates = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MeshCertificates {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MeshCertificates"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MeshCertificates {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_certificates,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MeshCertificates")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableCertificates" => Ok(__FieldTag::__enable_certificates),
                            "enable_certificates" => Ok(__FieldTag::__enable_certificates),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MeshCertificates;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MeshCertificates")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_certificates => {
                            if !fields.insert(__FieldTag::__enable_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_certificates",
                                ));
                            }
                            result.enable_certificates =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MeshCertificates {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable_certificates.is_some() {
            state.serialize_entry("enableCertificates", &self.enable_certificates)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MeshCertificates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MeshCertificates");
        debug_struct.field("enable_certificates", &self.enable_certificates);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration of etcd encryption.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatabaseEncryption {
    /// Name of CloudKMS key to use for the encryption of secrets in etcd.
    /// Ex. projects/my-project/locations/global/keyRings/my-ring/cryptoKeys/my-key
    pub key_name: std::string::String,

    /// The desired state of etcd encryption.
    pub state: crate::model::database_encryption::State,

    /// Output only. The current state of etcd encryption.
    pub current_state: std::option::Option<crate::model::database_encryption::CurrentState>,

    /// Output only. Keys in use by the cluster for decrypting
    /// existing objects, in addition to the key in `key_name`.
    ///
    /// Each item is a CloudKMS key resource.
    pub decryption_keys: std::vec::Vec<std::string::String>,

    /// Output only. Records errors seen during DatabaseEncryption update
    /// operations.
    pub last_operation_errors: std::vec::Vec<crate::model::database_encryption::OperationError>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatabaseEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_name][crate::model::DatabaseEncryption::key_name].
    pub fn set_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DatabaseEncryption::state].
    pub fn set_state<T: std::convert::Into<crate::model::database_encryption::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [current_state][crate::model::DatabaseEncryption::current_state].
    pub fn set_current_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::database_encryption::CurrentState>,
    {
        self.current_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_state][crate::model::DatabaseEncryption::current_state].
    pub fn set_or_clear_current_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::database_encryption::CurrentState>,
    {
        self.current_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [decryption_keys][crate::model::DatabaseEncryption::decryption_keys].
    pub fn set_decryption_keys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.decryption_keys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [last_operation_errors][crate::model::DatabaseEncryption::last_operation_errors].
    pub fn set_last_operation_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::database_encryption::OperationError>,
    {
        use std::iter::Iterator;
        self.last_operation_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DatabaseEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DatabaseEncryption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatabaseEncryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_name,
            __state,
            __current_state,
            __decryption_keys,
            __last_operation_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseEncryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyName" => Ok(__FieldTag::__key_name),
                            "key_name" => Ok(__FieldTag::__key_name),
                            "state" => Ok(__FieldTag::__state),
                            "currentState" => Ok(__FieldTag::__current_state),
                            "current_state" => Ok(__FieldTag::__current_state),
                            "decryptionKeys" => Ok(__FieldTag::__decryption_keys),
                            "decryption_keys" => Ok(__FieldTag::__decryption_keys),
                            "lastOperationErrors" => Ok(__FieldTag::__last_operation_errors),
                            "last_operation_errors" => Ok(__FieldTag::__last_operation_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatabaseEncryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseEncryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_name => {
                            if !fields.insert(__FieldTag::__key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_name",
                                ));
                            }
                            result.key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::database_encryption::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__current_state => {
                            if !fields.insert(__FieldTag::__current_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_state",
                                ));
                            }
                            result.current_state = map.next_value::<std::option::Option<
                                crate::model::database_encryption::CurrentState,
                            >>()?;
                        }
                        __FieldTag::__decryption_keys => {
                            if !fields.insert(__FieldTag::__decryption_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for decryption_keys",
                                ));
                            }
                            result.decryption_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__last_operation_errors => {
                            if !fields.insert(__FieldTag::__last_operation_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_operation_errors",
                                ));
                            }
                            result.last_operation_errors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::database_encryption::OperationError,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatabaseEncryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key_name.is_empty() {
            state.serialize_entry("keyName", &self.key_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.current_state.is_some() {
            state.serialize_entry("currentState", &self.current_state)?;
        }
        if !self.decryption_keys.is_empty() {
            state.serialize_entry("decryptionKeys", &self.decryption_keys)?;
        }
        if !self.last_operation_errors.is_empty() {
            state.serialize_entry("lastOperationErrors", &self.last_operation_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatabaseEncryption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseEncryption");
        debug_struct.field("key_name", &self.key_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("current_state", &self.current_state);
        debug_struct.field("decryption_keys", &self.decryption_keys);
        debug_struct.field("last_operation_errors", &self.last_operation_errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DatabaseEncryption].
pub mod database_encryption {
    #[allow(unused_imports)]
    use super::*;

    /// OperationError records errors seen from CloudKMS keys
    /// encountered during updates to DatabaseEncryption configuration.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OperationError {
        /// CloudKMS key resource that had the error.
        pub key_name: std::string::String,

        /// Description of the error seen during the operation.
        pub error_message: std::string::String,

        /// Time when the CloudKMS error was seen.
        pub timestamp: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OperationError {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key_name][crate::model::database_encryption::OperationError::key_name].
        pub fn set_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key_name = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::database_encryption::OperationError::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }

        /// Sets the value of [timestamp][crate::model::database_encryption::OperationError::timestamp].
        pub fn set_timestamp<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.timestamp = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [timestamp][crate::model::database_encryption::OperationError::timestamp].
        pub fn set_or_clear_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.timestamp = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for OperationError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.DatabaseEncryption.OperationError"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OperationError {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key_name,
                __error_message,
                __timestamp,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OperationError")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "keyName" => Ok(__FieldTag::__key_name),
                                "key_name" => Ok(__FieldTag::__key_name),
                                "errorMessage" => Ok(__FieldTag::__error_message),
                                "error_message" => Ok(__FieldTag::__error_message),
                                "timestamp" => Ok(__FieldTag::__timestamp),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OperationError;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OperationError")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key_name => {
                                if !fields.insert(__FieldTag::__key_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key_name",
                                    ));
                                }
                                result.key_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__error_message => {
                                if !fields.insert(__FieldTag::__error_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_message",
                                    ));
                                }
                                result.error_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__timestamp => {
                                if !fields.insert(__FieldTag::__timestamp) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for timestamp",
                                    ));
                                }
                                result.timestamp =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OperationError {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.key_name.is_empty() {
                state.serialize_entry("keyName", &self.key_name)?;
            }
            if !self.error_message.is_empty() {
                state.serialize_entry("errorMessage", &self.error_message)?;
            }
            if self.timestamp.is_some() {
                state.serialize_entry("timestamp", &self.timestamp)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for OperationError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("OperationError");
            debug_struct.field("key_name", &self.key_name);
            debug_struct.field("error_message", &self.error_message);
            debug_struct.field("timestamp", &self.timestamp);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// State of etcd encryption.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Should never be set
        Unknown,
        /// Secrets in etcd are encrypted.
        Encrypted,
        /// Secrets in etcd are stored in plain text (at etcd level) - this is
        /// unrelated to Compute Engine level full disk encryption.
        Decrypted,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Encrypted => std::option::Option::Some(1),
                Self::Decrypted => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Encrypted => std::option::Option::Some("ENCRYPTED"),
                Self::Decrypted => std::option::Option::Some("DECRYPTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Encrypted,
                2 => Self::Decrypted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "ENCRYPTED" => Self::Encrypted,
                "DECRYPTED" => Self::Decrypted,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Encrypted => serializer.serialize_i32(1),
                Self::Decrypted => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.container.v1.DatabaseEncryption.State",
            ))
        }
    }

    /// Current State of etcd encryption.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CurrentState {
        /// Should never be set
        Unspecified,
        /// Secrets in etcd are encrypted.
        Encrypted,
        /// Secrets in etcd are stored in plain text (at etcd level) - this is
        /// unrelated to Compute Engine level full disk encryption.
        Decrypted,
        /// Encryption (or re-encryption with a different CloudKMS key)
        /// of Secrets is in progress.
        EncryptionPending,
        /// Encryption (or re-encryption with a different CloudKMS key) of Secrets in
        /// etcd encountered an error.
        EncryptionError,
        /// De-crypting Secrets to plain text in etcd is in progress.
        DecryptionPending,
        /// De-crypting Secrets to plain text in etcd encountered an error.
        DecryptionError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CurrentState::value] or
        /// [CurrentState::name].
        UnknownValue(current_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod current_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CurrentState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Encrypted => std::option::Option::Some(7),
                Self::Decrypted => std::option::Option::Some(2),
                Self::EncryptionPending => std::option::Option::Some(3),
                Self::EncryptionError => std::option::Option::Some(4),
                Self::DecryptionPending => std::option::Option::Some(5),
                Self::DecryptionError => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CURRENT_STATE_UNSPECIFIED"),
                Self::Encrypted => std::option::Option::Some("CURRENT_STATE_ENCRYPTED"),
                Self::Decrypted => std::option::Option::Some("CURRENT_STATE_DECRYPTED"),
                Self::EncryptionPending => {
                    std::option::Option::Some("CURRENT_STATE_ENCRYPTION_PENDING")
                }
                Self::EncryptionError => {
                    std::option::Option::Some("CURRENT_STATE_ENCRYPTION_ERROR")
                }
                Self::DecryptionPending => {
                    std::option::Option::Some("CURRENT_STATE_DECRYPTION_PENDING")
                }
                Self::DecryptionError => {
                    std::option::Option::Some("CURRENT_STATE_DECRYPTION_ERROR")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CurrentState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CurrentState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CurrentState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::Decrypted,
                3 => Self::EncryptionPending,
                4 => Self::EncryptionError,
                5 => Self::DecryptionPending,
                6 => Self::DecryptionError,
                7 => Self::Encrypted,
                _ => Self::UnknownValue(current_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CurrentState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CURRENT_STATE_UNSPECIFIED" => Self::Unspecified,
                "CURRENT_STATE_ENCRYPTED" => Self::Encrypted,
                "CURRENT_STATE_DECRYPTED" => Self::Decrypted,
                "CURRENT_STATE_ENCRYPTION_PENDING" => Self::EncryptionPending,
                "CURRENT_STATE_ENCRYPTION_ERROR" => Self::EncryptionError,
                "CURRENT_STATE_DECRYPTION_PENDING" => Self::DecryptionPending,
                "CURRENT_STATE_DECRYPTION_ERROR" => Self::DecryptionError,
                _ => Self::UnknownValue(current_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CurrentState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Encrypted => serializer.serialize_i32(7),
                Self::Decrypted => serializer.serialize_i32(2),
                Self::EncryptionPending => serializer.serialize_i32(3),
                Self::EncryptionError => serializer.serialize_i32(4),
                Self::DecryptionPending => serializer.serialize_i32(5),
                Self::DecryptionError => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CurrentState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CurrentState>::new(
                ".google.container.v1.DatabaseEncryption.CurrentState",
            ))
        }
    }
}

/// ListUsableSubnetworksRequest requests the list of usable subnetworks
/// available to a user for creating clusters.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsableSubnetworksRequest {
    /// The parent project where subnetworks are usable.
    /// Specified in the format `projects/*`.
    pub parent: std::string::String,

    /// Filtering currently only supports equality on the networkProjectId and must
    /// be in the form: "networkProjectId=[PROJECTID]", where `networkProjectId`
    /// is the project which owns the listed subnetworks. This defaults to the
    /// parent project ID.
    pub filter: std::string::String,

    /// The max number of results per page that should be returned. If the number
    /// of available results is larger than `page_size`, a `next_page_token` is
    /// returned which can be used to get the next page of results in subsequent
    /// requests. Acceptable values are 0 to 500, inclusive. (Default: 500)
    pub page_size: i32,

    /// Specifies a page token to use. Set this to the nextPageToken returned by
    /// previous list requests to get the next page of results.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsableSubnetworksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUsableSubnetworksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListUsableSubnetworksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUsableSubnetworksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsableSubnetworksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUsableSubnetworksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListUsableSubnetworksRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsableSubnetworksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsableSubnetworksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsableSubnetworksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsableSubnetworksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsableSubnetworksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListUsableSubnetworksRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUsableSubnetworksRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ListUsableSubnetworksResponse is the response of
/// ListUsableSubnetworksRequest.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsableSubnetworksResponse {
    /// A list of usable subnetworks in the specified network project.
    pub subnetworks: std::vec::Vec<crate::model::UsableSubnetwork>,

    /// This token allows you to get the next page of results for list requests.
    /// If the number of results is larger than `page_size`, use the
    /// `next_page_token` as a value for the query parameter `page_token` in the
    /// next request. The value will become empty when there are no more pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsableSubnetworksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnetworks][crate::model::ListUsableSubnetworksResponse::subnetworks].
    pub fn set_subnetworks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UsableSubnetwork>,
    {
        use std::iter::Iterator;
        self.subnetworks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUsableSubnetworksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUsableSubnetworksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ListUsableSubnetworksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUsableSubnetworksResponse {
    type PageItem = crate::model::UsableSubnetwork;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.subnetworks
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsableSubnetworksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subnetworks,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsableSubnetworksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subnetworks" => Ok(__FieldTag::__subnetworks),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsableSubnetworksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsableSubnetworksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subnetworks => {
                            if !fields.insert(__FieldTag::__subnetworks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetworks",
                                ));
                            }
                            result.subnetworks =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UsableSubnetwork>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsableSubnetworksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subnetworks.is_empty() {
            state.serialize_entry("subnetworks", &self.subnetworks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListUsableSubnetworksResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUsableSubnetworksResponse");
        debug_struct.field("subnetworks", &self.subnetworks);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Secondary IP range of a usable subnetwork.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UsableSubnetworkSecondaryRange {
    /// The name associated with this subnetwork secondary range, used when adding
    /// an alias IP range to a VM instance.
    pub range_name: std::string::String,

    /// The range of IP addresses belonging to this subnetwork secondary range.
    pub ip_cidr_range: std::string::String,

    /// This field is to determine the status of the secondary range programmably.
    pub status: crate::model::usable_subnetwork_secondary_range::Status,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsableSubnetworkSecondaryRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [range_name][crate::model::UsableSubnetworkSecondaryRange::range_name].
    pub fn set_range_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.range_name = v.into();
        self
    }

    /// Sets the value of [ip_cidr_range][crate::model::UsableSubnetworkSecondaryRange::ip_cidr_range].
    pub fn set_ip_cidr_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_cidr_range = v.into();
        self
    }

    /// Sets the value of [status][crate::model::UsableSubnetworkSecondaryRange::status].
    pub fn set_status<
        T: std::convert::Into<crate::model::usable_subnetwork_secondary_range::Status>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for UsableSubnetworkSecondaryRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UsableSubnetworkSecondaryRange"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UsableSubnetworkSecondaryRange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __range_name,
            __ip_cidr_range,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UsableSubnetworkSecondaryRange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rangeName" => Ok(__FieldTag::__range_name),
                            "range_name" => Ok(__FieldTag::__range_name),
                            "ipCidrRange" => Ok(__FieldTag::__ip_cidr_range),
                            "ip_cidr_range" => Ok(__FieldTag::__ip_cidr_range),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UsableSubnetworkSecondaryRange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UsableSubnetworkSecondaryRange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__range_name => {
                            if !fields.insert(__FieldTag::__range_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_name",
                                ));
                            }
                            result.range_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_cidr_range => {
                            if !fields.insert(__FieldTag::__ip_cidr_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_cidr_range",
                                ));
                            }
                            result.ip_cidr_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<
                                    crate::model::usable_subnetwork_secondary_range::Status,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UsableSubnetworkSecondaryRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.range_name.is_empty() {
            state.serialize_entry("rangeName", &self.range_name)?;
        }
        if !self.ip_cidr_range.is_empty() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UsableSubnetworkSecondaryRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UsableSubnetworkSecondaryRange");
        debug_struct.field("range_name", &self.range_name);
        debug_struct.field("ip_cidr_range", &self.ip_cidr_range);
        debug_struct.field("status", &self.status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [UsableSubnetworkSecondaryRange].
pub mod usable_subnetwork_secondary_range {
    #[allow(unused_imports)]
    use super::*;

    /// Status shows the current usage of a secondary IP range.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// UNKNOWN is the zero value of the Status enum. It's not a valid status.
        Unknown,
        /// UNUSED denotes that this range is unclaimed by any cluster.
        Unused,
        /// IN_USE_SERVICE denotes that this range is claimed by cluster(s) for
        /// services. User-managed services range can be shared between clusters
        /// within the same subnetwork.
        InUseService,
        /// IN_USE_SHAREABLE_POD denotes this range was created by the network admin
        /// and is currently claimed by a cluster for pods. It can only be used by
        /// other clusters as a pod range.
        InUseShareablePod,
        /// IN_USE_MANAGED_POD denotes this range was created by GKE and is claimed
        /// for pods. It cannot be used for other clusters.
        InUseManagedPod,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Unused => std::option::Option::Some(1),
                Self::InUseService => std::option::Option::Some(2),
                Self::InUseShareablePod => std::option::Option::Some(3),
                Self::InUseManagedPod => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Unused => std::option::Option::Some("UNUSED"),
                Self::InUseService => std::option::Option::Some("IN_USE_SERVICE"),
                Self::InUseShareablePod => std::option::Option::Some("IN_USE_SHAREABLE_POD"),
                Self::InUseManagedPod => std::option::Option::Some("IN_USE_MANAGED_POD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Unused,
                2 => Self::InUseService,
                3 => Self::InUseShareablePod,
                4 => Self::InUseManagedPod,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "UNUSED" => Self::Unused,
                "IN_USE_SERVICE" => Self::InUseService,
                "IN_USE_SHAREABLE_POD" => Self::InUseShareablePod,
                "IN_USE_MANAGED_POD" => Self::InUseManagedPod,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Unused => serializer.serialize_i32(1),
                Self::InUseService => serializer.serialize_i32(2),
                Self::InUseShareablePod => serializer.serialize_i32(3),
                Self::InUseManagedPod => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.container.v1.UsableSubnetworkSecondaryRange.Status",
            ))
        }
    }
}

/// UsableSubnetwork resource returns the subnetwork name, its associated network
/// and the primary CIDR range.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UsableSubnetwork {
    /// Subnetwork Name.
    /// Example: projects/my-project/regions/us-central1/subnetworks/my-subnet
    pub subnetwork: std::string::String,

    /// Network Name.
    /// Example: projects/my-project/global/networks/my-network
    pub network: std::string::String,

    /// The range of internal addresses that are owned by this subnetwork.
    pub ip_cidr_range: std::string::String,

    /// Secondary IP ranges.
    pub secondary_ip_ranges: std::vec::Vec<crate::model::UsableSubnetworkSecondaryRange>,

    /// A human readable status message representing the reasons for cases where
    /// the caller cannot use the secondary ranges under the subnet. For example if
    /// the secondary_ip_ranges is empty due to a permission issue, an insufficient
    /// permission message will be given by status_message.
    pub status_message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UsableSubnetwork {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subnetwork][crate::model::UsableSubnetwork::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [network][crate::model::UsableSubnetwork::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [ip_cidr_range][crate::model::UsableSubnetwork::ip_cidr_range].
    pub fn set_ip_cidr_range<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.ip_cidr_range = v.into();
        self
    }

    /// Sets the value of [secondary_ip_ranges][crate::model::UsableSubnetwork::secondary_ip_ranges].
    pub fn set_secondary_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UsableSubnetworkSecondaryRange>,
    {
        use std::iter::Iterator;
        self.secondary_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [status_message][crate::model::UsableSubnetwork::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }
}

impl wkt::message::Message for UsableSubnetwork {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UsableSubnetwork"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UsableSubnetwork {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subnetwork,
            __network,
            __ip_cidr_range,
            __secondary_ip_ranges,
            __status_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UsableSubnetwork")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "network" => Ok(__FieldTag::__network),
                            "ipCidrRange" => Ok(__FieldTag::__ip_cidr_range),
                            "ip_cidr_range" => Ok(__FieldTag::__ip_cidr_range),
                            "secondaryIpRanges" => Ok(__FieldTag::__secondary_ip_ranges),
                            "secondary_ip_ranges" => Ok(__FieldTag::__secondary_ip_ranges),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UsableSubnetwork;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UsableSubnetwork")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_cidr_range => {
                            if !fields.insert(__FieldTag::__ip_cidr_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_cidr_range",
                                ));
                            }
                            result.ip_cidr_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_ip_ranges => {
                            if !fields.insert(__FieldTag::__secondary_ip_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_ip_ranges",
                                ));
                            }
                            result.secondary_ip_ranges = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UsableSubnetworkSecondaryRange>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UsableSubnetwork {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.ip_cidr_range.is_empty() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if !self.secondary_ip_ranges.is_empty() {
            state.serialize_entry("secondaryIpRanges", &self.secondary_ip_ranges)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UsableSubnetwork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UsableSubnetwork");
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("network", &self.network);
        debug_struct.field("ip_cidr_range", &self.ip_cidr_range);
        debug_struct.field("secondary_ip_ranges", &self.secondary_ip_ranges);
        debug_struct.field("status_message", &self.status_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for exporting cluster resource usages.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceUsageExportConfig {
    /// Configuration to use BigQuery as usage export destination.
    pub bigquery_destination:
        std::option::Option<crate::model::resource_usage_export_config::BigQueryDestination>,

    /// Whether to enable network egress metering for this cluster. If enabled, a
    /// daemonset will be created in the cluster to meter network egress traffic.
    pub enable_network_egress_metering: bool,

    /// Configuration to enable resource consumption metering.
    pub consumption_metering_config:
        std::option::Option<crate::model::resource_usage_export_config::ConsumptionMeteringConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceUsageExportConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bigquery_destination][crate::model::ResourceUsageExportConfig::bigquery_destination].
    pub fn set_bigquery_destination<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::resource_usage_export_config::BigQueryDestination>,
    {
        self.bigquery_destination = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [bigquery_destination][crate::model::ResourceUsageExportConfig::bigquery_destination].
    pub fn set_or_clear_bigquery_destination<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::resource_usage_export_config::BigQueryDestination>,
    {
        self.bigquery_destination = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_network_egress_metering][crate::model::ResourceUsageExportConfig::enable_network_egress_metering].
    pub fn set_enable_network_egress_metering<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_network_egress_metering = v.into();
        self
    }

    /// Sets the value of [consumption_metering_config][crate::model::ResourceUsageExportConfig::consumption_metering_config].
    pub fn set_consumption_metering_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::resource_usage_export_config::ConsumptionMeteringConfig,
            >,
    {
        self.consumption_metering_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [consumption_metering_config][crate::model::ResourceUsageExportConfig::consumption_metering_config].
    pub fn set_or_clear_consumption_metering_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::resource_usage_export_config::ConsumptionMeteringConfig,
            >,
    {
        self.consumption_metering_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ResourceUsageExportConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ResourceUsageExportConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceUsageExportConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bigquery_destination,
            __enable_network_egress_metering,
            __consumption_metering_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceUsageExportConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigqueryDestination" => Ok(__FieldTag::__bigquery_destination),
                            "bigquery_destination" => Ok(__FieldTag::__bigquery_destination),
                            "enableNetworkEgressMetering" => {
                                Ok(__FieldTag::__enable_network_egress_metering)
                            }
                            "enable_network_egress_metering" => {
                                Ok(__FieldTag::__enable_network_egress_metering)
                            }
                            "consumptionMeteringConfig" => {
                                Ok(__FieldTag::__consumption_metering_config)
                            }
                            "consumption_metering_config" => {
                                Ok(__FieldTag::__consumption_metering_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceUsageExportConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceUsageExportConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bigquery_destination => {
                            if !fields.insert(__FieldTag::__bigquery_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_destination",
                                ));
                            }
                            result.bigquery_destination = map.next_value::<std::option::Option<
                                crate::model::resource_usage_export_config::BigQueryDestination,
                            >>()?;
                        }
                        __FieldTag::__enable_network_egress_metering => {
                            if !fields.insert(__FieldTag::__enable_network_egress_metering) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_network_egress_metering",
                                ));
                            }
                            result.enable_network_egress_metering = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__consumption_metering_config => {
                            if !fields.insert(__FieldTag::__consumption_metering_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consumption_metering_config",
                                ));
                            }
                            result.consumption_metering_config = map.next_value::<std::option::Option<crate::model::resource_usage_export_config::ConsumptionMeteringConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceUsageExportConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bigquery_destination.is_some() {
            state.serialize_entry("bigqueryDestination", &self.bigquery_destination)?;
        }
        if !wkt::internal::is_default(&self.enable_network_egress_metering) {
            state.serialize_entry(
                "enableNetworkEgressMetering",
                &self.enable_network_egress_metering,
            )?;
        }
        if self.consumption_metering_config.is_some() {
            state.serialize_entry(
                "consumptionMeteringConfig",
                &self.consumption_metering_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResourceUsageExportConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceUsageExportConfig");
        debug_struct.field("bigquery_destination", &self.bigquery_destination);
        debug_struct.field(
            "enable_network_egress_metering",
            &self.enable_network_egress_metering,
        );
        debug_struct.field(
            "consumption_metering_config",
            &self.consumption_metering_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ResourceUsageExportConfig].
pub mod resource_usage_export_config {
    #[allow(unused_imports)]
    use super::*;

    /// Parameters for using BigQuery as the destination of resource usage export.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BigQueryDestination {
        /// The ID of a BigQuery Dataset.
        pub dataset_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryDestination {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dataset_id][crate::model::resource_usage_export_config::BigQueryDestination::dataset_id].
        pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.dataset_id = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryDestination {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ResourceUsageExportConfig.BigQueryDestination"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BigQueryDestination {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dataset_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BigQueryDestination")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "datasetId" => Ok(__FieldTag::__dataset_id),
                                "dataset_id" => Ok(__FieldTag::__dataset_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BigQueryDestination;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BigQueryDestination")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dataset_id => {
                                if !fields.insert(__FieldTag::__dataset_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dataset_id",
                                    ));
                                }
                                result.dataset_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BigQueryDestination {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dataset_id.is_empty() {
                state.serialize_entry("datasetId", &self.dataset_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for BigQueryDestination {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("BigQueryDestination");
            debug_struct.field("dataset_id", &self.dataset_id);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Parameters for controlling consumption metering.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConsumptionMeteringConfig {
        /// Whether to enable consumption metering for this cluster. If enabled, a
        /// second BigQuery table will be created to hold resource consumption
        /// records.
        pub enabled: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConsumptionMeteringConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::resource_usage_export_config::ConsumptionMeteringConfig::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }
    }

    impl wkt::message::Message for ConsumptionMeteringConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ResourceUsageExportConfig.ConsumptionMeteringConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConsumptionMeteringConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConsumptionMeteringConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConsumptionMeteringConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConsumptionMeteringConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConsumptionMeteringConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ConsumptionMeteringConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ConsumptionMeteringConfig");
            debug_struct.field("enabled", &self.enabled);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// VerticalPodAutoscaling contains global, per-cluster information
/// required by Vertical Pod Autoscaler to automatically adjust
/// the resources of pods controlled by it.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VerticalPodAutoscaling {
    /// Enables vertical pod autoscaling.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerticalPodAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::VerticalPodAutoscaling::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for VerticalPodAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.VerticalPodAutoscaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerticalPodAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerticalPodAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerticalPodAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerticalPodAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerticalPodAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VerticalPodAutoscaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VerticalPodAutoscaling");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// DefaultSnatStatus contains the desired state of whether default sNAT should
/// be disabled on the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DefaultSnatStatus {
    /// Disables cluster default sNAT rules.
    pub disabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DefaultSnatStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disabled][crate::model::DefaultSnatStatus::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for DefaultSnatStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.DefaultSnatStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DefaultSnatStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DefaultSnatStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DefaultSnatStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DefaultSnatStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DefaultSnatStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DefaultSnatStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DefaultSnatStatus");
        debug_struct.field("disabled", &self.disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration of Shielded Nodes feature.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedNodes {
    /// Whether Shielded Nodes features are enabled on all nodes in this cluster.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShieldedNodes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ShieldedNodes::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for ShieldedNodes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ShieldedNodes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ShieldedNodes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShieldedNodes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ShieldedNodes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShieldedNodes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ShieldedNodes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ShieldedNodes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShieldedNodes");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration of gVNIC feature.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VirtualNIC {
    /// Whether gVNIC features are enabled in the node pool.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VirtualNIC {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::VirtualNIC::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for VirtualNIC {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.VirtualNIC"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VirtualNIC {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VirtualNIC")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VirtualNIC;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VirtualNIC")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VirtualNIC {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VirtualNIC {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VirtualNIC");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration of Fast Socket feature.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FastSocket {
    /// Whether Fast Socket features are enabled in the node pool.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FastSocket {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::FastSocket::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for FastSocket {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.FastSocket"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FastSocket {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FastSocket")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FastSocket;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FastSocket")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FastSocket {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FastSocket {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FastSocket");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// NotificationConfig is the configuration of notifications.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NotificationConfig {
    /// Notification config for Pub/Sub.
    pub pubsub: std::option::Option<crate::model::notification_config::PubSub>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NotificationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [pubsub][crate::model::NotificationConfig::pubsub].
    pub fn set_pubsub<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::notification_config::PubSub>,
    {
        self.pubsub = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pubsub][crate::model::NotificationConfig::pubsub].
    pub fn set_or_clear_pubsub<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::notification_config::PubSub>,
    {
        self.pubsub = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NotificationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NotificationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NotificationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pubsub,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NotificationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pubsub" => Ok(__FieldTag::__pubsub),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NotificationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NotificationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pubsub => {
                            if !fields.insert(__FieldTag::__pubsub) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub",
                                ));
                            }
                            result.pubsub = map.next_value::<std::option::Option<crate::model::notification_config::PubSub>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NotificationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.pubsub.is_some() {
            state.serialize_entry("pubsub", &self.pubsub)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NotificationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NotificationConfig");
        debug_struct.field("pubsub", &self.pubsub);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NotificationConfig].
pub mod notification_config {
    #[allow(unused_imports)]
    use super::*;

    /// Pub/Sub specific notification config.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PubSub {
        /// Enable notifications for Pub/Sub.
        pub enabled: bool,

        /// The desired Pub/Sub topic to which notifications will be
        /// sent by GKE. Format is `projects/{project}/topics/{topic}`.
        pub topic: std::string::String,

        /// Allows filtering to one or more specific event types. If no filter is
        /// specified, or if a filter is specified with no event types, all event
        /// types will be sent
        pub filter: std::option::Option<crate::model::notification_config::Filter>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PubSub {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::notification_config::PubSub::enabled].
        pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enabled = v.into();
            self
        }

        /// Sets the value of [topic][crate::model::notification_config::PubSub::topic].
        pub fn set_topic<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.topic = v.into();
            self
        }

        /// Sets the value of [filter][crate::model::notification_config::PubSub::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::notification_config::Filter>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::notification_config::PubSub::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::notification_config::Filter>,
        {
            self.filter = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for PubSub {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NotificationConfig.PubSub"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PubSub {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                __topic,
                __filter,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PubSub")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                "topic" => Ok(__FieldTag::__topic),
                                "filter" => Ok(__FieldTag::__filter),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PubSub;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PubSub")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__topic => {
                                if !fields.insert(__FieldTag::__topic) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for topic",
                                    ));
                                }
                                result.topic = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__filter => {
                                if !fields.insert(__FieldTag::__filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for filter",
                                    ));
                                }
                                result.filter = map.next_value::<std::option::Option<
                                    crate::model::notification_config::Filter,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PubSub {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enabled) {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if !self.topic.is_empty() {
                state.serialize_entry("topic", &self.topic)?;
            }
            if self.filter.is_some() {
                state.serialize_entry("filter", &self.filter)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for PubSub {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("PubSub");
            debug_struct.field("enabled", &self.enabled);
            debug_struct.field("topic", &self.topic);
            debug_struct.field("filter", &self.filter);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Allows filtering to one or more specific event types. If event types are
    /// present, those and only those event types will be transmitted to the
    /// cluster. Other types will be skipped. If no filter is specified, or no
    /// event types are present, all event types will be sent
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Filter {
        /// Event types to allowlist.
        pub event_type: std::vec::Vec<crate::model::notification_config::EventType>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Filter {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [event_type][crate::model::notification_config::Filter::event_type].
        pub fn set_event_type<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::notification_config::EventType>,
        {
            use std::iter::Iterator;
            self.event_type = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Filter {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.NotificationConfig.Filter"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Filter {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __event_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Filter")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "eventType" => Ok(__FieldTag::__event_type),
                                "event_type" => Ok(__FieldTag::__event_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Filter;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Filter")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__event_type => {
                                if !fields.insert(__FieldTag::__event_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for event_type",
                                    ));
                                }
                                result.event_type = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::notification_config::EventType>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Filter {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.event_type.is_empty() {
                state.serialize_entry("eventType", &self.event_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Filter {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Filter");
            debug_struct.field("event_type", &self.event_type);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Types of notifications currently supported. Can be used to filter what
    /// notifications are sent.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// Not set, will be ignored.
        Unspecified,
        /// Corresponds with UpgradeAvailableEvent.
        UpgradeAvailableEvent,
        /// Corresponds with UpgradeEvent.
        UpgradeEvent,
        /// Corresponds with SecurityBulletinEvent.
        SecurityBulletinEvent,
        /// Corresponds with UpgradeInfoEvent.
        UpgradeInfoEvent,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UpgradeAvailableEvent => std::option::Option::Some(1),
                Self::UpgradeEvent => std::option::Option::Some(2),
                Self::SecurityBulletinEvent => std::option::Option::Some(3),
                Self::UpgradeInfoEvent => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::UpgradeAvailableEvent => std::option::Option::Some("UPGRADE_AVAILABLE_EVENT"),
                Self::UpgradeEvent => std::option::Option::Some("UPGRADE_EVENT"),
                Self::SecurityBulletinEvent => std::option::Option::Some("SECURITY_BULLETIN_EVENT"),
                Self::UpgradeInfoEvent => std::option::Option::Some("UPGRADE_INFO_EVENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UpgradeAvailableEvent,
                2 => Self::UpgradeEvent,
                3 => Self::SecurityBulletinEvent,
                4 => Self::UpgradeInfoEvent,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "UPGRADE_AVAILABLE_EVENT" => Self::UpgradeAvailableEvent,
                "UPGRADE_EVENT" => Self::UpgradeEvent,
                "SECURITY_BULLETIN_EVENT" => Self::SecurityBulletinEvent,
                "UPGRADE_INFO_EVENT" => Self::UpgradeInfoEvent,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UpgradeAvailableEvent => serializer.serialize_i32(1),
                Self::UpgradeEvent => serializer.serialize_i32(2),
                Self::SecurityBulletinEvent => serializer.serialize_i32(3),
                Self::UpgradeInfoEvent => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.container.v1.NotificationConfig.EventType",
            ))
        }
    }
}

/// ConfidentialNodes is configuration for the confidential nodes feature, which
/// makes nodes run on confidential VMs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfidentialNodes {
    /// Whether Confidential Nodes feature is enabled.
    pub enabled: bool,

    /// Defines the type of technology used by the confidential node.
    pub confidential_instance_type: crate::model::confidential_nodes::ConfidentialInstanceType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfidentialNodes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ConfidentialNodes::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [confidential_instance_type][crate::model::ConfidentialNodes::confidential_instance_type].
    pub fn set_confidential_instance_type<
        T: std::convert::Into<crate::model::confidential_nodes::ConfidentialInstanceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.confidential_instance_type = v.into();
        self
    }
}

impl wkt::message::Message for ConfidentialNodes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ConfidentialNodes"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfidentialNodes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __confidential_instance_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfidentialNodes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "confidentialInstanceType" => {
                                Ok(__FieldTag::__confidential_instance_type)
                            }
                            "confidential_instance_type" => {
                                Ok(__FieldTag::__confidential_instance_type)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfidentialNodes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfidentialNodes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidential_instance_type => {
                            if !fields.insert(__FieldTag::__confidential_instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidential_instance_type",
                                ));
                            }
                            result.confidential_instance_type = map
                                .next_value::<std::option::Option<
                                    crate::model::confidential_nodes::ConfidentialInstanceType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfidentialNodes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.confidential_instance_type) {
            state.serialize_entry("confidentialInstanceType", &self.confidential_instance_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConfidentialNodes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfidentialNodes");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field(
            "confidential_instance_type",
            &self.confidential_instance_type,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConfidentialNodes].
pub mod confidential_nodes {
    #[allow(unused_imports)]
    use super::*;

    /// The type of technology used by the confidential node.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConfidentialInstanceType {
        /// No type specified. Do not use this value.
        Unspecified,
        /// AMD Secure Encrypted Virtualization.
        Sev,
        /// AMD Secure Encrypted Virtualization - Secure Nested Paging.
        SevSnp,
        /// Intel Trust Domain eXtension.
        Tdx,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConfidentialInstanceType::value] or
        /// [ConfidentialInstanceType::name].
        UnknownValue(confidential_instance_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod confidential_instance_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConfidentialInstanceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Sev => std::option::Option::Some(1),
                Self::SevSnp => std::option::Option::Some(2),
                Self::Tdx => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CONFIDENTIAL_INSTANCE_TYPE_UNSPECIFIED")
                }
                Self::Sev => std::option::Option::Some("SEV"),
                Self::SevSnp => std::option::Option::Some("SEV_SNP"),
                Self::Tdx => std::option::Option::Some("TDX"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConfidentialInstanceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConfidentialInstanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConfidentialInstanceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Sev,
                2 => Self::SevSnp,
                3 => Self::Tdx,
                _ => Self::UnknownValue(confidential_instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConfidentialInstanceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONFIDENTIAL_INSTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SEV" => Self::Sev,
                "SEV_SNP" => Self::SevSnp,
                "TDX" => Self::Tdx,
                _ => Self::UnknownValue(confidential_instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConfidentialInstanceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Sev => serializer.serialize_i32(1),
                Self::SevSnp => serializer.serialize_i32(2),
                Self::Tdx => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConfidentialInstanceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<ConfidentialInstanceType>::new(
                    ".google.container.v1.ConfidentialNodes.ConfidentialInstanceType",
                ),
            )
        }
    }
}

/// UpgradeEvent is a notification sent to customers by the cluster server when
/// a resource is upgrading.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeEvent {
    /// The resource type that is upgrading.
    pub resource_type: crate::model::UpgradeResourceType,

    /// The operation associated with this upgrade.
    pub operation: std::string::String,

    /// The time when the operation was started.
    pub operation_start_time: std::option::Option<wkt::Timestamp>,

    /// The current version before the upgrade.
    pub current_version: std::string::String,

    /// The target version for the upgrade.
    pub target_version: std::string::String,

    /// Optional relative path to the resource. For example in node pool upgrades,
    /// the relative path of the node pool.
    pub resource: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_type][crate::model::UpgradeEvent::resource_type].
    pub fn set_resource_type<T: std::convert::Into<crate::model::UpgradeResourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::UpgradeEvent::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [operation_start_time][crate::model::UpgradeEvent::operation_start_time].
    pub fn set_operation_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.operation_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operation_start_time][crate::model::UpgradeEvent::operation_start_time].
    pub fn set_or_clear_operation_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.operation_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [current_version][crate::model::UpgradeEvent::current_version].
    pub fn set_current_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.current_version = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeEvent::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::UpgradeEvent::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpgradeEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_type,
            __operation,
            __operation_start_time,
            __current_version,
            __target_version,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "operation" => Ok(__FieldTag::__operation),
                            "operationStartTime" => Ok(__FieldTag::__operation_start_time),
                            "operation_start_time" => Ok(__FieldTag::__operation_start_time),
                            "currentVersion" => Ok(__FieldTag::__current_version),
                            "current_version" => Ok(__FieldTag::__current_version),
                            "targetVersion" => Ok(__FieldTag::__target_version),
                            "target_version" => Ok(__FieldTag::__target_version),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map.next_value::<std::option::Option<crate::model::UpgradeResourceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation_start_time => {
                            if !fields.insert(__FieldTag::__operation_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_start_time",
                                ));
                            }
                            result.operation_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__current_version => {
                            if !fields.insert(__FieldTag::__current_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_version",
                                ));
                            }
                            result.current_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version => {
                            if !fields.insert(__FieldTag::__target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version",
                                ));
                            }
                            result.target_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.resource_type) {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.operation.is_empty() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if self.operation_start_time.is_some() {
            state.serialize_entry("operationStartTime", &self.operation_start_time)?;
        }
        if !self.current_version.is_empty() {
            state.serialize_entry("currentVersion", &self.current_version)?;
        }
        if !self.target_version.is_empty() {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpgradeEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeEvent");
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("operation", &self.operation);
        debug_struct.field("operation_start_time", &self.operation_start_time);
        debug_struct.field("current_version", &self.current_version);
        debug_struct.field("target_version", &self.target_version);
        debug_struct.field("resource", &self.resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// UpgradeInfoEvent is a notification sent to customers about the upgrade
/// information of a resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeInfoEvent {
    /// The resource type associated with the upgrade.
    pub resource_type: crate::model::UpgradeResourceType,

    /// The operation associated with this upgrade.
    pub operation: std::string::String,

    /// The time when the operation was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time when the operation ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The current version before the upgrade.
    pub current_version: std::string::String,

    /// The target version for the upgrade.
    pub target_version: std::string::String,

    /// Optional relative path to the resource. For example in node pool upgrades,
    /// the relative path of the node pool.
    pub resource: std::string::String,

    /// Output only. The state of the upgrade.
    pub state: crate::model::upgrade_info_event::State,

    /// The end of standard support timestamp.
    pub standard_support_end_time: std::option::Option<wkt::Timestamp>,

    /// The end of extended support timestamp.
    pub extended_support_end_time: std::option::Option<wkt::Timestamp>,

    /// A brief description of the event.
    pub description: std::string::String,

    /// The type of the event.
    pub event_type: crate::model::upgrade_info_event::EventType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeInfoEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_type][crate::model::UpgradeInfoEvent::resource_type].
    pub fn set_resource_type<T: std::convert::Into<crate::model::UpgradeResourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::UpgradeInfoEvent::operation].
    pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::UpgradeInfoEvent::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpgradeInfoEvent::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UpgradeInfoEvent::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UpgradeInfoEvent::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [current_version][crate::model::UpgradeInfoEvent::current_version].
    pub fn set_current_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.current_version = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeInfoEvent::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [resource][crate::model::UpgradeInfoEvent::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UpgradeInfoEvent::state].
    pub fn set_state<T: std::convert::Into<crate::model::upgrade_info_event::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [standard_support_end_time][crate::model::UpgradeInfoEvent::standard_support_end_time].
    pub fn set_standard_support_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.standard_support_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [standard_support_end_time][crate::model::UpgradeInfoEvent::standard_support_end_time].
    pub fn set_or_clear_standard_support_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.standard_support_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [extended_support_end_time][crate::model::UpgradeInfoEvent::extended_support_end_time].
    pub fn set_extended_support_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.extended_support_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [extended_support_end_time][crate::model::UpgradeInfoEvent::extended_support_end_time].
    pub fn set_or_clear_extended_support_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.extended_support_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::UpgradeInfoEvent::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [event_type][crate::model::UpgradeInfoEvent::event_type].
    pub fn set_event_type<T: std::convert::Into<crate::model::upgrade_info_event::EventType>>(
        mut self,
        v: T,
    ) -> Self {
        self.event_type = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeInfoEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpgradeInfoEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeInfoEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_type,
            __operation,
            __start_time,
            __end_time,
            __current_version,
            __target_version,
            __resource,
            __state,
            __standard_support_end_time,
            __extended_support_end_time,
            __description,
            __event_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeInfoEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "operation" => Ok(__FieldTag::__operation),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "currentVersion" => Ok(__FieldTag::__current_version),
                            "current_version" => Ok(__FieldTag::__current_version),
                            "targetVersion" => Ok(__FieldTag::__target_version),
                            "target_version" => Ok(__FieldTag::__target_version),
                            "resource" => Ok(__FieldTag::__resource),
                            "state" => Ok(__FieldTag::__state),
                            "standardSupportEndTime" => Ok(__FieldTag::__standard_support_end_time),
                            "standard_support_end_time" => {
                                Ok(__FieldTag::__standard_support_end_time)
                            }
                            "extendedSupportEndTime" => Ok(__FieldTag::__extended_support_end_time),
                            "extended_support_end_time" => {
                                Ok(__FieldTag::__extended_support_end_time)
                            }
                            "description" => Ok(__FieldTag::__description),
                            "eventType" => Ok(__FieldTag::__event_type),
                            "event_type" => Ok(__FieldTag::__event_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeInfoEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeInfoEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map.next_value::<std::option::Option<crate::model::UpgradeResourceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__current_version => {
                            if !fields.insert(__FieldTag::__current_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_version",
                                ));
                            }
                            result.current_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version => {
                            if !fields.insert(__FieldTag::__target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version",
                                ));
                            }
                            result.target_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::upgrade_info_event::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__standard_support_end_time => {
                            if !fields.insert(__FieldTag::__standard_support_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard_support_end_time",
                                ));
                            }
                            result.standard_support_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__extended_support_end_time => {
                            if !fields.insert(__FieldTag::__extended_support_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extended_support_end_time",
                                ));
                            }
                            result.extended_support_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_type => {
                            if !fields.insert(__FieldTag::__event_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_type",
                                ));
                            }
                            result.event_type =
                                map.next_value::<std::option::Option<
                                    crate::model::upgrade_info_event::EventType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeInfoEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.resource_type) {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.operation.is_empty() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.current_version.is_empty() {
            state.serialize_entry("currentVersion", &self.current_version)?;
        }
        if !self.target_version.is_empty() {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.standard_support_end_time.is_some() {
            state.serialize_entry("standardSupportEndTime", &self.standard_support_end_time)?;
        }
        if self.extended_support_end_time.is_some() {
            state.serialize_entry("extendedSupportEndTime", &self.extended_support_end_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.event_type) {
            state.serialize_entry("eventType", &self.event_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpgradeInfoEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeInfoEvent");
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("operation", &self.operation);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("current_version", &self.current_version);
        debug_struct.field("target_version", &self.target_version);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("state", &self.state);
        debug_struct.field("standard_support_end_time", &self.standard_support_end_time);
        debug_struct.field("extended_support_end_time", &self.extended_support_end_time);
        debug_struct.field("description", &self.description);
        debug_struct.field("event_type", &self.event_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [UpgradeInfoEvent].
pub mod upgrade_info_event {
    #[allow(unused_imports)]
    use super::*;

    /// The state of the upgrade.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// STATE_UNSPECIFIED indicates the state is unspecified.
        Unspecified,
        /// STARTED indicates the upgrade has started.
        Started,
        /// SUCCEEDED indicates the upgrade has completed successfully.
        Succeeded,
        /// FAILED indicates the upgrade has failed.
        Failed,
        /// CANCELED indicates the upgrade has canceled.
        Canceled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Started => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Failed => std::option::Option::Some(5),
                Self::Canceled => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Started => std::option::Option::Some("STARTED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Canceled => std::option::Option::Some("CANCELED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                3 => Self::Started,
                4 => Self::Succeeded,
                5 => Self::Failed,
                6 => Self::Canceled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "STARTED" => Self::Started,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELED" => Self::Canceled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Started => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Failed => serializer.serialize_i32(5),
                Self::Canceled => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.container.v1.UpgradeInfoEvent.State",
            ))
        }
    }

    /// The type of the event.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// EVENT_TYPE_UNSPECIFIED indicates the event type is unspecified.
        Unspecified,
        /// END_OF_SUPPORT indicates GKE version reaches end of support, check
        /// standard_support_end_time and extended_support_end_time for more details.
        EndOfSupport,
        /// COS_MILESTONE_VERSION_UPDATE indicates that the COS node image will
        /// update COS milestone version for new patch versions starting with
        /// the one in the description.
        CosMilestoneVersionUpdate,
        /// UPGRADE_LIFECYCLE indicates the event is about the upgrade lifecycle.
        UpgradeLifecycle,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::EndOfSupport => std::option::Option::Some(1),
                Self::CosMilestoneVersionUpdate => std::option::Option::Some(2),
                Self::UpgradeLifecycle => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::EndOfSupport => std::option::Option::Some("END_OF_SUPPORT"),
                Self::CosMilestoneVersionUpdate => {
                    std::option::Option::Some("COS_MILESTONE_VERSION_UPDATE")
                }
                Self::UpgradeLifecycle => std::option::Option::Some("UPGRADE_LIFECYCLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::EndOfSupport,
                2 => Self::CosMilestoneVersionUpdate,
                3 => Self::UpgradeLifecycle,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "END_OF_SUPPORT" => Self::EndOfSupport,
                "COS_MILESTONE_VERSION_UPDATE" => Self::CosMilestoneVersionUpdate,
                "UPGRADE_LIFECYCLE" => Self::UpgradeLifecycle,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::EndOfSupport => serializer.serialize_i32(1),
                Self::CosMilestoneVersionUpdate => serializer.serialize_i32(2),
                Self::UpgradeLifecycle => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.container.v1.UpgradeInfoEvent.EventType",
            ))
        }
    }
}

/// UpgradeAvailableEvent is a notification sent to customers when a new
/// available version is released.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeAvailableEvent {
    /// The release version available for upgrade.
    pub version: std::string::String,

    /// The resource type of the release version.
    pub resource_type: crate::model::UpgradeResourceType,

    /// The release channel of the version. If empty, it means a non-channel
    /// release.
    pub release_channel: std::option::Option<crate::model::ReleaseChannel>,

    /// Optional relative path to the resource. For example, the relative path of
    /// the node pool.
    pub resource: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeAvailableEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::UpgradeAvailableEvent::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [resource_type][crate::model::UpgradeAvailableEvent::resource_type].
    pub fn set_resource_type<T: std::convert::Into<crate::model::UpgradeResourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type = v.into();
        self
    }

    /// Sets the value of [release_channel][crate::model::UpgradeAvailableEvent::release_channel].
    pub fn set_release_channel<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReleaseChannel>,
    {
        self.release_channel = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [release_channel][crate::model::UpgradeAvailableEvent::release_channel].
    pub fn set_or_clear_release_channel<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReleaseChannel>,
    {
        self.release_channel = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource][crate::model::UpgradeAvailableEvent::resource].
    pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.resource = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeAvailableEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpgradeAvailableEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeAvailableEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __resource_type,
            __release_channel,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeAvailableEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "releaseChannel" => Ok(__FieldTag::__release_channel),
                            "release_channel" => Ok(__FieldTag::__release_channel),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeAvailableEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeAvailableEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map.next_value::<std::option::Option<crate::model::UpgradeResourceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__release_channel => {
                            if !fields.insert(__FieldTag::__release_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_channel",
                                ));
                            }
                            result.release_channel = map
                                .next_value::<std::option::Option<crate::model::ReleaseChannel>>(
                                )?;
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeAvailableEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.resource_type) {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if self.release_channel.is_some() {
            state.serialize_entry("releaseChannel", &self.release_channel)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpgradeAvailableEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeAvailableEvent");
        debug_struct.field("version", &self.version);
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("release_channel", &self.release_channel);
        debug_struct.field("resource", &self.resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SecurityBulletinEvent is a notification sent to customers when a security
/// bulletin has been posted that they are vulnerable to.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecurityBulletinEvent {
    /// The resource type (node/control plane) that has the vulnerability. Multiple
    /// notifications (1 notification per resource type) will be sent for a
    /// vulnerability that affects > 1 resource type.
    pub resource_type_affected: std::string::String,

    /// The ID of the bulletin corresponding to the vulnerability.
    pub bulletin_id: std::string::String,

    /// The CVEs associated with this bulletin.
    pub cve_ids: std::vec::Vec<std::string::String>,

    /// The severity of this bulletin as it relates to GKE.
    pub severity: std::string::String,

    /// The URI link to the bulletin on the website for more information.
    pub bulletin_uri: std::string::String,

    /// A brief description of the bulletin. See the bulletin pointed to by the
    /// bulletin_uri field for an expanded description.
    pub brief_description: std::string::String,

    /// The GKE minor versions affected by this vulnerability.
    pub affected_supported_minors: std::vec::Vec<std::string::String>,

    /// The GKE versions where this vulnerability is patched.
    pub patched_versions: std::vec::Vec<std::string::String>,

    /// This represents a version selected from the patched_versions field that
    /// the cluster receiving this notification should most likely want to upgrade
    /// to based on its current version. Note that if this notification is being
    /// received by a given cluster, it means that this version is currently
    /// available as an upgrade target in that cluster's location.
    pub suggested_upgrade_target: std::string::String,

    /// If this field is specified, it means there are manual steps that the user
    /// must take to make their clusters safe.
    pub manual_steps_required: bool,

    /// The GKE versions where this vulnerability is mitigated.
    pub mitigated_versions: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecurityBulletinEvent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_type_affected][crate::model::SecurityBulletinEvent::resource_type_affected].
    pub fn set_resource_type_affected<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_type_affected = v.into();
        self
    }

    /// Sets the value of [bulletin_id][crate::model::SecurityBulletinEvent::bulletin_id].
    pub fn set_bulletin_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bulletin_id = v.into();
        self
    }

    /// Sets the value of [cve_ids][crate::model::SecurityBulletinEvent::cve_ids].
    pub fn set_cve_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.cve_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [severity][crate::model::SecurityBulletinEvent::severity].
    pub fn set_severity<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [bulletin_uri][crate::model::SecurityBulletinEvent::bulletin_uri].
    pub fn set_bulletin_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bulletin_uri = v.into();
        self
    }

    /// Sets the value of [brief_description][crate::model::SecurityBulletinEvent::brief_description].
    pub fn set_brief_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.brief_description = v.into();
        self
    }

    /// Sets the value of [affected_supported_minors][crate::model::SecurityBulletinEvent::affected_supported_minors].
    pub fn set_affected_supported_minors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.affected_supported_minors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [patched_versions][crate::model::SecurityBulletinEvent::patched_versions].
    pub fn set_patched_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.patched_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [suggested_upgrade_target][crate::model::SecurityBulletinEvent::suggested_upgrade_target].
    pub fn set_suggested_upgrade_target<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.suggested_upgrade_target = v.into();
        self
    }

    /// Sets the value of [manual_steps_required][crate::model::SecurityBulletinEvent::manual_steps_required].
    pub fn set_manual_steps_required<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.manual_steps_required = v.into();
        self
    }

    /// Sets the value of [mitigated_versions][crate::model::SecurityBulletinEvent::mitigated_versions].
    pub fn set_mitigated_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.mitigated_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SecurityBulletinEvent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SecurityBulletinEvent"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecurityBulletinEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_type_affected,
            __bulletin_id,
            __cve_ids,
            __severity,
            __bulletin_uri,
            __brief_description,
            __affected_supported_minors,
            __patched_versions,
            __suggested_upgrade_target,
            __manual_steps_required,
            __mitigated_versions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecurityBulletinEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceTypeAffected" => Ok(__FieldTag::__resource_type_affected),
                            "resource_type_affected" => Ok(__FieldTag::__resource_type_affected),
                            "bulletinId" => Ok(__FieldTag::__bulletin_id),
                            "bulletin_id" => Ok(__FieldTag::__bulletin_id),
                            "cveIds" => Ok(__FieldTag::__cve_ids),
                            "cve_ids" => Ok(__FieldTag::__cve_ids),
                            "severity" => Ok(__FieldTag::__severity),
                            "bulletinUri" => Ok(__FieldTag::__bulletin_uri),
                            "bulletin_uri" => Ok(__FieldTag::__bulletin_uri),
                            "briefDescription" => Ok(__FieldTag::__brief_description),
                            "brief_description" => Ok(__FieldTag::__brief_description),
                            "affectedSupportedMinors" => {
                                Ok(__FieldTag::__affected_supported_minors)
                            }
                            "affected_supported_minors" => {
                                Ok(__FieldTag::__affected_supported_minors)
                            }
                            "patchedVersions" => Ok(__FieldTag::__patched_versions),
                            "patched_versions" => Ok(__FieldTag::__patched_versions),
                            "suggestedUpgradeTarget" => Ok(__FieldTag::__suggested_upgrade_target),
                            "suggested_upgrade_target" => {
                                Ok(__FieldTag::__suggested_upgrade_target)
                            }
                            "manualStepsRequired" => Ok(__FieldTag::__manual_steps_required),
                            "manual_steps_required" => Ok(__FieldTag::__manual_steps_required),
                            "mitigatedVersions" => Ok(__FieldTag::__mitigated_versions),
                            "mitigated_versions" => Ok(__FieldTag::__mitigated_versions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecurityBulletinEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecurityBulletinEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_type_affected => {
                            if !fields.insert(__FieldTag::__resource_type_affected) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type_affected",
                                ));
                            }
                            result.resource_type_affected = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bulletin_id => {
                            if !fields.insert(__FieldTag::__bulletin_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bulletin_id",
                                ));
                            }
                            result.bulletin_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cve_ids => {
                            if !fields.insert(__FieldTag::__cve_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cve_ids",
                                ));
                            }
                            result.cve_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bulletin_uri => {
                            if !fields.insert(__FieldTag::__bulletin_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bulletin_uri",
                                ));
                            }
                            result.bulletin_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__brief_description => {
                            if !fields.insert(__FieldTag::__brief_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for brief_description",
                                ));
                            }
                            result.brief_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__affected_supported_minors => {
                            if !fields.insert(__FieldTag::__affected_supported_minors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for affected_supported_minors",
                                ));
                            }
                            result.affected_supported_minors = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__patched_versions => {
                            if !fields.insert(__FieldTag::__patched_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patched_versions",
                                ));
                            }
                            result.patched_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__suggested_upgrade_target => {
                            if !fields.insert(__FieldTag::__suggested_upgrade_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggested_upgrade_target",
                                ));
                            }
                            result.suggested_upgrade_target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__manual_steps_required => {
                            if !fields.insert(__FieldTag::__manual_steps_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manual_steps_required",
                                ));
                            }
                            result.manual_steps_required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mitigated_versions => {
                            if !fields.insert(__FieldTag::__mitigated_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mitigated_versions",
                                ));
                            }
                            result.mitigated_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecurityBulletinEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_type_affected.is_empty() {
            state.serialize_entry("resourceTypeAffected", &self.resource_type_affected)?;
        }
        if !self.bulletin_id.is_empty() {
            state.serialize_entry("bulletinId", &self.bulletin_id)?;
        }
        if !self.cve_ids.is_empty() {
            state.serialize_entry("cveIds", &self.cve_ids)?;
        }
        if !self.severity.is_empty() {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.bulletin_uri.is_empty() {
            state.serialize_entry("bulletinUri", &self.bulletin_uri)?;
        }
        if !self.brief_description.is_empty() {
            state.serialize_entry("briefDescription", &self.brief_description)?;
        }
        if !self.affected_supported_minors.is_empty() {
            state.serialize_entry("affectedSupportedMinors", &self.affected_supported_minors)?;
        }
        if !self.patched_versions.is_empty() {
            state.serialize_entry("patchedVersions", &self.patched_versions)?;
        }
        if !self.suggested_upgrade_target.is_empty() {
            state.serialize_entry("suggestedUpgradeTarget", &self.suggested_upgrade_target)?;
        }
        if !wkt::internal::is_default(&self.manual_steps_required) {
            state.serialize_entry("manualStepsRequired", &self.manual_steps_required)?;
        }
        if !self.mitigated_versions.is_empty() {
            state.serialize_entry("mitigatedVersions", &self.mitigated_versions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SecurityBulletinEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecurityBulletinEvent");
        debug_struct.field("resource_type_affected", &self.resource_type_affected);
        debug_struct.field("bulletin_id", &self.bulletin_id);
        debug_struct.field("cve_ids", &self.cve_ids);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("bulletin_uri", &self.bulletin_uri);
        debug_struct.field("brief_description", &self.brief_description);
        debug_struct.field("affected_supported_minors", &self.affected_supported_minors);
        debug_struct.field("patched_versions", &self.patched_versions);
        debug_struct.field("suggested_upgrade_target", &self.suggested_upgrade_target);
        debug_struct.field("manual_steps_required", &self.manual_steps_required);
        debug_struct.field("mitigated_versions", &self.mitigated_versions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Autopilot is the configuration for Autopilot settings on the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Autopilot {
    /// Enable Autopilot
    pub enabled: bool,

    /// WorkloadPolicyConfig is the configuration related to GCW workload policy
    pub workload_policy_config: std::option::Option<crate::model::WorkloadPolicyConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Autopilot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::Autopilot::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [workload_policy_config][crate::model::Autopilot::workload_policy_config].
    pub fn set_workload_policy_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadPolicyConfig>,
    {
        self.workload_policy_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workload_policy_config][crate::model::Autopilot::workload_policy_config].
    pub fn set_or_clear_workload_policy_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkloadPolicyConfig>,
    {
        self.workload_policy_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Autopilot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.Autopilot"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Autopilot {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __workload_policy_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Autopilot")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "workloadPolicyConfig" => Ok(__FieldTag::__workload_policy_config),
                            "workload_policy_config" => Ok(__FieldTag::__workload_policy_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Autopilot;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Autopilot")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_policy_config => {
                            if !fields.insert(__FieldTag::__workload_policy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_policy_config",
                                ));
                            }
                            result.workload_policy_config = map.next_value::<std::option::Option<crate::model::WorkloadPolicyConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Autopilot {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.workload_policy_config.is_some() {
            state.serialize_entry("workloadPolicyConfig", &self.workload_policy_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Autopilot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Autopilot");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("workload_policy_config", &self.workload_policy_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// WorkloadPolicyConfig is the configuration related to GCW workload policy
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkloadPolicyConfig {
    /// If true, workloads can use NET_ADMIN capability.
    pub allow_net_admin: std::option::Option<bool>,

    /// If true, enables the GCW Auditor that audits workloads on
    /// standard clusters.
    pub autopilot_compatibility_auditing_enabled: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkloadPolicyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allow_net_admin][crate::model::WorkloadPolicyConfig::allow_net_admin].
    pub fn set_allow_net_admin<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.allow_net_admin = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allow_net_admin][crate::model::WorkloadPolicyConfig::allow_net_admin].
    pub fn set_or_clear_allow_net_admin<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.allow_net_admin = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autopilot_compatibility_auditing_enabled][crate::model::WorkloadPolicyConfig::autopilot_compatibility_auditing_enabled].
    pub fn set_autopilot_compatibility_auditing_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.autopilot_compatibility_auditing_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autopilot_compatibility_auditing_enabled][crate::model::WorkloadPolicyConfig::autopilot_compatibility_auditing_enabled].
    pub fn set_or_clear_autopilot_compatibility_auditing_enabled<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.autopilot_compatibility_auditing_enabled = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WorkloadPolicyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.WorkloadPolicyConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkloadPolicyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allow_net_admin,
            __autopilot_compatibility_auditing_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkloadPolicyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowNetAdmin" => Ok(__FieldTag::__allow_net_admin),
                            "allow_net_admin" => Ok(__FieldTag::__allow_net_admin),
                            "autopilotCompatibilityAuditingEnabled" => {
                                Ok(__FieldTag::__autopilot_compatibility_auditing_enabled)
                            }
                            "autopilot_compatibility_auditing_enabled" => {
                                Ok(__FieldTag::__autopilot_compatibility_auditing_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkloadPolicyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkloadPolicyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allow_net_admin => {
                            if !fields.insert(__FieldTag::__allow_net_admin) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_net_admin",
                                ));
                            }
                            result.allow_net_admin =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__autopilot_compatibility_auditing_enabled => {
                            if !fields
                                .insert(__FieldTag::__autopilot_compatibility_auditing_enabled)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autopilot_compatibility_auditing_enabled",
                                ));
                            }
                            result.autopilot_compatibility_auditing_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkloadPolicyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.allow_net_admin.is_some() {
            state.serialize_entry("allowNetAdmin", &self.allow_net_admin)?;
        }
        if self.autopilot_compatibility_auditing_enabled.is_some() {
            state.serialize_entry(
                "autopilotCompatibilityAuditingEnabled",
                &self.autopilot_compatibility_auditing_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for WorkloadPolicyConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkloadPolicyConfig");
        debug_struct.field("allow_net_admin", &self.allow_net_admin);
        debug_struct.field(
            "autopilot_compatibility_auditing_enabled",
            &self.autopilot_compatibility_auditing_enabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// LoggingConfig is cluster logging configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LoggingConfig {
    /// Logging components configuration
    pub component_config: std::option::Option<crate::model::LoggingComponentConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [component_config][crate::model::LoggingConfig::component_config].
    pub fn set_component_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingComponentConfig>,
    {
        self.component_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [component_config][crate::model::LoggingConfig::component_config].
    pub fn set_or_clear_component_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingComponentConfig>,
    {
        self.component_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for LoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LoggingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __component_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "componentConfig" => Ok(__FieldTag::__component_config),
                            "component_config" => Ok(__FieldTag::__component_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__component_config => {
                            if !fields.insert(__FieldTag::__component_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for component_config",
                                ));
                            }
                            result.component_config = map.next_value::<std::option::Option<crate::model::LoggingComponentConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.component_config.is_some() {
            state.serialize_entry("componentConfig", &self.component_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingConfig");
        debug_struct.field("component_config", &self.component_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// LoggingComponentConfig is cluster logging component configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LoggingComponentConfig {
    /// Select components to collect logs. An empty set would disable all logging.
    pub enable_components: std::vec::Vec<crate::model::logging_component_config::Component>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingComponentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_components][crate::model::LoggingComponentConfig::enable_components].
    pub fn set_enable_components<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::logging_component_config::Component>,
    {
        use std::iter::Iterator;
        self.enable_components = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for LoggingComponentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LoggingComponentConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoggingComponentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_components,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingComponentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableComponents" => Ok(__FieldTag::__enable_components),
                            "enable_components" => Ok(__FieldTag::__enable_components),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoggingComponentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingComponentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_components => {
                            if !fields.insert(__FieldTag::__enable_components) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_components",
                                ));
                            }
                            result.enable_components = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::logging_component_config::Component,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoggingComponentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.enable_components.is_empty() {
            state.serialize_entry("enableComponents", &self.enable_components)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LoggingComponentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingComponentConfig");
        debug_struct.field("enable_components", &self.enable_components);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [LoggingComponentConfig].
pub mod logging_component_config {
    #[allow(unused_imports)]
    use super::*;

    /// GKE components exposing logs
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Component {
        /// Default value. This shouldn't be used.
        Unspecified,
        /// system components
        SystemComponents,
        /// workloads
        Workloads,
        /// kube-apiserver
        Apiserver,
        /// kube-scheduler
        Scheduler,
        /// kube-controller-manager
        ControllerManager,
        /// kcp-sshd
        KcpSshd,
        /// kcp connection logs
        KcpConnection,
        /// horizontal pod autoscaler decision logs
        KcpHpa,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Component::value] or
        /// [Component::name].
        UnknownValue(component::UnknownValue),
    }

    #[doc(hidden)]
    pub mod component {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Component {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SystemComponents => std::option::Option::Some(1),
                Self::Workloads => std::option::Option::Some(2),
                Self::Apiserver => std::option::Option::Some(3),
                Self::Scheduler => std::option::Option::Some(4),
                Self::ControllerManager => std::option::Option::Some(5),
                Self::KcpSshd => std::option::Option::Some(7),
                Self::KcpConnection => std::option::Option::Some(8),
                Self::KcpHpa => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPONENT_UNSPECIFIED"),
                Self::SystemComponents => std::option::Option::Some("SYSTEM_COMPONENTS"),
                Self::Workloads => std::option::Option::Some("WORKLOADS"),
                Self::Apiserver => std::option::Option::Some("APISERVER"),
                Self::Scheduler => std::option::Option::Some("SCHEDULER"),
                Self::ControllerManager => std::option::Option::Some("CONTROLLER_MANAGER"),
                Self::KcpSshd => std::option::Option::Some("KCP_SSHD"),
                Self::KcpConnection => std::option::Option::Some("KCP_CONNECTION"),
                Self::KcpHpa => std::option::Option::Some("KCP_HPA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Component {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Component {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Component {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SystemComponents,
                2 => Self::Workloads,
                3 => Self::Apiserver,
                4 => Self::Scheduler,
                5 => Self::ControllerManager,
                7 => Self::KcpSshd,
                8 => Self::KcpConnection,
                9 => Self::KcpHpa,
                _ => Self::UnknownValue(component::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Component {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPONENT_UNSPECIFIED" => Self::Unspecified,
                "SYSTEM_COMPONENTS" => Self::SystemComponents,
                "WORKLOADS" => Self::Workloads,
                "APISERVER" => Self::Apiserver,
                "SCHEDULER" => Self::Scheduler,
                "CONTROLLER_MANAGER" => Self::ControllerManager,
                "KCP_SSHD" => Self::KcpSshd,
                "KCP_CONNECTION" => Self::KcpConnection,
                "KCP_HPA" => Self::KcpHpa,
                _ => Self::UnknownValue(component::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Component {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SystemComponents => serializer.serialize_i32(1),
                Self::Workloads => serializer.serialize_i32(2),
                Self::Apiserver => serializer.serialize_i32(3),
                Self::Scheduler => serializer.serialize_i32(4),
                Self::ControllerManager => serializer.serialize_i32(5),
                Self::KcpSshd => serializer.serialize_i32(7),
                Self::KcpConnection => serializer.serialize_i32(8),
                Self::KcpHpa => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Component {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Component>::new(
                ".google.container.v1.LoggingComponentConfig.Component",
            ))
        }
    }
}

/// RayClusterLoggingConfig specifies configuration of Ray logging.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RayClusterLoggingConfig {
    /// Enable log collection for Ray clusters.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RayClusterLoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::RayClusterLoggingConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for RayClusterLoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RayClusterLoggingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RayClusterLoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RayClusterLoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RayClusterLoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RayClusterLoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RayClusterLoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RayClusterLoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RayClusterLoggingConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MonitoringConfig is cluster monitoring configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MonitoringConfig {
    /// Monitoring components configuration
    pub component_config: std::option::Option<crate::model::MonitoringComponentConfig>,

    /// Enable Google Cloud Managed Service for Prometheus
    /// in the cluster.
    pub managed_prometheus_config: std::option::Option<crate::model::ManagedPrometheusConfig>,

    /// Configuration of Advanced Datapath Observability features.
    pub advanced_datapath_observability_config:
        std::option::Option<crate::model::AdvancedDatapathObservabilityConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MonitoringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [component_config][crate::model::MonitoringConfig::component_config].
    pub fn set_component_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringComponentConfig>,
    {
        self.component_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [component_config][crate::model::MonitoringConfig::component_config].
    pub fn set_or_clear_component_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MonitoringComponentConfig>,
    {
        self.component_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [managed_prometheus_config][crate::model::MonitoringConfig::managed_prometheus_config].
    pub fn set_managed_prometheus_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagedPrometheusConfig>,
    {
        self.managed_prometheus_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [managed_prometheus_config][crate::model::MonitoringConfig::managed_prometheus_config].
    pub fn set_or_clear_managed_prometheus_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagedPrometheusConfig>,
    {
        self.managed_prometheus_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [advanced_datapath_observability_config][crate::model::MonitoringConfig::advanced_datapath_observability_config].
    pub fn set_advanced_datapath_observability_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedDatapathObservabilityConfig>,
    {
        self.advanced_datapath_observability_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_datapath_observability_config][crate::model::MonitoringConfig::advanced_datapath_observability_config].
    pub fn set_or_clear_advanced_datapath_observability_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedDatapathObservabilityConfig>,
    {
        self.advanced_datapath_observability_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MonitoringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MonitoringConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MonitoringConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __component_config,
            __managed_prometheus_config,
            __advanced_datapath_observability_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MonitoringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "componentConfig" => Ok(__FieldTag::__component_config),
                            "component_config" => Ok(__FieldTag::__component_config),
                            "managedPrometheusConfig" => {
                                Ok(__FieldTag::__managed_prometheus_config)
                            }
                            "managed_prometheus_config" => {
                                Ok(__FieldTag::__managed_prometheus_config)
                            }
                            "advancedDatapathObservabilityConfig" => {
                                Ok(__FieldTag::__advanced_datapath_observability_config)
                            }
                            "advanced_datapath_observability_config" => {
                                Ok(__FieldTag::__advanced_datapath_observability_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MonitoringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MonitoringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__component_config => {
                            if !fields.insert(__FieldTag::__component_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for component_config",
                                ));
                            }
                            result.component_config = map.next_value::<std::option::Option<crate::model::MonitoringComponentConfig>>()?
                                ;
                        }
                        __FieldTag::__managed_prometheus_config => {
                            if !fields.insert(__FieldTag::__managed_prometheus_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_prometheus_config",
                                ));
                            }
                            result.managed_prometheus_config = map.next_value::<std::option::Option<crate::model::ManagedPrometheusConfig>>()?
                                ;
                        }
                        __FieldTag::__advanced_datapath_observability_config => {
                            if !fields.insert(__FieldTag::__advanced_datapath_observability_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_datapath_observability_config",
                                ));
                            }
                            result.advanced_datapath_observability_config =
                                map.next_value::<std::option::Option<
                                    crate::model::AdvancedDatapathObservabilityConfig,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MonitoringConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.component_config.is_some() {
            state.serialize_entry("componentConfig", &self.component_config)?;
        }
        if self.managed_prometheus_config.is_some() {
            state.serialize_entry("managedPrometheusConfig", &self.managed_prometheus_config)?;
        }
        if self.advanced_datapath_observability_config.is_some() {
            state.serialize_entry(
                "advancedDatapathObservabilityConfig",
                &self.advanced_datapath_observability_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MonitoringConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MonitoringConfig");
        debug_struct.field("component_config", &self.component_config);
        debug_struct.field("managed_prometheus_config", &self.managed_prometheus_config);
        debug_struct.field(
            "advanced_datapath_observability_config",
            &self.advanced_datapath_observability_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AdvancedDatapathObservabilityConfig specifies configuration of observability
/// features of advanced datapath.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvancedDatapathObservabilityConfig {
    /// Expose flow metrics on nodes
    pub enable_metrics: bool,

    /// Method used to make Relay available
    pub relay_mode: crate::model::advanced_datapath_observability_config::RelayMode,

    /// Enable Relay component
    pub enable_relay: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdvancedDatapathObservabilityConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_metrics][crate::model::AdvancedDatapathObservabilityConfig::enable_metrics].
    pub fn set_enable_metrics<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_metrics = v.into();
        self
    }

    /// Sets the value of [relay_mode][crate::model::AdvancedDatapathObservabilityConfig::relay_mode].
    pub fn set_relay_mode<
        T: std::convert::Into<crate::model::advanced_datapath_observability_config::RelayMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.relay_mode = v.into();
        self
    }

    /// Sets the value of [enable_relay][crate::model::AdvancedDatapathObservabilityConfig::enable_relay].
    pub fn set_enable_relay<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_relay = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_relay][crate::model::AdvancedDatapathObservabilityConfig::enable_relay].
    pub fn set_or_clear_enable_relay<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_relay = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AdvancedDatapathObservabilityConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AdvancedDatapathObservabilityConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdvancedDatapathObservabilityConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_metrics,
            __relay_mode,
            __enable_relay,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvancedDatapathObservabilityConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableMetrics" => Ok(__FieldTag::__enable_metrics),
                            "enable_metrics" => Ok(__FieldTag::__enable_metrics),
                            "relayMode" => Ok(__FieldTag::__relay_mode),
                            "relay_mode" => Ok(__FieldTag::__relay_mode),
                            "enableRelay" => Ok(__FieldTag::__enable_relay),
                            "enable_relay" => Ok(__FieldTag::__enable_relay),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdvancedDatapathObservabilityConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvancedDatapathObservabilityConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_metrics => {
                            if !fields.insert(__FieldTag::__enable_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_metrics",
                                ));
                            }
                            result.enable_metrics = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relay_mode => {
                            if !fields.insert(__FieldTag::__relay_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relay_mode",
                                ));
                            }
                            result.relay_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::advanced_datapath_observability_config::RelayMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_relay => {
                            if !fields.insert(__FieldTag::__enable_relay) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_relay",
                                ));
                            }
                            result.enable_relay = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdvancedDatapathObservabilityConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_metrics) {
            state.serialize_entry("enableMetrics", &self.enable_metrics)?;
        }
        if !wkt::internal::is_default(&self.relay_mode) {
            state.serialize_entry("relayMode", &self.relay_mode)?;
        }
        if self.enable_relay.is_some() {
            state.serialize_entry("enableRelay", &self.enable_relay)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdvancedDatapathObservabilityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvancedDatapathObservabilityConfig");
        debug_struct.field("enable_metrics", &self.enable_metrics);
        debug_struct.field("relay_mode", &self.relay_mode);
        debug_struct.field("enable_relay", &self.enable_relay);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AdvancedDatapathObservabilityConfig].
pub mod advanced_datapath_observability_config {
    #[allow(unused_imports)]
    use super::*;

    /// Supported Relay modes
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RelayMode {
        /// Default value. This shouldn't be used.
        Unspecified,
        /// disabled
        Disabled,
        /// exposed via internal load balancer
        InternalVpcLb,
        /// exposed via external load balancer
        ExternalLb,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RelayMode::value] or
        /// [RelayMode::name].
        UnknownValue(relay_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod relay_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RelayMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::InternalVpcLb => std::option::Option::Some(3),
                Self::ExternalLb => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RELAY_MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::InternalVpcLb => std::option::Option::Some("INTERNAL_VPC_LB"),
                Self::ExternalLb => std::option::Option::Some("EXTERNAL_LB"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RelayMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RelayMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RelayMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                3 => Self::InternalVpcLb,
                4 => Self::ExternalLb,
                _ => Self::UnknownValue(relay_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RelayMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RELAY_MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "INTERNAL_VPC_LB" => Self::InternalVpcLb,
                "EXTERNAL_LB" => Self::ExternalLb,
                _ => Self::UnknownValue(relay_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RelayMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::InternalVpcLb => serializer.serialize_i32(3),
                Self::ExternalLb => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RelayMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RelayMode>::new(
                ".google.container.v1.AdvancedDatapathObservabilityConfig.RelayMode",
            ))
        }
    }
}

/// RayClusterMonitoringConfig specifies monitoring configuration for Ray
/// clusters.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RayClusterMonitoringConfig {
    /// Enable metrics collection for Ray clusters.
    pub enabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RayClusterMonitoringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::RayClusterMonitoringConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }
}

impl wkt::message::Message for RayClusterMonitoringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.RayClusterMonitoringConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RayClusterMonitoringConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RayClusterMonitoringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RayClusterMonitoringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RayClusterMonitoringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RayClusterMonitoringConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RayClusterMonitoringConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RayClusterMonitoringConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// NodePoolLoggingConfig specifies logging configuration for nodepools.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodePoolLoggingConfig {
    /// Logging variant configuration.
    pub variant_config: std::option::Option<crate::model::LoggingVariantConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePoolLoggingConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [variant_config][crate::model::NodePoolLoggingConfig::variant_config].
    pub fn set_variant_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LoggingVariantConfig>,
    {
        self.variant_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [variant_config][crate::model::NodePoolLoggingConfig::variant_config].
    pub fn set_or_clear_variant_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LoggingVariantConfig>,
    {
        self.variant_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodePoolLoggingConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodePoolLoggingConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodePoolLoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __variant_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePoolLoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "variantConfig" => Ok(__FieldTag::__variant_config),
                            "variant_config" => Ok(__FieldTag::__variant_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodePoolLoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePoolLoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__variant_config => {
                            if !fields.insert(__FieldTag::__variant_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for variant_config",
                                ));
                            }
                            result.variant_config = map.next_value::<std::option::Option<crate::model::LoggingVariantConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodePoolLoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.variant_config.is_some() {
            state.serialize_entry("variantConfig", &self.variant_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodePoolLoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePoolLoggingConfig");
        debug_struct.field("variant_config", &self.variant_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// LoggingVariantConfig specifies the behaviour of the logging component.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LoggingVariantConfig {
    /// Logging variant deployed on nodes.
    pub variant: crate::model::logging_variant_config::Variant,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoggingVariantConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [variant][crate::model::LoggingVariantConfig::variant].
    pub fn set_variant<T: std::convert::Into<crate::model::logging_variant_config::Variant>>(
        mut self,
        v: T,
    ) -> Self {
        self.variant = v.into();
        self
    }
}

impl wkt::message::Message for LoggingVariantConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LoggingVariantConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoggingVariantConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __variant,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingVariantConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "variant" => Ok(__FieldTag::__variant),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoggingVariantConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingVariantConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__variant => {
                            if !fields.insert(__FieldTag::__variant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for variant",
                                ));
                            }
                            result.variant =
                                map.next_value::<std::option::Option<
                                    crate::model::logging_variant_config::Variant,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoggingVariantConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.variant) {
            state.serialize_entry("variant", &self.variant)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LoggingVariantConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingVariantConfig");
        debug_struct.field("variant", &self.variant);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [LoggingVariantConfig].
pub mod logging_variant_config {
    #[allow(unused_imports)]
    use super::*;

    /// Logging component variants.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Variant {
        /// Default value. This shouldn't be used.
        Unspecified,
        /// default logging variant.
        Default,
        /// maximum logging throughput variant.
        MaxThroughput,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Variant::value] or
        /// [Variant::name].
        UnknownValue(variant::UnknownValue),
    }

    #[doc(hidden)]
    pub mod variant {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Variant {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Default => std::option::Option::Some(1),
                Self::MaxThroughput => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VARIANT_UNSPECIFIED"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::MaxThroughput => std::option::Option::Some("MAX_THROUGHPUT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Variant {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Variant {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Variant {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Default,
                2 => Self::MaxThroughput,
                _ => Self::UnknownValue(variant::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Variant {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VARIANT_UNSPECIFIED" => Self::Unspecified,
                "DEFAULT" => Self::Default,
                "MAX_THROUGHPUT" => Self::MaxThroughput,
                _ => Self::UnknownValue(variant::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Variant {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Default => serializer.serialize_i32(1),
                Self::MaxThroughput => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Variant {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Variant>::new(
                ".google.container.v1.LoggingVariantConfig.Variant",
            ))
        }
    }
}

/// MonitoringComponentConfig is cluster monitoring component configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MonitoringComponentConfig {
    /// Select components to collect metrics. An empty set would disable all
    /// monitoring.
    pub enable_components: std::vec::Vec<crate::model::monitoring_component_config::Component>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MonitoringComponentConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_components][crate::model::MonitoringComponentConfig::enable_components].
    pub fn set_enable_components<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::monitoring_component_config::Component>,
    {
        use std::iter::Iterator;
        self.enable_components = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MonitoringComponentConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.MonitoringComponentConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MonitoringComponentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_components,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MonitoringComponentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableComponents" => Ok(__FieldTag::__enable_components),
                            "enable_components" => Ok(__FieldTag::__enable_components),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MonitoringComponentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MonitoringComponentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_components => {
                            if !fields.insert(__FieldTag::__enable_components) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_components",
                                ));
                            }
                            result.enable_components = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::monitoring_component_config::Component,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MonitoringComponentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.enable_components.is_empty() {
            state.serialize_entry("enableComponents", &self.enable_components)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MonitoringComponentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MonitoringComponentConfig");
        debug_struct.field("enable_components", &self.enable_components);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MonitoringComponentConfig].
pub mod monitoring_component_config {
    #[allow(unused_imports)]
    use super::*;

    /// GKE components exposing metrics
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Component {
        /// Default value. This shouldn't be used.
        Unspecified,
        /// system components
        SystemComponents,
        /// kube-apiserver
        Apiserver,
        /// kube-scheduler
        Scheduler,
        /// kube-controller-manager
        ControllerManager,
        /// Storage
        Storage,
        /// Horizontal Pod Autoscaling
        Hpa,
        /// Pod
        Pod,
        /// DaemonSet
        Daemonset,
        /// Deployment
        Deployment,
        /// Statefulset
        Statefulset,
        /// CADVISOR
        Cadvisor,
        /// KUBELET
        Kubelet,
        /// NVIDIA Data Center GPU Manager (DCGM)
        Dcgm,
        /// JobSet
        Jobset,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Component::value] or
        /// [Component::name].
        UnknownValue(component::UnknownValue),
    }

    #[doc(hidden)]
    pub mod component {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Component {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::SystemComponents => std::option::Option::Some(1),
                Self::Apiserver => std::option::Option::Some(3),
                Self::Scheduler => std::option::Option::Some(4),
                Self::ControllerManager => std::option::Option::Some(5),
                Self::Storage => std::option::Option::Some(7),
                Self::Hpa => std::option::Option::Some(8),
                Self::Pod => std::option::Option::Some(9),
                Self::Daemonset => std::option::Option::Some(10),
                Self::Deployment => std::option::Option::Some(11),
                Self::Statefulset => std::option::Option::Some(12),
                Self::Cadvisor => std::option::Option::Some(13),
                Self::Kubelet => std::option::Option::Some(14),
                Self::Dcgm => std::option::Option::Some(15),
                Self::Jobset => std::option::Option::Some(16),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("COMPONENT_UNSPECIFIED"),
                Self::SystemComponents => std::option::Option::Some("SYSTEM_COMPONENTS"),
                Self::Apiserver => std::option::Option::Some("APISERVER"),
                Self::Scheduler => std::option::Option::Some("SCHEDULER"),
                Self::ControllerManager => std::option::Option::Some("CONTROLLER_MANAGER"),
                Self::Storage => std::option::Option::Some("STORAGE"),
                Self::Hpa => std::option::Option::Some("HPA"),
                Self::Pod => std::option::Option::Some("POD"),
                Self::Daemonset => std::option::Option::Some("DAEMONSET"),
                Self::Deployment => std::option::Option::Some("DEPLOYMENT"),
                Self::Statefulset => std::option::Option::Some("STATEFULSET"),
                Self::Cadvisor => std::option::Option::Some("CADVISOR"),
                Self::Kubelet => std::option::Option::Some("KUBELET"),
                Self::Dcgm => std::option::Option::Some("DCGM"),
                Self::Jobset => std::option::Option::Some("JOBSET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Component {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Component {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Component {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::SystemComponents,
                3 => Self::Apiserver,
                4 => Self::Scheduler,
                5 => Self::ControllerManager,
                7 => Self::Storage,
                8 => Self::Hpa,
                9 => Self::Pod,
                10 => Self::Daemonset,
                11 => Self::Deployment,
                12 => Self::Statefulset,
                13 => Self::Cadvisor,
                14 => Self::Kubelet,
                15 => Self::Dcgm,
                16 => Self::Jobset,
                _ => Self::UnknownValue(component::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Component {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "COMPONENT_UNSPECIFIED" => Self::Unspecified,
                "SYSTEM_COMPONENTS" => Self::SystemComponents,
                "APISERVER" => Self::Apiserver,
                "SCHEDULER" => Self::Scheduler,
                "CONTROLLER_MANAGER" => Self::ControllerManager,
                "STORAGE" => Self::Storage,
                "HPA" => Self::Hpa,
                "POD" => Self::Pod,
                "DAEMONSET" => Self::Daemonset,
                "DEPLOYMENT" => Self::Deployment,
                "STATEFULSET" => Self::Statefulset,
                "CADVISOR" => Self::Cadvisor,
                "KUBELET" => Self::Kubelet,
                "DCGM" => Self::Dcgm,
                "JOBSET" => Self::Jobset,
                _ => Self::UnknownValue(component::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Component {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::SystemComponents => serializer.serialize_i32(1),
                Self::Apiserver => serializer.serialize_i32(3),
                Self::Scheduler => serializer.serialize_i32(4),
                Self::ControllerManager => serializer.serialize_i32(5),
                Self::Storage => serializer.serialize_i32(7),
                Self::Hpa => serializer.serialize_i32(8),
                Self::Pod => serializer.serialize_i32(9),
                Self::Daemonset => serializer.serialize_i32(10),
                Self::Deployment => serializer.serialize_i32(11),
                Self::Statefulset => serializer.serialize_i32(12),
                Self::Cadvisor => serializer.serialize_i32(13),
                Self::Kubelet => serializer.serialize_i32(14),
                Self::Dcgm => serializer.serialize_i32(15),
                Self::Jobset => serializer.serialize_i32(16),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Component {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Component>::new(
                ".google.container.v1.MonitoringComponentConfig.Component",
            ))
        }
    }
}

/// ManagedPrometheusConfig defines the configuration for
/// Google Cloud Managed Service for Prometheus.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagedPrometheusConfig {
    /// Enable Managed Collection.
    pub enabled: bool,

    /// GKE Workload Auto-Monitoring Configuration.
    pub auto_monitoring_config: std::option::Option<crate::model::AutoMonitoringConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedPrometheusConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::ManagedPrometheusConfig::enabled].
    pub fn set_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enabled = v.into();
        self
    }

    /// Sets the value of [auto_monitoring_config][crate::model::ManagedPrometheusConfig::auto_monitoring_config].
    pub fn set_auto_monitoring_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutoMonitoringConfig>,
    {
        self.auto_monitoring_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auto_monitoring_config][crate::model::ManagedPrometheusConfig::auto_monitoring_config].
    pub fn set_or_clear_auto_monitoring_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutoMonitoringConfig>,
    {
        self.auto_monitoring_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ManagedPrometheusConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ManagedPrometheusConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManagedPrometheusConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __auto_monitoring_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedPrometheusConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "autoMonitoringConfig" => Ok(__FieldTag::__auto_monitoring_config),
                            "auto_monitoring_config" => Ok(__FieldTag::__auto_monitoring_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManagedPrometheusConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedPrometheusConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_monitoring_config => {
                            if !fields.insert(__FieldTag::__auto_monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_monitoring_config",
                                ));
                            }
                            result.auto_monitoring_config = map.next_value::<std::option::Option<crate::model::AutoMonitoringConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManagedPrometheusConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.auto_monitoring_config.is_some() {
            state.serialize_entry("autoMonitoringConfig", &self.auto_monitoring_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ManagedPrometheusConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManagedPrometheusConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("auto_monitoring_config", &self.auto_monitoring_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AutoMonitoringConfig defines the configuration for GKE Workload
/// Auto-Monitoring.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoMonitoringConfig {
    /// Scope for GKE Workload Auto-Monitoring.
    pub scope: crate::model::auto_monitoring_config::Scope,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoMonitoringConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [scope][crate::model::AutoMonitoringConfig::scope].
    pub fn set_scope<T: std::convert::Into<crate::model::auto_monitoring_config::Scope>>(
        mut self,
        v: T,
    ) -> Self {
        self.scope = v.into();
        self
    }
}

impl wkt::message::Message for AutoMonitoringConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.AutoMonitoringConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutoMonitoringConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoMonitoringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutoMonitoringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoMonitoringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope =
                                map.next_value::<std::option::Option<
                                    crate::model::auto_monitoring_config::Scope,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutoMonitoringConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutoMonitoringConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoMonitoringConfig");
        debug_struct.field("scope", &self.scope);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AutoMonitoringConfig].
pub mod auto_monitoring_config {
    #[allow(unused_imports)]
    use super::*;

    /// Scope for applications monitored by Auto-Monitoring
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Scope {
        /// Not set.
        Unspecified,
        /// Auto-Monitoring is enabled for all supported applications.
        All,
        /// Disable Auto-Monitoring.
        None,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Scope::value] or
        /// [Scope::name].
        UnknownValue(scope::UnknownValue),
    }

    #[doc(hidden)]
    pub mod scope {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Scope {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::All => std::option::Option::Some(1),
                Self::None => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCOPE_UNSPECIFIED"),
                Self::All => std::option::Option::Some("ALL"),
                Self::None => std::option::Option::Some("NONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Scope {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Scope {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Scope {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::All,
                2 => Self::None,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Scope {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCOPE_UNSPECIFIED" => Self::Unspecified,
                "ALL" => Self::All,
                "NONE" => Self::None,
                _ => Self::UnknownValue(scope::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Scope {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::All => serializer.serialize_i32(1),
                Self::None => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Scope {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Scope>::new(
                ".google.container.v1.AutoMonitoringConfig.Scope",
            ))
        }
    }
}

/// PodAutoscaling is used for configuration of parameters
/// for workload autoscaling.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PodAutoscaling {
    /// Selected Horizontal Pod Autoscaling profile.
    pub hpa_profile: std::option::Option<crate::model::pod_autoscaling::HPAProfile>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PodAutoscaling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hpa_profile][crate::model::PodAutoscaling::hpa_profile].
    pub fn set_hpa_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::pod_autoscaling::HPAProfile>,
    {
        self.hpa_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hpa_profile][crate::model::PodAutoscaling::hpa_profile].
    pub fn set_or_clear_hpa_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::pod_autoscaling::HPAProfile>,
    {
        self.hpa_profile = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PodAutoscaling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.PodAutoscaling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PodAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hpa_profile,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PodAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hpaProfile" => Ok(__FieldTag::__hpa_profile),
                            "hpa_profile" => Ok(__FieldTag::__hpa_profile),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PodAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PodAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hpa_profile => {
                            if !fields.insert(__FieldTag::__hpa_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hpa_profile",
                                ));
                            }
                            result.hpa_profile = map.next_value::<std::option::Option<crate::model::pod_autoscaling::HPAProfile>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PodAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.hpa_profile.is_some() {
            state.serialize_entry("hpaProfile", &self.hpa_profile)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PodAutoscaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PodAutoscaling");
        debug_struct.field("hpa_profile", &self.hpa_profile);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PodAutoscaling].
pub mod pod_autoscaling {
    #[allow(unused_imports)]
    use super::*;

    /// Possible types of Horizontal Pod Autoscaling profile.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum HPAProfile {
        /// HPA_PROFILE_UNSPECIFIED is used when no custom HPA profile is set.
        Unspecified,
        /// Customers explicitly opt-out of HPA profiles.
        None,
        /// PERFORMANCE is used when customers opt-in to the performance HPA profile.
        /// In this profile we support a higher number of HPAs per cluster and faster
        /// metrics collection for workload autoscaling.
        Performance,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [HPAProfile::value] or
        /// [HPAProfile::name].
        UnknownValue(hpa_profile::UnknownValue),
    }

    #[doc(hidden)]
    pub mod hpa_profile {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl HPAProfile {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Performance => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("HPA_PROFILE_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Performance => std::option::Option::Some("PERFORMANCE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for HPAProfile {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for HPAProfile {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for HPAProfile {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Performance,
                _ => Self::UnknownValue(hpa_profile::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for HPAProfile {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HPA_PROFILE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "PERFORMANCE" => Self::Performance,
                _ => Self::UnknownValue(hpa_profile::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for HPAProfile {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Performance => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for HPAProfile {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<HPAProfile>::new(
                ".google.container.v1.PodAutoscaling.HPAProfile",
            ))
        }
    }
}

/// Fleet is the fleet configuration for the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Fleet {
    /// The Fleet host project(project ID or project number) where this cluster
    /// will be registered to. This field cannot be changed after the cluster has
    /// been registered.
    pub project: std::string::String,

    /// Output only. The full resource name of the registered fleet membership of
    /// the cluster, in the format
    /// `//gkehub.googleapis.com/projects/*/locations/*/memberships/*`.
    pub membership: std::string::String,

    /// Output only. Whether the cluster has been registered through the fleet
    /// API.
    pub pre_registered: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Fleet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::Fleet::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [membership][crate::model::Fleet::membership].
    pub fn set_membership<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.membership = v.into();
        self
    }

    /// Sets the value of [pre_registered][crate::model::Fleet::pre_registered].
    pub fn set_pre_registered<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.pre_registered = v.into();
        self
    }
}

impl wkt::message::Message for Fleet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.Fleet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Fleet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __membership,
            __pre_registered,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fleet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "membership" => Ok(__FieldTag::__membership),
                            "preRegistered" => Ok(__FieldTag::__pre_registered),
                            "pre_registered" => Ok(__FieldTag::__pre_registered),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Fleet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fleet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__membership => {
                            if !fields.insert(__FieldTag::__membership) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for membership",
                                ));
                            }
                            result.membership = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pre_registered => {
                            if !fields.insert(__FieldTag::__pre_registered) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pre_registered",
                                ));
                            }
                            result.pre_registered = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Fleet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.membership.is_empty() {
            state.serialize_entry("membership", &self.membership)?;
        }
        if !wkt::internal::is_default(&self.pre_registered) {
            state.serialize_entry("preRegistered", &self.pre_registered)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Fleet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Fleet");
        debug_struct.field("project", &self.project);
        debug_struct.field("membership", &self.membership);
        debug_struct.field("pre_registered", &self.pre_registered);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for all of the cluster's control plane endpoints.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ControlPlaneEndpointsConfig {
    /// DNS endpoint configuration.
    pub dns_endpoint_config:
        std::option::Option<crate::model::control_plane_endpoints_config::DNSEndpointConfig>,

    /// IP endpoints configuration.
    pub ip_endpoints_config:
        std::option::Option<crate::model::control_plane_endpoints_config::IPEndpointsConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ControlPlaneEndpointsConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dns_endpoint_config][crate::model::ControlPlaneEndpointsConfig::dns_endpoint_config].
    pub fn set_dns_endpoint_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::control_plane_endpoints_config::DNSEndpointConfig>,
    {
        self.dns_endpoint_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dns_endpoint_config][crate::model::ControlPlaneEndpointsConfig::dns_endpoint_config].
    pub fn set_or_clear_dns_endpoint_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::control_plane_endpoints_config::DNSEndpointConfig>,
    {
        self.dns_endpoint_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ip_endpoints_config][crate::model::ControlPlaneEndpointsConfig::ip_endpoints_config].
    pub fn set_ip_endpoints_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::control_plane_endpoints_config::IPEndpointsConfig>,
    {
        self.ip_endpoints_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_endpoints_config][crate::model::ControlPlaneEndpointsConfig::ip_endpoints_config].
    pub fn set_or_clear_ip_endpoints_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::control_plane_endpoints_config::IPEndpointsConfig>,
    {
        self.ip_endpoints_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ControlPlaneEndpointsConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ControlPlaneEndpointsConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ControlPlaneEndpointsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dns_endpoint_config,
            __ip_endpoints_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ControlPlaneEndpointsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dnsEndpointConfig" => Ok(__FieldTag::__dns_endpoint_config),
                            "dns_endpoint_config" => Ok(__FieldTag::__dns_endpoint_config),
                            "ipEndpointsConfig" => Ok(__FieldTag::__ip_endpoints_config),
                            "ip_endpoints_config" => Ok(__FieldTag::__ip_endpoints_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ControlPlaneEndpointsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ControlPlaneEndpointsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dns_endpoint_config => {
                            if !fields.insert(__FieldTag::__dns_endpoint_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_endpoint_config",
                                ));
                            }
                            result.dns_endpoint_config = map.next_value::<std::option::Option<
                                crate::model::control_plane_endpoints_config::DNSEndpointConfig,
                            >>()?;
                        }
                        __FieldTag::__ip_endpoints_config => {
                            if !fields.insert(__FieldTag::__ip_endpoints_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_endpoints_config",
                                ));
                            }
                            result.ip_endpoints_config = map.next_value::<std::option::Option<
                                crate::model::control_plane_endpoints_config::IPEndpointsConfig,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ControlPlaneEndpointsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dns_endpoint_config.is_some() {
            state.serialize_entry("dnsEndpointConfig", &self.dns_endpoint_config)?;
        }
        if self.ip_endpoints_config.is_some() {
            state.serialize_entry("ipEndpointsConfig", &self.ip_endpoints_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ControlPlaneEndpointsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ControlPlaneEndpointsConfig");
        debug_struct.field("dns_endpoint_config", &self.dns_endpoint_config);
        debug_struct.field("ip_endpoints_config", &self.ip_endpoints_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ControlPlaneEndpointsConfig].
pub mod control_plane_endpoints_config {
    #[allow(unused_imports)]
    use super::*;

    /// Describes the configuration of a DNS endpoint.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DNSEndpointConfig {
        /// Output only. The cluster's DNS endpoint configuration.
        /// A DNS format address. This is accessible from the public internet.
        /// Ex: uid.us-central1.gke.goog.
        /// Always present, but the behavior may change according to the value of
        /// [DNSEndpointConfig.allow_external_traffic][google.container.v1.ControlPlaneEndpointsConfig.DNSEndpointConfig.allow_external_traffic].
        ///
        /// [google.container.v1.ControlPlaneEndpointsConfig.DNSEndpointConfig.allow_external_traffic]: crate::model::control_plane_endpoints_config::DNSEndpointConfig::allow_external_traffic
        pub endpoint: std::string::String,

        /// Controls whether user traffic is allowed over this endpoint. Note that
        /// GCP-managed services may still use the endpoint even if this is false.
        pub allow_external_traffic: std::option::Option<bool>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DNSEndpointConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [endpoint][crate::model::control_plane_endpoints_config::DNSEndpointConfig::endpoint].
        pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.endpoint = v.into();
            self
        }

        /// Sets the value of [allow_external_traffic][crate::model::control_plane_endpoints_config::DNSEndpointConfig::allow_external_traffic].
        pub fn set_allow_external_traffic<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.allow_external_traffic = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [allow_external_traffic][crate::model::control_plane_endpoints_config::DNSEndpointConfig::allow_external_traffic].
        pub fn set_or_clear_allow_external_traffic<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.allow_external_traffic = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DNSEndpointConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ControlPlaneEndpointsConfig.DNSEndpointConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DNSEndpointConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __endpoint,
                __allow_external_traffic,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DNSEndpointConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "endpoint" => Ok(__FieldTag::__endpoint),
                                "allowExternalTraffic" => Ok(__FieldTag::__allow_external_traffic),
                                "allow_external_traffic" => {
                                    Ok(__FieldTag::__allow_external_traffic)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DNSEndpointConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DNSEndpointConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__endpoint => {
                                if !fields.insert(__FieldTag::__endpoint) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for endpoint",
                                    ));
                                }
                                result.endpoint = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allow_external_traffic => {
                                if !fields.insert(__FieldTag::__allow_external_traffic) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_external_traffic",
                                    ));
                                }
                                result.allow_external_traffic =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DNSEndpointConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.endpoint.is_empty() {
                state.serialize_entry("endpoint", &self.endpoint)?;
            }
            if self.allow_external_traffic.is_some() {
                state.serialize_entry("allowExternalTraffic", &self.allow_external_traffic)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DNSEndpointConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DNSEndpointConfig");
            debug_struct.field("endpoint", &self.endpoint);
            debug_struct.field("allow_external_traffic", &self.allow_external_traffic);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// IP endpoints configuration.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IPEndpointsConfig {
        /// Controls whether to allow direct IP access.
        pub enabled: std::option::Option<bool>,

        /// Controls whether the control plane allows access through a public IP.
        /// It is invalid to specify both
        /// [PrivateClusterConfig.enablePrivateEndpoint][] and this field at the same
        /// time.
        pub enable_public_endpoint: std::option::Option<bool>,

        /// Controls whether the control plane's private endpoint is accessible from
        /// sources in other regions.
        /// It is invalid to specify both
        /// [PrivateClusterMasterGlobalAccessConfig.enabled][google.container.v1.PrivateClusterMasterGlobalAccessConfig.enabled]
        /// and this field at the same time.
        ///
        /// [google.container.v1.PrivateClusterMasterGlobalAccessConfig.enabled]: crate::model::PrivateClusterMasterGlobalAccessConfig::enabled
        pub global_access: std::option::Option<bool>,

        /// Configuration of authorized networks. If enabled, restricts access to the
        /// control plane based on source IP.
        /// It is invalid to specify both
        /// [Cluster.masterAuthorizedNetworksConfig][] and this field at the same
        /// time.
        pub authorized_networks_config:
            std::option::Option<crate::model::MasterAuthorizedNetworksConfig>,

        /// Output only. The external IP address of this cluster's control plane.
        /// Only populated if enabled.
        pub public_endpoint: std::string::String,

        /// Output only. The internal IP address of this cluster's control plane.
        /// Only populated if enabled.
        pub private_endpoint: std::string::String,

        /// Subnet to provision the master's private endpoint during cluster
        /// creation. Specified in projects/*/regions/*/subnetworks/* format. It is
        /// invalid to specify both
        /// [PrivateClusterConfig.privateEndpointSubnetwork][] and this field at the
        /// same time.
        pub private_endpoint_subnetwork: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IPEndpointsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enabled][crate::model::control_plane_endpoints_config::IPEndpointsConfig::enabled].
        pub fn set_enabled<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.enabled = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [enabled][crate::model::control_plane_endpoints_config::IPEndpointsConfig::enabled].
        pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.enabled = v.map(|x| x.into());
            self
        }

        /// Sets the value of [enable_public_endpoint][crate::model::control_plane_endpoints_config::IPEndpointsConfig::enable_public_endpoint].
        pub fn set_enable_public_endpoint<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.enable_public_endpoint = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [enable_public_endpoint][crate::model::control_plane_endpoints_config::IPEndpointsConfig::enable_public_endpoint].
        pub fn set_or_clear_enable_public_endpoint<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.enable_public_endpoint = v.map(|x| x.into());
            self
        }

        /// Sets the value of [global_access][crate::model::control_plane_endpoints_config::IPEndpointsConfig::global_access].
        pub fn set_global_access<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.global_access = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [global_access][crate::model::control_plane_endpoints_config::IPEndpointsConfig::global_access].
        pub fn set_or_clear_global_access<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.global_access = v.map(|x| x.into());
            self
        }

        /// Sets the value of [authorized_networks_config][crate::model::control_plane_endpoints_config::IPEndpointsConfig::authorized_networks_config].
        pub fn set_authorized_networks_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::MasterAuthorizedNetworksConfig>,
        {
            self.authorized_networks_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [authorized_networks_config][crate::model::control_plane_endpoints_config::IPEndpointsConfig::authorized_networks_config].
        pub fn set_or_clear_authorized_networks_config<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::MasterAuthorizedNetworksConfig>,
        {
            self.authorized_networks_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [public_endpoint][crate::model::control_plane_endpoints_config::IPEndpointsConfig::public_endpoint].
        pub fn set_public_endpoint<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.public_endpoint = v.into();
            self
        }

        /// Sets the value of [private_endpoint][crate::model::control_plane_endpoints_config::IPEndpointsConfig::private_endpoint].
        pub fn set_private_endpoint<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.private_endpoint = v.into();
            self
        }

        /// Sets the value of [private_endpoint_subnetwork][crate::model::control_plane_endpoints_config::IPEndpointsConfig::private_endpoint_subnetwork].
        pub fn set_private_endpoint_subnetwork<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.private_endpoint_subnetwork = v.into();
            self
        }
    }

    impl wkt::message::Message for IPEndpointsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.container.v1.ControlPlaneEndpointsConfig.IPEndpointsConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IPEndpointsConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enabled,
                __enable_public_endpoint,
                __global_access,
                __authorized_networks_config,
                __public_endpoint,
                __private_endpoint,
                __private_endpoint_subnetwork,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IPEndpointsConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enabled" => Ok(__FieldTag::__enabled),
                                "enablePublicEndpoint" => Ok(__FieldTag::__enable_public_endpoint),
                                "enable_public_endpoint" => {
                                    Ok(__FieldTag::__enable_public_endpoint)
                                }
                                "globalAccess" => Ok(__FieldTag::__global_access),
                                "global_access" => Ok(__FieldTag::__global_access),
                                "authorizedNetworksConfig" => {
                                    Ok(__FieldTag::__authorized_networks_config)
                                }
                                "authorized_networks_config" => {
                                    Ok(__FieldTag::__authorized_networks_config)
                                }
                                "publicEndpoint" => Ok(__FieldTag::__public_endpoint),
                                "public_endpoint" => Ok(__FieldTag::__public_endpoint),
                                "privateEndpoint" => Ok(__FieldTag::__private_endpoint),
                                "private_endpoint" => Ok(__FieldTag::__private_endpoint),
                                "privateEndpointSubnetwork" => {
                                    Ok(__FieldTag::__private_endpoint_subnetwork)
                                }
                                "private_endpoint_subnetwork" => {
                                    Ok(__FieldTag::__private_endpoint_subnetwork)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IPEndpointsConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IPEndpointsConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enabled => {
                                if !fields.insert(__FieldTag::__enabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enabled",
                                    ));
                                }
                                result.enabled = map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__enable_public_endpoint => {
                                if !fields.insert(__FieldTag::__enable_public_endpoint) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_public_endpoint",
                                    ));
                                }
                                result.enable_public_endpoint =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__global_access => {
                                if !fields.insert(__FieldTag::__global_access) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for global_access",
                                    ));
                                }
                                result.global_access =
                                    map.next_value::<std::option::Option<bool>>()?;
                            }
                            __FieldTag::__authorized_networks_config => {
                                if !fields.insert(__FieldTag::__authorized_networks_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for authorized_networks_config",
                                    ));
                                }
                                result.authorized_networks_config = map
                                    .next_value::<std::option::Option<
                                        crate::model::MasterAuthorizedNetworksConfig,
                                    >>()?;
                            }
                            __FieldTag::__public_endpoint => {
                                if !fields.insert(__FieldTag::__public_endpoint) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for public_endpoint",
                                    ));
                                }
                                result.public_endpoint = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__private_endpoint => {
                                if !fields.insert(__FieldTag::__private_endpoint) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for private_endpoint",
                                    ));
                                }
                                result.private_endpoint = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__private_endpoint_subnetwork => {
                                if !fields.insert(__FieldTag::__private_endpoint_subnetwork) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for private_endpoint_subnetwork",
                                    ));
                                }
                                result.private_endpoint_subnetwork = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IPEndpointsConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.enabled.is_some() {
                state.serialize_entry("enabled", &self.enabled)?;
            }
            if self.enable_public_endpoint.is_some() {
                state.serialize_entry("enablePublicEndpoint", &self.enable_public_endpoint)?;
            }
            if self.global_access.is_some() {
                state.serialize_entry("globalAccess", &self.global_access)?;
            }
            if self.authorized_networks_config.is_some() {
                state.serialize_entry(
                    "authorizedNetworksConfig",
                    &self.authorized_networks_config,
                )?;
            }
            if !self.public_endpoint.is_empty() {
                state.serialize_entry("publicEndpoint", &self.public_endpoint)?;
            }
            if !self.private_endpoint.is_empty() {
                state.serialize_entry("privateEndpoint", &self.private_endpoint)?;
            }
            if !self.private_endpoint_subnetwork.is_empty() {
                state.serialize_entry(
                    "privateEndpointSubnetwork",
                    &self.private_endpoint_subnetwork,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for IPEndpointsConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("IPEndpointsConfig");
            debug_struct.field("enabled", &self.enabled);
            debug_struct.field("enable_public_endpoint", &self.enable_public_endpoint);
            debug_struct.field("global_access", &self.global_access);
            debug_struct.field(
                "authorized_networks_config",
                &self.authorized_networks_config,
            );
            debug_struct.field("public_endpoint", &self.public_endpoint);
            debug_struct.field("private_endpoint", &self.private_endpoint);
            debug_struct.field(
                "private_endpoint_subnetwork",
                &self.private_endpoint_subnetwork,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// LocalNvmeSsdBlockConfig contains configuration for using raw-block local
/// NVMe SSDs
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocalNvmeSsdBlockConfig {
    /// Number of local NVMe SSDs to use.  The limit for this value is dependent
    /// upon the maximum number of disk available on a machine per zone. See:
    /// <https://cloud.google.com/compute/docs/disks/local-ssd>
    /// for more information.
    ///
    /// A zero (or unset) value has different meanings depending on machine type
    /// being used:
    ///
    /// 1. For pre-Gen3 machines, which support flexible numbers of local ssds,
    ///    zero (or unset) means to disable using local SSDs as ephemeral storage.
    /// 1. For Gen3 machines which dictate a specific number of local ssds, zero
    ///    (or unset) means to use the default number of local ssds that goes with
    ///    that machine type. For example, for a c3-standard-8-lssd machine, 2 local
    ///    ssds would be provisioned. For c3-standard-8 (which doesn't support local
    ///    ssds), 0 will be provisioned. See
    ///    <https://cloud.google.com/compute/docs/disks/local-ssd#choose_number_local_ssds>
    ///    for more info.
    pub local_ssd_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocalNvmeSsdBlockConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [local_ssd_count][crate::model::LocalNvmeSsdBlockConfig::local_ssd_count].
    pub fn set_local_ssd_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.local_ssd_count = v.into();
        self
    }
}

impl wkt::message::Message for LocalNvmeSsdBlockConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.LocalNvmeSsdBlockConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocalNvmeSsdBlockConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __local_ssd_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocalNvmeSsdBlockConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "localSsdCount" => Ok(__FieldTag::__local_ssd_count),
                            "local_ssd_count" => Ok(__FieldTag::__local_ssd_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocalNvmeSsdBlockConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocalNvmeSsdBlockConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__local_ssd_count => {
                            if !fields.insert(__FieldTag::__local_ssd_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_ssd_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.local_ssd_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocalNvmeSsdBlockConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.local_ssd_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("localSsdCount", &__With(&self.local_ssd_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LocalNvmeSsdBlockConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocalNvmeSsdBlockConfig");
        debug_struct.field("local_ssd_count", &self.local_ssd_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// EphemeralStorageLocalSsdConfig contains configuration for the node ephemeral
/// storage using Local SSDs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EphemeralStorageLocalSsdConfig {
    /// Number of local SSDs to use to back ephemeral storage. Uses NVMe
    /// interfaces.
    ///
    /// A zero (or unset) value has different meanings depending on machine type
    /// being used:
    ///
    /// 1. For pre-Gen3 machines, which support flexible numbers of local ssds,
    ///    zero (or unset) means to disable using local SSDs as ephemeral storage. The
    ///    limit for this value is dependent upon the maximum number of disk
    ///    available on a machine per zone. See:
    ///    <https://cloud.google.com/compute/docs/disks/local-ssd>
    ///    for more information.
    /// 1. For Gen3 machines which dictate a specific number of local ssds, zero
    ///    (or unset) means to use the default number of local ssds that goes with
    ///    that machine type. For example, for a c3-standard-8-lssd machine, 2 local
    ///    ssds would be provisioned. For c3-standard-8 (which doesn't support local
    ///    ssds), 0 will be provisioned. See
    ///    <https://cloud.google.com/compute/docs/disks/local-ssd#choose_number_local_ssds>
    ///    for more info.
    pub local_ssd_count: i32,

    /// Number of local SSDs to use for GKE Data Cache.
    pub data_cache_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EphemeralStorageLocalSsdConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [local_ssd_count][crate::model::EphemeralStorageLocalSsdConfig::local_ssd_count].
    pub fn set_local_ssd_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.local_ssd_count = v.into();
        self
    }

    /// Sets the value of [data_cache_count][crate::model::EphemeralStorageLocalSsdConfig::data_cache_count].
    pub fn set_data_cache_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.data_cache_count = v.into();
        self
    }
}

impl wkt::message::Message for EphemeralStorageLocalSsdConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.EphemeralStorageLocalSsdConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EphemeralStorageLocalSsdConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __local_ssd_count,
            __data_cache_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EphemeralStorageLocalSsdConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "localSsdCount" => Ok(__FieldTag::__local_ssd_count),
                            "local_ssd_count" => Ok(__FieldTag::__local_ssd_count),
                            "dataCacheCount" => Ok(__FieldTag::__data_cache_count),
                            "data_cache_count" => Ok(__FieldTag::__data_cache_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EphemeralStorageLocalSsdConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EphemeralStorageLocalSsdConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__local_ssd_count => {
                            if !fields.insert(__FieldTag::__local_ssd_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_ssd_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.local_ssd_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_cache_count => {
                            if !fields.insert(__FieldTag::__data_cache_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_cache_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_cache_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EphemeralStorageLocalSsdConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.local_ssd_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("localSsdCount", &__With(&self.local_ssd_count))?;
        }
        if !wkt::internal::is_default(&self.data_cache_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("dataCacheCount", &__With(&self.data_cache_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EphemeralStorageLocalSsdConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EphemeralStorageLocalSsdConfig");
        debug_struct.field("local_ssd_count", &self.local_ssd_count);
        debug_struct.field("data_cache_count", &self.data_cache_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A map of resource manager tag keys and values to be attached to the nodes
/// for managing Compute Engine firewalls using Network Firewall Policies.
/// Tags must be according to specifications in
/// <https://cloud.google.com/vpc/docs/tags-firewalls-overview#specifications>.
/// A maximum of 5 tag key-value pairs can be specified.
/// Existing tags will be replaced with new values.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceManagerTags {
    /// TagKeyValue must be in one of the following formats ([KEY]=[VALUE])
    ///
    /// 1. `tagKeys/{tag_key_id}=tagValues/{tag_value_id}`
    /// 1. `{org_id}/{tag_key_name}={tag_value_name}`
    /// 1. `{project_id}/{tag_key_name}={tag_value_name}`
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResourceManagerTags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tags][crate::model::ResourceManagerTags::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ResourceManagerTags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ResourceManagerTags"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResourceManagerTags {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceManagerTags")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResourceManagerTags;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceManagerTags")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResourceManagerTags {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResourceManagerTags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceManagerTags");
        debug_struct.field("tags", &self.tags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// EnterpriseConfig is the cluster enterprise configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnterpriseConfig {
    /// Output only. cluster_tier indicates the effective tier of the cluster.
    pub cluster_tier: crate::model::enterprise_config::ClusterTier,

    /// desired_tier specifies the desired tier of the cluster.
    pub desired_tier: crate::model::enterprise_config::ClusterTier,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_tier][crate::model::EnterpriseConfig::cluster_tier].
    pub fn set_cluster_tier<T: std::convert::Into<crate::model::enterprise_config::ClusterTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_tier = v.into();
        self
    }

    /// Sets the value of [desired_tier][crate::model::EnterpriseConfig::desired_tier].
    pub fn set_desired_tier<T: std::convert::Into<crate::model::enterprise_config::ClusterTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.desired_tier = v.into();
        self
    }
}

impl wkt::message::Message for EnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.EnterpriseConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnterpriseConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_tier,
            __desired_tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnterpriseConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterTier" => Ok(__FieldTag::__cluster_tier),
                            "cluster_tier" => Ok(__FieldTag::__cluster_tier),
                            "desiredTier" => Ok(__FieldTag::__desired_tier),
                            "desired_tier" => Ok(__FieldTag::__desired_tier),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnterpriseConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnterpriseConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_tier => {
                            if !fields.insert(__FieldTag::__cluster_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_tier",
                                ));
                            }
                            result.cluster_tier =
                                map.next_value::<std::option::Option<
                                    crate::model::enterprise_config::ClusterTier,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_tier => {
                            if !fields.insert(__FieldTag::__desired_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_tier",
                                ));
                            }
                            result.desired_tier =
                                map.next_value::<std::option::Option<
                                    crate::model::enterprise_config::ClusterTier,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnterpriseConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cluster_tier) {
            state.serialize_entry("clusterTier", &self.cluster_tier)?;
        }
        if !wkt::internal::is_default(&self.desired_tier) {
            state.serialize_entry("desiredTier", &self.desired_tier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnterpriseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnterpriseConfig");
        debug_struct.field("cluster_tier", &self.cluster_tier);
        debug_struct.field("desired_tier", &self.desired_tier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [EnterpriseConfig].
pub mod enterprise_config {
    #[allow(unused_imports)]
    use super::*;

    /// Premium tiers for GKE Cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClusterTier {
        /// CLUSTER_TIER_UNSPECIFIED is when cluster_tier is not set.
        Unspecified,
        /// STANDARD indicates a standard GKE cluster.
        Standard,
        /// ENTERPRISE indicates a GKE Enterprise cluster.
        Enterprise,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ClusterTier::value] or
        /// [ClusterTier::name].
        UnknownValue(cluster_tier::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cluster_tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ClusterTier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Enterprise => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLUSTER_TIER_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Enterprise => std::option::Option::Some("ENTERPRISE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ClusterTier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ClusterTier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ClusterTier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::Enterprise,
                _ => Self::UnknownValue(cluster_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ClusterTier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLUSTER_TIER_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                "ENTERPRISE" => Self::Enterprise,
                _ => Self::UnknownValue(cluster_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ClusterTier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Enterprise => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ClusterTier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ClusterTier>::new(
                ".google.container.v1.EnterpriseConfig.ClusterTier",
            ))
        }
    }
}

/// SecretManagerConfig is config for secret manager enablement.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecretManagerConfig {
    /// Enable/Disable Secret Manager Config.
    pub enabled: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretManagerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enabled][crate::model::SecretManagerConfig::enabled].
    pub fn set_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enabled][crate::model::SecretManagerConfig::enabled].
    pub fn set_or_clear_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enabled = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SecretManagerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SecretManagerConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecretManagerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretManagerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecretManagerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretManagerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecretManagerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SecretManagerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretManagerConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// BootDisk specifies the boot disk configuration for nodepools.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BootDisk {
    /// Disk type of the boot disk.
    /// (i.e. Hyperdisk-Balanced, PD-Balanced, etc.)
    pub disk_type: std::string::String,

    /// Disk size in GB. Replaces NodeConfig.disk_size_gb
    pub size_gb: i64,

    /// For Hyperdisk-Balanced only, the provisioned IOPS config value.
    pub provisioned_iops: i64,

    /// For Hyperdisk-Balanced only, the provisioned throughput config value.
    pub provisioned_throughput: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BootDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_type][crate::model::BootDisk::disk_type].
    pub fn set_disk_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::BootDisk::size_gb].
    pub fn set_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }

    /// Sets the value of [provisioned_iops][crate::model::BootDisk::provisioned_iops].
    pub fn set_provisioned_iops<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.provisioned_iops = v.into();
        self
    }

    /// Sets the value of [provisioned_throughput][crate::model::BootDisk::provisioned_throughput].
    pub fn set_provisioned_throughput<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.provisioned_throughput = v.into();
        self
    }
}

impl wkt::message::Message for BootDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.BootDisk"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BootDisk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disk_type,
            __size_gb,
            __provisioned_iops,
            __provisioned_throughput,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BootDisk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "sizeGb" => Ok(__FieldTag::__size_gb),
                            "size_gb" => Ok(__FieldTag::__size_gb),
                            "provisionedIops" => Ok(__FieldTag::__provisioned_iops),
                            "provisioned_iops" => Ok(__FieldTag::__provisioned_iops),
                            "provisionedThroughput" => Ok(__FieldTag::__provisioned_throughput),
                            "provisioned_throughput" => Ok(__FieldTag::__provisioned_throughput),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BootDisk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BootDisk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_gb => {
                            if !fields.insert(__FieldTag::__size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__provisioned_iops => {
                            if !fields.insert(__FieldTag::__provisioned_iops) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioned_iops",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.provisioned_iops =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__provisioned_throughput => {
                            if !fields.insert(__FieldTag::__provisioned_throughput) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioned_throughput",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.provisioned_throughput =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BootDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.disk_type.is_empty() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !wkt::internal::is_default(&self.size_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
        }
        if !wkt::internal::is_default(&self.provisioned_iops) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("provisionedIops", &__With(&self.provisioned_iops))?;
        }
        if !wkt::internal::is_default(&self.provisioned_throughput) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "provisionedThroughput",
                &__With(&self.provisioned_throughput),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BootDisk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BootDisk");
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("size_gb", &self.size_gb);
        debug_struct.field("provisioned_iops", &self.provisioned_iops);
        debug_struct.field("provisioned_throughput", &self.provisioned_throughput);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SecondaryBootDisk represents a persistent disk attached to a node
/// with special configurations based on its mode.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecondaryBootDisk {
    /// Disk mode (container image cache, etc.)
    pub mode: crate::model::secondary_boot_disk::Mode,

    /// Fully-qualified resource ID for an existing disk image.
    pub disk_image: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecondaryBootDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::SecondaryBootDisk::mode].
    pub fn set_mode<T: std::convert::Into<crate::model::secondary_boot_disk::Mode>>(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [disk_image][crate::model::SecondaryBootDisk::disk_image].
    pub fn set_disk_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_image = v.into();
        self
    }
}

impl wkt::message::Message for SecondaryBootDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SecondaryBootDisk"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecondaryBootDisk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __disk_image,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecondaryBootDisk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "diskImage" => Ok(__FieldTag::__disk_image),
                            "disk_image" => Ok(__FieldTag::__disk_image),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecondaryBootDisk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecondaryBootDisk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::secondary_boot_disk::Mode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__disk_image => {
                            if !fields.insert(__FieldTag::__disk_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_image",
                                ));
                            }
                            result.disk_image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecondaryBootDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self.disk_image.is_empty() {
            state.serialize_entry("diskImage", &self.disk_image)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SecondaryBootDisk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecondaryBootDisk");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("disk_image", &self.disk_image);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SecondaryBootDisk].
pub mod secondary_boot_disk {
    #[allow(unused_imports)]
    use super::*;

    /// Mode specifies how the secondary boot disk will be used.
    /// This triggers mode-specified logic in the control plane.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// MODE_UNSPECIFIED is when mode is not set.
        Unspecified,
        /// CONTAINER_IMAGE_CACHE is for using the secondary boot disk as
        /// a container image cache.
        ContainerImageCache,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ContainerImageCache => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MODE_UNSPECIFIED"),
                Self::ContainerImageCache => std::option::Option::Some("CONTAINER_IMAGE_CACHE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ContainerImageCache,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MODE_UNSPECIFIED" => Self::Unspecified,
                "CONTAINER_IMAGE_CACHE" => Self::ContainerImageCache,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ContainerImageCache => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.container.v1.SecondaryBootDisk.Mode",
            ))
        }
    }
}

/// SecondaryBootDiskUpdateStrategy is a placeholder which will be extended
/// in the future to define different options for updating secondary boot disks.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SecondaryBootDiskUpdateStrategy {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecondaryBootDiskUpdateStrategy {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SecondaryBootDiskUpdateStrategy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.SecondaryBootDiskUpdateStrategy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SecondaryBootDiskUpdateStrategy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecondaryBootDiskUpdateStrategy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SecondaryBootDiskUpdateStrategy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecondaryBootDiskUpdateStrategy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SecondaryBootDiskUpdateStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SecondaryBootDiskUpdateStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecondaryBootDiskUpdateStrategy");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// FetchClusterUpgradeInfoRequest fetches the upgrade information of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchClusterUpgradeInfoRequest {
    /// Required. The name (project, location, cluster) of the cluster to get.
    /// Specified in the format `projects/*/locations/*/clusters/*` or
    /// `projects/*/zones/*/clusters/*`.
    pub name: std::string::String,

    /// API request version that initiates this operation.
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchClusterUpgradeInfoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchClusterUpgradeInfoRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::FetchClusterUpgradeInfoRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for FetchClusterUpgradeInfoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.FetchClusterUpgradeInfoRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchClusterUpgradeInfoRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchClusterUpgradeInfoRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchClusterUpgradeInfoRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchClusterUpgradeInfoRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchClusterUpgradeInfoRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchClusterUpgradeInfoRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchClusterUpgradeInfoRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ClusterUpgradeInfo contains the upgrade information of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterUpgradeInfo {
    /// minor_target_version indicates the target version for minor upgrade.
    pub minor_target_version: std::option::Option<std::string::String>,

    /// patch_target_version indicates the target version for patch upgrade.
    pub patch_target_version: std::option::Option<std::string::String>,

    /// The auto upgrade status.
    pub auto_upgrade_status: std::vec::Vec<crate::model::cluster_upgrade_info::AutoUpgradeStatus>,

    /// The auto upgrade paused reason.
    pub paused_reason: std::vec::Vec<crate::model::cluster_upgrade_info::AutoUpgradePausedReason>,

    /// The list of past auto upgrades.
    pub upgrade_details: std::vec::Vec<crate::model::UpgradeDetails>,

    /// The cluster's current minor version's end of standard support timestamp.
    pub end_of_standard_support_timestamp: std::option::Option<std::string::String>,

    /// The cluster's current minor version's end of extended support timestamp.
    pub end_of_extended_support_timestamp: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterUpgradeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [minor_target_version][crate::model::ClusterUpgradeInfo::minor_target_version].
    pub fn set_minor_target_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.minor_target_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minor_target_version][crate::model::ClusterUpgradeInfo::minor_target_version].
    pub fn set_or_clear_minor_target_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.minor_target_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [patch_target_version][crate::model::ClusterUpgradeInfo::patch_target_version].
    pub fn set_patch_target_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.patch_target_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [patch_target_version][crate::model::ClusterUpgradeInfo::patch_target_version].
    pub fn set_or_clear_patch_target_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.patch_target_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [auto_upgrade_status][crate::model::ClusterUpgradeInfo::auto_upgrade_status].
    pub fn set_auto_upgrade_status<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::cluster_upgrade_info::AutoUpgradeStatus>,
    {
        use std::iter::Iterator;
        self.auto_upgrade_status = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [paused_reason][crate::model::ClusterUpgradeInfo::paused_reason].
    pub fn set_paused_reason<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::cluster_upgrade_info::AutoUpgradePausedReason>,
    {
        use std::iter::Iterator;
        self.paused_reason = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [upgrade_details][crate::model::ClusterUpgradeInfo::upgrade_details].
    pub fn set_upgrade_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpgradeDetails>,
    {
        use std::iter::Iterator;
        self.upgrade_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [end_of_standard_support_timestamp][crate::model::ClusterUpgradeInfo::end_of_standard_support_timestamp].
    pub fn set_end_of_standard_support_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_of_standard_support_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_of_standard_support_timestamp][crate::model::ClusterUpgradeInfo::end_of_standard_support_timestamp].
    pub fn set_or_clear_end_of_standard_support_timestamp<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_of_standard_support_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_of_extended_support_timestamp][crate::model::ClusterUpgradeInfo::end_of_extended_support_timestamp].
    pub fn set_end_of_extended_support_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_of_extended_support_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_of_extended_support_timestamp][crate::model::ClusterUpgradeInfo::end_of_extended_support_timestamp].
    pub fn set_or_clear_end_of_extended_support_timestamp<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_of_extended_support_timestamp = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ClusterUpgradeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.ClusterUpgradeInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterUpgradeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __minor_target_version,
            __patch_target_version,
            __auto_upgrade_status,
            __paused_reason,
            __upgrade_details,
            __end_of_standard_support_timestamp,
            __end_of_extended_support_timestamp,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterUpgradeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minorTargetVersion" => Ok(__FieldTag::__minor_target_version),
                            "minor_target_version" => Ok(__FieldTag::__minor_target_version),
                            "patchTargetVersion" => Ok(__FieldTag::__patch_target_version),
                            "patch_target_version" => Ok(__FieldTag::__patch_target_version),
                            "autoUpgradeStatus" => Ok(__FieldTag::__auto_upgrade_status),
                            "auto_upgrade_status" => Ok(__FieldTag::__auto_upgrade_status),
                            "pausedReason" => Ok(__FieldTag::__paused_reason),
                            "paused_reason" => Ok(__FieldTag::__paused_reason),
                            "upgradeDetails" => Ok(__FieldTag::__upgrade_details),
                            "upgrade_details" => Ok(__FieldTag::__upgrade_details),
                            "endOfStandardSupportTimestamp" => {
                                Ok(__FieldTag::__end_of_standard_support_timestamp)
                            }
                            "end_of_standard_support_timestamp" => {
                                Ok(__FieldTag::__end_of_standard_support_timestamp)
                            }
                            "endOfExtendedSupportTimestamp" => {
                                Ok(__FieldTag::__end_of_extended_support_timestamp)
                            }
                            "end_of_extended_support_timestamp" => {
                                Ok(__FieldTag::__end_of_extended_support_timestamp)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterUpgradeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterUpgradeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__minor_target_version => {
                            if !fields.insert(__FieldTag::__minor_target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minor_target_version",
                                ));
                            }
                            result.minor_target_version =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__patch_target_version => {
                            if !fields.insert(__FieldTag::__patch_target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_target_version",
                                ));
                            }
                            result.patch_target_version =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__auto_upgrade_status => {
                            if !fields.insert(__FieldTag::__auto_upgrade_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_upgrade_status",
                                ));
                            }
                            result.auto_upgrade_status = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::cluster_upgrade_info::AutoUpgradeStatus,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__paused_reason => {
                            if !fields.insert(__FieldTag::__paused_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paused_reason",
                                ));
                            }
                            result.paused_reason = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::cluster_upgrade_info::AutoUpgradePausedReason,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgrade_details => {
                            if !fields.insert(__FieldTag::__upgrade_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_details",
                                ));
                            }
                            result.upgrade_details =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UpgradeDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_of_standard_support_timestamp => {
                            if !fields.insert(__FieldTag::__end_of_standard_support_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_standard_support_timestamp",
                                ));
                            }
                            result.end_of_standard_support_timestamp =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__end_of_extended_support_timestamp => {
                            if !fields.insert(__FieldTag::__end_of_extended_support_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_extended_support_timestamp",
                                ));
                            }
                            result.end_of_extended_support_timestamp =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterUpgradeInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.minor_target_version.is_some() {
            state.serialize_entry("minorTargetVersion", &self.minor_target_version)?;
        }
        if self.patch_target_version.is_some() {
            state.serialize_entry("patchTargetVersion", &self.patch_target_version)?;
        }
        if !self.auto_upgrade_status.is_empty() {
            state.serialize_entry("autoUpgradeStatus", &self.auto_upgrade_status)?;
        }
        if !self.paused_reason.is_empty() {
            state.serialize_entry("pausedReason", &self.paused_reason)?;
        }
        if !self.upgrade_details.is_empty() {
            state.serialize_entry("upgradeDetails", &self.upgrade_details)?;
        }
        if self.end_of_standard_support_timestamp.is_some() {
            state.serialize_entry(
                "endOfStandardSupportTimestamp",
                &self.end_of_standard_support_timestamp,
            )?;
        }
        if self.end_of_extended_support_timestamp.is_some() {
            state.serialize_entry(
                "endOfExtendedSupportTimestamp",
                &self.end_of_extended_support_timestamp,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClusterUpgradeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterUpgradeInfo");
        debug_struct.field("minor_target_version", &self.minor_target_version);
        debug_struct.field("patch_target_version", &self.patch_target_version);
        debug_struct.field("auto_upgrade_status", &self.auto_upgrade_status);
        debug_struct.field("paused_reason", &self.paused_reason);
        debug_struct.field("upgrade_details", &self.upgrade_details);
        debug_struct.field(
            "end_of_standard_support_timestamp",
            &self.end_of_standard_support_timestamp,
        );
        debug_struct.field(
            "end_of_extended_support_timestamp",
            &self.end_of_extended_support_timestamp,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ClusterUpgradeInfo].
pub mod cluster_upgrade_info {
    #[allow(unused_imports)]
    use super::*;

    /// AutoUpgradeStatus indicates the status of auto upgrade.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoUpgradeStatus {
        /// UNKNOWN indicates an unknown status.
        Unknown,
        /// ACTIVE indicates an active status.
        Active,
        /// MINOR_UPGRADE_PAUSED indicates the minor version upgrade is
        /// paused.
        MinorUpgradePaused,
        /// UPGRADE_PAUSED indicates the upgrade is paused.
        UpgradePaused,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoUpgradeStatus::value] or
        /// [AutoUpgradeStatus::name].
        UnknownValue(auto_upgrade_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod auto_upgrade_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AutoUpgradeStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::MinorUpgradePaused => std::option::Option::Some(4),
                Self::UpgradePaused => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::MinorUpgradePaused => std::option::Option::Some("MINOR_UPGRADE_PAUSED"),
                Self::UpgradePaused => std::option::Option::Some("UPGRADE_PAUSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AutoUpgradeStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AutoUpgradeStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AutoUpgradeStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Active,
                4 => Self::MinorUpgradePaused,
                5 => Self::UpgradePaused,
                _ => Self::UnknownValue(auto_upgrade_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AutoUpgradeStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "ACTIVE" => Self::Active,
                "MINOR_UPGRADE_PAUSED" => Self::MinorUpgradePaused,
                "UPGRADE_PAUSED" => Self::UpgradePaused,
                _ => Self::UnknownValue(auto_upgrade_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AutoUpgradeStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::MinorUpgradePaused => serializer.serialize_i32(4),
                Self::UpgradePaused => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AutoUpgradeStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoUpgradeStatus>::new(
                ".google.container.v1.ClusterUpgradeInfo.AutoUpgradeStatus",
            ))
        }
    }

    /// AutoUpgradePausedReason indicates the reason for auto upgrade paused
    /// status.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoUpgradePausedReason {
        /// AUTO_UPGRADE_PAUSED_REASON_UNSPECIFIED indicates an unspecified reason.
        Unspecified,
        /// MAINTENANCE_WINDOW indicates the cluster is outside customer maintenance
        /// window.
        MaintenanceWindow,
        /// MAINTENANCE_EXCLUSION_NO_UPGRADES indicates the cluster is in a
        /// maintenance exclusion with scope NO_UPGRADES.
        MaintenanceExclusionNoUpgrades,
        /// MAINTENANCE_EXCLUSION_NO_MINOR_UPGRADES indicates the cluster is in a
        /// maintenance exclusion with scope NO_MINOR_UPGRADES.
        MaintenanceExclusionNoMinorUpgrades,
        /// CLUSTER_DISRUPTION_BUDGET indicates the cluster is outside the cluster
        /// disruption budget.
        ClusterDisruptionBudget,
        /// CLUSTER_DISRUPTION_BUDGET_MINOR_UPGRADE indicates the cluster is outside
        /// the cluster disruption budget for minor version upgrade.
        ClusterDisruptionBudgetMinorUpgrade,
        /// SYSTEM_CONFIG indicates the cluster upgrade is paused  by system config.
        SystemConfig,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoUpgradePausedReason::value] or
        /// [AutoUpgradePausedReason::name].
        UnknownValue(auto_upgrade_paused_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod auto_upgrade_paused_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AutoUpgradePausedReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MaintenanceWindow => std::option::Option::Some(1),
                Self::MaintenanceExclusionNoUpgrades => std::option::Option::Some(5),
                Self::MaintenanceExclusionNoMinorUpgrades => std::option::Option::Some(6),
                Self::ClusterDisruptionBudget => std::option::Option::Some(4),
                Self::ClusterDisruptionBudgetMinorUpgrade => std::option::Option::Some(7),
                Self::SystemConfig => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("AUTO_UPGRADE_PAUSED_REASON_UNSPECIFIED")
                }
                Self::MaintenanceWindow => std::option::Option::Some("MAINTENANCE_WINDOW"),
                Self::MaintenanceExclusionNoUpgrades => {
                    std::option::Option::Some("MAINTENANCE_EXCLUSION_NO_UPGRADES")
                }
                Self::MaintenanceExclusionNoMinorUpgrades => {
                    std::option::Option::Some("MAINTENANCE_EXCLUSION_NO_MINOR_UPGRADES")
                }
                Self::ClusterDisruptionBudget => {
                    std::option::Option::Some("CLUSTER_DISRUPTION_BUDGET")
                }
                Self::ClusterDisruptionBudgetMinorUpgrade => {
                    std::option::Option::Some("CLUSTER_DISRUPTION_BUDGET_MINOR_UPGRADE")
                }
                Self::SystemConfig => std::option::Option::Some("SYSTEM_CONFIG"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AutoUpgradePausedReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AutoUpgradePausedReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AutoUpgradePausedReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MaintenanceWindow,
                4 => Self::ClusterDisruptionBudget,
                5 => Self::MaintenanceExclusionNoUpgrades,
                6 => Self::MaintenanceExclusionNoMinorUpgrades,
                7 => Self::ClusterDisruptionBudgetMinorUpgrade,
                8 => Self::SystemConfig,
                _ => Self::UnknownValue(auto_upgrade_paused_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AutoUpgradePausedReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTO_UPGRADE_PAUSED_REASON_UNSPECIFIED" => Self::Unspecified,
                "MAINTENANCE_WINDOW" => Self::MaintenanceWindow,
                "MAINTENANCE_EXCLUSION_NO_UPGRADES" => Self::MaintenanceExclusionNoUpgrades,
                "MAINTENANCE_EXCLUSION_NO_MINOR_UPGRADES" => {
                    Self::MaintenanceExclusionNoMinorUpgrades
                }
                "CLUSTER_DISRUPTION_BUDGET" => Self::ClusterDisruptionBudget,
                "CLUSTER_DISRUPTION_BUDGET_MINOR_UPGRADE" => {
                    Self::ClusterDisruptionBudgetMinorUpgrade
                }
                "SYSTEM_CONFIG" => Self::SystemConfig,
                _ => Self::UnknownValue(auto_upgrade_paused_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AutoUpgradePausedReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MaintenanceWindow => serializer.serialize_i32(1),
                Self::MaintenanceExclusionNoUpgrades => serializer.serialize_i32(5),
                Self::MaintenanceExclusionNoMinorUpgrades => serializer.serialize_i32(6),
                Self::ClusterDisruptionBudget => serializer.serialize_i32(4),
                Self::ClusterDisruptionBudgetMinorUpgrade => serializer.serialize_i32(7),
                Self::SystemConfig => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AutoUpgradePausedReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<AutoUpgradePausedReason>::new(
                    ".google.container.v1.ClusterUpgradeInfo.AutoUpgradePausedReason",
                ),
            )
        }
    }
}

/// UpgradeDetails contains detailed information of each individual upgrade
/// operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeDetails {
    /// Output only. The state of the upgrade.
    pub state: crate::model::upgrade_details::State,

    /// The start timestamp of the upgrade.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end timestamp of the upgrade.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The version before the upgrade.
    pub initial_version: std::string::String,

    /// The version after the upgrade.
    pub target_version: std::string::String,

    /// The start type of the upgrade.
    pub start_type: crate::model::upgrade_details::StartType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [state][crate::model::UpgradeDetails::state].
    pub fn set_state<T: std::convert::Into<crate::model::upgrade_details::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::UpgradeDetails::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpgradeDetails::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UpgradeDetails::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UpgradeDetails::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initial_version][crate::model::UpgradeDetails::initial_version].
    pub fn set_initial_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.initial_version = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeDetails::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [start_type][crate::model::UpgradeDetails::start_type].
    pub fn set_start_type<T: std::convert::Into<crate::model::upgrade_details::StartType>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_type = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.UpgradeDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __start_time,
            __end_time,
            __initial_version,
            __target_version,
            __start_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "initialVersion" => Ok(__FieldTag::__initial_version),
                            "initial_version" => Ok(__FieldTag::__initial_version),
                            "targetVersion" => Ok(__FieldTag::__target_version),
                            "target_version" => Ok(__FieldTag::__target_version),
                            "startType" => Ok(__FieldTag::__start_type),
                            "start_type" => Ok(__FieldTag::__start_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::upgrade_details::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__initial_version => {
                            if !fields.insert(__FieldTag::__initial_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_version",
                                ));
                            }
                            result.initial_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version => {
                            if !fields.insert(__FieldTag::__target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version",
                                ));
                            }
                            result.target_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_type => {
                            if !fields.insert(__FieldTag::__start_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_type",
                                ));
                            }
                            result.start_type = map.next_value::<std::option::Option<crate::model::upgrade_details::StartType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.initial_version.is_empty() {
            state.serialize_entry("initialVersion", &self.initial_version)?;
        }
        if !self.target_version.is_empty() {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !wkt::internal::is_default(&self.start_type) {
            state.serialize_entry("startType", &self.start_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpgradeDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeDetails");
        debug_struct.field("state", &self.state);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("initial_version", &self.initial_version);
        debug_struct.field("target_version", &self.target_version);
        debug_struct.field("start_type", &self.start_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [UpgradeDetails].
pub mod upgrade_details {
    #[allow(unused_imports)]
    use super::*;

    /// State indicates the state of the upgrade.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Upgrade state is unknown.
        Unknown,
        /// Upgrade has failed with an error.
        Failed,
        /// Upgrade has succeeded.
        Succeeded,
        /// Upgrade has been canceled.
        Canceled,
        /// Upgrade is running.
        Running,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Failed => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Canceled => std::option::Option::Some(3),
                Self::Running => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Canceled => std::option::Option::Some("CANCELED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Failed,
                2 => Self::Succeeded,
                3 => Self::Canceled,
                4 => Self::Running,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELED" => Self::Canceled,
                "RUNNING" => Self::Running,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Failed => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Canceled => serializer.serialize_i32(3),
                Self::Running => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.container.v1.UpgradeDetails.State",
            ))
        }
    }

    /// StartType indicates the type of starting the upgrade.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StartType {
        /// Upgrade start type is unspecified.
        Unspecified,
        /// Upgrade started automatically.
        Automatic,
        /// Upgrade started manually.
        Manual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StartType::value] or
        /// [StartType::name].
        UnknownValue(start_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod start_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StartType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Automatic => std::option::Option::Some(1),
                Self::Manual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("START_TYPE_UNSPECIFIED"),
                Self::Automatic => std::option::Option::Some("AUTOMATIC"),
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StartType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StartType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StartType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Automatic,
                2 => Self::Manual,
                _ => Self::UnknownValue(start_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StartType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "START_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC" => Self::Automatic,
                "MANUAL" => Self::Manual,
                _ => Self::UnknownValue(start_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StartType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Automatic => serializer.serialize_i32(1),
                Self::Manual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StartType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StartType>::new(
                ".google.container.v1.UpgradeDetails.StartType",
            ))
        }
    }
}

/// FetchNodePoolUpgradeInfoRequest fetches the upgrade information of a
/// nodepool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchNodePoolUpgradeInfoRequest {
    /// Required. The name (project, location, cluster, nodepool) of the nodepool
    /// to get. Specified in the format
    /// `projects/*/locations/*/clusters/*/nodePools/*` or
    /// `projects/*/zones/*/clusters/*/nodePools/*`.
    pub name: std::string::String,

    /// API request version that initiates this operation.
    pub version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchNodePoolUpgradeInfoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchNodePoolUpgradeInfoRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::FetchNodePoolUpgradeInfoRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for FetchNodePoolUpgradeInfoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.FetchNodePoolUpgradeInfoRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchNodePoolUpgradeInfoRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchNodePoolUpgradeInfoRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchNodePoolUpgradeInfoRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchNodePoolUpgradeInfoRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchNodePoolUpgradeInfoRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchNodePoolUpgradeInfoRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchNodePoolUpgradeInfoRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// NodePoolUpgradeInfo contains the upgrade information of a nodepool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodePoolUpgradeInfo {
    /// minor_target_version indicates the target version for minor upgrade.
    pub minor_target_version: std::option::Option<std::string::String>,

    /// patch_target_version indicates the target version for patch upgrade.
    pub patch_target_version: std::option::Option<std::string::String>,

    /// The auto upgrade status.
    pub auto_upgrade_status: std::vec::Vec<crate::model::node_pool_upgrade_info::AutoUpgradeStatus>,

    /// The auto upgrade paused reason.
    pub paused_reason: std::vec::Vec<crate::model::node_pool_upgrade_info::AutoUpgradePausedReason>,

    /// The list of past auto upgrades.
    pub upgrade_details: std::vec::Vec<crate::model::UpgradeDetails>,

    /// The nodepool's current minor version's end of standard support timestamp.
    pub end_of_standard_support_timestamp: std::option::Option<std::string::String>,

    /// The nodepool's current minor version's end of extended support timestamp.
    pub end_of_extended_support_timestamp: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePoolUpgradeInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [minor_target_version][crate::model::NodePoolUpgradeInfo::minor_target_version].
    pub fn set_minor_target_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.minor_target_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minor_target_version][crate::model::NodePoolUpgradeInfo::minor_target_version].
    pub fn set_or_clear_minor_target_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.minor_target_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [patch_target_version][crate::model::NodePoolUpgradeInfo::patch_target_version].
    pub fn set_patch_target_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.patch_target_version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [patch_target_version][crate::model::NodePoolUpgradeInfo::patch_target_version].
    pub fn set_or_clear_patch_target_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.patch_target_version = v.map(|x| x.into());
        self
    }

    /// Sets the value of [auto_upgrade_status][crate::model::NodePoolUpgradeInfo::auto_upgrade_status].
    pub fn set_auto_upgrade_status<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::node_pool_upgrade_info::AutoUpgradeStatus>,
    {
        use std::iter::Iterator;
        self.auto_upgrade_status = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [paused_reason][crate::model::NodePoolUpgradeInfo::paused_reason].
    pub fn set_paused_reason<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::node_pool_upgrade_info::AutoUpgradePausedReason>,
    {
        use std::iter::Iterator;
        self.paused_reason = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [upgrade_details][crate::model::NodePoolUpgradeInfo::upgrade_details].
    pub fn set_upgrade_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpgradeDetails>,
    {
        use std::iter::Iterator;
        self.upgrade_details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [end_of_standard_support_timestamp][crate::model::NodePoolUpgradeInfo::end_of_standard_support_timestamp].
    pub fn set_end_of_standard_support_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_of_standard_support_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_of_standard_support_timestamp][crate::model::NodePoolUpgradeInfo::end_of_standard_support_timestamp].
    pub fn set_or_clear_end_of_standard_support_timestamp<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_of_standard_support_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_of_extended_support_timestamp][crate::model::NodePoolUpgradeInfo::end_of_extended_support_timestamp].
    pub fn set_end_of_extended_support_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_of_extended_support_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_of_extended_support_timestamp][crate::model::NodePoolUpgradeInfo::end_of_extended_support_timestamp].
    pub fn set_or_clear_end_of_extended_support_timestamp<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_of_extended_support_timestamp = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodePoolUpgradeInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.NodePoolUpgradeInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodePoolUpgradeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __minor_target_version,
            __patch_target_version,
            __auto_upgrade_status,
            __paused_reason,
            __upgrade_details,
            __end_of_standard_support_timestamp,
            __end_of_extended_support_timestamp,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePoolUpgradeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minorTargetVersion" => Ok(__FieldTag::__minor_target_version),
                            "minor_target_version" => Ok(__FieldTag::__minor_target_version),
                            "patchTargetVersion" => Ok(__FieldTag::__patch_target_version),
                            "patch_target_version" => Ok(__FieldTag::__patch_target_version),
                            "autoUpgradeStatus" => Ok(__FieldTag::__auto_upgrade_status),
                            "auto_upgrade_status" => Ok(__FieldTag::__auto_upgrade_status),
                            "pausedReason" => Ok(__FieldTag::__paused_reason),
                            "paused_reason" => Ok(__FieldTag::__paused_reason),
                            "upgradeDetails" => Ok(__FieldTag::__upgrade_details),
                            "upgrade_details" => Ok(__FieldTag::__upgrade_details),
                            "endOfStandardSupportTimestamp" => {
                                Ok(__FieldTag::__end_of_standard_support_timestamp)
                            }
                            "end_of_standard_support_timestamp" => {
                                Ok(__FieldTag::__end_of_standard_support_timestamp)
                            }
                            "endOfExtendedSupportTimestamp" => {
                                Ok(__FieldTag::__end_of_extended_support_timestamp)
                            }
                            "end_of_extended_support_timestamp" => {
                                Ok(__FieldTag::__end_of_extended_support_timestamp)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodePoolUpgradeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePoolUpgradeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__minor_target_version => {
                            if !fields.insert(__FieldTag::__minor_target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minor_target_version",
                                ));
                            }
                            result.minor_target_version =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__patch_target_version => {
                            if !fields.insert(__FieldTag::__patch_target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_target_version",
                                ));
                            }
                            result.patch_target_version =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__auto_upgrade_status => {
                            if !fields.insert(__FieldTag::__auto_upgrade_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_upgrade_status",
                                ));
                            }
                            result.auto_upgrade_status = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::node_pool_upgrade_info::AutoUpgradeStatus,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__paused_reason => {
                            if !fields.insert(__FieldTag::__paused_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paused_reason",
                                ));
                            }
                            result.paused_reason = map.next_value::<std::option::Option<std::vec::Vec<crate::model::node_pool_upgrade_info::AutoUpgradePausedReason>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__upgrade_details => {
                            if !fields.insert(__FieldTag::__upgrade_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_details",
                                ));
                            }
                            result.upgrade_details =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UpgradeDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_of_standard_support_timestamp => {
                            if !fields.insert(__FieldTag::__end_of_standard_support_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_standard_support_timestamp",
                                ));
                            }
                            result.end_of_standard_support_timestamp =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__end_of_extended_support_timestamp => {
                            if !fields.insert(__FieldTag::__end_of_extended_support_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_extended_support_timestamp",
                                ));
                            }
                            result.end_of_extended_support_timestamp =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodePoolUpgradeInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.minor_target_version.is_some() {
            state.serialize_entry("minorTargetVersion", &self.minor_target_version)?;
        }
        if self.patch_target_version.is_some() {
            state.serialize_entry("patchTargetVersion", &self.patch_target_version)?;
        }
        if !self.auto_upgrade_status.is_empty() {
            state.serialize_entry("autoUpgradeStatus", &self.auto_upgrade_status)?;
        }
        if !self.paused_reason.is_empty() {
            state.serialize_entry("pausedReason", &self.paused_reason)?;
        }
        if !self.upgrade_details.is_empty() {
            state.serialize_entry("upgradeDetails", &self.upgrade_details)?;
        }
        if self.end_of_standard_support_timestamp.is_some() {
            state.serialize_entry(
                "endOfStandardSupportTimestamp",
                &self.end_of_standard_support_timestamp,
            )?;
        }
        if self.end_of_extended_support_timestamp.is_some() {
            state.serialize_entry(
                "endOfExtendedSupportTimestamp",
                &self.end_of_extended_support_timestamp,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodePoolUpgradeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePoolUpgradeInfo");
        debug_struct.field("minor_target_version", &self.minor_target_version);
        debug_struct.field("patch_target_version", &self.patch_target_version);
        debug_struct.field("auto_upgrade_status", &self.auto_upgrade_status);
        debug_struct.field("paused_reason", &self.paused_reason);
        debug_struct.field("upgrade_details", &self.upgrade_details);
        debug_struct.field(
            "end_of_standard_support_timestamp",
            &self.end_of_standard_support_timestamp,
        );
        debug_struct.field(
            "end_of_extended_support_timestamp",
            &self.end_of_extended_support_timestamp,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NodePoolUpgradeInfo].
pub mod node_pool_upgrade_info {
    #[allow(unused_imports)]
    use super::*;

    /// AutoUpgradeStatus indicates the status of auto upgrade.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoUpgradeStatus {
        /// UNKNOWN indicates an unknown status.
        Unknown,
        /// ACTIVE indicates an active status.
        Active,
        /// MINOR_UPGRADE_PAUSED indicates the minor version upgrade is
        /// paused.
        MinorUpgradePaused,
        /// UPGRADE_PAUSED indicates the upgrade is paused.
        UpgradePaused,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoUpgradeStatus::value] or
        /// [AutoUpgradeStatus::name].
        UnknownValue(auto_upgrade_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod auto_upgrade_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AutoUpgradeStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unknown => std::option::Option::Some(0),
                Self::Active => std::option::Option::Some(1),
                Self::MinorUpgradePaused => std::option::Option::Some(2),
                Self::UpgradePaused => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::MinorUpgradePaused => std::option::Option::Some("MINOR_UPGRADE_PAUSED"),
                Self::UpgradePaused => std::option::Option::Some("UPGRADE_PAUSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AutoUpgradeStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AutoUpgradeStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AutoUpgradeStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unknown,
                1 => Self::Active,
                2 => Self::MinorUpgradePaused,
                3 => Self::UpgradePaused,
                _ => Self::UnknownValue(auto_upgrade_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AutoUpgradeStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNKNOWN" => Self::Unknown,
                "ACTIVE" => Self::Active,
                "MINOR_UPGRADE_PAUSED" => Self::MinorUpgradePaused,
                "UPGRADE_PAUSED" => Self::UpgradePaused,
                _ => Self::UnknownValue(auto_upgrade_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AutoUpgradeStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unknown => serializer.serialize_i32(0),
                Self::Active => serializer.serialize_i32(1),
                Self::MinorUpgradePaused => serializer.serialize_i32(2),
                Self::UpgradePaused => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AutoUpgradeStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoUpgradeStatus>::new(
                ".google.container.v1.NodePoolUpgradeInfo.AutoUpgradeStatus",
            ))
        }
    }

    /// AutoUpgradePausedReason indicates the reason for auto upgrade paused
    /// status.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoUpgradePausedReason {
        /// AUTO_UPGRADE_PAUSED_REASON_UNSPECIFIED indicates an unspecified reason.
        Unspecified,
        /// MAINTENANCE_WINDOW indicates the cluster is outside customer maintenance
        /// window.
        MaintenanceWindow,
        /// MAINTENANCE_EXCLUSION_NO_UPGRADES indicates the cluster is in a
        /// maintenance exclusion with scope NO_UPGRADES.
        MaintenanceExclusionNoUpgrades,
        /// MAINTENANCE_EXCLUSION_NO_MINOR_UPGRADES indicates the cluster is in a
        /// maintenance exclusion with scope NO_MINOR_UPGRADES.
        MaintenanceExclusionNoMinorUpgrades,
        /// SYSTEM_CONFIG indicates the cluster upgrade is paused by system config.
        SystemConfig,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoUpgradePausedReason::value] or
        /// [AutoUpgradePausedReason::name].
        UnknownValue(auto_upgrade_paused_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod auto_upgrade_paused_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AutoUpgradePausedReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MaintenanceWindow => std::option::Option::Some(1),
                Self::MaintenanceExclusionNoUpgrades => std::option::Option::Some(2),
                Self::MaintenanceExclusionNoMinorUpgrades => std::option::Option::Some(3),
                Self::SystemConfig => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("AUTO_UPGRADE_PAUSED_REASON_UNSPECIFIED")
                }
                Self::MaintenanceWindow => std::option::Option::Some("MAINTENANCE_WINDOW"),
                Self::MaintenanceExclusionNoUpgrades => {
                    std::option::Option::Some("MAINTENANCE_EXCLUSION_NO_UPGRADES")
                }
                Self::MaintenanceExclusionNoMinorUpgrades => {
                    std::option::Option::Some("MAINTENANCE_EXCLUSION_NO_MINOR_UPGRADES")
                }
                Self::SystemConfig => std::option::Option::Some("SYSTEM_CONFIG"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AutoUpgradePausedReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AutoUpgradePausedReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AutoUpgradePausedReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MaintenanceWindow,
                2 => Self::MaintenanceExclusionNoUpgrades,
                3 => Self::MaintenanceExclusionNoMinorUpgrades,
                4 => Self::SystemConfig,
                _ => Self::UnknownValue(auto_upgrade_paused_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AutoUpgradePausedReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTO_UPGRADE_PAUSED_REASON_UNSPECIFIED" => Self::Unspecified,
                "MAINTENANCE_WINDOW" => Self::MaintenanceWindow,
                "MAINTENANCE_EXCLUSION_NO_UPGRADES" => Self::MaintenanceExclusionNoUpgrades,
                "MAINTENANCE_EXCLUSION_NO_MINOR_UPGRADES" => {
                    Self::MaintenanceExclusionNoMinorUpgrades
                }
                "SYSTEM_CONFIG" => Self::SystemConfig,
                _ => Self::UnknownValue(auto_upgrade_paused_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AutoUpgradePausedReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MaintenanceWindow => serializer.serialize_i32(1),
                Self::MaintenanceExclusionNoUpgrades => serializer.serialize_i32(2),
                Self::MaintenanceExclusionNoMinorUpgrades => serializer.serialize_i32(3),
                Self::SystemConfig => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AutoUpgradePausedReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<AutoUpgradePausedReason>::new(
                    ".google.container.v1.NodePoolUpgradeInfo.AutoUpgradePausedReason",
                ),
            )
        }
    }
}

/// GkeAutoUpgradeConfig is the configuration for GKE auto upgrades.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GkeAutoUpgradeConfig {
    /// PatchMode specifies how auto upgrade patch builds should be
    /// selected.
    pub patch_mode: crate::model::gke_auto_upgrade_config::PatchMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GkeAutoUpgradeConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [patch_mode][crate::model::GkeAutoUpgradeConfig::patch_mode].
    pub fn set_patch_mode<
        T: std::convert::Into<crate::model::gke_auto_upgrade_config::PatchMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.patch_mode = v.into();
        self
    }
}

impl wkt::message::Message for GkeAutoUpgradeConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.container.v1.GkeAutoUpgradeConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GkeAutoUpgradeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patch_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GkeAutoUpgradeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patchMode" => Ok(__FieldTag::__patch_mode),
                            "patch_mode" => Ok(__FieldTag::__patch_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GkeAutoUpgradeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GkeAutoUpgradeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patch_mode => {
                            if !fields.insert(__FieldTag::__patch_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_mode",
                                ));
                            }
                            result.patch_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::gke_auto_upgrade_config::PatchMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GkeAutoUpgradeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.patch_mode) {
            state.serialize_entry("patchMode", &self.patch_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GkeAutoUpgradeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GkeAutoUpgradeConfig");
        debug_struct.field("patch_mode", &self.patch_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GkeAutoUpgradeConfig].
pub mod gke_auto_upgrade_config {
    #[allow(unused_imports)]
    use super::*;

    /// PatchMode specifies how auto upgrade patch builds should be
    /// selected.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PatchMode {
        /// PATCH_MODE_UNSPECIFIED defaults to using the upgrade target from the
        /// channel's patch upgrade targets as the upgrade target for the
        /// version.
        Unspecified,
        /// ACCELERATED denotes that the latest patch build in the channel should be
        /// used as the upgrade target for the version.
        Accelerated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PatchMode::value] or
        /// [PatchMode::name].
        UnknownValue(patch_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod patch_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PatchMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Accelerated => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PATCH_MODE_UNSPECIFIED"),
                Self::Accelerated => std::option::Option::Some("ACCELERATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PatchMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PatchMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PatchMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Accelerated,
                _ => Self::UnknownValue(patch_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PatchMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PATCH_MODE_UNSPECIFIED" => Self::Unspecified,
                "ACCELERATED" => Self::Accelerated,
                _ => Self::UnknownValue(patch_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PatchMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Accelerated => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PatchMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PatchMode>::new(
                ".google.container.v1.GkeAutoUpgradeConfig.PatchMode",
            ))
        }
    }
}

/// PrivateIPv6GoogleAccess controls whether and how the pods can communicate
/// with Google Services through gRPC over IPv6.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum PrivateIPv6GoogleAccess {
    /// Default value. Same as DISABLED
    PrivateIpv6GoogleAccessUnspecified,
    /// No private access to or from Google Services
    PrivateIpv6GoogleAccessDisabled,
    /// Enables private IPv6 access to Google Services from GKE
    PrivateIpv6GoogleAccessToGoogle,
    /// Enables private IPv6 access to and from Google Services
    PrivateIpv6GoogleAccessBidirectional,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [PrivateIPv6GoogleAccess::value] or
    /// [PrivateIPv6GoogleAccess::name].
    UnknownValue(private_i_pv_6_google_access::UnknownValue),
}

#[doc(hidden)]
pub mod private_i_pv_6_google_access {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl PrivateIPv6GoogleAccess {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::PrivateIpv6GoogleAccessUnspecified => std::option::Option::Some(0),
            Self::PrivateIpv6GoogleAccessDisabled => std::option::Option::Some(1),
            Self::PrivateIpv6GoogleAccessToGoogle => std::option::Option::Some(2),
            Self::PrivateIpv6GoogleAccessBidirectional => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::PrivateIpv6GoogleAccessUnspecified => {
                std::option::Option::Some("PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED")
            }
            Self::PrivateIpv6GoogleAccessDisabled => {
                std::option::Option::Some("PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED")
            }
            Self::PrivateIpv6GoogleAccessToGoogle => {
                std::option::Option::Some("PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE")
            }
            Self::PrivateIpv6GoogleAccessBidirectional => {
                std::option::Option::Some("PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for PrivateIPv6GoogleAccess {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for PrivateIPv6GoogleAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for PrivateIPv6GoogleAccess {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::PrivateIpv6GoogleAccessUnspecified,
            1 => Self::PrivateIpv6GoogleAccessDisabled,
            2 => Self::PrivateIpv6GoogleAccessToGoogle,
            3 => Self::PrivateIpv6GoogleAccessBidirectional,
            _ => Self::UnknownValue(private_i_pv_6_google_access::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for PrivateIPv6GoogleAccess {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PRIVATE_IPV6_GOOGLE_ACCESS_UNSPECIFIED" => Self::PrivateIpv6GoogleAccessUnspecified,
            "PRIVATE_IPV6_GOOGLE_ACCESS_DISABLED" => Self::PrivateIpv6GoogleAccessDisabled,
            "PRIVATE_IPV6_GOOGLE_ACCESS_TO_GOOGLE" => Self::PrivateIpv6GoogleAccessToGoogle,
            "PRIVATE_IPV6_GOOGLE_ACCESS_BIDIRECTIONAL" => {
                Self::PrivateIpv6GoogleAccessBidirectional
            }
            _ => Self::UnknownValue(private_i_pv_6_google_access::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for PrivateIPv6GoogleAccess {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::PrivateIpv6GoogleAccessUnspecified => serializer.serialize_i32(0),
            Self::PrivateIpv6GoogleAccessDisabled => serializer.serialize_i32(1),
            Self::PrivateIpv6GoogleAccessToGoogle => serializer.serialize_i32(2),
            Self::PrivateIpv6GoogleAccessBidirectional => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for PrivateIPv6GoogleAccess {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<PrivateIPv6GoogleAccess>::new(
            ".google.container.v1.PrivateIPv6GoogleAccess",
        ))
    }
}

/// UpgradeResourceType is the resource type that is upgrading. It is used
/// in upgrade notifications.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum UpgradeResourceType {
    /// Default value. This shouldn't be used.
    Unspecified,
    /// Master / control plane
    Master,
    /// Node pool
    NodePool,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [UpgradeResourceType::value] or
    /// [UpgradeResourceType::name].
    UnknownValue(upgrade_resource_type::UnknownValue),
}

#[doc(hidden)]
pub mod upgrade_resource_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl UpgradeResourceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Master => std::option::Option::Some(1),
            Self::NodePool => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("UPGRADE_RESOURCE_TYPE_UNSPECIFIED"),
            Self::Master => std::option::Option::Some("MASTER"),
            Self::NodePool => std::option::Option::Some("NODE_POOL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for UpgradeResourceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for UpgradeResourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for UpgradeResourceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Master,
            2 => Self::NodePool,
            _ => Self::UnknownValue(upgrade_resource_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for UpgradeResourceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UPGRADE_RESOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "MASTER" => Self::Master,
            "NODE_POOL" => Self::NodePool,
            _ => Self::UnknownValue(upgrade_resource_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for UpgradeResourceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Master => serializer.serialize_i32(1),
            Self::NodePool => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for UpgradeResourceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<UpgradeResourceType>::new(
            ".google.container.v1.UpgradeResourceType",
        ))
    }
}

/// The datapath provider selects the implementation of the Kubernetes networking
/// model for service resolution and network policy enforcement.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DatapathProvider {
    /// Default value.
    Unspecified,
    /// Use the IPTables implementation based on kube-proxy.
    LegacyDatapath,
    /// Use the eBPF based GKE Dataplane V2 with additional features. See the [GKE
    /// Dataplane V2
    /// documentation](https://cloud.google.com/kubernetes-engine/docs/how-to/dataplane-v2)
    /// for more.
    AdvancedDatapath,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DatapathProvider::value] or
    /// [DatapathProvider::name].
    UnknownValue(datapath_provider::UnknownValue),
}

#[doc(hidden)]
pub mod datapath_provider {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DatapathProvider {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::LegacyDatapath => std::option::Option::Some(1),
            Self::AdvancedDatapath => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DATAPATH_PROVIDER_UNSPECIFIED"),
            Self::LegacyDatapath => std::option::Option::Some("LEGACY_DATAPATH"),
            Self::AdvancedDatapath => std::option::Option::Some("ADVANCED_DATAPATH"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DatapathProvider {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DatapathProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DatapathProvider {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::LegacyDatapath,
            2 => Self::AdvancedDatapath,
            _ => Self::UnknownValue(datapath_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DatapathProvider {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DATAPATH_PROVIDER_UNSPECIFIED" => Self::Unspecified,
            "LEGACY_DATAPATH" => Self::LegacyDatapath,
            "ADVANCED_DATAPATH" => Self::AdvancedDatapath,
            _ => Self::UnknownValue(datapath_provider::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DatapathProvider {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::LegacyDatapath => serializer.serialize_i32(1),
            Self::AdvancedDatapath => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DatapathProvider {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DatapathProvider>::new(
            ".google.container.v1.DatapathProvider",
        ))
    }
}

/// Strategy used for node pool update.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NodePoolUpdateStrategy {
    /// Default value if unset. GKE internally defaults the update strategy to
    /// SURGE for unspecified strategies.
    Unspecified,
    /// blue-green upgrade.
    BlueGreen,
    /// SURGE is the traditional way of upgrade a node pool.
    /// max_surge and max_unavailable determines the level of upgrade parallelism.
    Surge,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NodePoolUpdateStrategy::value] or
    /// [NodePoolUpdateStrategy::name].
    UnknownValue(node_pool_update_strategy::UnknownValue),
}

#[doc(hidden)]
pub mod node_pool_update_strategy {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NodePoolUpdateStrategy {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::BlueGreen => std::option::Option::Some(2),
            Self::Surge => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED"),
            Self::BlueGreen => std::option::Option::Some("BLUE_GREEN"),
            Self::Surge => std::option::Option::Some("SURGE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NodePoolUpdateStrategy {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NodePoolUpdateStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NodePoolUpdateStrategy {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            2 => Self::BlueGreen,
            3 => Self::Surge,
            _ => Self::UnknownValue(node_pool_update_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for NodePoolUpdateStrategy {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NODE_POOL_UPDATE_STRATEGY_UNSPECIFIED" => Self::Unspecified,
            "BLUE_GREEN" => Self::BlueGreen,
            "SURGE" => Self::Surge,
            _ => Self::UnknownValue(node_pool_update_strategy::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for NodePoolUpdateStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::BlueGreen => serializer.serialize_i32(2),
            Self::Surge => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NodePoolUpdateStrategy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NodePoolUpdateStrategy>::new(
            ".google.container.v1.NodePoolUpdateStrategy",
        ))
    }
}

/// Possible values for IP stack type
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum StackType {
    /// Default value, will be defaulted as IPV4 only
    Unspecified,
    /// Cluster is IPV4 only
    Ipv4,
    /// Cluster can use both IPv4 and IPv6
    Ipv4Ipv6,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [StackType::value] or
    /// [StackType::name].
    UnknownValue(stack_type::UnknownValue),
}

#[doc(hidden)]
pub mod stack_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl StackType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Ipv4 => std::option::Option::Some(1),
            Self::Ipv4Ipv6 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STACK_TYPE_UNSPECIFIED"),
            Self::Ipv4 => std::option::Option::Some("IPV4"),
            Self::Ipv4Ipv6 => std::option::Option::Some("IPV4_IPV6"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for StackType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for StackType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for StackType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Ipv4,
            2 => Self::Ipv4Ipv6,
            _ => Self::UnknownValue(stack_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for StackType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STACK_TYPE_UNSPECIFIED" => Self::Unspecified,
            "IPV4" => Self::Ipv4,
            "IPV4_IPV6" => Self::Ipv4Ipv6,
            _ => Self::UnknownValue(stack_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for StackType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Ipv4 => serializer.serialize_i32(1),
            Self::Ipv4Ipv6 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for StackType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<StackType>::new(
            ".google.container.v1.StackType",
        ))
    }
}

/// Possible values for IPv6 access type
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum IPv6AccessType {
    /// Default value, will be defaulted as type external.
    Ipv6AccessTypeUnspecified,
    /// Access type internal (all v6 addresses are internal IPs)
    Internal,
    /// Access type external (all v6 addresses are external IPs)
    External,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [IPv6AccessType::value] or
    /// [IPv6AccessType::name].
    UnknownValue(i_pv_6_access_type::UnknownValue),
}

#[doc(hidden)]
pub mod i_pv_6_access_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl IPv6AccessType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Ipv6AccessTypeUnspecified => std::option::Option::Some(0),
            Self::Internal => std::option::Option::Some(1),
            Self::External => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Ipv6AccessTypeUnspecified => {
                std::option::Option::Some("IPV6_ACCESS_TYPE_UNSPECIFIED")
            }
            Self::Internal => std::option::Option::Some("INTERNAL"),
            Self::External => std::option::Option::Some("EXTERNAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for IPv6AccessType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for IPv6AccessType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for IPv6AccessType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Ipv6AccessTypeUnspecified,
            1 => Self::Internal,
            2 => Self::External,
            _ => Self::UnknownValue(i_pv_6_access_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for IPv6AccessType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "IPV6_ACCESS_TYPE_UNSPECIFIED" => Self::Ipv6AccessTypeUnspecified,
            "INTERNAL" => Self::Internal,
            "EXTERNAL" => Self::External,
            _ => Self::UnknownValue(i_pv_6_access_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for IPv6AccessType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Ipv6AccessTypeUnspecified => serializer.serialize_i32(0),
            Self::Internal => serializer.serialize_i32(1),
            Self::External => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for IPv6AccessType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<IPv6AccessType>::new(
            ".google.container.v1.IPv6AccessType",
        ))
    }
}

/// Options for in-transit encryption.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum InTransitEncryptionConfig {
    /// Unspecified, will be inferred as default -
    /// IN_TRANSIT_ENCRYPTION_UNSPECIFIED.
    Unspecified,
    /// In-transit encryption is disabled.
    InTransitEncryptionDisabled,
    /// Data in-transit is encrypted using inter-node transparent encryption.
    InTransitEncryptionInterNodeTransparent,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [InTransitEncryptionConfig::value] or
    /// [InTransitEncryptionConfig::name].
    UnknownValue(in_transit_encryption_config::UnknownValue),
}

#[doc(hidden)]
pub mod in_transit_encryption_config {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl InTransitEncryptionConfig {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::InTransitEncryptionDisabled => std::option::Option::Some(1),
            Self::InTransitEncryptionInterNodeTransparent => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED")
            }
            Self::InTransitEncryptionDisabled => {
                std::option::Option::Some("IN_TRANSIT_ENCRYPTION_DISABLED")
            }
            Self::InTransitEncryptionInterNodeTransparent => {
                std::option::Option::Some("IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for InTransitEncryptionConfig {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for InTransitEncryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for InTransitEncryptionConfig {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::InTransitEncryptionDisabled,
            2 => Self::InTransitEncryptionInterNodeTransparent,
            _ => Self::UnknownValue(in_transit_encryption_config::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for InTransitEncryptionConfig {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "IN_TRANSIT_ENCRYPTION_CONFIG_UNSPECIFIED" => Self::Unspecified,
            "IN_TRANSIT_ENCRYPTION_DISABLED" => Self::InTransitEncryptionDisabled,
            "IN_TRANSIT_ENCRYPTION_INTER_NODE_TRANSPARENT" => {
                Self::InTransitEncryptionInterNodeTransparent
            }
            _ => Self::UnknownValue(in_transit_encryption_config::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for InTransitEncryptionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::InTransitEncryptionDisabled => serializer.serialize_i32(1),
            Self::InTransitEncryptionInterNodeTransparent => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for InTransitEncryptionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(
            wkt::internal::EnumVisitor::<InTransitEncryptionConfig>::new(
                ".google.container.v1.InTransitEncryptionConfig",
            ),
        )
    }
}
