// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::LinuxNodeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LinuxNodeConfig");
        debug_struct.field("sysctls", &self.sysctls);
        debug_struct.field("cgroup_mode", &self.cgroup_mode);
        debug_struct.field("hugepages", &self.hugepages);
        debug_struct.field(
            "transparent_hugepage_enabled",
            &self.transparent_hugepage_enabled,
        );
        debug_struct.field(
            "transparent_hugepage_defrag",
            &self.transparent_hugepage_defrag,
        );
        debug_struct.field("swap_config", &self.swap_config);
        debug_struct.field(
            "node_kernel_module_loading",
            &self.node_kernel_module_loading,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::linux_node_config::HugepagesConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HugepagesConfig");
        debug_struct.field("hugepage_size2m", &self.hugepage_size2m);
        debug_struct.field("hugepage_size1g", &self.hugepage_size1g);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::linux_node_config::SwapConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SwapConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("encryption_config", &self.encryption_config);
        debug_struct.field("performance_profile", &self.performance_profile);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::linux_node_config::swap_config::EncryptionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptionConfig");
        debug_struct.field("disabled", &self.disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::linux_node_config::swap_config::BootDiskProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BootDiskProfile");
        debug_struct.field("swap_size", &self.swap_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::linux_node_config::swap_config::EphemeralLocalSsdProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EphemeralLocalSsdProfile");
        debug_struct.field("swap_size", &self.swap_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::linux_node_config::swap_config::DedicatedLocalSsdProfile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DedicatedLocalSsdProfile");
        debug_struct.field("disk_count", &self.disk_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::linux_node_config::NodeKernelModuleLoading {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeKernelModuleLoading");
        debug_struct.field("policy", &self.policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WindowsNodeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WindowsNodeConfig");
        debug_struct.field("os_version", &self.os_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeKubeletConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeKubeletConfig");
        debug_struct.field("cpu_manager_policy", &self.cpu_manager_policy);
        debug_struct.field("topology_manager", &self.topology_manager);
        debug_struct.field("memory_manager", &self.memory_manager);
        debug_struct.field("cpu_cfs_quota", &self.cpu_cfs_quota);
        debug_struct.field("cpu_cfs_quota_period", &self.cpu_cfs_quota_period);
        debug_struct.field("pod_pids_limit", &self.pod_pids_limit);
        debug_struct.field(
            "insecure_kubelet_readonly_port_enabled",
            &self.insecure_kubelet_readonly_port_enabled,
        );
        debug_struct.field(
            "image_gc_low_threshold_percent",
            &self.image_gc_low_threshold_percent,
        );
        debug_struct.field(
            "image_gc_high_threshold_percent",
            &self.image_gc_high_threshold_percent,
        );
        debug_struct.field("image_minimum_gc_age", &self.image_minimum_gc_age);
        debug_struct.field("image_maximum_gc_age", &self.image_maximum_gc_age);
        debug_struct.field("container_log_max_size", &self.container_log_max_size);
        debug_struct.field("container_log_max_files", &self.container_log_max_files);
        debug_struct.field("allowed_unsafe_sysctls", &self.allowed_unsafe_sysctls);
        debug_struct.field("eviction_soft", &self.eviction_soft);
        debug_struct.field(
            "eviction_soft_grace_period",
            &self.eviction_soft_grace_period,
        );
        debug_struct.field("eviction_minimum_reclaim", &self.eviction_minimum_reclaim);
        debug_struct.field(
            "eviction_max_pod_grace_period_seconds",
            &self.eviction_max_pod_grace_period_seconds,
        );
        debug_struct.field("max_parallel_image_pulls", &self.max_parallel_image_pulls);
        debug_struct.field("single_process_oom_kill", &self.single_process_oom_kill);
        debug_struct.field(
            "shutdown_grace_period_seconds",
            &self.shutdown_grace_period_seconds,
        );
        debug_struct.field(
            "shutdown_grace_period_critical_pods_seconds",
            &self.shutdown_grace_period_critical_pods_seconds,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TopologyManager {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TopologyManager");
        debug_struct.field("policy", &self.policy);
        debug_struct.field("scope", &self.scope);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MemoryManager {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MemoryManager");
        debug_struct.field("policy", &self.policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EvictionSignals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvictionSignals");
        debug_struct.field("memory_available", &self.memory_available);
        debug_struct.field("nodefs_available", &self.nodefs_available);
        debug_struct.field("nodefs_inodes_free", &self.nodefs_inodes_free);
        debug_struct.field("imagefs_available", &self.imagefs_available);
        debug_struct.field("imagefs_inodes_free", &self.imagefs_inodes_free);
        debug_struct.field("pid_available", &self.pid_available);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EvictionGracePeriod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvictionGracePeriod");
        debug_struct.field("memory_available", &self.memory_available);
        debug_struct.field("nodefs_available", &self.nodefs_available);
        debug_struct.field("nodefs_inodes_free", &self.nodefs_inodes_free);
        debug_struct.field("imagefs_available", &self.imagefs_available);
        debug_struct.field("imagefs_inodes_free", &self.imagefs_inodes_free);
        debug_struct.field("pid_available", &self.pid_available);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EvictionMinimumReclaim {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EvictionMinimumReclaim");
        debug_struct.field("memory_available", &self.memory_available);
        debug_struct.field("nodefs_available", &self.nodefs_available);
        debug_struct.field("nodefs_inodes_free", &self.nodefs_inodes_free);
        debug_struct.field("imagefs_available", &self.imagefs_available);
        debug_struct.field("imagefs_inodes_free", &self.imagefs_inodes_free);
        debug_struct.field("pid_available", &self.pid_available);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeConfig");
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field("oauth_scopes", &self.oauth_scopes);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("image_type", &self.image_type);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("local_ssd_count", &self.local_ssd_count);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("preemptible", &self.preemptible);
        debug_struct.field("accelerators", &self.accelerators);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("min_cpu_platform", &self.min_cpu_platform);
        debug_struct.field("workload_metadata_config", &self.workload_metadata_config);
        debug_struct.field("taints", &self.taints);
        debug_struct.field("sandbox_config", &self.sandbox_config);
        debug_struct.field("node_group", &self.node_group);
        debug_struct.field("reservation_affinity", &self.reservation_affinity);
        debug_struct.field("shielded_instance_config", &self.shielded_instance_config);
        debug_struct.field("linux_node_config", &self.linux_node_config);
        debug_struct.field("kubelet_config", &self.kubelet_config);
        debug_struct.field("boot_disk_kms_key", &self.boot_disk_kms_key);
        debug_struct.field("gcfs_config", &self.gcfs_config);
        debug_struct.field("advanced_machine_features", &self.advanced_machine_features);
        debug_struct.field("gvnic", &self.gvnic);
        debug_struct.field("spot", &self.spot);
        debug_struct.field("confidential_nodes", &self.confidential_nodes);
        debug_struct.field("fast_socket", &self.fast_socket);
        debug_struct.field("resource_labels", &self.resource_labels);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("windows_node_config", &self.windows_node_config);
        debug_struct.field(
            "local_nvme_ssd_block_config",
            &self.local_nvme_ssd_block_config,
        );
        debug_struct.field(
            "ephemeral_storage_local_ssd_config",
            &self.ephemeral_storage_local_ssd_config,
        );
        debug_struct.field("sole_tenant_config", &self.sole_tenant_config);
        debug_struct.field("containerd_config", &self.containerd_config);
        debug_struct.field("resource_manager_tags", &self.resource_manager_tags);
        debug_struct.field(
            "enable_confidential_storage",
            &self.enable_confidential_storage,
        );
        debug_struct.field("secondary_boot_disks", &self.secondary_boot_disks);
        debug_struct.field("storage_pools", &self.storage_pools);
        debug_struct.field(
            "secondary_boot_disk_update_strategy",
            &self.secondary_boot_disk_update_strategy,
        );
        debug_struct.field("gpu_direct_config", &self.gpu_direct_config);
        debug_struct.field("max_run_duration", &self.max_run_duration);
        debug_struct.field("local_ssd_encryption_mode", &self.local_ssd_encryption_mode);
        debug_struct.field("effective_cgroup_mode", &self.effective_cgroup_mode);
        debug_struct.field("flex_start", &self.flex_start);
        debug_struct.field("boot_disk", &self.boot_disk);
        debug_struct.field("consolidation_delay", &self.consolidation_delay);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AdvancedMachineFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvancedMachineFeatures");
        debug_struct.field("threads_per_core", &self.threads_per_core);
        debug_struct.field(
            "enable_nested_virtualization",
            &self.enable_nested_virtualization,
        );
        debug_struct.field(
            "performance_monitoring_unit",
            &self.performance_monitoring_unit,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeNetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeNetworkConfig");
        debug_struct.field("create_pod_range", &self.create_pod_range);
        debug_struct.field("pod_range", &self.pod_range);
        debug_struct.field("pod_ipv4_cidr_block", &self.pod_ipv4_cidr_block);
        debug_struct.field("enable_private_nodes", &self.enable_private_nodes);
        debug_struct.field(
            "network_performance_config",
            &self.network_performance_config,
        );
        debug_struct.field(
            "pod_cidr_overprovision_config",
            &self.pod_cidr_overprovision_config,
        );
        debug_struct.field(
            "additional_node_network_configs",
            &self.additional_node_network_configs,
        );
        debug_struct.field(
            "additional_pod_network_configs",
            &self.additional_pod_network_configs,
        );
        debug_struct.field(
            "pod_ipv4_range_utilization",
            &self.pod_ipv4_range_utilization,
        );
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("network_tier_config", &self.network_tier_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::node_network_config::NetworkPerformanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkPerformanceConfig");
        debug_struct.field(
            "total_egress_bandwidth_tier",
            &self.total_egress_bandwidth_tier,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AdditionalNodeNetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdditionalNodeNetworkConfig");
        debug_struct.field("network", &self.network);
        debug_struct.field("subnetwork", &self.subnetwork);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AdditionalPodNetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdditionalPodNetworkConfig");
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("secondary_pod_range", &self.secondary_pod_range);
        debug_struct.field("max_pods_per_node", &self.max_pods_per_node);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ShieldedInstanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShieldedInstanceConfig");
        debug_struct.field("enable_secure_boot", &self.enable_secure_boot);
        debug_struct.field(
            "enable_integrity_monitoring",
            &self.enable_integrity_monitoring,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SandboxConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SandboxConfig");
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcfsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcfsConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReservationAffinity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReservationAffinity");
        debug_struct.field("consume_reservation_type", &self.consume_reservation_type);
        debug_struct.field("key", &self.key);
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SoleTenantConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SoleTenantConfig");
        debug_struct.field("node_affinities", &self.node_affinities);
        debug_struct.field("min_node_cpus", &self.min_node_cpus);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::sole_tenant_config::NodeAffinity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeAffinity");
        debug_struct.field("key", &self.key);
        debug_struct.field("operator", &self.operator);
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ContainerdConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ContainerdConfig");
        debug_struct.field(
            "private_registry_access_config",
            &self.private_registry_access_config,
        );
        debug_struct.field("writable_cgroups", &self.writable_cgroups);
        debug_struct.field("registry_hosts", &self.registry_hosts);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::containerd_config::PrivateRegistryAccessConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateRegistryAccessConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field(
            "certificate_authority_domain_config",
            &self.certificate_authority_domain_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug
    for super::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CertificateAuthorityDomainConfig");
        debug_struct.field("fqdns", &self.fqdns);
        debug_struct.field("certificate_config", &self.certificate_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GCPSecretManagerCertificateConfig");
        debug_struct.field("secret_uri", &self.secret_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::containerd_config::WritableCgroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WritableCgroups");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::containerd_config::RegistryHostConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RegistryHostConfig");
        debug_struct.field("server", &self.server);
        debug_struct.field("hosts", &self.hosts);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::containerd_config::registry_host_config::CertificateConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CertificateConfig");
        debug_struct.field("certificate", &self.certificate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::containerd_config::registry_host_config::CertificateConfigPair {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CertificateConfigPair");
        debug_struct.field("cert", &self.cert);
        debug_struct.field("key", &self.key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::containerd_config::registry_host_config::RegistryHeader {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RegistryHeader");
        debug_struct.field("key", &self.key);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::containerd_config::registry_host_config::HostConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HostConfig");
        debug_struct.field("host", &self.host);
        debug_struct.field("capabilities", &self.capabilities);
        debug_struct.field("override_path", &self.override_path);
        debug_struct.field("header", &self.header);
        debug_struct.field("ca", &self.ca);
        debug_struct.field("client", &self.client);
        debug_struct.field("dial_timeout", &self.dial_timeout);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeTaint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeTaint");
        debug_struct.field("key", &self.key);
        debug_struct.field("value", &self.value);
        debug_struct.field("effect", &self.effect);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeTaints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeTaints");
        debug_struct.field("taints", &self.taints);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeLabels {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeLabels");
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ResourceLabels {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceLabels");
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NetworkTags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkTags");
        debug_struct.field("tags", &self.tags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MasterAuth {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MasterAuth");
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("client_certificate_config", &self.client_certificate_config);
        debug_struct.field("cluster_ca_certificate", &self.cluster_ca_certificate);
        debug_struct.field("client_certificate", &self.client_certificate);
        debug_struct.field("client_key", &self.client_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClientCertificateConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClientCertificateConfig");
        debug_struct.field("issue_client_certificate", &self.issue_client_certificate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AddonsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddonsConfig");
        debug_struct.field("http_load_balancing", &self.http_load_balancing);
        debug_struct.field(
            "horizontal_pod_autoscaling",
            &self.horizontal_pod_autoscaling,
        );
        debug_struct.field("kubernetes_dashboard", &self.kubernetes_dashboard);
        debug_struct.field("network_policy_config", &self.network_policy_config);
        debug_struct.field("cloud_run_config", &self.cloud_run_config);
        debug_struct.field("dns_cache_config", &self.dns_cache_config);
        debug_struct.field("config_connector_config", &self.config_connector_config);
        debug_struct.field(
            "gce_persistent_disk_csi_driver_config",
            &self.gce_persistent_disk_csi_driver_config,
        );
        debug_struct.field(
            "gcp_filestore_csi_driver_config",
            &self.gcp_filestore_csi_driver_config,
        );
        debug_struct.field("gke_backup_agent_config", &self.gke_backup_agent_config);
        debug_struct.field(
            "gcs_fuse_csi_driver_config",
            &self.gcs_fuse_csi_driver_config,
        );
        debug_struct.field("stateful_ha_config", &self.stateful_ha_config);
        debug_struct.field(
            "parallelstore_csi_driver_config",
            &self.parallelstore_csi_driver_config,
        );
        debug_struct.field("ray_operator_config", &self.ray_operator_config);
        debug_struct.field(
            "high_scale_checkpointing_config",
            &self.high_scale_checkpointing_config,
        );
        debug_struct.field("lustre_csi_driver_config", &self.lustre_csi_driver_config);
        debug_struct.field("slice_controller_config", &self.slice_controller_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HttpLoadBalancing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpLoadBalancing");
        debug_struct.field("disabled", &self.disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HorizontalPodAutoscaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HorizontalPodAutoscaling");
        debug_struct.field("disabled", &self.disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::KubernetesDashboard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("KubernetesDashboard");
        debug_struct.field("disabled", &self.disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NetworkPolicyConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkPolicyConfig");
        debug_struct.field("disabled", &self.disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DnsCacheConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DnsCacheConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrivateClusterMasterGlobalAccessConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateClusterMasterGlobalAccessConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrivateClusterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivateClusterConfig");
        debug_struct.field("enable_private_nodes", &self.enable_private_nodes);
        debug_struct.field("enable_private_endpoint", &self.enable_private_endpoint);
        debug_struct.field("master_ipv4_cidr_block", &self.master_ipv4_cidr_block);
        debug_struct.field("private_endpoint", &self.private_endpoint);
        debug_struct.field("public_endpoint", &self.public_endpoint);
        debug_struct.field("peering_name", &self.peering_name);
        debug_struct.field(
            "master_global_access_config",
            &self.master_global_access_config,
        );
        debug_struct.field(
            "private_endpoint_subnetwork",
            &self.private_endpoint_subnetwork,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AuthenticatorGroupsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthenticatorGroupsConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("security_group", &self.security_group);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CloudRunConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloudRunConfig");
        debug_struct.field("disabled", &self.disabled);
        debug_struct.field("load_balancer_type", &self.load_balancer_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConfigConnectorConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigConnectorConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcePersistentDiskCsiDriverConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcePersistentDiskCsiDriverConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcpFilestoreCsiDriverConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcpFilestoreCsiDriverConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GcsFuseCsiDriverConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GcsFuseCsiDriverConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ParallelstoreCsiDriverConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ParallelstoreCsiDriverConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HighScaleCheckpointingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HighScaleCheckpointingConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LustreCsiDriverConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LustreCsiDriverConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("enable_legacy_lustre_port", &self.enable_legacy_lustre_port);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SliceControllerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SliceControllerConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RayOperatorConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RayOperatorConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field(
            "ray_cluster_logging_config",
            &self.ray_cluster_logging_config,
        );
        debug_struct.field(
            "ray_cluster_monitoring_config",
            &self.ray_cluster_monitoring_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GkeBackupAgentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GkeBackupAgentConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StatefulHAConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StatefulHAConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MasterAuthorizedNetworksConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MasterAuthorizedNetworksConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("cidr_blocks", &self.cidr_blocks);
        debug_struct.field(
            "gcp_public_cidrs_access_enabled",
            &self.gcp_public_cidrs_access_enabled,
        );
        debug_struct.field(
            "private_endpoint_enforcement_enabled",
            &self.private_endpoint_enforcement_enabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::master_authorized_networks_config::CidrBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CidrBlock");
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("cidr_block", &self.cidr_block);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LegacyAbac {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LegacyAbac");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NetworkPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkPolicy");
        debug_struct.field("provider", &self.provider);
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BinaryAuthorization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BinaryAuthorization");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("evaluation_mode", &self.evaluation_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PodCIDROverprovisionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PodCIDROverprovisionConfig");
        debug_struct.field("disable", &self.disable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IPAllocationPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IPAllocationPolicy");
        debug_struct.field("use_ip_aliases", &self.use_ip_aliases);
        debug_struct.field("create_subnetwork", &self.create_subnetwork);
        debug_struct.field("subnetwork_name", &self.subnetwork_name);
        debug_struct.field("cluster_ipv4_cidr", &self.cluster_ipv4_cidr);
        debug_struct.field("node_ipv4_cidr", &self.node_ipv4_cidr);
        debug_struct.field("services_ipv4_cidr", &self.services_ipv4_cidr);
        debug_struct.field(
            "cluster_secondary_range_name",
            &self.cluster_secondary_range_name,
        );
        debug_struct.field(
            "services_secondary_range_name",
            &self.services_secondary_range_name,
        );
        debug_struct.field("cluster_ipv4_cidr_block", &self.cluster_ipv4_cidr_block);
        debug_struct.field("node_ipv4_cidr_block", &self.node_ipv4_cidr_block);
        debug_struct.field("services_ipv4_cidr_block", &self.services_ipv4_cidr_block);
        debug_struct.field("tpu_ipv4_cidr_block", &self.tpu_ipv4_cidr_block);
        debug_struct.field("use_routes", &self.use_routes);
        debug_struct.field("stack_type", &self.stack_type);
        debug_struct.field("ipv6_access_type", &self.ipv6_access_type);
        debug_struct.field(
            "pod_cidr_overprovision_config",
            &self.pod_cidr_overprovision_config,
        );
        debug_struct.field("subnet_ipv6_cidr_block", &self.subnet_ipv6_cidr_block);
        debug_struct.field("services_ipv6_cidr_block", &self.services_ipv6_cidr_block);
        debug_struct.field(
            "additional_pod_ranges_config",
            &self.additional_pod_ranges_config,
        );
        debug_struct.field(
            "default_pod_ipv4_range_utilization",
            &self.default_pod_ipv4_range_utilization,
        );
        debug_struct.field(
            "additional_ip_ranges_configs",
            &self.additional_ip_ranges_configs,
        );
        debug_struct.field("auto_ipam_config", &self.auto_ipam_config);
        debug_struct.field("network_tier_config", &self.network_tier_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Cluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cluster");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("initial_node_count", &self.initial_node_count);
        debug_struct.field("node_config", &self.node_config);
        debug_struct.field("master_auth", &self.master_auth);
        debug_struct.field("logging_service", &self.logging_service);
        debug_struct.field("monitoring_service", &self.monitoring_service);
        debug_struct.field("network", &self.network);
        debug_struct.field("cluster_ipv4_cidr", &self.cluster_ipv4_cidr);
        debug_struct.field("addons_config", &self.addons_config);
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("node_pools", &self.node_pools);
        debug_struct.field("locations", &self.locations);
        debug_struct.field("enable_kubernetes_alpha", &self.enable_kubernetes_alpha);
        debug_struct.field(
            "alpha_cluster_feature_gates",
            &self.alpha_cluster_feature_gates,
        );
        debug_struct.field("resource_labels", &self.resource_labels);
        debug_struct.field("label_fingerprint", &self.label_fingerprint);
        debug_struct.field("legacy_abac", &self.legacy_abac);
        debug_struct.field("network_policy", &self.network_policy);
        debug_struct.field("ip_allocation_policy", &self.ip_allocation_policy);
        debug_struct.field(
            "master_authorized_networks_config",
            &self.master_authorized_networks_config,
        );
        debug_struct.field("maintenance_policy", &self.maintenance_policy);
        debug_struct.field("binary_authorization", &self.binary_authorization);
        debug_struct.field("autoscaling", &self.autoscaling);
        debug_struct.field("network_config", &self.network_config);
        debug_struct.field(
            "default_max_pods_constraint",
            &self.default_max_pods_constraint,
        );
        debug_struct.field(
            "resource_usage_export_config",
            &self.resource_usage_export_config,
        );
        debug_struct.field(
            "authenticator_groups_config",
            &self.authenticator_groups_config,
        );
        debug_struct.field("private_cluster_config", &self.private_cluster_config);
        debug_struct.field("database_encryption", &self.database_encryption);
        debug_struct.field("vertical_pod_autoscaling", &self.vertical_pod_autoscaling);
        debug_struct.field("shielded_nodes", &self.shielded_nodes);
        debug_struct.field("release_channel", &self.release_channel);
        debug_struct.field("workload_identity_config", &self.workload_identity_config);
        debug_struct.field("mesh_certificates", &self.mesh_certificates);
        debug_struct.field("cost_management_config", &self.cost_management_config);
        debug_struct.field("notification_config", &self.notification_config);
        debug_struct.field("confidential_nodes", &self.confidential_nodes);
        debug_struct.field("identity_service_config", &self.identity_service_config);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("endpoint", &self.endpoint);
        debug_struct.field("initial_cluster_version", &self.initial_cluster_version);
        debug_struct.field("current_master_version", &self.current_master_version);
        debug_struct.field("current_node_version", &self.current_node_version);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("status", &self.status);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("node_ipv4_cidr_size", &self.node_ipv4_cidr_size);
        debug_struct.field("services_ipv4_cidr", &self.services_ipv4_cidr);
        debug_struct.field("instance_group_urls", &self.instance_group_urls);
        debug_struct.field("current_node_count", &self.current_node_count);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("location", &self.location);
        debug_struct.field("enable_tpu", &self.enable_tpu);
        debug_struct.field("tpu_ipv4_cidr_block", &self.tpu_ipv4_cidr_block);
        debug_struct.field("conditions", &self.conditions);
        debug_struct.field("autopilot", &self.autopilot);
        debug_struct.field("id", &self.id);
        debug_struct.field("node_pool_defaults", &self.node_pool_defaults);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("monitoring_config", &self.monitoring_config);
        debug_struct.field("node_pool_auto_config", &self.node_pool_auto_config);
        debug_struct.field("pod_autoscaling", &self.pod_autoscaling);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("fleet", &self.fleet);
        debug_struct.field("security_posture_config", &self.security_posture_config);
        debug_struct.field(
            "control_plane_endpoints_config",
            &self.control_plane_endpoints_config,
        );
        debug_struct.field("enable_k8s_beta_apis", &self.enable_k8s_beta_apis);
        debug_struct.field("enterprise_config", &self.enterprise_config);
        debug_struct.field("secret_manager_config", &self.secret_manager_config);
        debug_struct.field("compliance_posture_config", &self.compliance_posture_config);
        debug_struct.field("satisfies_pzs", &self.satisfies_pzs);
        debug_struct.field("satisfies_pzi", &self.satisfies_pzi);
        debug_struct.field("user_managed_keys_config", &self.user_managed_keys_config);
        debug_struct.field("rbac_binding_config", &self.rbac_binding_config);
        debug_struct.field("gke_auto_upgrade_config", &self.gke_auto_upgrade_config);
        debug_struct.field(
            "anonymous_authentication_config",
            &self.anonymous_authentication_config,
        );
        debug_struct.field(
            "managed_opentelemetry_config",
            &self.managed_opentelemetry_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RBACBindingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RBACBindingConfig");
        debug_struct.field(
            "enable_insecure_binding_system_unauthenticated",
            &self.enable_insecure_binding_system_unauthenticated,
        );
        debug_struct.field(
            "enable_insecure_binding_system_authenticated",
            &self.enable_insecure_binding_system_authenticated,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UserManagedKeysConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserManagedKeysConfig");
        debug_struct.field("cluster_ca", &self.cluster_ca);
        debug_struct.field("etcd_api_ca", &self.etcd_api_ca);
        debug_struct.field("etcd_peer_ca", &self.etcd_peer_ca);
        debug_struct.field(
            "service_account_signing_keys",
            &self.service_account_signing_keys,
        );
        debug_struct.field(
            "service_account_verification_keys",
            &self.service_account_verification_keys,
        );
        debug_struct.field("aggregation_ca", &self.aggregation_ca);
        debug_struct.field(
            "control_plane_disk_encryption_key",
            &self.control_plane_disk_encryption_key,
        );
        debug_struct.field(
            "control_plane_disk_encryption_key_versions",
            &self.control_plane_disk_encryption_key_versions,
        );
        debug_struct.field(
            "gkeops_etcd_backup_encryption_key",
            &self.gkeops_etcd_backup_encryption_key,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AnonymousAuthenticationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AnonymousAuthenticationConfig");
        debug_struct.field("mode", &self.mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CompliancePostureConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompliancePostureConfig");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("compliance_standards", &self.compliance_standards);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::compliance_posture_config::ComplianceStandard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComplianceStandard");
        debug_struct.field("standard", &self.standard);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::K8sBetaAPIConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("K8sBetaAPIConfig");
        debug_struct.field("enabled_apis", &self.enabled_apis);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecurityPostureConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecurityPostureConfig");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("vulnerability_mode", &self.vulnerability_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodePoolAutoConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePoolAutoConfig");
        debug_struct.field("network_tags", &self.network_tags);
        debug_struct.field("resource_manager_tags", &self.resource_manager_tags);
        debug_struct.field("node_kubelet_config", &self.node_kubelet_config);
        debug_struct.field("linux_node_config", &self.linux_node_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodePoolDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePoolDefaults");
        debug_struct.field("node_config_defaults", &self.node_config_defaults);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeConfigDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeConfigDefaults");
        debug_struct.field("gcfs_config", &self.gcfs_config);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("containerd_config", &self.containerd_config);
        debug_struct.field("node_kubelet_config", &self.node_kubelet_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClusterUpdate {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterUpdate");
        debug_struct.field("desired_node_version", &self.desired_node_version);
        debug_struct.field(
            "desired_monitoring_service",
            &self.desired_monitoring_service,
        );
        debug_struct.field("desired_addons_config", &self.desired_addons_config);
        debug_struct.field("desired_node_pool_id", &self.desired_node_pool_id);
        debug_struct.field("desired_image_type", &self.desired_image_type);
        debug_struct.field(
            "desired_database_encryption",
            &self.desired_database_encryption,
        );
        debug_struct.field(
            "desired_workload_identity_config",
            &self.desired_workload_identity_config,
        );
        debug_struct.field("desired_mesh_certificates", &self.desired_mesh_certificates);
        debug_struct.field("desired_shielded_nodes", &self.desired_shielded_nodes);
        debug_struct.field(
            "desired_cost_management_config",
            &self.desired_cost_management_config,
        );
        debug_struct.field("desired_dns_config", &self.desired_dns_config);
        debug_struct.field(
            "desired_node_pool_autoscaling",
            &self.desired_node_pool_autoscaling,
        );
        debug_struct.field("desired_locations", &self.desired_locations);
        debug_struct.field(
            "desired_master_authorized_networks_config",
            &self.desired_master_authorized_networks_config,
        );
        debug_struct.field(
            "desired_cluster_autoscaling",
            &self.desired_cluster_autoscaling,
        );
        debug_struct.field(
            "desired_binary_authorization",
            &self.desired_binary_authorization,
        );
        debug_struct.field("desired_logging_service", &self.desired_logging_service);
        debug_struct.field(
            "desired_resource_usage_export_config",
            &self.desired_resource_usage_export_config,
        );
        debug_struct.field(
            "desired_vertical_pod_autoscaling",
            &self.desired_vertical_pod_autoscaling,
        );
        debug_struct.field(
            "desired_private_cluster_config",
            &self.desired_private_cluster_config,
        );
        debug_struct.field(
            "desired_intra_node_visibility_config",
            &self.desired_intra_node_visibility_config,
        );
        debug_struct.field(
            "desired_default_snat_status",
            &self.desired_default_snat_status,
        );
        debug_struct.field("desired_release_channel", &self.desired_release_channel);
        debug_struct.field(
            "desired_l4ilb_subsetting_config",
            &self.desired_l4ilb_subsetting_config,
        );
        debug_struct.field("desired_datapath_provider", &self.desired_datapath_provider);
        debug_struct.field(
            "desired_private_ipv6_google_access",
            &self.desired_private_ipv6_google_access,
        );
        debug_struct.field(
            "desired_notification_config",
            &self.desired_notification_config,
        );
        debug_struct.field(
            "desired_authenticator_groups_config",
            &self.desired_authenticator_groups_config,
        );
        debug_struct.field("desired_logging_config", &self.desired_logging_config);
        debug_struct.field("desired_monitoring_config", &self.desired_monitoring_config);
        debug_struct.field(
            "desired_identity_service_config",
            &self.desired_identity_service_config,
        );
        debug_struct.field(
            "desired_service_external_ips_config",
            &self.desired_service_external_ips_config,
        );
        debug_struct.field(
            "desired_enable_private_endpoint",
            &self.desired_enable_private_endpoint,
        );
        debug_struct.field(
            "desired_default_enable_private_nodes",
            &self.desired_default_enable_private_nodes,
        );
        debug_struct.field(
            "desired_control_plane_endpoints_config",
            &self.desired_control_plane_endpoints_config,
        );
        debug_struct.field("desired_master_version", &self.desired_master_version);
        debug_struct.field("desired_gcfs_config", &self.desired_gcfs_config);
        debug_struct.field(
            "desired_node_pool_auto_config_network_tags",
            &self.desired_node_pool_auto_config_network_tags,
        );
        debug_struct.field("desired_pod_autoscaling", &self.desired_pod_autoscaling);
        debug_struct.field(
            "desired_gateway_api_config",
            &self.desired_gateway_api_config,
        );
        debug_struct.field("etag", &self.etag);
        debug_struct.field(
            "desired_node_pool_logging_config",
            &self.desired_node_pool_logging_config,
        );
        debug_struct.field("desired_fleet", &self.desired_fleet);
        debug_struct.field("desired_stack_type", &self.desired_stack_type);
        debug_struct.field(
            "additional_pod_ranges_config",
            &self.additional_pod_ranges_config,
        );
        debug_struct.field(
            "removed_additional_pod_ranges_config",
            &self.removed_additional_pod_ranges_config,
        );
        debug_struct.field("enable_k8s_beta_apis", &self.enable_k8s_beta_apis);
        debug_struct.field(
            "desired_security_posture_config",
            &self.desired_security_posture_config,
        );
        debug_struct.field(
            "desired_network_performance_config",
            &self.desired_network_performance_config,
        );
        debug_struct.field(
            "desired_enable_fqdn_network_policy",
            &self.desired_enable_fqdn_network_policy,
        );
        debug_struct.field(
            "desired_autopilot_workload_policy_config",
            &self.desired_autopilot_workload_policy_config,
        );
        debug_struct.field("desired_k8s_beta_apis", &self.desired_k8s_beta_apis);
        debug_struct.field("desired_containerd_config", &self.desired_containerd_config);
        debug_struct.field(
            "desired_enable_multi_networking",
            &self.desired_enable_multi_networking,
        );
        debug_struct.field(
            "desired_node_pool_auto_config_resource_manager_tags",
            &self.desired_node_pool_auto_config_resource_manager_tags,
        );
        debug_struct.field(
            "desired_in_transit_encryption_config",
            &self.desired_in_transit_encryption_config,
        );
        debug_struct.field(
            "desired_enable_cilium_clusterwide_network_policy",
            &self.desired_enable_cilium_clusterwide_network_policy,
        );
        debug_struct.field(
            "desired_secret_manager_config",
            &self.desired_secret_manager_config,
        );
        debug_struct.field(
            "desired_compliance_posture_config",
            &self.desired_compliance_posture_config,
        );
        debug_struct.field(
            "desired_node_kubelet_config",
            &self.desired_node_kubelet_config,
        );
        debug_struct.field(
            "desired_node_pool_auto_config_kubelet_config",
            &self.desired_node_pool_auto_config_kubelet_config,
        );
        debug_struct.field("user_managed_keys_config", &self.user_managed_keys_config);
        debug_struct.field(
            "desired_rbac_binding_config",
            &self.desired_rbac_binding_config,
        );
        debug_struct.field(
            "desired_additional_ip_ranges_config",
            &self.desired_additional_ip_ranges_config,
        );
        debug_struct.field("desired_enterprise_config", &self.desired_enterprise_config);
        debug_struct.field("desired_auto_ipam_config", &self.desired_auto_ipam_config);
        debug_struct.field(
            "desired_disable_l4_lb_firewall_reconciliation",
            &self.desired_disable_l4_lb_firewall_reconciliation,
        );
        debug_struct.field(
            "desired_node_pool_auto_config_linux_node_config",
            &self.desired_node_pool_auto_config_linux_node_config,
        );
        debug_struct.field(
            "desired_user_managed_keys_config",
            &self.desired_user_managed_keys_config,
        );
        debug_struct.field(
            "desired_anonymous_authentication_config",
            &self.desired_anonymous_authentication_config,
        );
        debug_struct.field("gke_auto_upgrade_config", &self.gke_auto_upgrade_config);
        debug_struct.field(
            "desired_network_tier_config",
            &self.desired_network_tier_config,
        );
        debug_struct.field(
            "desired_privileged_admission_config",
            &self.desired_privileged_admission_config,
        );
        debug_struct.field(
            "desired_managed_opentelemetry_config",
            &self.desired_managed_opentelemetry_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AdditionalPodRangesConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdditionalPodRangesConfig");
        debug_struct.field("pod_range_names", &self.pod_range_names);
        debug_struct.field("pod_range_info", &self.pod_range_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AdditionalIPRangesConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdditionalIPRangesConfig");
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("pod_ipv4_range_names", &self.pod_ipv4_range_names);
        debug_struct.field("status", &self.status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DesiredAdditionalIPRangesConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DesiredAdditionalIPRangesConfig");
        debug_struct.field(
            "additional_ip_ranges_configs",
            &self.additional_ip_ranges_configs,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AutoIpamConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoIpamConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RangeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RangeInfo");
        debug_struct.field("range_name", &self.range_name);
        debug_struct.field("utilization", &self.utilization);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DesiredEnterpriseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DesiredEnterpriseConfig");
        debug_struct.field("desired_tier", &self.desired_tier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Operation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Operation");
        debug_struct.field("name", &self.name);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("operation_type", &self.operation_type);
        debug_struct.field("status", &self.status);
        debug_struct.field("detail", &self.detail);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("target_link", &self.target_link);
        debug_struct.field("location", &self.location);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("progress", &self.progress);
        debug_struct.field("cluster_conditions", &self.cluster_conditions);
        debug_struct.field("nodepool_conditions", &self.nodepool_conditions);
        debug_struct.field("error", &self.error);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OperationProgress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationProgress");
        debug_struct.field("name", &self.name);
        debug_struct.field("status", &self.status);
        debug_struct.field("metrics", &self.metrics);
        debug_struct.field("stages", &self.stages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::operation_progress::Metric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Metric");
        debug_struct.field("name", &self.name);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("update", &self.update);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateNodePoolRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("node_version", &self.node_version);
        debug_struct.field("image_type", &self.image_type);
        debug_struct.field("name", &self.name);
        debug_struct.field("locations", &self.locations);
        debug_struct.field("workload_metadata_config", &self.workload_metadata_config);
        debug_struct.field("upgrade_settings", &self.upgrade_settings);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("taints", &self.taints);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("linux_node_config", &self.linux_node_config);
        debug_struct.field("kubelet_config", &self.kubelet_config);
        debug_struct.field("node_network_config", &self.node_network_config);
        debug_struct.field("gcfs_config", &self.gcfs_config);
        debug_struct.field("confidential_nodes", &self.confidential_nodes);
        debug_struct.field("gvnic", &self.gvnic);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("fast_socket", &self.fast_socket);
        debug_struct.field("logging_config", &self.logging_config);
        debug_struct.field("resource_labels", &self.resource_labels);
        debug_struct.field("windows_node_config", &self.windows_node_config);
        debug_struct.field("accelerators", &self.accelerators);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field("resource_manager_tags", &self.resource_manager_tags);
        debug_struct.field("containerd_config", &self.containerd_config);
        debug_struct.field("queued_provisioning", &self.queued_provisioning);
        debug_struct.field("storage_pools", &self.storage_pools);
        debug_struct.field("max_run_duration", &self.max_run_duration);
        debug_struct.field("flex_start", &self.flex_start);
        debug_struct.field("boot_disk", &self.boot_disk);
        debug_struct.field("node_drain_config", &self.node_drain_config);
        debug_struct.field("consolidation_delay", &self.consolidation_delay);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetNodePoolAutoscalingRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetNodePoolAutoscalingRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("autoscaling", &self.autoscaling);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetLoggingServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetLoggingServiceRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("logging_service", &self.logging_service);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetMonitoringServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetMonitoringServiceRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("monitoring_service", &self.monitoring_service);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetAddonsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetAddonsConfigRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("addons_config", &self.addons_config);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetLocationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetLocationsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("locations", &self.locations);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateMasterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateMasterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("master_version", &self.master_version);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetMasterAuthRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetMasterAuthRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("action", &self.action);
        debug_struct.field("update", &self.update);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteClusterRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListClustersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListClustersRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListClustersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListClustersResponse");
        debug_struct.field("clusters", &self.clusters);
        debug_struct.field("missing_zones", &self.missing_zones);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetOperationRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("operation_id", &self.operation_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListOperationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOperationsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CancelOperationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelOperationRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("operation_id", &self.operation_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListOperationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListOperationsResponse");
        debug_struct.field("operations", &self.operations);
        debug_struct.field("missing_zones", &self.missing_zones);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetServerConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetServerConfigRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ServerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServerConfig");
        debug_struct.field("default_cluster_version", &self.default_cluster_version);
        debug_struct.field("valid_node_versions", &self.valid_node_versions);
        debug_struct.field("default_image_type", &self.default_image_type);
        debug_struct.field("valid_image_types", &self.valid_image_types);
        debug_struct.field("valid_master_versions", &self.valid_master_versions);
        debug_struct.field("channels", &self.channels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::server_config::ReleaseChannelConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReleaseChannelConfig");
        debug_struct.field("channel", &self.channel);
        debug_struct.field("default_version", &self.default_version);
        debug_struct.field("valid_versions", &self.valid_versions);
        debug_struct.field("upgrade_target_version", &self.upgrade_target_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateNodePoolRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool", &self.node_pool);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteNodePoolRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListNodePoolsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNodePoolsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetNodePoolRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BlueGreenSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BlueGreenSettings");
        debug_struct.field("node_pool_soak_duration", &self.node_pool_soak_duration);
        debug_struct.field("rollout_policy", &self.rollout_policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::blue_green_settings::StandardRolloutPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StandardRolloutPolicy");
        debug_struct.field("batch_soak_duration", &self.batch_soak_duration);
        debug_struct.field("update_batch_size", &self.update_batch_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::blue_green_settings::AutoscaledRolloutPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoscaledRolloutPolicy");
        debug_struct.field("wait_for_drain_duration", &self.wait_for_drain_duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodePool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePool");
        debug_struct.field("name", &self.name);
        debug_struct.field("config", &self.config);
        debug_struct.field("initial_node_count", &self.initial_node_count);
        debug_struct.field("locations", &self.locations);
        debug_struct.field("network_config", &self.network_config);
        debug_struct.field("self_link", &self.self_link);
        debug_struct.field("version", &self.version);
        debug_struct.field("instance_group_urls", &self.instance_group_urls);
        debug_struct.field("status", &self.status);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("autoscaling", &self.autoscaling);
        debug_struct.field("management", &self.management);
        debug_struct.field("max_pods_constraint", &self.max_pods_constraint);
        debug_struct.field("conditions", &self.conditions);
        debug_struct.field("pod_ipv4_cidr_size", &self.pod_ipv4_cidr_size);
        debug_struct.field("upgrade_settings", &self.upgrade_settings);
        debug_struct.field("placement_policy", &self.placement_policy);
        debug_struct.field("update_info", &self.update_info);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("queued_provisioning", &self.queued_provisioning);
        debug_struct.field("best_effort_provisioning", &self.best_effort_provisioning);
        debug_struct.field("node_drain_config", &self.node_drain_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::node_pool::UpgradeSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeSettings");
        debug_struct.field("max_surge", &self.max_surge);
        debug_struct.field("max_unavailable", &self.max_unavailable);
        debug_struct.field("strategy", &self.strategy);
        debug_struct.field("blue_green_settings", &self.blue_green_settings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::node_pool::UpdateInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInfo");
        debug_struct.field("blue_green_info", &self.blue_green_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::node_pool::update_info::BlueGreenInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BlueGreenInfo");
        debug_struct.field("phase", &self.phase);
        debug_struct.field("blue_instance_group_urls", &self.blue_instance_group_urls);
        debug_struct.field("green_instance_group_urls", &self.green_instance_group_urls);
        debug_struct.field(
            "blue_pool_deletion_start_time",
            &self.blue_pool_deletion_start_time,
        );
        debug_struct.field("green_pool_version", &self.green_pool_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::node_pool::PlacementPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PlacementPolicy");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("tpu_topology", &self.tpu_topology);
        debug_struct.field("policy_name", &self.policy_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::node_pool::QueuedProvisioning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QueuedProvisioning");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::node_pool::NodeDrainConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeDrainConfig");
        debug_struct.field(
            "respect_pdb_during_node_pool_deletion",
            &self.respect_pdb_during_node_pool_deletion,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeManagement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeManagement");
        debug_struct.field("auto_upgrade", &self.auto_upgrade);
        debug_struct.field("auto_repair", &self.auto_repair);
        debug_struct.field("upgrade_options", &self.upgrade_options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BestEffortProvisioning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BestEffortProvisioning");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("min_provision_nodes", &self.min_provision_nodes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AutoUpgradeOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoUpgradeOptions");
        debug_struct.field("auto_upgrade_start_time", &self.auto_upgrade_start_time);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MaintenancePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenancePolicy");
        debug_struct.field("window", &self.window);
        debug_struct.field("resource_version", &self.resource_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenanceWindow");
        debug_struct.field("maintenance_exclusions", &self.maintenance_exclusions);
        debug_struct.field("policy", &self.policy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TimeWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeWindow");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("options", &self.options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MaintenanceExclusionOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenanceExclusionOptions");
        debug_struct.field("scope", &self.scope);
        debug_struct.field("end_time_behavior", &self.end_time_behavior);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RecurringTimeWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecurringTimeWindow");
        debug_struct.field("window", &self.window);
        debug_struct.field("recurrence", &self.recurrence);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DailyMaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DailyMaintenanceWindow");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("duration", &self.duration);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetNodePoolManagementRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetNodePoolManagementRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("management", &self.management);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetNodePoolSizeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetNodePoolSizeRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("node_count", &self.node_count);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CompleteNodePoolUpgradeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompleteNodePoolUpgradeRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RollbackNodePoolUpgradeRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RollbackNodePoolUpgradeRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("name", &self.name);
        debug_struct.field("respect_pdb", &self.respect_pdb);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListNodePoolsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNodePoolsResponse");
        debug_struct.field("node_pools", &self.node_pools);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClusterAutoscaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterAutoscaling");
        debug_struct.field(
            "enable_node_autoprovisioning",
            &self.enable_node_autoprovisioning,
        );
        debug_struct.field("resource_limits", &self.resource_limits);
        debug_struct.field("autoscaling_profile", &self.autoscaling_profile);
        debug_struct.field(
            "autoprovisioning_node_pool_defaults",
            &self.autoprovisioning_node_pool_defaults,
        );
        debug_struct.field(
            "autoprovisioning_locations",
            &self.autoprovisioning_locations,
        );
        debug_struct.field(
            "default_compute_class_config",
            &self.default_compute_class_config,
        );
        debug_struct.field("autopilot_general_profile", &self.autopilot_general_profile);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AutoprovisioningNodePoolDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoprovisioningNodePoolDefaults");
        debug_struct.field("oauth_scopes", &self.oauth_scopes);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("upgrade_settings", &self.upgrade_settings);
        debug_struct.field("management", &self.management);
        debug_struct.field("min_cpu_platform", &self.min_cpu_platform);
        debug_struct.field("disk_size_gb", &self.disk_size_gb);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("shielded_instance_config", &self.shielded_instance_config);
        debug_struct.field("boot_disk_kms_key", &self.boot_disk_kms_key);
        debug_struct.field("image_type", &self.image_type);
        debug_struct.field(
            "insecure_kubelet_readonly_port_enabled",
            &self.insecure_kubelet_readonly_port_enabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ResourceLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceLimit");
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("minimum", &self.minimum);
        debug_struct.field("maximum", &self.maximum);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DefaultComputeClassConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DefaultComputeClassConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodePoolAutoscaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePoolAutoscaling");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("min_node_count", &self.min_node_count);
        debug_struct.field("max_node_count", &self.max_node_count);
        debug_struct.field("autoprovisioned", &self.autoprovisioned);
        debug_struct.field("location_policy", &self.location_policy);
        debug_struct.field("total_min_node_count", &self.total_min_node_count);
        debug_struct.field("total_max_node_count", &self.total_max_node_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetLabelsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetLabelsRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("resource_labels", &self.resource_labels);
        debug_struct.field("label_fingerprint", &self.label_fingerprint);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetLegacyAbacRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetLegacyAbacRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StartIPRotationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartIPRotationRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("name", &self.name);
        debug_struct.field("rotate_credentials", &self.rotate_credentials);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CompleteIPRotationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CompleteIPRotationRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AcceleratorConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AcceleratorConfig");
        debug_struct.field("accelerator_count", &self.accelerator_count);
        debug_struct.field("accelerator_type", &self.accelerator_type);
        debug_struct.field("gpu_partition_size", &self.gpu_partition_size);
        debug_struct.field("gpu_sharing_config", &self.gpu_sharing_config);
        debug_struct.field(
            "gpu_driver_installation_config",
            &self.gpu_driver_installation_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GPUSharingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GPUSharingConfig");
        debug_struct.field(
            "max_shared_clients_per_gpu",
            &self.max_shared_clients_per_gpu,
        );
        debug_struct.field("gpu_sharing_strategy", &self.gpu_sharing_strategy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GPUDriverInstallationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GPUDriverInstallationConfig");
        debug_struct.field("gpu_driver_version", &self.gpu_driver_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkloadMetadataConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkloadMetadataConfig");
        debug_struct.field("mode", &self.mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetNetworkPolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetNetworkPolicyRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("network_policy", &self.network_policy);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SetMaintenancePolicyRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SetMaintenancePolicyRequest");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("maintenance_policy", &self.maintenance_policy);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::StatusCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StatusCondition");
        debug_struct.field("code", &self.code);
        debug_struct.field("message", &self.message);
        debug_struct.field("canonical_code", &self.canonical_code);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NetworkConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkConfig");
        debug_struct.field("network", &self.network);
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field(
            "enable_intra_node_visibility",
            &self.enable_intra_node_visibility,
        );
        debug_struct.field("default_snat_status", &self.default_snat_status);
        debug_struct.field("enable_l4ilb_subsetting", &self.enable_l4ilb_subsetting);
        debug_struct.field("datapath_provider", &self.datapath_provider);
        debug_struct.field(
            "private_ipv6_google_access",
            &self.private_ipv6_google_access,
        );
        debug_struct.field("dns_config", &self.dns_config);
        debug_struct.field(
            "service_external_ips_config",
            &self.service_external_ips_config,
        );
        debug_struct.field("gateway_api_config", &self.gateway_api_config);
        debug_struct.field("enable_multi_networking", &self.enable_multi_networking);
        debug_struct.field(
            "network_performance_config",
            &self.network_performance_config,
        );
        debug_struct.field(
            "enable_fqdn_network_policy",
            &self.enable_fqdn_network_policy,
        );
        debug_struct.field(
            "in_transit_encryption_config",
            &self.in_transit_encryption_config,
        );
        debug_struct.field(
            "enable_cilium_clusterwide_network_policy",
            &self.enable_cilium_clusterwide_network_policy,
        );
        debug_struct.field(
            "default_enable_private_nodes",
            &self.default_enable_private_nodes,
        );
        debug_struct.field(
            "disable_l4_lb_firewall_reconciliation",
            &self.disable_l4_lb_firewall_reconciliation,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::network_config::ClusterNetworkPerformanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterNetworkPerformanceConfig");
        debug_struct.field(
            "total_egress_bandwidth_tier",
            &self.total_egress_bandwidth_tier,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GatewayAPIConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GatewayAPIConfig");
        debug_struct.field("channel", &self.channel);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ServiceExternalIPsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceExternalIPsConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetOpenIDConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetOpenIDConfigRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetOpenIDConfigResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetOpenIDConfigResponse");
        debug_struct.field("issuer", &self.issuer);
        debug_struct.field("jwks_uri", &self.jwks_uri);
        debug_struct.field("response_types_supported", &self.response_types_supported);
        debug_struct.field("subject_types_supported", &self.subject_types_supported);
        debug_struct.field(
            "id_token_signing_alg_values_supported",
            &self.id_token_signing_alg_values_supported,
        );
        debug_struct.field("claims_supported", &self.claims_supported);
        debug_struct.field("grant_types", &self.grant_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetJSONWebKeysRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetJSONWebKeysRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Jwk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Jwk");
        debug_struct.field("kty", &self.kty);
        debug_struct.field("alg", &self.alg);
        debug_struct.field("r#use", &self.r#use);
        debug_struct.field("kid", &self.kid);
        debug_struct.field("n", &self.n);
        debug_struct.field("e", &self.e);
        debug_struct.field("x", &self.x);
        debug_struct.field("y", &self.y);
        debug_struct.field("crv", &self.crv);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetJSONWebKeysResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetJSONWebKeysResponse");
        debug_struct.field("keys", &self.keys);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CheckAutopilotCompatibilityRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckAutopilotCompatibilityRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AutopilotCompatibilityIssue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutopilotCompatibilityIssue");
        debug_struct.field("last_observation", &self.last_observation);
        debug_struct.field("constraint_type", &self.constraint_type);
        debug_struct.field("incompatibility_type", &self.incompatibility_type);
        debug_struct.field("subjects", &self.subjects);
        debug_struct.field("documentation_url", &self.documentation_url);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CheckAutopilotCompatibilityResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckAutopilotCompatibilityResponse");
        debug_struct.field("issues", &self.issues);
        debug_struct.field("summary", &self.summary);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReleaseChannel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReleaseChannel");
        debug_struct.field("channel", &self.channel);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CostManagementConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CostManagementConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IntraNodeVisibilityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IntraNodeVisibilityConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ILBSubsettingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ILBSubsettingConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DNSConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DNSConfig");
        debug_struct.field("cluster_dns", &self.cluster_dns);
        debug_struct.field("cluster_dns_scope", &self.cluster_dns_scope);
        debug_struct.field("cluster_dns_domain", &self.cluster_dns_domain);
        debug_struct.field(
            "additive_vpc_scope_dns_domain",
            &self.additive_vpc_scope_dns_domain,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MaxPodsConstraint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaxPodsConstraint");
        debug_struct.field("max_pods_per_node", &self.max_pods_per_node);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkloadIdentityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkloadIdentityConfig");
        debug_struct.field("workload_pool", &self.workload_pool);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::IdentityServiceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IdentityServiceConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MeshCertificates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MeshCertificates");
        debug_struct.field("enable_certificates", &self.enable_certificates);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DatabaseEncryption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatabaseEncryption");
        debug_struct.field("key_name", &self.key_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("current_state", &self.current_state);
        debug_struct.field("decryption_keys", &self.decryption_keys);
        debug_struct.field("last_operation_errors", &self.last_operation_errors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::database_encryption::OperationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationError");
        debug_struct.field("key_name", &self.key_name);
        debug_struct.field("error_message", &self.error_message);
        debug_struct.field("timestamp", &self.timestamp);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListUsableSubnetworksRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUsableSubnetworksRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListUsableSubnetworksResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUsableSubnetworksResponse");
        debug_struct.field("subnetworks", &self.subnetworks);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UsableSubnetworkSecondaryRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UsableSubnetworkSecondaryRange");
        debug_struct.field("range_name", &self.range_name);
        debug_struct.field("ip_cidr_range", &self.ip_cidr_range);
        debug_struct.field("status", &self.status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UsableSubnetwork {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UsableSubnetwork");
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("network", &self.network);
        debug_struct.field("ip_cidr_range", &self.ip_cidr_range);
        debug_struct.field("secondary_ip_ranges", &self.secondary_ip_ranges);
        debug_struct.field("status_message", &self.status_message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ResourceUsageExportConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceUsageExportConfig");
        debug_struct.field("bigquery_destination", &self.bigquery_destination);
        debug_struct.field(
            "enable_network_egress_metering",
            &self.enable_network_egress_metering,
        );
        debug_struct.field(
            "consumption_metering_config",
            &self.consumption_metering_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::resource_usage_export_config::BigQueryDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BigQueryDestination");
        debug_struct.field("dataset_id", &self.dataset_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::resource_usage_export_config::ConsumptionMeteringConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConsumptionMeteringConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VerticalPodAutoscaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VerticalPodAutoscaling");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DefaultSnatStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DefaultSnatStatus");
        debug_struct.field("disabled", &self.disabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ShieldedNodes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShieldedNodes");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VirtualNIC {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VirtualNIC");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FastSocket {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FastSocket");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GPUDirectConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GPUDirectConfig");
        debug_struct.field("gpu_direct_strategy", &self.gpu_direct_strategy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NotificationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NotificationConfig");
        debug_struct.field("pubsub", &self.pubsub);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::notification_config::PubSub {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PubSub");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("topic", &self.topic);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::notification_config::Filter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Filter");
        debug_struct.field("event_type", &self.event_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConfidentialNodes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfidentialNodes");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field(
            "confidential_instance_type",
            &self.confidential_instance_type,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpgradeEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeEvent");
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("operation", &self.operation);
        debug_struct.field("operation_start_time", &self.operation_start_time);
        debug_struct.field("current_version", &self.current_version);
        debug_struct.field("target_version", &self.target_version);
        debug_struct.field("resource", &self.resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpgradeInfoEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeInfoEvent");
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("operation", &self.operation);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("current_version", &self.current_version);
        debug_struct.field("target_version", &self.target_version);
        debug_struct.field("resource", &self.resource);
        debug_struct.field("state", &self.state);
        debug_struct.field("standard_support_end_time", &self.standard_support_end_time);
        debug_struct.field("extended_support_end_time", &self.extended_support_end_time);
        debug_struct.field("description", &self.description);
        debug_struct.field("event_type", &self.event_type);
        debug_struct.field("disruption_event", &self.disruption_event);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DisruptionEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisruptionEvent");
        debug_struct.field("disruption_type", &self.disruption_type);
        debug_struct.field("pdb_blocked_node", &self.pdb_blocked_node);
        debug_struct.field("pdb_blocked_pod", &self.pdb_blocked_pod);
        debug_struct.field("pdb_violation_timeout", &self.pdb_violation_timeout);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::disruption_event::PdbBlockedPod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PdbBlockedPod");
        debug_struct.field("namespace", &self.namespace);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpgradeAvailableEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeAvailableEvent");
        debug_struct.field("version", &self.version);
        debug_struct.field("resource_type", &self.resource_type);
        debug_struct.field("release_channel", &self.release_channel);
        debug_struct.field("resource", &self.resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecurityBulletinEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecurityBulletinEvent");
        debug_struct.field("resource_type_affected", &self.resource_type_affected);
        debug_struct.field("bulletin_id", &self.bulletin_id);
        debug_struct.field("cve_ids", &self.cve_ids);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("bulletin_uri", &self.bulletin_uri);
        debug_struct.field("brief_description", &self.brief_description);
        debug_struct.field("affected_supported_minors", &self.affected_supported_minors);
        debug_struct.field("patched_versions", &self.patched_versions);
        debug_struct.field("suggested_upgrade_target", &self.suggested_upgrade_target);
        debug_struct.field("manual_steps_required", &self.manual_steps_required);
        debug_struct.field("mitigated_versions", &self.mitigated_versions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Autopilot {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Autopilot");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("workload_policy_config", &self.workload_policy_config);
        debug_struct.field(
            "privileged_admission_config",
            &self.privileged_admission_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PrivilegedAdmissionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivilegedAdmissionConfig");
        debug_struct.field("allowlist_paths", &self.allowlist_paths);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::WorkloadPolicyConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("WorkloadPolicyConfig");
        debug_struct.field("allow_net_admin", &self.allow_net_admin);
        debug_struct.field(
            "autopilot_compatibility_auditing_enabled",
            &self.autopilot_compatibility_auditing_enabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingConfig");
        debug_struct.field("component_config", &self.component_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LoggingComponentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingComponentConfig");
        debug_struct.field("enable_components", &self.enable_components);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RayClusterLoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RayClusterLoggingConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MonitoringConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MonitoringConfig");
        debug_struct.field("component_config", &self.component_config);
        debug_struct.field("managed_prometheus_config", &self.managed_prometheus_config);
        debug_struct.field(
            "advanced_datapath_observability_config",
            &self.advanced_datapath_observability_config,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AdvancedDatapathObservabilityConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdvancedDatapathObservabilityConfig");
        debug_struct.field("enable_metrics", &self.enable_metrics);
        debug_struct.field("relay_mode", &self.relay_mode);
        debug_struct.field("enable_relay", &self.enable_relay);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RayClusterMonitoringConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RayClusterMonitoringConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodePoolLoggingConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePoolLoggingConfig");
        debug_struct.field("variant_config", &self.variant_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LoggingVariantConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingVariantConfig");
        debug_struct.field("variant", &self.variant);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MonitoringComponentConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MonitoringComponentConfig");
        debug_struct.field("enable_components", &self.enable_components);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ManagedPrometheusConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManagedPrometheusConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("auto_monitoring_config", &self.auto_monitoring_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AutoMonitoringConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutoMonitoringConfig");
        debug_struct.field("scope", &self.scope);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PodAutoscaling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PodAutoscaling");
        debug_struct.field("hpa_profile", &self.hpa_profile);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Fleet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Fleet");
        debug_struct.field("project", &self.project);
        debug_struct.field("membership", &self.membership);
        debug_struct.field("pre_registered", &self.pre_registered);
        debug_struct.field("membership_type", &self.membership_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ControlPlaneEndpointsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ControlPlaneEndpointsConfig");
        debug_struct.field("dns_endpoint_config", &self.dns_endpoint_config);
        debug_struct.field("ip_endpoints_config", &self.ip_endpoints_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::control_plane_endpoints_config::DNSEndpointConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DNSEndpointConfig");
        debug_struct.field("endpoint", &self.endpoint);
        debug_struct.field("allow_external_traffic", &self.allow_external_traffic);
        debug_struct.field("enable_k8s_tokens_via_dns", &self.enable_k8s_tokens_via_dns);
        debug_struct.field("enable_k8s_certs_via_dns", &self.enable_k8s_certs_via_dns);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::control_plane_endpoints_config::IPEndpointsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("IPEndpointsConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("enable_public_endpoint", &self.enable_public_endpoint);
        debug_struct.field("global_access", &self.global_access);
        debug_struct.field(
            "authorized_networks_config",
            &self.authorized_networks_config,
        );
        debug_struct.field("public_endpoint", &self.public_endpoint);
        debug_struct.field("private_endpoint", &self.private_endpoint);
        debug_struct.field(
            "private_endpoint_subnetwork",
            &self.private_endpoint_subnetwork,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LocalNvmeSsdBlockConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocalNvmeSsdBlockConfig");
        debug_struct.field("local_ssd_count", &self.local_ssd_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EphemeralStorageLocalSsdConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EphemeralStorageLocalSsdConfig");
        debug_struct.field("local_ssd_count", &self.local_ssd_count);
        debug_struct.field("data_cache_count", &self.data_cache_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ResourceManagerTags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceManagerTags");
        debug_struct.field("tags", &self.tags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::EnterpriseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnterpriseConfig");
        debug_struct.field("cluster_tier", &self.cluster_tier);
        debug_struct.field("desired_tier", &self.desired_tier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecretManagerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecretManagerConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("rotation_config", &self.rotation_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::secret_manager_config::RotationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RotationConfig");
        debug_struct.field("enabled", &self.enabled);
        debug_struct.field("rotation_interval", &self.rotation_interval);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BootDisk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BootDisk");
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("size_gb", &self.size_gb);
        debug_struct.field("provisioned_iops", &self.provisioned_iops);
        debug_struct.field("provisioned_throughput", &self.provisioned_throughput);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecondaryBootDisk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecondaryBootDisk");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("disk_image", &self.disk_image);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SecondaryBootDiskUpdateStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SecondaryBootDiskUpdateStrategy");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchClusterUpgradeInfoRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchClusterUpgradeInfoRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClusterUpgradeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterUpgradeInfo");
        debug_struct.field("minor_target_version", &self.minor_target_version);
        debug_struct.field("patch_target_version", &self.patch_target_version);
        debug_struct.field("auto_upgrade_status", &self.auto_upgrade_status);
        debug_struct.field("paused_reason", &self.paused_reason);
        debug_struct.field("upgrade_details", &self.upgrade_details);
        debug_struct.field(
            "end_of_standard_support_timestamp",
            &self.end_of_standard_support_timestamp,
        );
        debug_struct.field(
            "end_of_extended_support_timestamp",
            &self.end_of_extended_support_timestamp,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpgradeDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeDetails");
        debug_struct.field("state", &self.state);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("initial_version", &self.initial_version);
        debug_struct.field("target_version", &self.target_version);
        debug_struct.field("start_type", &self.start_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchNodePoolUpgradeInfoRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchNodePoolUpgradeInfoRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("version", &self.version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodePoolUpgradeInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePoolUpgradeInfo");
        debug_struct.field("minor_target_version", &self.minor_target_version);
        debug_struct.field("patch_target_version", &self.patch_target_version);
        debug_struct.field("auto_upgrade_status", &self.auto_upgrade_status);
        debug_struct.field("paused_reason", &self.paused_reason);
        debug_struct.field("upgrade_details", &self.upgrade_details);
        debug_struct.field(
            "end_of_standard_support_timestamp",
            &self.end_of_standard_support_timestamp,
        );
        debug_struct.field(
            "end_of_extended_support_timestamp",
            &self.end_of_extended_support_timestamp,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GkeAutoUpgradeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GkeAutoUpgradeConfig");
        debug_struct.field("patch_mode", &self.patch_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NetworkTierConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkTierConfig");
        debug_struct.field("network_tier", &self.network_tier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ManagedOpenTelemetryConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManagedOpenTelemetryConfig");
        debug_struct.field("scope", &self.scope);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
