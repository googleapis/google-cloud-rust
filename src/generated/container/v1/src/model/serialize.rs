// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl serde::ser::Serialize for super::LinuxNodeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sysctls.is_empty() {
            state.serialize_entry("sysctls", &self.sysctls)?;
        }
        if !wkt::internal::is_default(&self.cgroup_mode) {
            state.serialize_entry("cgroupMode", &self.cgroup_mode)?;
        }
        if self.hugepages.is_some() {
            state.serialize_entry("hugepages", &self.hugepages)?;
        }
        if !wkt::internal::is_default(&self.transparent_hugepage_enabled) {
            state.serialize_entry(
                "transparentHugepageEnabled",
                &self.transparent_hugepage_enabled,
            )?;
        }
        if !wkt::internal::is_default(&self.transparent_hugepage_defrag) {
            state.serialize_entry(
                "transparentHugepageDefrag",
                &self.transparent_hugepage_defrag,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::linux_node_config::HugepagesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.hugepage_size2m.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("hugepageSize2m", &__With(&self.hugepage_size2m))?;
        }
        if self.hugepage_size1g.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("hugepageSize1g", &__With(&self.hugepage_size1g))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::WindowsNodeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.os_version) {
            state.serialize_entry("osVersion", &self.os_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodeKubeletConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cpu_manager_policy.is_empty() {
            state.serialize_entry("cpuManagerPolicy", &self.cpu_manager_policy)?;
        }
        if self.topology_manager.is_some() {
            state.serialize_entry("topologyManager", &self.topology_manager)?;
        }
        if self.memory_manager.is_some() {
            state.serialize_entry("memoryManager", &self.memory_manager)?;
        }
        if self.cpu_cfs_quota.is_some() {
            state.serialize_entry("cpuCfsQuota", &self.cpu_cfs_quota)?;
        }
        if !self.cpu_cfs_quota_period.is_empty() {
            state.serialize_entry("cpuCfsQuotaPeriod", &self.cpu_cfs_quota_period)?;
        }
        if !wkt::internal::is_default(&self.pod_pids_limit) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("podPidsLimit", &__With(&self.pod_pids_limit))?;
        }
        if self.insecure_kubelet_readonly_port_enabled.is_some() {
            state.serialize_entry(
                "insecureKubeletReadonlyPortEnabled",
                &self.insecure_kubelet_readonly_port_enabled,
            )?;
        }
        if !wkt::internal::is_default(&self.image_gc_low_threshold_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "imageGcLowThresholdPercent",
                &__With(&self.image_gc_low_threshold_percent),
            )?;
        }
        if !wkt::internal::is_default(&self.image_gc_high_threshold_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "imageGcHighThresholdPercent",
                &__With(&self.image_gc_high_threshold_percent),
            )?;
        }
        if !self.image_minimum_gc_age.is_empty() {
            state.serialize_entry("imageMinimumGcAge", &self.image_minimum_gc_age)?;
        }
        if !self.image_maximum_gc_age.is_empty() {
            state.serialize_entry("imageMaximumGcAge", &self.image_maximum_gc_age)?;
        }
        if !self.container_log_max_size.is_empty() {
            state.serialize_entry("containerLogMaxSize", &self.container_log_max_size)?;
        }
        if !wkt::internal::is_default(&self.container_log_max_files) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "containerLogMaxFiles",
                &__With(&self.container_log_max_files),
            )?;
        }
        if !self.allowed_unsafe_sysctls.is_empty() {
            state.serialize_entry("allowedUnsafeSysctls", &self.allowed_unsafe_sysctls)?;
        }
        if self.eviction_soft.is_some() {
            state.serialize_entry("evictionSoft", &self.eviction_soft)?;
        }
        if self.eviction_soft_grace_period.is_some() {
            state.serialize_entry("evictionSoftGracePeriod", &self.eviction_soft_grace_period)?;
        }
        if self.eviction_minimum_reclaim.is_some() {
            state.serialize_entry("evictionMinimumReclaim", &self.eviction_minimum_reclaim)?;
        }
        if !wkt::internal::is_default(&self.eviction_max_pod_grace_period_seconds) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "evictionMaxPodGracePeriodSeconds",
                &__With(&self.eviction_max_pod_grace_period_seconds),
            )?;
        }
        if !wkt::internal::is_default(&self.max_parallel_image_pulls) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxParallelImagePulls",
                &__With(&self.max_parallel_image_pulls),
            )?;
        }
        if self.single_process_oom_kill.is_some() {
            state.serialize_entry("singleProcessOomKill", &self.single_process_oom_kill)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::TopologyManager {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policy.is_empty() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self.scope.is_empty() {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MemoryManager {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.policy.is_empty() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::EvictionSignals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.memory_available.is_empty() {
            state.serialize_entry("memoryAvailable", &self.memory_available)?;
        }
        if !self.nodefs_available.is_empty() {
            state.serialize_entry("nodefsAvailable", &self.nodefs_available)?;
        }
        if !self.nodefs_inodes_free.is_empty() {
            state.serialize_entry("nodefsInodesFree", &self.nodefs_inodes_free)?;
        }
        if !self.imagefs_available.is_empty() {
            state.serialize_entry("imagefsAvailable", &self.imagefs_available)?;
        }
        if !self.imagefs_inodes_free.is_empty() {
            state.serialize_entry("imagefsInodesFree", &self.imagefs_inodes_free)?;
        }
        if !self.pid_available.is_empty() {
            state.serialize_entry("pidAvailable", &self.pid_available)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::EvictionGracePeriod {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.memory_available.is_empty() {
            state.serialize_entry("memoryAvailable", &self.memory_available)?;
        }
        if !self.nodefs_available.is_empty() {
            state.serialize_entry("nodefsAvailable", &self.nodefs_available)?;
        }
        if !self.nodefs_inodes_free.is_empty() {
            state.serialize_entry("nodefsInodesFree", &self.nodefs_inodes_free)?;
        }
        if !self.imagefs_available.is_empty() {
            state.serialize_entry("imagefsAvailable", &self.imagefs_available)?;
        }
        if !self.imagefs_inodes_free.is_empty() {
            state.serialize_entry("imagefsInodesFree", &self.imagefs_inodes_free)?;
        }
        if !self.pid_available.is_empty() {
            state.serialize_entry("pidAvailable", &self.pid_available)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::EvictionMinimumReclaim {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.memory_available.is_empty() {
            state.serialize_entry("memoryAvailable", &self.memory_available)?;
        }
        if !self.nodefs_available.is_empty() {
            state.serialize_entry("nodefsAvailable", &self.nodefs_available)?;
        }
        if !self.nodefs_inodes_free.is_empty() {
            state.serialize_entry("nodefsInodesFree", &self.nodefs_inodes_free)?;
        }
        if !self.imagefs_available.is_empty() {
            state.serialize_entry("imagefsAvailable", &self.imagefs_available)?;
        }
        if !self.imagefs_inodes_free.is_empty() {
            state.serialize_entry("imagefsInodesFree", &self.imagefs_inodes_free)?;
        }
        if !self.pid_available.is_empty() {
            state.serialize_entry("pidAvailable", &self.pid_available)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !wkt::internal::is_default(&self.disk_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if !self.oauth_scopes.is_empty() {
            state.serialize_entry("oauthScopes", &self.oauth_scopes)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.image_type.is_empty() {
            state.serialize_entry("imageType", &self.image_type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.local_ssd_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("localSsdCount", &__With(&self.local_ssd_count))?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !wkt::internal::is_default(&self.preemptible) {
            state.serialize_entry("preemptible", &self.preemptible)?;
        }
        if !self.accelerators.is_empty() {
            state.serialize_entry("accelerators", &self.accelerators)?;
        }
        if !self.disk_type.is_empty() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self.min_cpu_platform.is_empty() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if self.workload_metadata_config.is_some() {
            state.serialize_entry("workloadMetadataConfig", &self.workload_metadata_config)?;
        }
        if !self.taints.is_empty() {
            state.serialize_entry("taints", &self.taints)?;
        }
        if self.sandbox_config.is_some() {
            state.serialize_entry("sandboxConfig", &self.sandbox_config)?;
        }
        if !self.node_group.is_empty() {
            state.serialize_entry("nodeGroup", &self.node_group)?;
        }
        if self.reservation_affinity.is_some() {
            state.serialize_entry("reservationAffinity", &self.reservation_affinity)?;
        }
        if self.shielded_instance_config.is_some() {
            state.serialize_entry("shieldedInstanceConfig", &self.shielded_instance_config)?;
        }
        if self.linux_node_config.is_some() {
            state.serialize_entry("linuxNodeConfig", &self.linux_node_config)?;
        }
        if self.kubelet_config.is_some() {
            state.serialize_entry("kubeletConfig", &self.kubelet_config)?;
        }
        if !self.boot_disk_kms_key.is_empty() {
            state.serialize_entry("bootDiskKmsKey", &self.boot_disk_kms_key)?;
        }
        if self.gcfs_config.is_some() {
            state.serialize_entry("gcfsConfig", &self.gcfs_config)?;
        }
        if self.advanced_machine_features.is_some() {
            state.serialize_entry("advancedMachineFeatures", &self.advanced_machine_features)?;
        }
        if self.gvnic.is_some() {
            state.serialize_entry("gvnic", &self.gvnic)?;
        }
        if !wkt::internal::is_default(&self.spot) {
            state.serialize_entry("spot", &self.spot)?;
        }
        if self.confidential_nodes.is_some() {
            state.serialize_entry("confidentialNodes", &self.confidential_nodes)?;
        }
        if self.fast_socket.is_some() {
            state.serialize_entry("fastSocket", &self.fast_socket)?;
        }
        if !self.resource_labels.is_empty() {
            state.serialize_entry("resourceLabels", &self.resource_labels)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.windows_node_config.is_some() {
            state.serialize_entry("windowsNodeConfig", &self.windows_node_config)?;
        }
        if self.local_nvme_ssd_block_config.is_some() {
            state.serialize_entry("localNvmeSsdBlockConfig", &self.local_nvme_ssd_block_config)?;
        }
        if self.ephemeral_storage_local_ssd_config.is_some() {
            state.serialize_entry(
                "ephemeralStorageLocalSsdConfig",
                &self.ephemeral_storage_local_ssd_config,
            )?;
        }
        if self.sole_tenant_config.is_some() {
            state.serialize_entry("soleTenantConfig", &self.sole_tenant_config)?;
        }
        if self.containerd_config.is_some() {
            state.serialize_entry("containerdConfig", &self.containerd_config)?;
        }
        if self.resource_manager_tags.is_some() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if !wkt::internal::is_default(&self.enable_confidential_storage) {
            state.serialize_entry(
                "enableConfidentialStorage",
                &self.enable_confidential_storage,
            )?;
        }
        if !self.secondary_boot_disks.is_empty() {
            state.serialize_entry("secondaryBootDisks", &self.secondary_boot_disks)?;
        }
        if !self.storage_pools.is_empty() {
            state.serialize_entry("storagePools", &self.storage_pools)?;
        }
        if self.secondary_boot_disk_update_strategy.is_some() {
            state.serialize_entry(
                "secondaryBootDiskUpdateStrategy",
                &self.secondary_boot_disk_update_strategy,
            )?;
        }
        if self.max_run_duration.is_some() {
            state.serialize_entry("maxRunDuration", &self.max_run_duration)?;
        }
        if self.local_ssd_encryption_mode.is_some() {
            state.serialize_entry("localSsdEncryptionMode", &self.local_ssd_encryption_mode)?;
        }
        if !wkt::internal::is_default(&self.effective_cgroup_mode) {
            state.serialize_entry("effectiveCgroupMode", &self.effective_cgroup_mode)?;
        }
        if self.flex_start.is_some() {
            state.serialize_entry("flexStart", &self.flex_start)?;
        }
        if self.boot_disk.is_some() {
            state.serialize_entry("bootDisk", &self.boot_disk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AdvancedMachineFeatures {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.threads_per_core.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("threadsPerCore", &__With(&self.threads_per_core))?;
        }
        if self.enable_nested_virtualization.is_some() {
            state.serialize_entry(
                "enableNestedVirtualization",
                &self.enable_nested_virtualization,
            )?;
        }
        if self.performance_monitoring_unit.is_some() {
            state.serialize_entry(
                "performanceMonitoringUnit",
                &self.performance_monitoring_unit,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodeNetworkConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.create_pod_range) {
            state.serialize_entry("createPodRange", &self.create_pod_range)?;
        }
        if !self.pod_range.is_empty() {
            state.serialize_entry("podRange", &self.pod_range)?;
        }
        if !self.pod_ipv4_cidr_block.is_empty() {
            state.serialize_entry("podIpv4CidrBlock", &self.pod_ipv4_cidr_block)?;
        }
        if self.enable_private_nodes.is_some() {
            state.serialize_entry("enablePrivateNodes", &self.enable_private_nodes)?;
        }
        if self.network_performance_config.is_some() {
            state.serialize_entry("networkPerformanceConfig", &self.network_performance_config)?;
        }
        if self.pod_cidr_overprovision_config.is_some() {
            state.serialize_entry(
                "podCidrOverprovisionConfig",
                &self.pod_cidr_overprovision_config,
            )?;
        }
        if !self.additional_node_network_configs.is_empty() {
            state.serialize_entry(
                "additionalNodeNetworkConfigs",
                &self.additional_node_network_configs,
            )?;
        }
        if !self.additional_pod_network_configs.is_empty() {
            state.serialize_entry(
                "additionalPodNetworkConfigs",
                &self.additional_pod_network_configs,
            )?;
        }
        if !wkt::internal::is_default(&self.pod_ipv4_range_utilization) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "podIpv4RangeUtilization",
                &__With(&self.pod_ipv4_range_utilization),
            )?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::node_network_config::NetworkPerformanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.total_egress_bandwidth_tier.is_some() {
            state.serialize_entry(
                "totalEgressBandwidthTier",
                &self.total_egress_bandwidth_tier,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AdditionalNodeNetworkConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AdditionalPodNetworkConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.secondary_pod_range.is_empty() {
            state.serialize_entry("secondaryPodRange", &self.secondary_pod_range)?;
        }
        if self.max_pods_per_node.is_some() {
            state.serialize_entry("maxPodsPerNode", &self.max_pods_per_node)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ShieldedInstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_secure_boot) {
            state.serialize_entry("enableSecureBoot", &self.enable_secure_boot)?;
        }
        if !wkt::internal::is_default(&self.enable_integrity_monitoring) {
            state.serialize_entry(
                "enableIntegrityMonitoring",
                &self.enable_integrity_monitoring,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SandboxConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GcfsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ReservationAffinity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.consume_reservation_type) {
            state.serialize_entry("consumeReservationType", &self.consume_reservation_type)?;
        }
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SoleTenantConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_affinities.is_empty() {
            state.serialize_entry("nodeAffinities", &self.node_affinities)?;
        }
        if self.min_node_cpus.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("minNodeCpus", &__With(&self.min_node_cpus))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::sole_tenant_config::NodeAffinity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !wkt::internal::is_default(&self.operator) {
            state.serialize_entry("operator", &self.operator)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ContainerdConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.private_registry_access_config.is_some() {
            state.serialize_entry(
                "privateRegistryAccessConfig",
                &self.private_registry_access_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::containerd_config::PrivateRegistryAccessConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.certificate_authority_domain_config.is_empty() {
            state.serialize_entry(
                "certificateAuthorityDomainConfig",
                &self.certificate_authority_domain_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize
    for super::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig
{
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.fqdns.is_empty() {
            state.serialize_entry("fqdns", &self.fqdns)?;
        }
        if let Some(value) = self.gcp_secret_manager_certificate_config() {
            state.serialize_entry("gcpSecretManagerCertificateConfig", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        #[allow(unused_imports)]
        use std::option::Option::Some;
        use serde::ser::SerializeMap;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.secret_uri.is_empty() {
            state.serialize_entry("secretUri", &self.secret_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodeTaint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !self.value.is_empty() {
            state.serialize_entry("value", &self.value)?;
        }
        if !wkt::internal::is_default(&self.effect) {
            state.serialize_entry("effect", &self.effect)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodeTaints {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.taints.is_empty() {
            state.serialize_entry("taints", &self.taints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodeLabels {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceLabels {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkTags {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MasterAuth {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if self.client_certificate_config.is_some() {
            state.serialize_entry("clientCertificateConfig", &self.client_certificate_config)?;
        }
        if !self.cluster_ca_certificate.is_empty() {
            state.serialize_entry("clusterCaCertificate", &self.cluster_ca_certificate)?;
        }
        if !self.client_certificate.is_empty() {
            state.serialize_entry("clientCertificate", &self.client_certificate)?;
        }
        if !self.client_key.is_empty() {
            state.serialize_entry("clientKey", &self.client_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ClientCertificateConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.issue_client_certificate) {
            state.serialize_entry("issueClientCertificate", &self.issue_client_certificate)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AddonsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.http_load_balancing.is_some() {
            state.serialize_entry("httpLoadBalancing", &self.http_load_balancing)?;
        }
        if self.horizontal_pod_autoscaling.is_some() {
            state.serialize_entry("horizontalPodAutoscaling", &self.horizontal_pod_autoscaling)?;
        }
        if self.kubernetes_dashboard.is_some() {
            state.serialize_entry("kubernetesDashboard", &self.kubernetes_dashboard)?;
        }
        if self.network_policy_config.is_some() {
            state.serialize_entry("networkPolicyConfig", &self.network_policy_config)?;
        }
        if self.cloud_run_config.is_some() {
            state.serialize_entry("cloudRunConfig", &self.cloud_run_config)?;
        }
        if self.dns_cache_config.is_some() {
            state.serialize_entry("dnsCacheConfig", &self.dns_cache_config)?;
        }
        if self.config_connector_config.is_some() {
            state.serialize_entry("configConnectorConfig", &self.config_connector_config)?;
        }
        if self.gce_persistent_disk_csi_driver_config.is_some() {
            state.serialize_entry(
                "gcePersistentDiskCsiDriverConfig",
                &self.gce_persistent_disk_csi_driver_config,
            )?;
        }
        if self.gcp_filestore_csi_driver_config.is_some() {
            state.serialize_entry(
                "gcpFilestoreCsiDriverConfig",
                &self.gcp_filestore_csi_driver_config,
            )?;
        }
        if self.gke_backup_agent_config.is_some() {
            state.serialize_entry("gkeBackupAgentConfig", &self.gke_backup_agent_config)?;
        }
        if self.gcs_fuse_csi_driver_config.is_some() {
            state.serialize_entry("gcsFuseCsiDriverConfig", &self.gcs_fuse_csi_driver_config)?;
        }
        if self.stateful_ha_config.is_some() {
            state.serialize_entry("statefulHaConfig", &self.stateful_ha_config)?;
        }
        if self.parallelstore_csi_driver_config.is_some() {
            state.serialize_entry(
                "parallelstoreCsiDriverConfig",
                &self.parallelstore_csi_driver_config,
            )?;
        }
        if self.ray_operator_config.is_some() {
            state.serialize_entry("rayOperatorConfig", &self.ray_operator_config)?;
        }
        if self.high_scale_checkpointing_config.is_some() {
            state.serialize_entry(
                "highScaleCheckpointingConfig",
                &self.high_scale_checkpointing_config,
            )?;
        }
        if self.lustre_csi_driver_config.is_some() {
            state.serialize_entry("lustreCsiDriverConfig", &self.lustre_csi_driver_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::HttpLoadBalancing {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::HorizontalPodAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::KubernetesDashboard {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkPolicyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DnsCacheConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::PrivateClusterMasterGlobalAccessConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::PrivateClusterConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_private_nodes) {
            state.serialize_entry("enablePrivateNodes", &self.enable_private_nodes)?;
        }
        if !wkt::internal::is_default(&self.enable_private_endpoint) {
            state.serialize_entry("enablePrivateEndpoint", &self.enable_private_endpoint)?;
        }
        if !self.master_ipv4_cidr_block.is_empty() {
            state.serialize_entry("masterIpv4CidrBlock", &self.master_ipv4_cidr_block)?;
        }
        if !self.private_endpoint.is_empty() {
            state.serialize_entry("privateEndpoint", &self.private_endpoint)?;
        }
        if !self.public_endpoint.is_empty() {
            state.serialize_entry("publicEndpoint", &self.public_endpoint)?;
        }
        if !self.peering_name.is_empty() {
            state.serialize_entry("peeringName", &self.peering_name)?;
        }
        if self.master_global_access_config.is_some() {
            state.serialize_entry(
                "masterGlobalAccessConfig",
                &self.master_global_access_config,
            )?;
        }
        if !self.private_endpoint_subnetwork.is_empty() {
            state.serialize_entry(
                "privateEndpointSubnetwork",
                &self.private_endpoint_subnetwork,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AuthenticatorGroupsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.security_group.is_empty() {
            state.serialize_entry("securityGroup", &self.security_group)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CloudRunConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !wkt::internal::is_default(&self.load_balancer_type) {
            state.serialize_entry("loadBalancerType", &self.load_balancer_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ConfigConnectorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GcePersistentDiskCsiDriverConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GcpFilestoreCsiDriverConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GcsFuseCsiDriverConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ParallelstoreCsiDriverConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::HighScaleCheckpointingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LustreCsiDriverConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.enable_legacy_lustre_port) {
            state.serialize_entry("enableLegacyLustrePort", &self.enable_legacy_lustre_port)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RayOperatorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.ray_cluster_logging_config.is_some() {
            state.serialize_entry("rayClusterLoggingConfig", &self.ray_cluster_logging_config)?;
        }
        if self.ray_cluster_monitoring_config.is_some() {
            state.serialize_entry(
                "rayClusterMonitoringConfig",
                &self.ray_cluster_monitoring_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GkeBackupAgentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::StatefulHAConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MasterAuthorizedNetworksConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.cidr_blocks.is_empty() {
            state.serialize_entry("cidrBlocks", &self.cidr_blocks)?;
        }
        if self.gcp_public_cidrs_access_enabled.is_some() {
            state.serialize_entry(
                "gcpPublicCidrsAccessEnabled",
                &self.gcp_public_cidrs_access_enabled,
            )?;
        }
        if self.private_endpoint_enforcement_enabled.is_some() {
            state.serialize_entry(
                "privateEndpointEnforcementEnabled",
                &self.private_endpoint_enforcement_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::master_authorized_networks_config::CidrBlock {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.cidr_block.is_empty() {
            state.serialize_entry("cidrBlock", &self.cidr_block)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LegacyAbac {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.provider) {
            state.serialize_entry("provider", &self.provider)?;
        }
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::BinaryAuthorization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.evaluation_mode) {
            state.serialize_entry("evaluationMode", &self.evaluation_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::PodCIDROverprovisionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disable) {
            state.serialize_entry("disable", &self.disable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::IPAllocationPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.use_ip_aliases) {
            state.serialize_entry("useIpAliases", &self.use_ip_aliases)?;
        }
        if !wkt::internal::is_default(&self.create_subnetwork) {
            state.serialize_entry("createSubnetwork", &self.create_subnetwork)?;
        }
        if !self.subnetwork_name.is_empty() {
            state.serialize_entry("subnetworkName", &self.subnetwork_name)?;
        }
        if !self.cluster_ipv4_cidr.is_empty() {
            state.serialize_entry("clusterIpv4Cidr", &self.cluster_ipv4_cidr)?;
        }
        if !self.node_ipv4_cidr.is_empty() {
            state.serialize_entry("nodeIpv4Cidr", &self.node_ipv4_cidr)?;
        }
        if !self.services_ipv4_cidr.is_empty() {
            state.serialize_entry("servicesIpv4Cidr", &self.services_ipv4_cidr)?;
        }
        if !self.cluster_secondary_range_name.is_empty() {
            state.serialize_entry(
                "clusterSecondaryRangeName",
                &self.cluster_secondary_range_name,
            )?;
        }
        if !self.services_secondary_range_name.is_empty() {
            state.serialize_entry(
                "servicesSecondaryRangeName",
                &self.services_secondary_range_name,
            )?;
        }
        if !self.cluster_ipv4_cidr_block.is_empty() {
            state.serialize_entry("clusterIpv4CidrBlock", &self.cluster_ipv4_cidr_block)?;
        }
        if !self.node_ipv4_cidr_block.is_empty() {
            state.serialize_entry("nodeIpv4CidrBlock", &self.node_ipv4_cidr_block)?;
        }
        if !self.services_ipv4_cidr_block.is_empty() {
            state.serialize_entry("servicesIpv4CidrBlock", &self.services_ipv4_cidr_block)?;
        }
        if !self.tpu_ipv4_cidr_block.is_empty() {
            state.serialize_entry("tpuIpv4CidrBlock", &self.tpu_ipv4_cidr_block)?;
        }
        if !wkt::internal::is_default(&self.use_routes) {
            state.serialize_entry("useRoutes", &self.use_routes)?;
        }
        if !wkt::internal::is_default(&self.stack_type) {
            state.serialize_entry("stackType", &self.stack_type)?;
        }
        if !wkt::internal::is_default(&self.ipv6_access_type) {
            state.serialize_entry("ipv6AccessType", &self.ipv6_access_type)?;
        }
        if self.pod_cidr_overprovision_config.is_some() {
            state.serialize_entry(
                "podCidrOverprovisionConfig",
                &self.pod_cidr_overprovision_config,
            )?;
        }
        if !self.subnet_ipv6_cidr_block.is_empty() {
            state.serialize_entry("subnetIpv6CidrBlock", &self.subnet_ipv6_cidr_block)?;
        }
        if !self.services_ipv6_cidr_block.is_empty() {
            state.serialize_entry("servicesIpv6CidrBlock", &self.services_ipv6_cidr_block)?;
        }
        if self.additional_pod_ranges_config.is_some() {
            state.serialize_entry(
                "additionalPodRangesConfig",
                &self.additional_pod_ranges_config,
            )?;
        }
        if !wkt::internal::is_default(&self.default_pod_ipv4_range_utilization) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "defaultPodIpv4RangeUtilization",
                &__With(&self.default_pod_ipv4_range_utilization),
            )?;
        }
        if !self.additional_ip_ranges_configs.is_empty() {
            state.serialize_entry(
                "additionalIpRangesConfigs",
                &self.additional_ip_ranges_configs,
            )?;
        }
        if self.auto_ipam_config.is_some() {
            state.serialize_entry("autoIpamConfig", &self.auto_ipam_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Cluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.initial_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("initialNodeCount", &__With(&self.initial_node_count))?;
        }
        if self.node_config.is_some() {
            state.serialize_entry("nodeConfig", &self.node_config)?;
        }
        if self.master_auth.is_some() {
            state.serialize_entry("masterAuth", &self.master_auth)?;
        }
        if !self.logging_service.is_empty() {
            state.serialize_entry("loggingService", &self.logging_service)?;
        }
        if !self.monitoring_service.is_empty() {
            state.serialize_entry("monitoringService", &self.monitoring_service)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.cluster_ipv4_cidr.is_empty() {
            state.serialize_entry("clusterIpv4Cidr", &self.cluster_ipv4_cidr)?;
        }
        if self.addons_config.is_some() {
            state.serialize_entry("addonsConfig", &self.addons_config)?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.node_pools.is_empty() {
            state.serialize_entry("nodePools", &self.node_pools)?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if !wkt::internal::is_default(&self.enable_kubernetes_alpha) {
            state.serialize_entry("enableKubernetesAlpha", &self.enable_kubernetes_alpha)?;
        }
        if !self.alpha_cluster_feature_gates.is_empty() {
            state.serialize_entry(
                "alphaClusterFeatureGates",
                &self.alpha_cluster_feature_gates,
            )?;
        }
        if !self.resource_labels.is_empty() {
            state.serialize_entry("resourceLabels", &self.resource_labels)?;
        }
        if !self.label_fingerprint.is_empty() {
            state.serialize_entry("labelFingerprint", &self.label_fingerprint)?;
        }
        if self.legacy_abac.is_some() {
            state.serialize_entry("legacyAbac", &self.legacy_abac)?;
        }
        if self.network_policy.is_some() {
            state.serialize_entry("networkPolicy", &self.network_policy)?;
        }
        if self.ip_allocation_policy.is_some() {
            state.serialize_entry("ipAllocationPolicy", &self.ip_allocation_policy)?;
        }
        if self.master_authorized_networks_config.is_some() {
            state.serialize_entry(
                "masterAuthorizedNetworksConfig",
                &self.master_authorized_networks_config,
            )?;
        }
        if self.maintenance_policy.is_some() {
            state.serialize_entry("maintenancePolicy", &self.maintenance_policy)?;
        }
        if self.binary_authorization.is_some() {
            state.serialize_entry("binaryAuthorization", &self.binary_authorization)?;
        }
        if self.autoscaling.is_some() {
            state.serialize_entry("autoscaling", &self.autoscaling)?;
        }
        if self.network_config.is_some() {
            state.serialize_entry("networkConfig", &self.network_config)?;
        }
        if self.default_max_pods_constraint.is_some() {
            state.serialize_entry(
                "defaultMaxPodsConstraint",
                &self.default_max_pods_constraint,
            )?;
        }
        if self.resource_usage_export_config.is_some() {
            state.serialize_entry(
                "resourceUsageExportConfig",
                &self.resource_usage_export_config,
            )?;
        }
        if self.authenticator_groups_config.is_some() {
            state.serialize_entry(
                "authenticatorGroupsConfig",
                &self.authenticator_groups_config,
            )?;
        }
        if self.private_cluster_config.is_some() {
            state.serialize_entry("privateClusterConfig", &self.private_cluster_config)?;
        }
        if self.database_encryption.is_some() {
            state.serialize_entry("databaseEncryption", &self.database_encryption)?;
        }
        if self.vertical_pod_autoscaling.is_some() {
            state.serialize_entry("verticalPodAutoscaling", &self.vertical_pod_autoscaling)?;
        }
        if self.shielded_nodes.is_some() {
            state.serialize_entry("shieldedNodes", &self.shielded_nodes)?;
        }
        if self.release_channel.is_some() {
            state.serialize_entry("releaseChannel", &self.release_channel)?;
        }
        if self.workload_identity_config.is_some() {
            state.serialize_entry("workloadIdentityConfig", &self.workload_identity_config)?;
        }
        if self.mesh_certificates.is_some() {
            state.serialize_entry("meshCertificates", &self.mesh_certificates)?;
        }
        if self.cost_management_config.is_some() {
            state.serialize_entry("costManagementConfig", &self.cost_management_config)?;
        }
        if self.notification_config.is_some() {
            state.serialize_entry("notificationConfig", &self.notification_config)?;
        }
        if self.confidential_nodes.is_some() {
            state.serialize_entry("confidentialNodes", &self.confidential_nodes)?;
        }
        if self.identity_service_config.is_some() {
            state.serialize_entry("identityServiceConfig", &self.identity_service_config)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.endpoint.is_empty() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if !self.initial_cluster_version.is_empty() {
            state.serialize_entry("initialClusterVersion", &self.initial_cluster_version)?;
        }
        if !self.current_master_version.is_empty() {
            state.serialize_entry("currentMasterVersion", &self.current_master_version)?;
        }
        if !self.current_node_version.is_empty() {
            state.serialize_entry("currentNodeVersion", &self.current_node_version)?;
        }
        if !self.create_time.is_empty() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.node_ipv4_cidr_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nodeIpv4CidrSize", &__With(&self.node_ipv4_cidr_size))?;
        }
        if !self.services_ipv4_cidr.is_empty() {
            state.serialize_entry("servicesIpv4Cidr", &self.services_ipv4_cidr)?;
        }
        if !self.instance_group_urls.is_empty() {
            state.serialize_entry("instanceGroupUrls", &self.instance_group_urls)?;
        }
        if !wkt::internal::is_default(&self.current_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("currentNodeCount", &__With(&self.current_node_count))?;
        }
        if !self.expire_time.is_empty() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.enable_tpu) {
            state.serialize_entry("enableTpu", &self.enable_tpu)?;
        }
        if !self.tpu_ipv4_cidr_block.is_empty() {
            state.serialize_entry("tpuIpv4CidrBlock", &self.tpu_ipv4_cidr_block)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if self.autopilot.is_some() {
            state.serialize_entry("autopilot", &self.autopilot)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if self.node_pool_defaults.is_some() {
            state.serialize_entry("nodePoolDefaults", &self.node_pool_defaults)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.monitoring_config.is_some() {
            state.serialize_entry("monitoringConfig", &self.monitoring_config)?;
        }
        if self.node_pool_auto_config.is_some() {
            state.serialize_entry("nodePoolAutoConfig", &self.node_pool_auto_config)?;
        }
        if self.pod_autoscaling.is_some() {
            state.serialize_entry("podAutoscaling", &self.pod_autoscaling)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.fleet.is_some() {
            state.serialize_entry("fleet", &self.fleet)?;
        }
        if self.security_posture_config.is_some() {
            state.serialize_entry("securityPostureConfig", &self.security_posture_config)?;
        }
        if self.control_plane_endpoints_config.is_some() {
            state.serialize_entry(
                "controlPlaneEndpointsConfig",
                &self.control_plane_endpoints_config,
            )?;
        }
        if self.enable_k8s_beta_apis.is_some() {
            state.serialize_entry("enableK8sBetaApis", &self.enable_k8s_beta_apis)?;
        }
        if self.enterprise_config.is_some() {
            state.serialize_entry("enterpriseConfig", &self.enterprise_config)?;
        }
        if self.secret_manager_config.is_some() {
            state.serialize_entry("secretManagerConfig", &self.secret_manager_config)?;
        }
        if self.compliance_posture_config.is_some() {
            state.serialize_entry("compliancePostureConfig", &self.compliance_posture_config)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if self.user_managed_keys_config.is_some() {
            state.serialize_entry("userManagedKeysConfig", &self.user_managed_keys_config)?;
        }
        if self.rbac_binding_config.is_some() {
            state.serialize_entry("rbacBindingConfig", &self.rbac_binding_config)?;
        }
        if self.gke_auto_upgrade_config.is_some() {
            state.serialize_entry("gkeAutoUpgradeConfig", &self.gke_auto_upgrade_config)?;
        }
        if self.anonymous_authentication_config.is_some() {
            state.serialize_entry(
                "anonymousAuthenticationConfig",
                &self.anonymous_authentication_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RBACBindingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self
            .enable_insecure_binding_system_unauthenticated
            .is_some()
        {
            state.serialize_entry(
                "enableInsecureBindingSystemUnauthenticated",
                &self.enable_insecure_binding_system_unauthenticated,
            )?;
        }
        if self.enable_insecure_binding_system_authenticated.is_some() {
            state.serialize_entry(
                "enableInsecureBindingSystemAuthenticated",
                &self.enable_insecure_binding_system_authenticated,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UserManagedKeysConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster_ca.is_empty() {
            state.serialize_entry("clusterCa", &self.cluster_ca)?;
        }
        if !self.etcd_api_ca.is_empty() {
            state.serialize_entry("etcdApiCa", &self.etcd_api_ca)?;
        }
        if !self.etcd_peer_ca.is_empty() {
            state.serialize_entry("etcdPeerCa", &self.etcd_peer_ca)?;
        }
        if !self.service_account_signing_keys.is_empty() {
            state.serialize_entry(
                "serviceAccountSigningKeys",
                &self.service_account_signing_keys,
            )?;
        }
        if !self.service_account_verification_keys.is_empty() {
            state.serialize_entry(
                "serviceAccountVerificationKeys",
                &self.service_account_verification_keys,
            )?;
        }
        if !self.aggregation_ca.is_empty() {
            state.serialize_entry("aggregationCa", &self.aggregation_ca)?;
        }
        if !self.control_plane_disk_encryption_key.is_empty() {
            state.serialize_entry(
                "controlPlaneDiskEncryptionKey",
                &self.control_plane_disk_encryption_key,
            )?;
        }
        if !self.gkeops_etcd_backup_encryption_key.is_empty() {
            state.serialize_entry(
                "gkeopsEtcdBackupEncryptionKey",
                &self.gkeops_etcd_backup_encryption_key,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AnonymousAuthenticationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CompliancePostureConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self.compliance_standards.is_empty() {
            state.serialize_entry("complianceStandards", &self.compliance_standards)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::compliance_posture_config::ComplianceStandard {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.standard.is_some() {
            state.serialize_entry("standard", &self.standard)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::K8sBetaAPIConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.enabled_apis.is_empty() {
            state.serialize_entry("enabledApis", &self.enabled_apis)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityPostureConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.mode.is_some() {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.vulnerability_mode.is_some() {
            state.serialize_entry("vulnerabilityMode", &self.vulnerability_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodePoolAutoConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.network_tags.is_some() {
            state.serialize_entry("networkTags", &self.network_tags)?;
        }
        if self.resource_manager_tags.is_some() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if self.node_kubelet_config.is_some() {
            state.serialize_entry("nodeKubeletConfig", &self.node_kubelet_config)?;
        }
        if self.linux_node_config.is_some() {
            state.serialize_entry("linuxNodeConfig", &self.linux_node_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodePoolDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.node_config_defaults.is_some() {
            state.serialize_entry("nodeConfigDefaults", &self.node_config_defaults)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodeConfigDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.gcfs_config.is_some() {
            state.serialize_entry("gcfsConfig", &self.gcfs_config)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.containerd_config.is_some() {
            state.serialize_entry("containerdConfig", &self.containerd_config)?;
        }
        if self.node_kubelet_config.is_some() {
            state.serialize_entry("nodeKubeletConfig", &self.node_kubelet_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ClusterUpdate {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.desired_node_version.is_empty() {
            state.serialize_entry("desiredNodeVersion", &self.desired_node_version)?;
        }
        if !self.desired_monitoring_service.is_empty() {
            state.serialize_entry("desiredMonitoringService", &self.desired_monitoring_service)?;
        }
        if self.desired_addons_config.is_some() {
            state.serialize_entry("desiredAddonsConfig", &self.desired_addons_config)?;
        }
        if !self.desired_node_pool_id.is_empty() {
            state.serialize_entry("desiredNodePoolId", &self.desired_node_pool_id)?;
        }
        if !self.desired_image_type.is_empty() {
            state.serialize_entry("desiredImageType", &self.desired_image_type)?;
        }
        if self.desired_database_encryption.is_some() {
            state.serialize_entry(
                "desiredDatabaseEncryption",
                &self.desired_database_encryption,
            )?;
        }
        if self.desired_workload_identity_config.is_some() {
            state.serialize_entry(
                "desiredWorkloadIdentityConfig",
                &self.desired_workload_identity_config,
            )?;
        }
        if self.desired_mesh_certificates.is_some() {
            state.serialize_entry("desiredMeshCertificates", &self.desired_mesh_certificates)?;
        }
        if self.desired_shielded_nodes.is_some() {
            state.serialize_entry("desiredShieldedNodes", &self.desired_shielded_nodes)?;
        }
        if self.desired_cost_management_config.is_some() {
            state.serialize_entry(
                "desiredCostManagementConfig",
                &self.desired_cost_management_config,
            )?;
        }
        if self.desired_dns_config.is_some() {
            state.serialize_entry("desiredDnsConfig", &self.desired_dns_config)?;
        }
        if self.desired_node_pool_autoscaling.is_some() {
            state.serialize_entry(
                "desiredNodePoolAutoscaling",
                &self.desired_node_pool_autoscaling,
            )?;
        }
        if !self.desired_locations.is_empty() {
            state.serialize_entry("desiredLocations", &self.desired_locations)?;
        }
        if self.desired_master_authorized_networks_config.is_some() {
            state.serialize_entry(
                "desiredMasterAuthorizedNetworksConfig",
                &self.desired_master_authorized_networks_config,
            )?;
        }
        if self.desired_cluster_autoscaling.is_some() {
            state.serialize_entry(
                "desiredClusterAutoscaling",
                &self.desired_cluster_autoscaling,
            )?;
        }
        if self.desired_binary_authorization.is_some() {
            state.serialize_entry(
                "desiredBinaryAuthorization",
                &self.desired_binary_authorization,
            )?;
        }
        if !self.desired_logging_service.is_empty() {
            state.serialize_entry("desiredLoggingService", &self.desired_logging_service)?;
        }
        if self.desired_resource_usage_export_config.is_some() {
            state.serialize_entry(
                "desiredResourceUsageExportConfig",
                &self.desired_resource_usage_export_config,
            )?;
        }
        if self.desired_vertical_pod_autoscaling.is_some() {
            state.serialize_entry(
                "desiredVerticalPodAutoscaling",
                &self.desired_vertical_pod_autoscaling,
            )?;
        }
        if self.desired_private_cluster_config.is_some() {
            state.serialize_entry(
                "desiredPrivateClusterConfig",
                &self.desired_private_cluster_config,
            )?;
        }
        if self.desired_intra_node_visibility_config.is_some() {
            state.serialize_entry(
                "desiredIntraNodeVisibilityConfig",
                &self.desired_intra_node_visibility_config,
            )?;
        }
        if self.desired_default_snat_status.is_some() {
            state.serialize_entry(
                "desiredDefaultSnatStatus",
                &self.desired_default_snat_status,
            )?;
        }
        if self.desired_release_channel.is_some() {
            state.serialize_entry("desiredReleaseChannel", &self.desired_release_channel)?;
        }
        if self.desired_l4ilb_subsetting_config.is_some() {
            state.serialize_entry(
                "desiredL4ilbSubsettingConfig",
                &self.desired_l4ilb_subsetting_config,
            )?;
        }
        if !wkt::internal::is_default(&self.desired_datapath_provider) {
            state.serialize_entry("desiredDatapathProvider", &self.desired_datapath_provider)?;
        }
        if !wkt::internal::is_default(&self.desired_private_ipv6_google_access) {
            state.serialize_entry(
                "desiredPrivateIpv6GoogleAccess",
                &self.desired_private_ipv6_google_access,
            )?;
        }
        if self.desired_notification_config.is_some() {
            state.serialize_entry(
                "desiredNotificationConfig",
                &self.desired_notification_config,
            )?;
        }
        if self.desired_authenticator_groups_config.is_some() {
            state.serialize_entry(
                "desiredAuthenticatorGroupsConfig",
                &self.desired_authenticator_groups_config,
            )?;
        }
        if self.desired_logging_config.is_some() {
            state.serialize_entry("desiredLoggingConfig", &self.desired_logging_config)?;
        }
        if self.desired_monitoring_config.is_some() {
            state.serialize_entry("desiredMonitoringConfig", &self.desired_monitoring_config)?;
        }
        if self.desired_identity_service_config.is_some() {
            state.serialize_entry(
                "desiredIdentityServiceConfig",
                &self.desired_identity_service_config,
            )?;
        }
        if self.desired_service_external_ips_config.is_some() {
            state.serialize_entry(
                "desiredServiceExternalIpsConfig",
                &self.desired_service_external_ips_config,
            )?;
        }
        if self.desired_enable_private_endpoint.is_some() {
            state.serialize_entry(
                "desiredEnablePrivateEndpoint",
                &self.desired_enable_private_endpoint,
            )?;
        }
        if self.desired_default_enable_private_nodes.is_some() {
            state.serialize_entry(
                "desiredDefaultEnablePrivateNodes",
                &self.desired_default_enable_private_nodes,
            )?;
        }
        if self.desired_control_plane_endpoints_config.is_some() {
            state.serialize_entry(
                "desiredControlPlaneEndpointsConfig",
                &self.desired_control_plane_endpoints_config,
            )?;
        }
        if !self.desired_master_version.is_empty() {
            state.serialize_entry("desiredMasterVersion", &self.desired_master_version)?;
        }
        if self.desired_gcfs_config.is_some() {
            state.serialize_entry("desiredGcfsConfig", &self.desired_gcfs_config)?;
        }
        if self.desired_node_pool_auto_config_network_tags.is_some() {
            state.serialize_entry(
                "desiredNodePoolAutoConfigNetworkTags",
                &self.desired_node_pool_auto_config_network_tags,
            )?;
        }
        if self.desired_pod_autoscaling.is_some() {
            state.serialize_entry("desiredPodAutoscaling", &self.desired_pod_autoscaling)?;
        }
        if self.desired_gateway_api_config.is_some() {
            state.serialize_entry("desiredGatewayApiConfig", &self.desired_gateway_api_config)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.desired_node_pool_logging_config.is_some() {
            state.serialize_entry(
                "desiredNodePoolLoggingConfig",
                &self.desired_node_pool_logging_config,
            )?;
        }
        if self.desired_fleet.is_some() {
            state.serialize_entry("desiredFleet", &self.desired_fleet)?;
        }
        if !wkt::internal::is_default(&self.desired_stack_type) {
            state.serialize_entry("desiredStackType", &self.desired_stack_type)?;
        }
        if self.additional_pod_ranges_config.is_some() {
            state.serialize_entry(
                "additionalPodRangesConfig",
                &self.additional_pod_ranges_config,
            )?;
        }
        if self.removed_additional_pod_ranges_config.is_some() {
            state.serialize_entry(
                "removedAdditionalPodRangesConfig",
                &self.removed_additional_pod_ranges_config,
            )?;
        }
        if self.enable_k8s_beta_apis.is_some() {
            state.serialize_entry("enableK8sBetaApis", &self.enable_k8s_beta_apis)?;
        }
        if self.desired_security_posture_config.is_some() {
            state.serialize_entry(
                "desiredSecurityPostureConfig",
                &self.desired_security_posture_config,
            )?;
        }
        if self.desired_network_performance_config.is_some() {
            state.serialize_entry(
                "desiredNetworkPerformanceConfig",
                &self.desired_network_performance_config,
            )?;
        }
        if self.desired_enable_fqdn_network_policy.is_some() {
            state.serialize_entry(
                "desiredEnableFqdnNetworkPolicy",
                &self.desired_enable_fqdn_network_policy,
            )?;
        }
        if self.desired_autopilot_workload_policy_config.is_some() {
            state.serialize_entry(
                "desiredAutopilotWorkloadPolicyConfig",
                &self.desired_autopilot_workload_policy_config,
            )?;
        }
        if self.desired_k8s_beta_apis.is_some() {
            state.serialize_entry("desiredK8sBetaApis", &self.desired_k8s_beta_apis)?;
        }
        if self.desired_containerd_config.is_some() {
            state.serialize_entry("desiredContainerdConfig", &self.desired_containerd_config)?;
        }
        if self.desired_enable_multi_networking.is_some() {
            state.serialize_entry(
                "desiredEnableMultiNetworking",
                &self.desired_enable_multi_networking,
            )?;
        }
        if self
            .desired_node_pool_auto_config_resource_manager_tags
            .is_some()
        {
            state.serialize_entry(
                "desiredNodePoolAutoConfigResourceManagerTags",
                &self.desired_node_pool_auto_config_resource_manager_tags,
            )?;
        }
        if self.desired_in_transit_encryption_config.is_some() {
            state.serialize_entry(
                "desiredInTransitEncryptionConfig",
                &self.desired_in_transit_encryption_config,
            )?;
        }
        if self
            .desired_enable_cilium_clusterwide_network_policy
            .is_some()
        {
            state.serialize_entry(
                "desiredEnableCiliumClusterwideNetworkPolicy",
                &self.desired_enable_cilium_clusterwide_network_policy,
            )?;
        }
        if self.desired_secret_manager_config.is_some() {
            state.serialize_entry(
                "desiredSecretManagerConfig",
                &self.desired_secret_manager_config,
            )?;
        }
        if self.desired_compliance_posture_config.is_some() {
            state.serialize_entry(
                "desiredCompliancePostureConfig",
                &self.desired_compliance_posture_config,
            )?;
        }
        if self.desired_node_kubelet_config.is_some() {
            state.serialize_entry(
                "desiredNodeKubeletConfig",
                &self.desired_node_kubelet_config,
            )?;
        }
        if self.desired_node_pool_auto_config_kubelet_config.is_some() {
            state.serialize_entry(
                "desiredNodePoolAutoConfigKubeletConfig",
                &self.desired_node_pool_auto_config_kubelet_config,
            )?;
        }
        if self.user_managed_keys_config.is_some() {
            state.serialize_entry("userManagedKeysConfig", &self.user_managed_keys_config)?;
        }
        if self.desired_rbac_binding_config.is_some() {
            state.serialize_entry(
                "desiredRbacBindingConfig",
                &self.desired_rbac_binding_config,
            )?;
        }
        if self.desired_additional_ip_ranges_config.is_some() {
            state.serialize_entry(
                "desiredAdditionalIpRangesConfig",
                &self.desired_additional_ip_ranges_config,
            )?;
        }
        if self.desired_enterprise_config.is_some() {
            state.serialize_entry("desiredEnterpriseConfig", &self.desired_enterprise_config)?;
        }
        if self.desired_auto_ipam_config.is_some() {
            state.serialize_entry("desiredAutoIpamConfig", &self.desired_auto_ipam_config)?;
        }
        if self.desired_disable_l4_lb_firewall_reconciliation.is_some() {
            state.serialize_entry(
                "desiredDisableL4LbFirewallReconciliation",
                &self.desired_disable_l4_lb_firewall_reconciliation,
            )?;
        }
        if self
            .desired_node_pool_auto_config_linux_node_config
            .is_some()
        {
            state.serialize_entry(
                "desiredNodePoolAutoConfigLinuxNodeConfig",
                &self.desired_node_pool_auto_config_linux_node_config,
            )?;
        }
        if self.desired_user_managed_keys_config.is_some() {
            state.serialize_entry(
                "desiredUserManagedKeysConfig",
                &self.desired_user_managed_keys_config,
            )?;
        }
        if self.desired_anonymous_authentication_config.is_some() {
            state.serialize_entry(
                "desiredAnonymousAuthenticationConfig",
                &self.desired_anonymous_authentication_config,
            )?;
        }
        if self.gke_auto_upgrade_config.is_some() {
            state.serialize_entry("gkeAutoUpgradeConfig", &self.gke_auto_upgrade_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AdditionalPodRangesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.pod_range_names.is_empty() {
            state.serialize_entry("podRangeNames", &self.pod_range_names)?;
        }
        if !self.pod_range_info.is_empty() {
            state.serialize_entry("podRangeInfo", &self.pod_range_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AdditionalIPRangesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.pod_ipv4_range_names.is_empty() {
            state.serialize_entry("podIpv4RangeNames", &self.pod_ipv4_range_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DesiredAdditionalIPRangesConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.additional_ip_ranges_configs.is_empty() {
            state.serialize_entry(
                "additionalIpRangesConfigs",
                &self.additional_ip_ranges_configs,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AutoIpamConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RangeInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.range_name.is_empty() {
            state.serialize_entry("rangeName", &self.range_name)?;
        }
        if !wkt::internal::is_default(&self.utilization) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("utilization", &__With(&self.utilization))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DesiredEnterpriseConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.desired_tier) {
            state.serialize_entry("desiredTier", &self.desired_tier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Operation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !wkt::internal::is_default(&self.operation_type) {
            state.serialize_entry("operationType", &self.operation_type)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.detail.is_empty() {
            state.serialize_entry("detail", &self.detail)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.target_link.is_empty() {
            state.serialize_entry("targetLink", &self.target_link)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !self.start_time.is_empty() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self.end_time.is_empty() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.progress.is_some() {
            state.serialize_entry("progress", &self.progress)?;
        }
        if !self.cluster_conditions.is_empty() {
            state.serialize_entry("clusterConditions", &self.cluster_conditions)?;
        }
        if !self.nodepool_conditions.is_empty() {
            state.serialize_entry("nodepoolConditions", &self.nodepool_conditions)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::OperationProgress {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.metrics.is_empty() {
            state.serialize_entry("metrics", &self.metrics)?;
        }
        if !self.stages.is_empty() {
            state.serialize_entry("stages", &self.stages)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::operation_progress::Metric {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.int_value() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("intValue", &__With(value))?;
        }
        if let Some(value) = self.double_value() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("doubleValue", &__With(value))?;
        }
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CreateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.update.is_some() {
            state.serialize_entry("update", &self.update)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !self.node_version.is_empty() {
            state.serialize_entry("nodeVersion", &self.node_version)?;
        }
        if !self.image_type.is_empty() {
            state.serialize_entry("imageType", &self.image_type)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if self.workload_metadata_config.is_some() {
            state.serialize_entry("workloadMetadataConfig", &self.workload_metadata_config)?;
        }
        if self.upgrade_settings.is_some() {
            state.serialize_entry("upgradeSettings", &self.upgrade_settings)?;
        }
        if self.tags.is_some() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if self.taints.is_some() {
            state.serialize_entry("taints", &self.taints)?;
        }
        if self.labels.is_some() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.linux_node_config.is_some() {
            state.serialize_entry("linuxNodeConfig", &self.linux_node_config)?;
        }
        if self.kubelet_config.is_some() {
            state.serialize_entry("kubeletConfig", &self.kubelet_config)?;
        }
        if self.node_network_config.is_some() {
            state.serialize_entry("nodeNetworkConfig", &self.node_network_config)?;
        }
        if self.gcfs_config.is_some() {
            state.serialize_entry("gcfsConfig", &self.gcfs_config)?;
        }
        if self.confidential_nodes.is_some() {
            state.serialize_entry("confidentialNodes", &self.confidential_nodes)?;
        }
        if self.gvnic.is_some() {
            state.serialize_entry("gvnic", &self.gvnic)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.fast_socket.is_some() {
            state.serialize_entry("fastSocket", &self.fast_socket)?;
        }
        if self.logging_config.is_some() {
            state.serialize_entry("loggingConfig", &self.logging_config)?;
        }
        if self.resource_labels.is_some() {
            state.serialize_entry("resourceLabels", &self.resource_labels)?;
        }
        if self.windows_node_config.is_some() {
            state.serialize_entry("windowsNodeConfig", &self.windows_node_config)?;
        }
        if !self.accelerators.is_empty() {
            state.serialize_entry("accelerators", &self.accelerators)?;
        }
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self.disk_type.is_empty() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !wkt::internal::is_default(&self.disk_size_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if self.resource_manager_tags.is_some() {
            state.serialize_entry("resourceManagerTags", &self.resource_manager_tags)?;
        }
        if self.containerd_config.is_some() {
            state.serialize_entry("containerdConfig", &self.containerd_config)?;
        }
        if self.queued_provisioning.is_some() {
            state.serialize_entry("queuedProvisioning", &self.queued_provisioning)?;
        }
        if !self.storage_pools.is_empty() {
            state.serialize_entry("storagePools", &self.storage_pools)?;
        }
        if self.max_run_duration.is_some() {
            state.serialize_entry("maxRunDuration", &self.max_run_duration)?;
        }
        if self.flex_start.is_some() {
            state.serialize_entry("flexStart", &self.flex_start)?;
        }
        if self.boot_disk.is_some() {
            state.serialize_entry("bootDisk", &self.boot_disk)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetNodePoolAutoscalingRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if self.autoscaling.is_some() {
            state.serialize_entry("autoscaling", &self.autoscaling)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetLoggingServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.logging_service.is_empty() {
            state.serialize_entry("loggingService", &self.logging_service)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetMonitoringServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.monitoring_service.is_empty() {
            state.serialize_entry("monitoringService", &self.monitoring_service)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetAddonsConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.addons_config.is_some() {
            state.serialize_entry("addonsConfig", &self.addons_config)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetLocationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UpdateMasterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.master_version.is_empty() {
            state.serialize_entry("masterVersion", &self.master_version)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetMasterAuthRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !wkt::internal::is_default(&self.action) {
            state.serialize_entry("action", &self.action)?;
        }
        if self.update.is_some() {
            state.serialize_entry("update", &self.update)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.clusters.is_empty() {
            state.serialize_entry("clusters", &self.clusters)?;
        }
        if !self.missing_zones.is_empty() {
            state.serialize_entry("missingZones", &self.missing_zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.operation_id.is_empty() {
            state.serialize_entry("operationId", &self.operation_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListOperationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CancelOperationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.operation_id.is_empty() {
            state.serialize_entry("operationId", &self.operation_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListOperationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operations.is_empty() {
            state.serialize_entry("operations", &self.operations)?;
        }
        if !self.missing_zones.is_empty() {
            state.serialize_entry("missingZones", &self.missing_zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetServerConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ServerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.default_cluster_version.is_empty() {
            state.serialize_entry("defaultClusterVersion", &self.default_cluster_version)?;
        }
        if !self.valid_node_versions.is_empty() {
            state.serialize_entry("validNodeVersions", &self.valid_node_versions)?;
        }
        if !self.default_image_type.is_empty() {
            state.serialize_entry("defaultImageType", &self.default_image_type)?;
        }
        if !self.valid_image_types.is_empty() {
            state.serialize_entry("validImageTypes", &self.valid_image_types)?;
        }
        if !self.valid_master_versions.is_empty() {
            state.serialize_entry("validMasterVersions", &self.valid_master_versions)?;
        }
        if !self.channels.is_empty() {
            state.serialize_entry("channels", &self.channels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::server_config::ReleaseChannelConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.channel) {
            state.serialize_entry("channel", &self.channel)?;
        }
        if !self.default_version.is_empty() {
            state.serialize_entry("defaultVersion", &self.default_version)?;
        }
        if !self.valid_versions.is_empty() {
            state.serialize_entry("validVersions", &self.valid_versions)?;
        }
        if !self.upgrade_target_version.is_empty() {
            state.serialize_entry("upgradeTargetVersion", &self.upgrade_target_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CreateNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.node_pool.is_some() {
            state.serialize_entry("nodePool", &self.node_pool)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DeleteNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListNodePoolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::BlueGreenSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.standard_rollout_policy() {
            state.serialize_entry("standardRolloutPolicy", value)?;
        }
        if self.node_pool_soak_duration.is_some() {
            state.serialize_entry("nodePoolSoakDuration", &self.node_pool_soak_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::blue_green_settings::StandardRolloutPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.batch_percentage() {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("batchPercentage", &__With(value))?;
        }
        if let Some(value) = self.batch_node_count() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("batchNodeCount", &__With(value))?;
        }
        if self.batch_soak_duration.is_some() {
            state.serialize_entry("batchSoakDuration", &self.batch_soak_duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodePool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !wkt::internal::is_default(&self.initial_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("initialNodeCount", &__With(&self.initial_node_count))?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if self.network_config.is_some() {
            state.serialize_entry("networkConfig", &self.network_config)?;
        }
        if !self.self_link.is_empty() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.instance_group_urls.is_empty() {
            state.serialize_entry("instanceGroupUrls", &self.instance_group_urls)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if self.autoscaling.is_some() {
            state.serialize_entry("autoscaling", &self.autoscaling)?;
        }
        if self.management.is_some() {
            state.serialize_entry("management", &self.management)?;
        }
        if self.max_pods_constraint.is_some() {
            state.serialize_entry("maxPodsConstraint", &self.max_pods_constraint)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !wkt::internal::is_default(&self.pod_ipv4_cidr_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("podIpv4CidrSize", &__With(&self.pod_ipv4_cidr_size))?;
        }
        if self.upgrade_settings.is_some() {
            state.serialize_entry("upgradeSettings", &self.upgrade_settings)?;
        }
        if self.placement_policy.is_some() {
            state.serialize_entry("placementPolicy", &self.placement_policy)?;
        }
        if self.update_info.is_some() {
            state.serialize_entry("updateInfo", &self.update_info)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.queued_provisioning.is_some() {
            state.serialize_entry("queuedProvisioning", &self.queued_provisioning)?;
        }
        if self.best_effort_provisioning.is_some() {
            state.serialize_entry("bestEffortProvisioning", &self.best_effort_provisioning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::node_pool::UpgradeSettings {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_surge) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxSurge", &__With(&self.max_surge))?;
        }
        if !wkt::internal::is_default(&self.max_unavailable) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxUnavailable", &__With(&self.max_unavailable))?;
        }
        if self.strategy.is_some() {
            state.serialize_entry("strategy", &self.strategy)?;
        }
        if self.blue_green_settings.is_some() {
            state.serialize_entry("blueGreenSettings", &self.blue_green_settings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::node_pool::UpdateInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.blue_green_info.is_some() {
            state.serialize_entry("blueGreenInfo", &self.blue_green_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::node_pool::update_info::BlueGreenInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.phase) {
            state.serialize_entry("phase", &self.phase)?;
        }
        if !self.blue_instance_group_urls.is_empty() {
            state.serialize_entry("blueInstanceGroupUrls", &self.blue_instance_group_urls)?;
        }
        if !self.green_instance_group_urls.is_empty() {
            state.serialize_entry("greenInstanceGroupUrls", &self.green_instance_group_urls)?;
        }
        if !self.blue_pool_deletion_start_time.is_empty() {
            state.serialize_entry(
                "bluePoolDeletionStartTime",
                &self.blue_pool_deletion_start_time,
            )?;
        }
        if !self.green_pool_version.is_empty() {
            state.serialize_entry("greenPoolVersion", &self.green_pool_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::node_pool::PlacementPolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.tpu_topology.is_empty() {
            state.serialize_entry("tpuTopology", &self.tpu_topology)?;
        }
        if !self.policy_name.is_empty() {
            state.serialize_entry("policyName", &self.policy_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::node_pool::QueuedProvisioning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodeManagement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.auto_upgrade) {
            state.serialize_entry("autoUpgrade", &self.auto_upgrade)?;
        }
        if !wkt::internal::is_default(&self.auto_repair) {
            state.serialize_entry("autoRepair", &self.auto_repair)?;
        }
        if self.upgrade_options.is_some() {
            state.serialize_entry("upgradeOptions", &self.upgrade_options)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::BestEffortProvisioning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.min_provision_nodes) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minProvisionNodes", &__With(&self.min_provision_nodes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AutoUpgradeOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.auto_upgrade_start_time.is_empty() {
            state.serialize_entry("autoUpgradeStartTime", &self.auto_upgrade_start_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MaintenancePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.window.is_some() {
            state.serialize_entry("window", &self.window)?;
        }
        if !self.resource_version.is_empty() {
            state.serialize_entry("resourceVersion", &self.resource_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MaintenanceWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.daily_maintenance_window() {
            state.serialize_entry("dailyMaintenanceWindow", value)?;
        }
        if let Some(value) = self.recurring_window() {
            state.serialize_entry("recurringWindow", value)?;
        }
        if !self.maintenance_exclusions.is_empty() {
            state.serialize_entry("maintenanceExclusions", &self.maintenance_exclusions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::TimeWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.maintenance_exclusion_options() {
            state.serialize_entry("maintenanceExclusionOptions", value)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MaintenanceExclusionOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RecurringTimeWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.window.is_some() {
            state.serialize_entry("window", &self.window)?;
        }
        if !self.recurrence.is_empty() {
            state.serialize_entry("recurrence", &self.recurrence)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DailyMaintenanceWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.start_time.is_empty() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self.duration.is_empty() {
            state.serialize_entry("duration", &self.duration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetNodePoolManagementRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if self.management.is_some() {
            state.serialize_entry("management", &self.management)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetNodePoolSizeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !wkt::internal::is_default(&self.node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nodeCount", &__With(&self.node_count))?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CompleteNodePoolUpgradeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RollbackNodePoolUpgradeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.respect_pdb) {
            state.serialize_entry("respectPdb", &self.respect_pdb)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListNodePoolsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_pools.is_empty() {
            state.serialize_entry("nodePools", &self.node_pools)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ClusterAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_node_autoprovisioning) {
            state.serialize_entry(
                "enableNodeAutoprovisioning",
                &self.enable_node_autoprovisioning,
            )?;
        }
        if !self.resource_limits.is_empty() {
            state.serialize_entry("resourceLimits", &self.resource_limits)?;
        }
        if !wkt::internal::is_default(&self.autoscaling_profile) {
            state.serialize_entry("autoscalingProfile", &self.autoscaling_profile)?;
        }
        if self.autoprovisioning_node_pool_defaults.is_some() {
            state.serialize_entry(
                "autoprovisioningNodePoolDefaults",
                &self.autoprovisioning_node_pool_defaults,
            )?;
        }
        if !self.autoprovisioning_locations.is_empty() {
            state.serialize_entry(
                "autoprovisioningLocations",
                &self.autoprovisioning_locations,
            )?;
        }
        if self.default_compute_class_config.is_some() {
            state.serialize_entry(
                "defaultComputeClassConfig",
                &self.default_compute_class_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AutoprovisioningNodePoolDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.oauth_scopes.is_empty() {
            state.serialize_entry("oauthScopes", &self.oauth_scopes)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.upgrade_settings.is_some() {
            state.serialize_entry("upgradeSettings", &self.upgrade_settings)?;
        }
        if self.management.is_some() {
            state.serialize_entry("management", &self.management)?;
        }
        if !self.min_cpu_platform.is_empty() {
            state.serialize_entry("minCpuPlatform", &self.min_cpu_platform)?;
        }
        if !wkt::internal::is_default(&self.disk_size_gb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if !self.disk_type.is_empty() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if self.shielded_instance_config.is_some() {
            state.serialize_entry("shieldedInstanceConfig", &self.shielded_instance_config)?;
        }
        if !self.boot_disk_kms_key.is_empty() {
            state.serialize_entry("bootDiskKmsKey", &self.boot_disk_kms_key)?;
        }
        if !self.image_type.is_empty() {
            state.serialize_entry("imageType", &self.image_type)?;
        }
        if self.insecure_kubelet_readonly_port_enabled.is_some() {
            state.serialize_entry(
                "insecureKubeletReadonlyPortEnabled",
                &self.insecure_kubelet_readonly_port_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceLimit {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_type.is_empty() {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !wkt::internal::is_default(&self.minimum) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minimum", &__With(&self.minimum))?;
        }
        if !wkt::internal::is_default(&self.maximum) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maximum", &__With(&self.maximum))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DefaultComputeClassConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodePoolAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.min_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minNodeCount", &__With(&self.min_node_count))?;
        }
        if !wkt::internal::is_default(&self.max_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxNodeCount", &__With(&self.max_node_count))?;
        }
        if !wkt::internal::is_default(&self.autoprovisioned) {
            state.serialize_entry("autoprovisioned", &self.autoprovisioned)?;
        }
        if !wkt::internal::is_default(&self.location_policy) {
            state.serialize_entry("locationPolicy", &self.location_policy)?;
        }
        if !wkt::internal::is_default(&self.total_min_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalMinNodeCount", &__With(&self.total_min_node_count))?;
        }
        if !wkt::internal::is_default(&self.total_max_node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalMaxNodeCount", &__With(&self.total_max_node_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetLabelsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.resource_labels.is_empty() {
            state.serialize_entry("resourceLabels", &self.resource_labels)?;
        }
        if !self.label_fingerprint.is_empty() {
            state.serialize_entry("labelFingerprint", &self.label_fingerprint)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetLegacyAbacRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::StartIPRotationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.rotate_credentials) {
            state.serialize_entry("rotateCredentials", &self.rotate_credentials)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CompleteIPRotationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AcceleratorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.accelerator_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("acceleratorCount", &__With(&self.accelerator_count))?;
        }
        if !self.accelerator_type.is_empty() {
            state.serialize_entry("acceleratorType", &self.accelerator_type)?;
        }
        if !self.gpu_partition_size.is_empty() {
            state.serialize_entry("gpuPartitionSize", &self.gpu_partition_size)?;
        }
        if self.gpu_sharing_config.is_some() {
            state.serialize_entry("gpuSharingConfig", &self.gpu_sharing_config)?;
        }
        if self.gpu_driver_installation_config.is_some() {
            state.serialize_entry(
                "gpuDriverInstallationConfig",
                &self.gpu_driver_installation_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GPUSharingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_shared_clients_per_gpu) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "maxSharedClientsPerGpu",
                &__With(&self.max_shared_clients_per_gpu),
            )?;
        }
        if self.gpu_sharing_strategy.is_some() {
            state.serialize_entry("gpuSharingStrategy", &self.gpu_sharing_strategy)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GPUDriverInstallationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.gpu_driver_version.is_some() {
            state.serialize_entry("gpuDriverVersion", &self.gpu_driver_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::WorkloadMetadataConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetNetworkPolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.network_policy.is_some() {
            state.serialize_entry("networkPolicy", &self.network_policy)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SetMaintenancePolicyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.maintenance_policy.is_some() {
            state.serialize_entry("maintenancePolicy", &self.maintenance_policy)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::StatusCondition {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !wkt::internal::is_default(&self.canonical_code) {
            state.serialize_entry("canonicalCode", &self.canonical_code)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NetworkConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !wkt::internal::is_default(&self.enable_intra_node_visibility) {
            state.serialize_entry(
                "enableIntraNodeVisibility",
                &self.enable_intra_node_visibility,
            )?;
        }
        if self.default_snat_status.is_some() {
            state.serialize_entry("defaultSnatStatus", &self.default_snat_status)?;
        }
        if !wkt::internal::is_default(&self.enable_l4ilb_subsetting) {
            state.serialize_entry("enableL4ilbSubsetting", &self.enable_l4ilb_subsetting)?;
        }
        if !wkt::internal::is_default(&self.datapath_provider) {
            state.serialize_entry("datapathProvider", &self.datapath_provider)?;
        }
        if !wkt::internal::is_default(&self.private_ipv6_google_access) {
            state.serialize_entry("privateIpv6GoogleAccess", &self.private_ipv6_google_access)?;
        }
        if self.dns_config.is_some() {
            state.serialize_entry("dnsConfig", &self.dns_config)?;
        }
        if self.service_external_ips_config.is_some() {
            state.serialize_entry(
                "serviceExternalIpsConfig",
                &self.service_external_ips_config,
            )?;
        }
        if self.gateway_api_config.is_some() {
            state.serialize_entry("gatewayApiConfig", &self.gateway_api_config)?;
        }
        if !wkt::internal::is_default(&self.enable_multi_networking) {
            state.serialize_entry("enableMultiNetworking", &self.enable_multi_networking)?;
        }
        if self.network_performance_config.is_some() {
            state.serialize_entry("networkPerformanceConfig", &self.network_performance_config)?;
        }
        if self.enable_fqdn_network_policy.is_some() {
            state.serialize_entry("enableFqdnNetworkPolicy", &self.enable_fqdn_network_policy)?;
        }
        if self.in_transit_encryption_config.is_some() {
            state.serialize_entry(
                "inTransitEncryptionConfig",
                &self.in_transit_encryption_config,
            )?;
        }
        if self.enable_cilium_clusterwide_network_policy.is_some() {
            state.serialize_entry(
                "enableCiliumClusterwideNetworkPolicy",
                &self.enable_cilium_clusterwide_network_policy,
            )?;
        }
        if self.default_enable_private_nodes.is_some() {
            state.serialize_entry(
                "defaultEnablePrivateNodes",
                &self.default_enable_private_nodes,
            )?;
        }
        if self.disable_l4_lb_firewall_reconciliation.is_some() {
            state.serialize_entry(
                "disableL4LbFirewallReconciliation",
                &self.disable_l4_lb_firewall_reconciliation,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::network_config::ClusterNetworkPerformanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.total_egress_bandwidth_tier.is_some() {
            state.serialize_entry(
                "totalEgressBandwidthTier",
                &self.total_egress_bandwidth_tier,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GatewayAPIConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.channel) {
            state.serialize_entry("channel", &self.channel)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ServiceExternalIPsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetOpenIDConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetOpenIDConfigResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issuer.is_empty() {
            state.serialize_entry("issuer", &self.issuer)?;
        }
        if !self.jwks_uri.is_empty() {
            state.serialize_entry("jwks_uri", &self.jwks_uri)?;
        }
        if !self.response_types_supported.is_empty() {
            state.serialize_entry("response_types_supported", &self.response_types_supported)?;
        }
        if !self.subject_types_supported.is_empty() {
            state.serialize_entry("subject_types_supported", &self.subject_types_supported)?;
        }
        if !self.id_token_signing_alg_values_supported.is_empty() {
            state.serialize_entry(
                "id_token_signing_alg_values_supported",
                &self.id_token_signing_alg_values_supported,
            )?;
        }
        if !self.claims_supported.is_empty() {
            state.serialize_entry("claims_supported", &self.claims_supported)?;
        }
        if !self.grant_types.is_empty() {
            state.serialize_entry("grant_types", &self.grant_types)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetJSONWebKeysRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Jwk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kty.is_empty() {
            state.serialize_entry("kty", &self.kty)?;
        }
        if !self.alg.is_empty() {
            state.serialize_entry("alg", &self.alg)?;
        }
        if !self.r#use.is_empty() {
            state.serialize_entry("use", &self.r#use)?;
        }
        if !self.kid.is_empty() {
            state.serialize_entry("kid", &self.kid)?;
        }
        if !self.n.is_empty() {
            state.serialize_entry("n", &self.n)?;
        }
        if !self.e.is_empty() {
            state.serialize_entry("e", &self.e)?;
        }
        if !self.x.is_empty() {
            state.serialize_entry("x", &self.x)?;
        }
        if !self.y.is_empty() {
            state.serialize_entry("y", &self.y)?;
        }
        if !self.crv.is_empty() {
            state.serialize_entry("crv", &self.crv)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GetJSONWebKeysResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.keys.is_empty() {
            state.serialize_entry("keys", &self.keys)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CheckAutopilotCompatibilityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AutopilotCompatibilityIssue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.last_observation.is_some() {
            state.serialize_entry("lastObservation", &self.last_observation)?;
        }
        if !self.constraint_type.is_empty() {
            state.serialize_entry("constraintType", &self.constraint_type)?;
        }
        if !wkt::internal::is_default(&self.incompatibility_type) {
            state.serialize_entry("incompatibilityType", &self.incompatibility_type)?;
        }
        if !self.subjects.is_empty() {
            state.serialize_entry("subjects", &self.subjects)?;
        }
        if !self.documentation_url.is_empty() {
            state.serialize_entry("documentationUrl", &self.documentation_url)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CheckAutopilotCompatibilityResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.issues.is_empty() {
            state.serialize_entry("issues", &self.issues)?;
        }
        if !self.summary.is_empty() {
            state.serialize_entry("summary", &self.summary)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ReleaseChannel {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.channel) {
            state.serialize_entry("channel", &self.channel)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::CostManagementConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::IntraNodeVisibilityConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ILBSubsettingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DNSConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cluster_dns) {
            state.serialize_entry("clusterDns", &self.cluster_dns)?;
        }
        if !wkt::internal::is_default(&self.cluster_dns_scope) {
            state.serialize_entry("clusterDnsScope", &self.cluster_dns_scope)?;
        }
        if !self.cluster_dns_domain.is_empty() {
            state.serialize_entry("clusterDnsDomain", &self.cluster_dns_domain)?;
        }
        if !self.additive_vpc_scope_dns_domain.is_empty() {
            state.serialize_entry(
                "additiveVpcScopeDnsDomain",
                &self.additive_vpc_scope_dns_domain,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MaxPodsConstraint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.max_pods_per_node) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxPodsPerNode", &__With(&self.max_pods_per_node))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::WorkloadIdentityConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workload_pool.is_empty() {
            state.serialize_entry("workloadPool", &self.workload_pool)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::IdentityServiceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MeshCertificates {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enable_certificates.is_some() {
            state.serialize_entry("enableCertificates", &self.enable_certificates)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DatabaseEncryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key_name.is_empty() {
            state.serialize_entry("keyName", &self.key_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.current_state.is_some() {
            state.serialize_entry("currentState", &self.current_state)?;
        }
        if !self.decryption_keys.is_empty() {
            state.serialize_entry("decryptionKeys", &self.decryption_keys)?;
        }
        if !self.last_operation_errors.is_empty() {
            state.serialize_entry("lastOperationErrors", &self.last_operation_errors)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::database_encryption::OperationError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key_name.is_empty() {
            state.serialize_entry("keyName", &self.key_name)?;
        }
        if !self.error_message.is_empty() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if self.timestamp.is_some() {
            state.serialize_entry("timestamp", &self.timestamp)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListUsableSubnetworksRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ListUsableSubnetworksResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subnetworks.is_empty() {
            state.serialize_entry("subnetworks", &self.subnetworks)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UsableSubnetworkSecondaryRange {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.range_name.is_empty() {
            state.serialize_entry("rangeName", &self.range_name)?;
        }
        if !self.ip_cidr_range.is_empty() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UsableSubnetwork {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.ip_cidr_range.is_empty() {
            state.serialize_entry("ipCidrRange", &self.ip_cidr_range)?;
        }
        if !self.secondary_ip_ranges.is_empty() {
            state.serialize_entry("secondaryIpRanges", &self.secondary_ip_ranges)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceUsageExportConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.bigquery_destination.is_some() {
            state.serialize_entry("bigqueryDestination", &self.bigquery_destination)?;
        }
        if !wkt::internal::is_default(&self.enable_network_egress_metering) {
            state.serialize_entry(
                "enableNetworkEgressMetering",
                &self.enable_network_egress_metering,
            )?;
        }
        if self.consumption_metering_config.is_some() {
            state.serialize_entry(
                "consumptionMeteringConfig",
                &self.consumption_metering_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::resource_usage_export_config::BigQueryDestination {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dataset_id.is_empty() {
            state.serialize_entry("datasetId", &self.dataset_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::resource_usage_export_config::ConsumptionMeteringConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::VerticalPodAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::DefaultSnatStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ShieldedNodes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::VirtualNIC {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::FastSocket {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NotificationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.pubsub.is_some() {
            state.serialize_entry("pubsub", &self.pubsub)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::notification_config::PubSub {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self.topic.is_empty() {
            state.serialize_entry("topic", &self.topic)?;
        }
        if self.filter.is_some() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::notification_config::Filter {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.event_type.is_empty() {
            state.serialize_entry("eventType", &self.event_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ConfidentialNodes {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !wkt::internal::is_default(&self.confidential_instance_type) {
            state.serialize_entry("confidentialInstanceType", &self.confidential_instance_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UpgradeEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.resource_type) {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.operation.is_empty() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if self.operation_start_time.is_some() {
            state.serialize_entry("operationStartTime", &self.operation_start_time)?;
        }
        if !self.current_version.is_empty() {
            state.serialize_entry("currentVersion", &self.current_version)?;
        }
        if !self.target_version.is_empty() {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UpgradeInfoEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.resource_type) {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if !self.operation.is_empty() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.current_version.is_empty() {
            state.serialize_entry("currentVersion", &self.current_version)?;
        }
        if !self.target_version.is_empty() {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.standard_support_end_time.is_some() {
            state.serialize_entry("standardSupportEndTime", &self.standard_support_end_time)?;
        }
        if self.extended_support_end_time.is_some() {
            state.serialize_entry("extendedSupportEndTime", &self.extended_support_end_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.event_type) {
            state.serialize_entry("eventType", &self.event_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UpgradeAvailableEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.resource_type) {
            state.serialize_entry("resourceType", &self.resource_type)?;
        }
        if self.release_channel.is_some() {
            state.serialize_entry("releaseChannel", &self.release_channel)?;
        }
        if !self.resource.is_empty() {
            state.serialize_entry("resource", &self.resource)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SecurityBulletinEvent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_type_affected.is_empty() {
            state.serialize_entry("resourceTypeAffected", &self.resource_type_affected)?;
        }
        if !self.bulletin_id.is_empty() {
            state.serialize_entry("bulletinId", &self.bulletin_id)?;
        }
        if !self.cve_ids.is_empty() {
            state.serialize_entry("cveIds", &self.cve_ids)?;
        }
        if !self.severity.is_empty() {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.bulletin_uri.is_empty() {
            state.serialize_entry("bulletinUri", &self.bulletin_uri)?;
        }
        if !self.brief_description.is_empty() {
            state.serialize_entry("briefDescription", &self.brief_description)?;
        }
        if !self.affected_supported_minors.is_empty() {
            state.serialize_entry("affectedSupportedMinors", &self.affected_supported_minors)?;
        }
        if !self.patched_versions.is_empty() {
            state.serialize_entry("patchedVersions", &self.patched_versions)?;
        }
        if !self.suggested_upgrade_target.is_empty() {
            state.serialize_entry("suggestedUpgradeTarget", &self.suggested_upgrade_target)?;
        }
        if !wkt::internal::is_default(&self.manual_steps_required) {
            state.serialize_entry("manualStepsRequired", &self.manual_steps_required)?;
        }
        if !self.mitigated_versions.is_empty() {
            state.serialize_entry("mitigatedVersions", &self.mitigated_versions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Autopilot {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.workload_policy_config.is_some() {
            state.serialize_entry("workloadPolicyConfig", &self.workload_policy_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::WorkloadPolicyConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.allow_net_admin.is_some() {
            state.serialize_entry("allowNetAdmin", &self.allow_net_admin)?;
        }
        if self.autopilot_compatibility_auditing_enabled.is_some() {
            state.serialize_entry(
                "autopilotCompatibilityAuditingEnabled",
                &self.autopilot_compatibility_auditing_enabled,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.component_config.is_some() {
            state.serialize_entry("componentConfig", &self.component_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LoggingComponentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.enable_components.is_empty() {
            state.serialize_entry("enableComponents", &self.enable_components)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RayClusterLoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MonitoringConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.component_config.is_some() {
            state.serialize_entry("componentConfig", &self.component_config)?;
        }
        if self.managed_prometheus_config.is_some() {
            state.serialize_entry("managedPrometheusConfig", &self.managed_prometheus_config)?;
        }
        if self.advanced_datapath_observability_config.is_some() {
            state.serialize_entry(
                "advancedDatapathObservabilityConfig",
                &self.advanced_datapath_observability_config,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AdvancedDatapathObservabilityConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_metrics) {
            state.serialize_entry("enableMetrics", &self.enable_metrics)?;
        }
        if !wkt::internal::is_default(&self.relay_mode) {
            state.serialize_entry("relayMode", &self.relay_mode)?;
        }
        if self.enable_relay.is_some() {
            state.serialize_entry("enableRelay", &self.enable_relay)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::RayClusterMonitoringConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodePoolLoggingConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.variant_config.is_some() {
            state.serialize_entry("variantConfig", &self.variant_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LoggingVariantConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.variant) {
            state.serialize_entry("variant", &self.variant)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::MonitoringComponentConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.enable_components.is_empty() {
            state.serialize_entry("enableComponents", &self.enable_components)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ManagedPrometheusConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enabled) {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.auto_monitoring_config.is_some() {
            state.serialize_entry("autoMonitoringConfig", &self.auto_monitoring_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::AutoMonitoringConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.scope) {
            state.serialize_entry("scope", &self.scope)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::PodAutoscaling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.hpa_profile.is_some() {
            state.serialize_entry("hpaProfile", &self.hpa_profile)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::Fleet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.membership.is_empty() {
            state.serialize_entry("membership", &self.membership)?;
        }
        if !wkt::internal::is_default(&self.pre_registered) {
            state.serialize_entry("preRegistered", &self.pre_registered)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ControlPlaneEndpointsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.dns_endpoint_config.is_some() {
            state.serialize_entry("dnsEndpointConfig", &self.dns_endpoint_config)?;
        }
        if self.ip_endpoints_config.is_some() {
            state.serialize_entry("ipEndpointsConfig", &self.ip_endpoints_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::control_plane_endpoints_config::DNSEndpointConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.endpoint.is_empty() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if self.allow_external_traffic.is_some() {
            state.serialize_entry("allowExternalTraffic", &self.allow_external_traffic)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::control_plane_endpoints_config::IPEndpointsConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if self.enable_public_endpoint.is_some() {
            state.serialize_entry("enablePublicEndpoint", &self.enable_public_endpoint)?;
        }
        if self.global_access.is_some() {
            state.serialize_entry("globalAccess", &self.global_access)?;
        }
        if self.authorized_networks_config.is_some() {
            state.serialize_entry("authorizedNetworksConfig", &self.authorized_networks_config)?;
        }
        if !self.public_endpoint.is_empty() {
            state.serialize_entry("publicEndpoint", &self.public_endpoint)?;
        }
        if !self.private_endpoint.is_empty() {
            state.serialize_entry("privateEndpoint", &self.private_endpoint)?;
        }
        if !self.private_endpoint_subnetwork.is_empty() {
            state.serialize_entry(
                "privateEndpointSubnetwork",
                &self.private_endpoint_subnetwork,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::LocalNvmeSsdBlockConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.local_ssd_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("localSsdCount", &__With(&self.local_ssd_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::EphemeralStorageLocalSsdConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.local_ssd_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("localSsdCount", &__With(&self.local_ssd_count))?;
        }
        if !wkt::internal::is_default(&self.data_cache_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("dataCacheCount", &__With(&self.data_cache_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ResourceManagerTags {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::EnterpriseConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cluster_tier) {
            state.serialize_entry("clusterTier", &self.cluster_tier)?;
        }
        if !wkt::internal::is_default(&self.desired_tier) {
            state.serialize_entry("desiredTier", &self.desired_tier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SecretManagerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.enabled.is_some() {
            state.serialize_entry("enabled", &self.enabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::BootDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.disk_type.is_empty() {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !wkt::internal::is_default(&self.size_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
        }
        if !wkt::internal::is_default(&self.provisioned_iops) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("provisionedIops", &__With(&self.provisioned_iops))?;
        }
        if !wkt::internal::is_default(&self.provisioned_throughput) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "provisionedThroughput",
                &__With(&self.provisioned_throughput),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SecondaryBootDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self.disk_image.is_empty() {
            state.serialize_entry("diskImage", &self.disk_image)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::SecondaryBootDiskUpdateStrategy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::FetchClusterUpgradeInfoRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::ClusterUpgradeInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.minor_target_version.is_some() {
            state.serialize_entry("minorTargetVersion", &self.minor_target_version)?;
        }
        if self.patch_target_version.is_some() {
            state.serialize_entry("patchTargetVersion", &self.patch_target_version)?;
        }
        if !self.auto_upgrade_status.is_empty() {
            state.serialize_entry("autoUpgradeStatus", &self.auto_upgrade_status)?;
        }
        if !self.paused_reason.is_empty() {
            state.serialize_entry("pausedReason", &self.paused_reason)?;
        }
        if !self.upgrade_details.is_empty() {
            state.serialize_entry("upgradeDetails", &self.upgrade_details)?;
        }
        if self.end_of_standard_support_timestamp.is_some() {
            state.serialize_entry(
                "endOfStandardSupportTimestamp",
                &self.end_of_standard_support_timestamp,
            )?;
        }
        if self.end_of_extended_support_timestamp.is_some() {
            state.serialize_entry(
                "endOfExtendedSupportTimestamp",
                &self.end_of_extended_support_timestamp,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::UpgradeDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.initial_version.is_empty() {
            state.serialize_entry("initialVersion", &self.initial_version)?;
        }
        if !self.target_version.is_empty() {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !wkt::internal::is_default(&self.start_type) {
            state.serialize_entry("startType", &self.start_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::FetchNodePoolUpgradeInfoRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::NodePoolUpgradeInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.minor_target_version.is_some() {
            state.serialize_entry("minorTargetVersion", &self.minor_target_version)?;
        }
        if self.patch_target_version.is_some() {
            state.serialize_entry("patchTargetVersion", &self.patch_target_version)?;
        }
        if !self.auto_upgrade_status.is_empty() {
            state.serialize_entry("autoUpgradeStatus", &self.auto_upgrade_status)?;
        }
        if !self.paused_reason.is_empty() {
            state.serialize_entry("pausedReason", &self.paused_reason)?;
        }
        if !self.upgrade_details.is_empty() {
            state.serialize_entry("upgradeDetails", &self.upgrade_details)?;
        }
        if self.end_of_standard_support_timestamp.is_some() {
            state.serialize_entry(
                "endOfStandardSupportTimestamp",
                &self.end_of_standard_support_timestamp,
            )?;
        }
        if self.end_of_extended_support_timestamp.is_some() {
            state.serialize_entry(
                "endOfExtendedSupportTimestamp",
                &self.end_of_extended_support_timestamp,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for super::GkeAutoUpgradeConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.patch_mode) {
            state.serialize_entry("patchMode", &self.patch_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
