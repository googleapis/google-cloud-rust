// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LinuxNodeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sysctls,
            __cgroup_mode,
            __hugepages,
            __transparent_hugepage_enabled,
            __transparent_hugepage_defrag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LinuxNodeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sysctls" => Ok(__FieldTag::__sysctls),
                            "cgroupMode" => Ok(__FieldTag::__cgroup_mode),
                            "cgroup_mode" => Ok(__FieldTag::__cgroup_mode),
                            "hugepages" => Ok(__FieldTag::__hugepages),
                            "transparentHugepageEnabled" => {
                                Ok(__FieldTag::__transparent_hugepage_enabled)
                            }
                            "transparent_hugepage_enabled" => {
                                Ok(__FieldTag::__transparent_hugepage_enabled)
                            }
                            "transparentHugepageDefrag" => {
                                Ok(__FieldTag::__transparent_hugepage_defrag)
                            }
                            "transparent_hugepage_defrag" => {
                                Ok(__FieldTag::__transparent_hugepage_defrag)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LinuxNodeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LinuxNodeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sysctls => {
                            if !fields.insert(__FieldTag::__sysctls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sysctls",
                                ));
                            }
                            result.sysctls = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cgroup_mode => {
                            if !fields.insert(__FieldTag::__cgroup_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cgroup_mode",
                                ));
                            }
                            result.cgroup_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::linux_node_config::CgroupMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hugepages => {
                            if !fields.insert(__FieldTag::__hugepages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hugepages",
                                ));
                            }
                            result.hugepages = map.next_value::<std::option::Option<
                                crate::model::linux_node_config::HugepagesConfig,
                            >>()?;
                        }
                        __FieldTag::__transparent_hugepage_enabled => {
                            if !fields.insert(__FieldTag::__transparent_hugepage_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transparent_hugepage_enabled",
                                ));
                            }
                            result.transparent_hugepage_enabled = map
                                .next_value::<std::option::Option<
                                    crate::model::linux_node_config::TransparentHugepageEnabled,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transparent_hugepage_defrag => {
                            if !fields.insert(__FieldTag::__transparent_hugepage_defrag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transparent_hugepage_defrag",
                                ));
                            }
                            result.transparent_hugepage_defrag = map
                                .next_value::<std::option::Option<
                                    crate::model::linux_node_config::TransparentHugepageDefrag,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::linux_node_config::HugepagesConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hugepage_size2m,
            __hugepage_size1g,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HugepagesConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hugepageSize2m" => Ok(__FieldTag::__hugepage_size2m),
                            "hugepage_size2m" => Ok(__FieldTag::__hugepage_size2m),
                            "hugepageSize1g" => Ok(__FieldTag::__hugepage_size1g),
                            "hugepage_size1g" => Ok(__FieldTag::__hugepage_size1g),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::linux_node_config::HugepagesConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HugepagesConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hugepage_size2m => {
                            if !fields.insert(__FieldTag::__hugepage_size2m) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hugepage_size2m",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hugepage_size2m = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__hugepage_size1g => {
                            if !fields.insert(__FieldTag::__hugepage_size1g) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hugepage_size1g",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.hugepage_size1g = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WindowsNodeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WindowsNodeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osVersion" => Ok(__FieldTag::__os_version),
                            "os_version" => Ok(__FieldTag::__os_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WindowsNodeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WindowsNodeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_version => {
                            if !fields.insert(__FieldTag::__os_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_version",
                                ));
                            }
                            result.os_version =
                                map.next_value::<std::option::Option<
                                    crate::model::windows_node_config::OSVersion,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodeKubeletConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpu_manager_policy,
            __topology_manager,
            __memory_manager,
            __cpu_cfs_quota,
            __cpu_cfs_quota_period,
            __pod_pids_limit,
            __insecure_kubelet_readonly_port_enabled,
            __image_gc_low_threshold_percent,
            __image_gc_high_threshold_percent,
            __image_minimum_gc_age,
            __image_maximum_gc_age,
            __container_log_max_size,
            __container_log_max_files,
            __allowed_unsafe_sysctls,
            __eviction_soft,
            __eviction_soft_grace_period,
            __eviction_minimum_reclaim,
            __eviction_max_pod_grace_period_seconds,
            __max_parallel_image_pulls,
            __single_process_oom_kill,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeKubeletConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpuManagerPolicy" => Ok(__FieldTag::__cpu_manager_policy),
                            "cpu_manager_policy" => Ok(__FieldTag::__cpu_manager_policy),
                            "topologyManager" => Ok(__FieldTag::__topology_manager),
                            "topology_manager" => Ok(__FieldTag::__topology_manager),
                            "memoryManager" => Ok(__FieldTag::__memory_manager),
                            "memory_manager" => Ok(__FieldTag::__memory_manager),
                            "cpuCfsQuota" => Ok(__FieldTag::__cpu_cfs_quota),
                            "cpu_cfs_quota" => Ok(__FieldTag::__cpu_cfs_quota),
                            "cpuCfsQuotaPeriod" => Ok(__FieldTag::__cpu_cfs_quota_period),
                            "cpu_cfs_quota_period" => Ok(__FieldTag::__cpu_cfs_quota_period),
                            "podPidsLimit" => Ok(__FieldTag::__pod_pids_limit),
                            "pod_pids_limit" => Ok(__FieldTag::__pod_pids_limit),
                            "insecureKubeletReadonlyPortEnabled" => {
                                Ok(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            }
                            "insecure_kubelet_readonly_port_enabled" => {
                                Ok(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            }
                            "imageGcLowThresholdPercent" => {
                                Ok(__FieldTag::__image_gc_low_threshold_percent)
                            }
                            "image_gc_low_threshold_percent" => {
                                Ok(__FieldTag::__image_gc_low_threshold_percent)
                            }
                            "imageGcHighThresholdPercent" => {
                                Ok(__FieldTag::__image_gc_high_threshold_percent)
                            }
                            "image_gc_high_threshold_percent" => {
                                Ok(__FieldTag::__image_gc_high_threshold_percent)
                            }
                            "imageMinimumGcAge" => Ok(__FieldTag::__image_minimum_gc_age),
                            "image_minimum_gc_age" => Ok(__FieldTag::__image_minimum_gc_age),
                            "imageMaximumGcAge" => Ok(__FieldTag::__image_maximum_gc_age),
                            "image_maximum_gc_age" => Ok(__FieldTag::__image_maximum_gc_age),
                            "containerLogMaxSize" => Ok(__FieldTag::__container_log_max_size),
                            "container_log_max_size" => Ok(__FieldTag::__container_log_max_size),
                            "containerLogMaxFiles" => Ok(__FieldTag::__container_log_max_files),
                            "container_log_max_files" => Ok(__FieldTag::__container_log_max_files),
                            "allowedUnsafeSysctls" => Ok(__FieldTag::__allowed_unsafe_sysctls),
                            "allowed_unsafe_sysctls" => Ok(__FieldTag::__allowed_unsafe_sysctls),
                            "evictionSoft" => Ok(__FieldTag::__eviction_soft),
                            "eviction_soft" => Ok(__FieldTag::__eviction_soft),
                            "evictionSoftGracePeriod" => {
                                Ok(__FieldTag::__eviction_soft_grace_period)
                            }
                            "eviction_soft_grace_period" => {
                                Ok(__FieldTag::__eviction_soft_grace_period)
                            }
                            "evictionMinimumReclaim" => Ok(__FieldTag::__eviction_minimum_reclaim),
                            "eviction_minimum_reclaim" => {
                                Ok(__FieldTag::__eviction_minimum_reclaim)
                            }
                            "evictionMaxPodGracePeriodSeconds" => {
                                Ok(__FieldTag::__eviction_max_pod_grace_period_seconds)
                            }
                            "eviction_max_pod_grace_period_seconds" => {
                                Ok(__FieldTag::__eviction_max_pod_grace_period_seconds)
                            }
                            "maxParallelImagePulls" => Ok(__FieldTag::__max_parallel_image_pulls),
                            "max_parallel_image_pulls" => {
                                Ok(__FieldTag::__max_parallel_image_pulls)
                            }
                            "singleProcessOomKill" => Ok(__FieldTag::__single_process_oom_kill),
                            "single_process_oom_kill" => Ok(__FieldTag::__single_process_oom_kill),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodeKubeletConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeKubeletConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpu_manager_policy => {
                            if !fields.insert(__FieldTag::__cpu_manager_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_manager_policy",
                                ));
                            }
                            result.cpu_manager_policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__topology_manager => {
                            if !fields.insert(__FieldTag::__topology_manager) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topology_manager",
                                ));
                            }
                            result.topology_manager = map
                                .next_value::<std::option::Option<crate::model::TopologyManager>>(
                                )?;
                        }
                        __FieldTag::__memory_manager => {
                            if !fields.insert(__FieldTag::__memory_manager) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_manager",
                                ));
                            }
                            result.memory_manager = map
                                .next_value::<std::option::Option<crate::model::MemoryManager>>()?;
                        }
                        __FieldTag::__cpu_cfs_quota => {
                            if !fields.insert(__FieldTag::__cpu_cfs_quota) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_cfs_quota",
                                ));
                            }
                            result.cpu_cfs_quota =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::__cpu_cfs_quota_period => {
                            if !fields.insert(__FieldTag::__cpu_cfs_quota_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_cfs_quota_period",
                                ));
                            }
                            result.cpu_cfs_quota_period = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_pids_limit => {
                            if !fields.insert(__FieldTag::__pod_pids_limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_pids_limit",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pod_pids_limit =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__insecure_kubelet_readonly_port_enabled => {
                            if !fields.insert(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insecure_kubelet_readonly_port_enabled",
                                ));
                            }
                            result.insecure_kubelet_readonly_port_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__image_gc_low_threshold_percent => {
                            if !fields.insert(__FieldTag::__image_gc_low_threshold_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_gc_low_threshold_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.image_gc_low_threshold_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__image_gc_high_threshold_percent => {
                            if !fields.insert(__FieldTag::__image_gc_high_threshold_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_gc_high_threshold_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.image_gc_high_threshold_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__image_minimum_gc_age => {
                            if !fields.insert(__FieldTag::__image_minimum_gc_age) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_minimum_gc_age",
                                ));
                            }
                            result.image_minimum_gc_age = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_maximum_gc_age => {
                            if !fields.insert(__FieldTag::__image_maximum_gc_age) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_maximum_gc_age",
                                ));
                            }
                            result.image_maximum_gc_age = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_log_max_size => {
                            if !fields.insert(__FieldTag::__container_log_max_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_log_max_size",
                                ));
                            }
                            result.container_log_max_size = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_log_max_files => {
                            if !fields.insert(__FieldTag::__container_log_max_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_log_max_files",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.container_log_max_files =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__allowed_unsafe_sysctls => {
                            if !fields.insert(__FieldTag::__allowed_unsafe_sysctls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allowed_unsafe_sysctls",
                                ));
                            }
                            result.allowed_unsafe_sysctls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__eviction_soft => {
                            if !fields.insert(__FieldTag::__eviction_soft) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eviction_soft",
                                ));
                            }
                            result.eviction_soft = map
                                .next_value::<std::option::Option<crate::model::EvictionSignals>>(
                                )?;
                        }
                        __FieldTag::__eviction_soft_grace_period => {
                            if !fields.insert(__FieldTag::__eviction_soft_grace_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eviction_soft_grace_period",
                                ));
                            }
                            result.eviction_soft_grace_period = map.next_value::<std::option::Option<crate::model::EvictionGracePeriod>>()?
                                ;
                        }
                        __FieldTag::__eviction_minimum_reclaim => {
                            if !fields.insert(__FieldTag::__eviction_minimum_reclaim) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eviction_minimum_reclaim",
                                ));
                            }
                            result.eviction_minimum_reclaim = map.next_value::<std::option::Option<crate::model::EvictionMinimumReclaim>>()?
                                ;
                        }
                        __FieldTag::__eviction_max_pod_grace_period_seconds => {
                            if !fields.insert(__FieldTag::__eviction_max_pod_grace_period_seconds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eviction_max_pod_grace_period_seconds",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.eviction_max_pod_grace_period_seconds =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_parallel_image_pulls => {
                            if !fields.insert(__FieldTag::__max_parallel_image_pulls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_parallel_image_pulls",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_parallel_image_pulls =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__single_process_oom_kill => {
                            if !fields.insert(__FieldTag::__single_process_oom_kill) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_process_oom_kill",
                                ));
                            }
                            result.single_process_oom_kill =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TopologyManager {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy,
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TopologyManager")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policy" => Ok(__FieldTag::__policy),
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TopologyManager;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TopologyManager")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MemoryManager {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __policy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MemoryManager")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "policy" => Ok(__FieldTag::__policy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MemoryManager;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MemoryManager")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EvictionSignals {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __memory_available,
            __nodefs_available,
            __nodefs_inodes_free,
            __imagefs_available,
            __imagefs_inodes_free,
            __pid_available,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvictionSignals")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "memoryAvailable" => Ok(__FieldTag::__memory_available),
                            "memory_available" => Ok(__FieldTag::__memory_available),
                            "nodefsAvailable" => Ok(__FieldTag::__nodefs_available),
                            "nodefs_available" => Ok(__FieldTag::__nodefs_available),
                            "nodefsInodesFree" => Ok(__FieldTag::__nodefs_inodes_free),
                            "nodefs_inodes_free" => Ok(__FieldTag::__nodefs_inodes_free),
                            "imagefsAvailable" => Ok(__FieldTag::__imagefs_available),
                            "imagefs_available" => Ok(__FieldTag::__imagefs_available),
                            "imagefsInodesFree" => Ok(__FieldTag::__imagefs_inodes_free),
                            "imagefs_inodes_free" => Ok(__FieldTag::__imagefs_inodes_free),
                            "pidAvailable" => Ok(__FieldTag::__pid_available),
                            "pid_available" => Ok(__FieldTag::__pid_available),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EvictionSignals;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvictionSignals")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__memory_available => {
                            if !fields.insert(__FieldTag::__memory_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_available",
                                ));
                            }
                            result.memory_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_available => {
                            if !fields.insert(__FieldTag::__nodefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_available",
                                ));
                            }
                            result.nodefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_inodes_free => {
                            if !fields.insert(__FieldTag::__nodefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_inodes_free",
                                ));
                            }
                            result.nodefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_available => {
                            if !fields.insert(__FieldTag::__imagefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_available",
                                ));
                            }
                            result.imagefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_inodes_free => {
                            if !fields.insert(__FieldTag::__imagefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_inodes_free",
                                ));
                            }
                            result.imagefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pid_available => {
                            if !fields.insert(__FieldTag::__pid_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pid_available",
                                ));
                            }
                            result.pid_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EvictionGracePeriod {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __memory_available,
            __nodefs_available,
            __nodefs_inodes_free,
            __imagefs_available,
            __imagefs_inodes_free,
            __pid_available,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvictionGracePeriod")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "memoryAvailable" => Ok(__FieldTag::__memory_available),
                            "memory_available" => Ok(__FieldTag::__memory_available),
                            "nodefsAvailable" => Ok(__FieldTag::__nodefs_available),
                            "nodefs_available" => Ok(__FieldTag::__nodefs_available),
                            "nodefsInodesFree" => Ok(__FieldTag::__nodefs_inodes_free),
                            "nodefs_inodes_free" => Ok(__FieldTag::__nodefs_inodes_free),
                            "imagefsAvailable" => Ok(__FieldTag::__imagefs_available),
                            "imagefs_available" => Ok(__FieldTag::__imagefs_available),
                            "imagefsInodesFree" => Ok(__FieldTag::__imagefs_inodes_free),
                            "imagefs_inodes_free" => Ok(__FieldTag::__imagefs_inodes_free),
                            "pidAvailable" => Ok(__FieldTag::__pid_available),
                            "pid_available" => Ok(__FieldTag::__pid_available),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EvictionGracePeriod;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvictionGracePeriod")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__memory_available => {
                            if !fields.insert(__FieldTag::__memory_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_available",
                                ));
                            }
                            result.memory_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_available => {
                            if !fields.insert(__FieldTag::__nodefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_available",
                                ));
                            }
                            result.nodefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_inodes_free => {
                            if !fields.insert(__FieldTag::__nodefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_inodes_free",
                                ));
                            }
                            result.nodefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_available => {
                            if !fields.insert(__FieldTag::__imagefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_available",
                                ));
                            }
                            result.imagefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_inodes_free => {
                            if !fields.insert(__FieldTag::__imagefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_inodes_free",
                                ));
                            }
                            result.imagefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pid_available => {
                            if !fields.insert(__FieldTag::__pid_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pid_available",
                                ));
                            }
                            result.pid_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EvictionMinimumReclaim {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __memory_available,
            __nodefs_available,
            __nodefs_inodes_free,
            __imagefs_available,
            __imagefs_inodes_free,
            __pid_available,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EvictionMinimumReclaim")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "memoryAvailable" => Ok(__FieldTag::__memory_available),
                            "memory_available" => Ok(__FieldTag::__memory_available),
                            "nodefsAvailable" => Ok(__FieldTag::__nodefs_available),
                            "nodefs_available" => Ok(__FieldTag::__nodefs_available),
                            "nodefsInodesFree" => Ok(__FieldTag::__nodefs_inodes_free),
                            "nodefs_inodes_free" => Ok(__FieldTag::__nodefs_inodes_free),
                            "imagefsAvailable" => Ok(__FieldTag::__imagefs_available),
                            "imagefs_available" => Ok(__FieldTag::__imagefs_available),
                            "imagefsInodesFree" => Ok(__FieldTag::__imagefs_inodes_free),
                            "imagefs_inodes_free" => Ok(__FieldTag::__imagefs_inodes_free),
                            "pidAvailable" => Ok(__FieldTag::__pid_available),
                            "pid_available" => Ok(__FieldTag::__pid_available),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EvictionMinimumReclaim;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EvictionMinimumReclaim")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__memory_available => {
                            if !fields.insert(__FieldTag::__memory_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_available",
                                ));
                            }
                            result.memory_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_available => {
                            if !fields.insert(__FieldTag::__nodefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_available",
                                ));
                            }
                            result.nodefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodefs_inodes_free => {
                            if !fields.insert(__FieldTag::__nodefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodefs_inodes_free",
                                ));
                            }
                            result.nodefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_available => {
                            if !fields.insert(__FieldTag::__imagefs_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_available",
                                ));
                            }
                            result.imagefs_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__imagefs_inodes_free => {
                            if !fields.insert(__FieldTag::__imagefs_inodes_free) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for imagefs_inodes_free",
                                ));
                            }
                            result.imagefs_inodes_free = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pid_available => {
                            if !fields.insert(__FieldTag::__pid_available) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pid_available",
                                ));
                            }
                            result.pid_available = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machine_type,
            __disk_size_gb,
            __oauth_scopes,
            __service_account,
            __metadata,
            __image_type,
            __labels,
            __local_ssd_count,
            __tags,
            __preemptible,
            __accelerators,
            __disk_type,
            __min_cpu_platform,
            __workload_metadata_config,
            __taints,
            __sandbox_config,
            __node_group,
            __reservation_affinity,
            __shielded_instance_config,
            __linux_node_config,
            __kubelet_config,
            __boot_disk_kms_key,
            __gcfs_config,
            __advanced_machine_features,
            __gvnic,
            __spot,
            __confidential_nodes,
            __fast_socket,
            __resource_labels,
            __logging_config,
            __windows_node_config,
            __local_nvme_ssd_block_config,
            __ephemeral_storage_local_ssd_config,
            __sole_tenant_config,
            __containerd_config,
            __resource_manager_tags,
            __enable_confidential_storage,
            __secondary_boot_disks,
            __storage_pools,
            __secondary_boot_disk_update_strategy,
            __max_run_duration,
            __local_ssd_encryption_mode,
            __effective_cgroup_mode,
            __flex_start,
            __boot_disk,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "oauthScopes" => Ok(__FieldTag::__oauth_scopes),
                            "oauth_scopes" => Ok(__FieldTag::__oauth_scopes),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "imageType" => Ok(__FieldTag::__image_type),
                            "image_type" => Ok(__FieldTag::__image_type),
                            "labels" => Ok(__FieldTag::__labels),
                            "localSsdCount" => Ok(__FieldTag::__local_ssd_count),
                            "local_ssd_count" => Ok(__FieldTag::__local_ssd_count),
                            "tags" => Ok(__FieldTag::__tags),
                            "preemptible" => Ok(__FieldTag::__preemptible),
                            "accelerators" => Ok(__FieldTag::__accelerators),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "minCpuPlatform" => Ok(__FieldTag::__min_cpu_platform),
                            "min_cpu_platform" => Ok(__FieldTag::__min_cpu_platform),
                            "workloadMetadataConfig" => Ok(__FieldTag::__workload_metadata_config),
                            "workload_metadata_config" => {
                                Ok(__FieldTag::__workload_metadata_config)
                            }
                            "taints" => Ok(__FieldTag::__taints),
                            "sandboxConfig" => Ok(__FieldTag::__sandbox_config),
                            "sandbox_config" => Ok(__FieldTag::__sandbox_config),
                            "nodeGroup" => Ok(__FieldTag::__node_group),
                            "node_group" => Ok(__FieldTag::__node_group),
                            "reservationAffinity" => Ok(__FieldTag::__reservation_affinity),
                            "reservation_affinity" => Ok(__FieldTag::__reservation_affinity),
                            "shieldedInstanceConfig" => Ok(__FieldTag::__shielded_instance_config),
                            "shielded_instance_config" => {
                                Ok(__FieldTag::__shielded_instance_config)
                            }
                            "linuxNodeConfig" => Ok(__FieldTag::__linux_node_config),
                            "linux_node_config" => Ok(__FieldTag::__linux_node_config),
                            "kubeletConfig" => Ok(__FieldTag::__kubelet_config),
                            "kubelet_config" => Ok(__FieldTag::__kubelet_config),
                            "bootDiskKmsKey" => Ok(__FieldTag::__boot_disk_kms_key),
                            "boot_disk_kms_key" => Ok(__FieldTag::__boot_disk_kms_key),
                            "gcfsConfig" => Ok(__FieldTag::__gcfs_config),
                            "gcfs_config" => Ok(__FieldTag::__gcfs_config),
                            "advancedMachineFeatures" => {
                                Ok(__FieldTag::__advanced_machine_features)
                            }
                            "advanced_machine_features" => {
                                Ok(__FieldTag::__advanced_machine_features)
                            }
                            "gvnic" => Ok(__FieldTag::__gvnic),
                            "spot" => Ok(__FieldTag::__spot),
                            "confidentialNodes" => Ok(__FieldTag::__confidential_nodes),
                            "confidential_nodes" => Ok(__FieldTag::__confidential_nodes),
                            "fastSocket" => Ok(__FieldTag::__fast_socket),
                            "fast_socket" => Ok(__FieldTag::__fast_socket),
                            "resourceLabels" => Ok(__FieldTag::__resource_labels),
                            "resource_labels" => Ok(__FieldTag::__resource_labels),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "windowsNodeConfig" => Ok(__FieldTag::__windows_node_config),
                            "windows_node_config" => Ok(__FieldTag::__windows_node_config),
                            "localNvmeSsdBlockConfig" => {
                                Ok(__FieldTag::__local_nvme_ssd_block_config)
                            }
                            "local_nvme_ssd_block_config" => {
                                Ok(__FieldTag::__local_nvme_ssd_block_config)
                            }
                            "ephemeralStorageLocalSsdConfig" => {
                                Ok(__FieldTag::__ephemeral_storage_local_ssd_config)
                            }
                            "ephemeral_storage_local_ssd_config" => {
                                Ok(__FieldTag::__ephemeral_storage_local_ssd_config)
                            }
                            "soleTenantConfig" => Ok(__FieldTag::__sole_tenant_config),
                            "sole_tenant_config" => Ok(__FieldTag::__sole_tenant_config),
                            "containerdConfig" => Ok(__FieldTag::__containerd_config),
                            "containerd_config" => Ok(__FieldTag::__containerd_config),
                            "resourceManagerTags" => Ok(__FieldTag::__resource_manager_tags),
                            "resource_manager_tags" => Ok(__FieldTag::__resource_manager_tags),
                            "enableConfidentialStorage" => {
                                Ok(__FieldTag::__enable_confidential_storage)
                            }
                            "enable_confidential_storage" => {
                                Ok(__FieldTag::__enable_confidential_storage)
                            }
                            "secondaryBootDisks" => Ok(__FieldTag::__secondary_boot_disks),
                            "secondary_boot_disks" => Ok(__FieldTag::__secondary_boot_disks),
                            "storagePools" => Ok(__FieldTag::__storage_pools),
                            "storage_pools" => Ok(__FieldTag::__storage_pools),
                            "secondaryBootDiskUpdateStrategy" => {
                                Ok(__FieldTag::__secondary_boot_disk_update_strategy)
                            }
                            "secondary_boot_disk_update_strategy" => {
                                Ok(__FieldTag::__secondary_boot_disk_update_strategy)
                            }
                            "maxRunDuration" => Ok(__FieldTag::__max_run_duration),
                            "max_run_duration" => Ok(__FieldTag::__max_run_duration),
                            "localSsdEncryptionMode" => Ok(__FieldTag::__local_ssd_encryption_mode),
                            "local_ssd_encryption_mode" => {
                                Ok(__FieldTag::__local_ssd_encryption_mode)
                            }
                            "effectiveCgroupMode" => Ok(__FieldTag::__effective_cgroup_mode),
                            "effective_cgroup_mode" => Ok(__FieldTag::__effective_cgroup_mode),
                            "flexStart" => Ok(__FieldTag::__flex_start),
                            "flex_start" => Ok(__FieldTag::__flex_start),
                            "bootDisk" => Ok(__FieldTag::__boot_disk),
                            "boot_disk" => Ok(__FieldTag::__boot_disk),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__oauth_scopes => {
                            if !fields.insert(__FieldTag::__oauth_scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_scopes",
                                ));
                            }
                            result.oauth_scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_type => {
                            if !fields.insert(__FieldTag::__image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_type",
                                ));
                            }
                            result.image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__local_ssd_count => {
                            if !fields.insert(__FieldTag::__local_ssd_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_ssd_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.local_ssd_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__preemptible => {
                            if !fields.insert(__FieldTag::__preemptible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preemptible",
                                ));
                            }
                            result.preemptible = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__accelerators => {
                            if !fields.insert(__FieldTag::__accelerators) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerators",
                                ));
                            }
                            result.accelerators =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AcceleratorConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_cpu_platform => {
                            if !fields.insert(__FieldTag::__min_cpu_platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_cpu_platform",
                                ));
                            }
                            result.min_cpu_platform = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_metadata_config => {
                            if !fields.insert(__FieldTag::__workload_metadata_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_metadata_config",
                                ));
                            }
                            result.workload_metadata_config = map.next_value::<std::option::Option<crate::model::WorkloadMetadataConfig>>()?
                                ;
                        }
                        __FieldTag::__taints => {
                            if !fields.insert(__FieldTag::__taints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taints",
                                ));
                            }
                            result.taints = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NodeTaint>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__sandbox_config => {
                            if !fields.insert(__FieldTag::__sandbox_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sandbox_config",
                                ));
                            }
                            result.sandbox_config = map
                                .next_value::<std::option::Option<crate::model::SandboxConfig>>()?;
                        }
                        __FieldTag::__node_group => {
                            if !fields.insert(__FieldTag::__node_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_group",
                                ));
                            }
                            result.node_group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reservation_affinity => {
                            if !fields.insert(__FieldTag::__reservation_affinity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reservation_affinity",
                                ));
                            }
                            result.reservation_affinity = map.next_value::<std::option::Option<crate::model::ReservationAffinity>>()?
                                ;
                        }
                        __FieldTag::__shielded_instance_config => {
                            if !fields.insert(__FieldTag::__shielded_instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shielded_instance_config",
                                ));
                            }
                            result.shielded_instance_config = map.next_value::<std::option::Option<crate::model::ShieldedInstanceConfig>>()?
                                ;
                        }
                        __FieldTag::__linux_node_config => {
                            if !fields.insert(__FieldTag::__linux_node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linux_node_config",
                                ));
                            }
                            result.linux_node_config = map
                                .next_value::<std::option::Option<crate::model::LinuxNodeConfig>>(
                                )?;
                        }
                        __FieldTag::__kubelet_config => {
                            if !fields.insert(__FieldTag::__kubelet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubelet_config",
                                ));
                            }
                            result.kubelet_config = map
                                .next_value::<std::option::Option<crate::model::NodeKubeletConfig>>(
                                )?;
                        }
                        __FieldTag::__boot_disk_kms_key => {
                            if !fields.insert(__FieldTag::__boot_disk_kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk_kms_key",
                                ));
                            }
                            result.boot_disk_kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcfs_config => {
                            if !fields.insert(__FieldTag::__gcfs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcfs_config",
                                ));
                            }
                            result.gcfs_config =
                                map.next_value::<std::option::Option<crate::model::GcfsConfig>>()?;
                        }
                        __FieldTag::__advanced_machine_features => {
                            if !fields.insert(__FieldTag::__advanced_machine_features) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_machine_features",
                                ));
                            }
                            result.advanced_machine_features = map.next_value::<std::option::Option<crate::model::AdvancedMachineFeatures>>()?
                                ;
                        }
                        __FieldTag::__gvnic => {
                            if !fields.insert(__FieldTag::__gvnic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gvnic",
                                ));
                            }
                            result.gvnic =
                                map.next_value::<std::option::Option<crate::model::VirtualNIC>>()?;
                        }
                        __FieldTag::__spot => {
                            if !fields.insert(__FieldTag::__spot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for spot",
                                ));
                            }
                            result.spot = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidential_nodes => {
                            if !fields.insert(__FieldTag::__confidential_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidential_nodes",
                                ));
                            }
                            result.confidential_nodes = map
                                .next_value::<std::option::Option<crate::model::ConfidentialNodes>>(
                                )?;
                        }
                        __FieldTag::__fast_socket => {
                            if !fields.insert(__FieldTag::__fast_socket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fast_socket",
                                ));
                            }
                            result.fast_socket =
                                map.next_value::<std::option::Option<crate::model::FastSocket>>()?;
                        }
                        __FieldTag::__resource_labels => {
                            if !fields.insert(__FieldTag::__resource_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_labels",
                                ));
                            }
                            result.resource_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map.next_value::<std::option::Option<crate::model::NodePoolLoggingConfig>>()?
                                ;
                        }
                        __FieldTag::__windows_node_config => {
                            if !fields.insert(__FieldTag::__windows_node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_node_config",
                                ));
                            }
                            result.windows_node_config = map
                                .next_value::<std::option::Option<crate::model::WindowsNodeConfig>>(
                                )?;
                        }
                        __FieldTag::__local_nvme_ssd_block_config => {
                            if !fields.insert(__FieldTag::__local_nvme_ssd_block_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_nvme_ssd_block_config",
                                ));
                            }
                            result.local_nvme_ssd_block_config = map.next_value::<std::option::Option<crate::model::LocalNvmeSsdBlockConfig>>()?
                                ;
                        }
                        __FieldTag::__ephemeral_storage_local_ssd_config => {
                            if !fields.insert(__FieldTag::__ephemeral_storage_local_ssd_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ephemeral_storage_local_ssd_config",
                                ));
                            }
                            result.ephemeral_storage_local_ssd_config =
                                map.next_value::<std::option::Option<
                                    crate::model::EphemeralStorageLocalSsdConfig,
                                >>()?;
                        }
                        __FieldTag::__sole_tenant_config => {
                            if !fields.insert(__FieldTag::__sole_tenant_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sole_tenant_config",
                                ));
                            }
                            result.sole_tenant_config = map
                                .next_value::<std::option::Option<crate::model::SoleTenantConfig>>(
                                )?;
                        }
                        __FieldTag::__containerd_config => {
                            if !fields.insert(__FieldTag::__containerd_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containerd_config",
                                ));
                            }
                            result.containerd_config = map
                                .next_value::<std::option::Option<crate::model::ContainerdConfig>>(
                                )?;
                        }
                        __FieldTag::__resource_manager_tags => {
                            if !fields.insert(__FieldTag::__resource_manager_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_manager_tags",
                                ));
                            }
                            result.resource_manager_tags = map.next_value::<std::option::Option<crate::model::ResourceManagerTags>>()?
                                ;
                        }
                        __FieldTag::__enable_confidential_storage => {
                            if !fields.insert(__FieldTag::__enable_confidential_storage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_confidential_storage",
                                ));
                            }
                            result.enable_confidential_storage = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_boot_disks => {
                            if !fields.insert(__FieldTag::__secondary_boot_disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_boot_disks",
                                ));
                            }
                            result.secondary_boot_disks =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SecondaryBootDisk>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__storage_pools => {
                            if !fields.insert(__FieldTag::__storage_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_pools",
                                ));
                            }
                            result.storage_pools = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__secondary_boot_disk_update_strategy => {
                            if !fields.insert(__FieldTag::__secondary_boot_disk_update_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_boot_disk_update_strategy",
                                ));
                            }
                            result.secondary_boot_disk_update_strategy = map
                                .next_value::<std::option::Option<
                                    crate::model::SecondaryBootDiskUpdateStrategy,
                                >>()?;
                        }
                        __FieldTag::__max_run_duration => {
                            if !fields.insert(__FieldTag::__max_run_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_run_duration",
                                ));
                            }
                            result.max_run_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__local_ssd_encryption_mode => {
                            if !fields.insert(__FieldTag::__local_ssd_encryption_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_ssd_encryption_mode",
                                ));
                            }
                            result.local_ssd_encryption_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::node_config::LocalSsdEncryptionMode,
                                >>()?;
                        }
                        __FieldTag::__effective_cgroup_mode => {
                            if !fields.insert(__FieldTag::__effective_cgroup_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effective_cgroup_mode",
                                ));
                            }
                            result.effective_cgroup_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::node_config::EffectiveCgroupMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__flex_start => {
                            if !fields.insert(__FieldTag::__flex_start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flex_start",
                                ));
                            }
                            result.flex_start = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__boot_disk => {
                            if !fields.insert(__FieldTag::__boot_disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk",
                                ));
                            }
                            result.boot_disk =
                                map.next_value::<std::option::Option<crate::model::BootDisk>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AdvancedMachineFeatures {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __threads_per_core,
            __enable_nested_virtualization,
            __performance_monitoring_unit,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvancedMachineFeatures")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "threadsPerCore" => Ok(__FieldTag::__threads_per_core),
                            "threads_per_core" => Ok(__FieldTag::__threads_per_core),
                            "enableNestedVirtualization" => {
                                Ok(__FieldTag::__enable_nested_virtualization)
                            }
                            "enable_nested_virtualization" => {
                                Ok(__FieldTag::__enable_nested_virtualization)
                            }
                            "performanceMonitoringUnit" => {
                                Ok(__FieldTag::__performance_monitoring_unit)
                            }
                            "performance_monitoring_unit" => {
                                Ok(__FieldTag::__performance_monitoring_unit)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AdvancedMachineFeatures;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvancedMachineFeatures")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__threads_per_core => {
                            if !fields.insert(__FieldTag::__threads_per_core) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for threads_per_core",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.threads_per_core = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__enable_nested_virtualization => {
                            if !fields.insert(__FieldTag::__enable_nested_virtualization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_nested_virtualization",
                                ));
                            }
                            result.enable_nested_virtualization =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__performance_monitoring_unit => {
                            if !fields.insert(__FieldTag::__performance_monitoring_unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for performance_monitoring_unit",
                                ));
                            }
                            result.performance_monitoring_unit = map
                                .next_value::<std::option::Option<
                                crate::model::advanced_machine_features::PerformanceMonitoringUnit,
                            >>(
                            )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodeNetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_pod_range,
            __pod_range,
            __pod_ipv4_cidr_block,
            __enable_private_nodes,
            __network_performance_config,
            __pod_cidr_overprovision_config,
            __additional_node_network_configs,
            __additional_pod_network_configs,
            __pod_ipv4_range_utilization,
            __subnetwork,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeNetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createPodRange" => Ok(__FieldTag::__create_pod_range),
                            "create_pod_range" => Ok(__FieldTag::__create_pod_range),
                            "podRange" => Ok(__FieldTag::__pod_range),
                            "pod_range" => Ok(__FieldTag::__pod_range),
                            "podIpv4CidrBlock" => Ok(__FieldTag::__pod_ipv4_cidr_block),
                            "pod_ipv4_cidr_block" => Ok(__FieldTag::__pod_ipv4_cidr_block),
                            "enablePrivateNodes" => Ok(__FieldTag::__enable_private_nodes),
                            "enable_private_nodes" => Ok(__FieldTag::__enable_private_nodes),
                            "networkPerformanceConfig" => {
                                Ok(__FieldTag::__network_performance_config)
                            }
                            "network_performance_config" => {
                                Ok(__FieldTag::__network_performance_config)
                            }
                            "podCidrOverprovisionConfig" => {
                                Ok(__FieldTag::__pod_cidr_overprovision_config)
                            }
                            "pod_cidr_overprovision_config" => {
                                Ok(__FieldTag::__pod_cidr_overprovision_config)
                            }
                            "additionalNodeNetworkConfigs" => {
                                Ok(__FieldTag::__additional_node_network_configs)
                            }
                            "additional_node_network_configs" => {
                                Ok(__FieldTag::__additional_node_network_configs)
                            }
                            "additionalPodNetworkConfigs" => {
                                Ok(__FieldTag::__additional_pod_network_configs)
                            }
                            "additional_pod_network_configs" => {
                                Ok(__FieldTag::__additional_pod_network_configs)
                            }
                            "podIpv4RangeUtilization" => {
                                Ok(__FieldTag::__pod_ipv4_range_utilization)
                            }
                            "pod_ipv4_range_utilization" => {
                                Ok(__FieldTag::__pod_ipv4_range_utilization)
                            }
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodeNetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeNetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_pod_range => {
                            if !fields.insert(__FieldTag::__create_pod_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_pod_range",
                                ));
                            }
                            result.create_pod_range = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_range => {
                            if !fields.insert(__FieldTag::__pod_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_range",
                                ));
                            }
                            result.pod_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__pod_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_ipv4_cidr_block",
                                ));
                            }
                            result.pod_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_private_nodes => {
                            if !fields.insert(__FieldTag::__enable_private_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_private_nodes",
                                ));
                            }
                            result.enable_private_nodes =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__network_performance_config => {
                            if !fields.insert(__FieldTag::__network_performance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_performance_config",
                                ));
                            }
                            result.network_performance_config = map
                                .next_value::<std::option::Option<
                                    crate::model::node_network_config::NetworkPerformanceConfig,
                                >>()?;
                        }
                        __FieldTag::__pod_cidr_overprovision_config => {
                            if !fields.insert(__FieldTag::__pod_cidr_overprovision_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_cidr_overprovision_config",
                                ));
                            }
                            result.pod_cidr_overprovision_config = map.next_value::<std::option::Option<crate::model::PodCIDROverprovisionConfig>>()?
                                ;
                        }
                        __FieldTag::__additional_node_network_configs => {
                            if !fields.insert(__FieldTag::__additional_node_network_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_node_network_configs",
                                ));
                            }
                            result.additional_node_network_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdditionalNodeNetworkConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_pod_network_configs => {
                            if !fields.insert(__FieldTag::__additional_pod_network_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_pod_network_configs",
                                ));
                            }
                            result.additional_pod_network_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdditionalPodNetworkConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_ipv4_range_utilization => {
                            if !fields.insert(__FieldTag::__pod_ipv4_range_utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_ipv4_range_utilization",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pod_ipv4_range_utilization =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::node_network_config::NetworkPerformanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_egress_bandwidth_tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkPerformanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalEgressBandwidthTier" => {
                                Ok(__FieldTag::__total_egress_bandwidth_tier)
                            }
                            "total_egress_bandwidth_tier" => {
                                Ok(__FieldTag::__total_egress_bandwidth_tier)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::node_network_config::NetworkPerformanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkPerformanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_egress_bandwidth_tier => {
                            if !fields.insert(__FieldTag::__total_egress_bandwidth_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_egress_bandwidth_tier",
                                ));
                            }
                            result.total_egress_bandwidth_tier = map
                                .next_value::<std::option::Option<
                                crate::model::node_network_config::network_performance_config::Tier,
                            >>(
                            )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AdditionalNodeNetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __subnetwork,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdditionalNodeNetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AdditionalNodeNetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdditionalNodeNetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AdditionalPodNetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subnetwork,
            __secondary_pod_range,
            __max_pods_per_node,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdditionalPodNetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "secondaryPodRange" => Ok(__FieldTag::__secondary_pod_range),
                            "secondary_pod_range" => Ok(__FieldTag::__secondary_pod_range),
                            "maxPodsPerNode" => Ok(__FieldTag::__max_pods_per_node),
                            "max_pods_per_node" => Ok(__FieldTag::__max_pods_per_node),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AdditionalPodNetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdditionalPodNetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_pod_range => {
                            if !fields.insert(__FieldTag::__secondary_pod_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_pod_range",
                                ));
                            }
                            result.secondary_pod_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_pods_per_node => {
                            if !fields.insert(__FieldTag::__max_pods_per_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_pods_per_node",
                                ));
                            }
                            result.max_pods_per_node = map
                                .next_value::<std::option::Option<crate::model::MaxPodsConstraint>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ShieldedInstanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_secure_boot,
            __enable_integrity_monitoring,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShieldedInstanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableSecureBoot" => Ok(__FieldTag::__enable_secure_boot),
                            "enable_secure_boot" => Ok(__FieldTag::__enable_secure_boot),
                            "enableIntegrityMonitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            "enable_integrity_monitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ShieldedInstanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShieldedInstanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_secure_boot => {
                            if !fields.insert(__FieldTag::__enable_secure_boot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_secure_boot",
                                ));
                            }
                            result.enable_secure_boot = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_integrity_monitoring => {
                            if !fields.insert(__FieldTag::__enable_integrity_monitoring) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_integrity_monitoring",
                                ));
                            }
                            result.enable_integrity_monitoring = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SandboxConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SandboxConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SandboxConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SandboxConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::sandbox_config::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcfsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcfsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcfsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcfsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ReservationAffinity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __consume_reservation_type,
            __key,
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReservationAffinity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "consumeReservationType" => Ok(__FieldTag::__consume_reservation_type),
                            "consume_reservation_type" => {
                                Ok(__FieldTag::__consume_reservation_type)
                            }
                            "key" => Ok(__FieldTag::__key),
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ReservationAffinity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReservationAffinity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__consume_reservation_type => {
                            if !fields.insert(__FieldTag::__consume_reservation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consume_reservation_type",
                                ));
                            }
                            result.consume_reservation_type = map.next_value::<std::option::Option<crate::model::reservation_affinity::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SoleTenantConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_affinities,
            __min_node_cpus,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SoleTenantConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodeAffinities" => Ok(__FieldTag::__node_affinities),
                            "node_affinities" => Ok(__FieldTag::__node_affinities),
                            "minNodeCpus" => Ok(__FieldTag::__min_node_cpus),
                            "min_node_cpus" => Ok(__FieldTag::__min_node_cpus),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SoleTenantConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SoleTenantConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_affinities => {
                            if !fields.insert(__FieldTag::__node_affinities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_affinities",
                                ));
                            }
                            result.node_affinities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::sole_tenant_config::NodeAffinity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_node_cpus => {
                            if !fields.insert(__FieldTag::__min_node_cpus) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_cpus",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_cpus = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::sole_tenant_config::NodeAffinity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __operator,
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeAffinity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "operator" => Ok(__FieldTag::__operator),
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::sole_tenant_config::NodeAffinity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeAffinity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operator => {
                            if !fields.insert(__FieldTag::__operator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operator",
                                ));
                            }
                            result.operator = map
                                .next_value::<std::option::Option<
                                    crate::model::sole_tenant_config::node_affinity::Operator,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ContainerdConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __private_registry_access_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContainerdConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "privateRegistryAccessConfig" => {
                                Ok(__FieldTag::__private_registry_access_config)
                            }
                            "private_registry_access_config" => {
                                Ok(__FieldTag::__private_registry_access_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ContainerdConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContainerdConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__private_registry_access_config => {
                            if !fields.insert(__FieldTag::__private_registry_access_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_registry_access_config",
                                ));
                            }
                            result.private_registry_access_config = map
                                .next_value::<std::option::Option<
                                    crate::model::containerd_config::PrivateRegistryAccessConfig,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::containerd_config::PrivateRegistryAccessConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __certificate_authority_domain_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivateRegistryAccessConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "certificateAuthorityDomainConfig" => {
                                Ok(__FieldTag::__certificate_authority_domain_config)
                            }
                            "certificate_authority_domain_config" => {
                                Ok(__FieldTag::__certificate_authority_domain_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::containerd_config::PrivateRegistryAccessConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateRegistryAccessConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__certificate_authority_domain_config => {
                            if !fields.insert(__FieldTag::__certificate_authority_domain_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for certificate_authority_domain_config",
                                ));
                            }
                            result.certificate_authority_domain_config = map.next_value::<std::option::Option<std::vec::Vec<crate::model::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fqdns,
            __gcp_secret_manager_certificate_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateAuthorityDomainConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fqdns" => Ok(__FieldTag::__fqdns),
                            "gcpSecretManagerCertificateConfig" => {
                                Ok(__FieldTag::__gcp_secret_manager_certificate_config)
                            }
                            "gcp_secret_manager_certificate_config" => {
                                Ok(__FieldTag::__gcp_secret_manager_certificate_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::containerd_config::private_registry_access_config::CertificateAuthorityDomainConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateAuthorityDomainConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fqdns => {
                            if !fields.insert(__FieldTag::__fqdns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fqdns",
                                ));
                            }
                            result.fqdns = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__gcp_secret_manager_certificate_config => {
                            if !fields.insert(__FieldTag::__gcp_secret_manager_certificate_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_secret_manager_certificate_config",
                                ));
                            }
                            if result.certificate_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `certificate_config`, a oneof with full ID .google.container.v1.ContainerdConfig.PrivateRegistryAccessConfig.CertificateAuthorityDomainConfig.gcp_secret_manager_certificate_config, latest field was gcpSecretManagerCertificateConfig",
                                ));
                            }
                            result.certificate_config = std::option::Option::Some(
                                crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::CertificateConfig::GcpSecretManagerCertificateConfig(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secret_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GCPSecretManagerCertificateConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secretUri" => Ok(__FieldTag::__secret_uri),
                            "secret_uri" => Ok(__FieldTag::__secret_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::containerd_config::private_registry_access_config::certificate_authority_domain_config::GCPSecretManagerCertificateConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GCPSecretManagerCertificateConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                use std::option::Option::Some;
                #[allow(unused_imports)]
                use serde::de::Error;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secret_uri => {
                            if !fields.insert(__FieldTag::__secret_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field("multiple values for secret_uri"));
                            }
                            result.secret_uri = map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default();
                        },
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        },
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodeTaint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __value,
            __effect,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeTaint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "value" => Ok(__FieldTag::__value),
                            "effect" => Ok(__FieldTag::__effect),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodeTaint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeTaint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            result.value = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__effect => {
                            if !fields.insert(__FieldTag::__effect) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for effect",
                                ));
                            }
                            result.effect = map.next_value::<std::option::Option<crate::model::node_taint::Effect>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodeTaints {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __taints,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeTaints")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "taints" => Ok(__FieldTag::__taints),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodeTaints;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeTaints")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__taints => {
                            if !fields.insert(__FieldTag::__taints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taints",
                                ));
                            }
                            result.taints = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NodeTaint>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodeLabels {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeLabels")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodeLabels;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeLabels")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResourceLabels {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceLabels")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResourceLabels;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceLabels")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NetworkTags {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkTags")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NetworkTags;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkTags")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MasterAuth {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __username,
            __password,
            __client_certificate_config,
            __cluster_ca_certificate,
            __client_certificate,
            __client_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MasterAuth")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "clientCertificateConfig" => {
                                Ok(__FieldTag::__client_certificate_config)
                            }
                            "client_certificate_config" => {
                                Ok(__FieldTag::__client_certificate_config)
                            }
                            "clusterCaCertificate" => Ok(__FieldTag::__cluster_ca_certificate),
                            "cluster_ca_certificate" => Ok(__FieldTag::__cluster_ca_certificate),
                            "clientCertificate" => Ok(__FieldTag::__client_certificate),
                            "client_certificate" => Ok(__FieldTag::__client_certificate),
                            "clientKey" => Ok(__FieldTag::__client_key),
                            "client_key" => Ok(__FieldTag::__client_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MasterAuth;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MasterAuth")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_certificate_config => {
                            if !fields.insert(__FieldTag::__client_certificate_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate_config",
                                ));
                            }
                            result.client_certificate_config = map.next_value::<std::option::Option<crate::model::ClientCertificateConfig>>()?
                                ;
                        }
                        __FieldTag::__cluster_ca_certificate => {
                            if !fields.insert(__FieldTag::__cluster_ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ca_certificate",
                                ));
                            }
                            result.cluster_ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_certificate => {
                            if !fields.insert(__FieldTag::__client_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate",
                                ));
                            }
                            result.client_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_key => {
                            if !fields.insert(__FieldTag::__client_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_key",
                                ));
                            }
                            result.client_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ClientCertificateConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue_client_certificate,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClientCertificateConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issueClientCertificate" => Ok(__FieldTag::__issue_client_certificate),
                            "issue_client_certificate" => {
                                Ok(__FieldTag::__issue_client_certificate)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ClientCertificateConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClientCertificateConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue_client_certificate => {
                            if !fields.insert(__FieldTag::__issue_client_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue_client_certificate",
                                ));
                            }
                            result.issue_client_certificate = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AddonsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __http_load_balancing,
            __horizontal_pod_autoscaling,
            __kubernetes_dashboard,
            __network_policy_config,
            __cloud_run_config,
            __dns_cache_config,
            __config_connector_config,
            __gce_persistent_disk_csi_driver_config,
            __gcp_filestore_csi_driver_config,
            __gke_backup_agent_config,
            __gcs_fuse_csi_driver_config,
            __stateful_ha_config,
            __parallelstore_csi_driver_config,
            __ray_operator_config,
            __high_scale_checkpointing_config,
            __lustre_csi_driver_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddonsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "httpLoadBalancing" => Ok(__FieldTag::__http_load_balancing),
                            "http_load_balancing" => Ok(__FieldTag::__http_load_balancing),
                            "horizontalPodAutoscaling" => {
                                Ok(__FieldTag::__horizontal_pod_autoscaling)
                            }
                            "horizontal_pod_autoscaling" => {
                                Ok(__FieldTag::__horizontal_pod_autoscaling)
                            }
                            "kubernetesDashboard" => Ok(__FieldTag::__kubernetes_dashboard),
                            "kubernetes_dashboard" => Ok(__FieldTag::__kubernetes_dashboard),
                            "networkPolicyConfig" => Ok(__FieldTag::__network_policy_config),
                            "network_policy_config" => Ok(__FieldTag::__network_policy_config),
                            "cloudRunConfig" => Ok(__FieldTag::__cloud_run_config),
                            "cloud_run_config" => Ok(__FieldTag::__cloud_run_config),
                            "dnsCacheConfig" => Ok(__FieldTag::__dns_cache_config),
                            "dns_cache_config" => Ok(__FieldTag::__dns_cache_config),
                            "configConnectorConfig" => Ok(__FieldTag::__config_connector_config),
                            "config_connector_config" => Ok(__FieldTag::__config_connector_config),
                            "gcePersistentDiskCsiDriverConfig" => {
                                Ok(__FieldTag::__gce_persistent_disk_csi_driver_config)
                            }
                            "gce_persistent_disk_csi_driver_config" => {
                                Ok(__FieldTag::__gce_persistent_disk_csi_driver_config)
                            }
                            "gcpFilestoreCsiDriverConfig" => {
                                Ok(__FieldTag::__gcp_filestore_csi_driver_config)
                            }
                            "gcp_filestore_csi_driver_config" => {
                                Ok(__FieldTag::__gcp_filestore_csi_driver_config)
                            }
                            "gkeBackupAgentConfig" => Ok(__FieldTag::__gke_backup_agent_config),
                            "gke_backup_agent_config" => Ok(__FieldTag::__gke_backup_agent_config),
                            "gcsFuseCsiDriverConfig" => {
                                Ok(__FieldTag::__gcs_fuse_csi_driver_config)
                            }
                            "gcs_fuse_csi_driver_config" => {
                                Ok(__FieldTag::__gcs_fuse_csi_driver_config)
                            }
                            "statefulHaConfig" => Ok(__FieldTag::__stateful_ha_config),
                            "stateful_ha_config" => Ok(__FieldTag::__stateful_ha_config),
                            "parallelstoreCsiDriverConfig" => {
                                Ok(__FieldTag::__parallelstore_csi_driver_config)
                            }
                            "parallelstore_csi_driver_config" => {
                                Ok(__FieldTag::__parallelstore_csi_driver_config)
                            }
                            "rayOperatorConfig" => Ok(__FieldTag::__ray_operator_config),
                            "ray_operator_config" => Ok(__FieldTag::__ray_operator_config),
                            "highScaleCheckpointingConfig" => {
                                Ok(__FieldTag::__high_scale_checkpointing_config)
                            }
                            "high_scale_checkpointing_config" => {
                                Ok(__FieldTag::__high_scale_checkpointing_config)
                            }
                            "lustreCsiDriverConfig" => Ok(__FieldTag::__lustre_csi_driver_config),
                            "lustre_csi_driver_config" => {
                                Ok(__FieldTag::__lustre_csi_driver_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AddonsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddonsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__http_load_balancing => {
                            if !fields.insert(__FieldTag::__http_load_balancing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_load_balancing",
                                ));
                            }
                            result.http_load_balancing = map
                                .next_value::<std::option::Option<crate::model::HttpLoadBalancing>>(
                                )?;
                        }
                        __FieldTag::__horizontal_pod_autoscaling => {
                            if !fields.insert(__FieldTag::__horizontal_pod_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for horizontal_pod_autoscaling",
                                ));
                            }
                            result.horizontal_pod_autoscaling = map.next_value::<std::option::Option<crate::model::HorizontalPodAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__kubernetes_dashboard => {
                            if !fields.insert(__FieldTag::__kubernetes_dashboard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubernetes_dashboard",
                                ));
                            }
                            result.kubernetes_dashboard = map.next_value::<std::option::Option<crate::model::KubernetesDashboard>>()?
                                ;
                        }
                        __FieldTag::__network_policy_config => {
                            if !fields.insert(__FieldTag::__network_policy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_policy_config",
                                ));
                            }
                            result.network_policy_config = map.next_value::<std::option::Option<crate::model::NetworkPolicyConfig>>()?
                                ;
                        }
                        __FieldTag::__cloud_run_config => {
                            if !fields.insert(__FieldTag::__cloud_run_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_run_config",
                                ));
                            }
                            result.cloud_run_config = map
                                .next_value::<std::option::Option<crate::model::CloudRunConfig>>(
                                )?;
                        }
                        __FieldTag::__dns_cache_config => {
                            if !fields.insert(__FieldTag::__dns_cache_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_cache_config",
                                ));
                            }
                            result.dns_cache_config = map
                                .next_value::<std::option::Option<crate::model::DnsCacheConfig>>(
                                )?;
                        }
                        __FieldTag::__config_connector_config => {
                            if !fields.insert(__FieldTag::__config_connector_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_connector_config",
                                ));
                            }
                            result.config_connector_config = map.next_value::<std::option::Option<crate::model::ConfigConnectorConfig>>()?
                                ;
                        }
                        __FieldTag::__gce_persistent_disk_csi_driver_config => {
                            if !fields.insert(__FieldTag::__gce_persistent_disk_csi_driver_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gce_persistent_disk_csi_driver_config",
                                ));
                            }
                            result.gce_persistent_disk_csi_driver_config =
                                map.next_value::<std::option::Option<
                                    crate::model::GcePersistentDiskCsiDriverConfig,
                                >>()?;
                        }
                        __FieldTag::__gcp_filestore_csi_driver_config => {
                            if !fields.insert(__FieldTag::__gcp_filestore_csi_driver_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_filestore_csi_driver_config",
                                ));
                            }
                            result.gcp_filestore_csi_driver_config = map.next_value::<std::option::Option<crate::model::GcpFilestoreCsiDriverConfig>>()?
                                ;
                        }
                        __FieldTag::__gke_backup_agent_config => {
                            if !fields.insert(__FieldTag::__gke_backup_agent_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_backup_agent_config",
                                ));
                            }
                            result.gke_backup_agent_config = map.next_value::<std::option::Option<crate::model::GkeBackupAgentConfig>>()?
                                ;
                        }
                        __FieldTag::__gcs_fuse_csi_driver_config => {
                            if !fields.insert(__FieldTag::__gcs_fuse_csi_driver_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_fuse_csi_driver_config",
                                ));
                            }
                            result.gcs_fuse_csi_driver_config = map.next_value::<std::option::Option<crate::model::GcsFuseCsiDriverConfig>>()?
                                ;
                        }
                        __FieldTag::__stateful_ha_config => {
                            if !fields.insert(__FieldTag::__stateful_ha_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stateful_ha_config",
                                ));
                            }
                            result.stateful_ha_config = map
                                .next_value::<std::option::Option<crate::model::StatefulHAConfig>>(
                                )?;
                        }
                        __FieldTag::__parallelstore_csi_driver_config => {
                            if !fields.insert(__FieldTag::__parallelstore_csi_driver_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parallelstore_csi_driver_config",
                                ));
                            }
                            result.parallelstore_csi_driver_config = map.next_value::<std::option::Option<crate::model::ParallelstoreCsiDriverConfig>>()?
                                ;
                        }
                        __FieldTag::__ray_operator_config => {
                            if !fields.insert(__FieldTag::__ray_operator_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ray_operator_config",
                                ));
                            }
                            result.ray_operator_config = map
                                .next_value::<std::option::Option<crate::model::RayOperatorConfig>>(
                                )?;
                        }
                        __FieldTag::__high_scale_checkpointing_config => {
                            if !fields.insert(__FieldTag::__high_scale_checkpointing_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for high_scale_checkpointing_config",
                                ));
                            }
                            result.high_scale_checkpointing_config = map.next_value::<std::option::Option<crate::model::HighScaleCheckpointingConfig>>()?
                                ;
                        }
                        __FieldTag::__lustre_csi_driver_config => {
                            if !fields.insert(__FieldTag::__lustre_csi_driver_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for lustre_csi_driver_config",
                                ));
                            }
                            result.lustre_csi_driver_config = map.next_value::<std::option::Option<crate::model::LustreCsiDriverConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HttpLoadBalancing {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpLoadBalancing")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HttpLoadBalancing;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpLoadBalancing")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HorizontalPodAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HorizontalPodAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HorizontalPodAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HorizontalPodAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::KubernetesDashboard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for KubernetesDashboard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::KubernetesDashboard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct KubernetesDashboard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NetworkPolicyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkPolicyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NetworkPolicyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkPolicyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DnsCacheConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DnsCacheConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DnsCacheConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DnsCacheConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PrivateClusterMasterGlobalAccessConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for PrivateClusterMasterGlobalAccessConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PrivateClusterMasterGlobalAccessConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateClusterMasterGlobalAccessConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PrivateClusterConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_private_nodes,
            __enable_private_endpoint,
            __master_ipv4_cidr_block,
            __private_endpoint,
            __public_endpoint,
            __peering_name,
            __master_global_access_config,
            __private_endpoint_subnetwork,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivateClusterConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enablePrivateNodes" => Ok(__FieldTag::__enable_private_nodes),
                            "enable_private_nodes" => Ok(__FieldTag::__enable_private_nodes),
                            "enablePrivateEndpoint" => Ok(__FieldTag::__enable_private_endpoint),
                            "enable_private_endpoint" => Ok(__FieldTag::__enable_private_endpoint),
                            "masterIpv4CidrBlock" => Ok(__FieldTag::__master_ipv4_cidr_block),
                            "master_ipv4_cidr_block" => Ok(__FieldTag::__master_ipv4_cidr_block),
                            "privateEndpoint" => Ok(__FieldTag::__private_endpoint),
                            "private_endpoint" => Ok(__FieldTag::__private_endpoint),
                            "publicEndpoint" => Ok(__FieldTag::__public_endpoint),
                            "public_endpoint" => Ok(__FieldTag::__public_endpoint),
                            "peeringName" => Ok(__FieldTag::__peering_name),
                            "peering_name" => Ok(__FieldTag::__peering_name),
                            "masterGlobalAccessConfig" => {
                                Ok(__FieldTag::__master_global_access_config)
                            }
                            "master_global_access_config" => {
                                Ok(__FieldTag::__master_global_access_config)
                            }
                            "privateEndpointSubnetwork" => {
                                Ok(__FieldTag::__private_endpoint_subnetwork)
                            }
                            "private_endpoint_subnetwork" => {
                                Ok(__FieldTag::__private_endpoint_subnetwork)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PrivateClusterConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivateClusterConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_private_nodes => {
                            if !fields.insert(__FieldTag::__enable_private_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_private_nodes",
                                ));
                            }
                            result.enable_private_nodes = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_private_endpoint => {
                            if !fields.insert(__FieldTag::__enable_private_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_private_endpoint",
                                ));
                            }
                            result.enable_private_endpoint = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__master_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__master_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_ipv4_cidr_block",
                                ));
                            }
                            result.master_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_endpoint => {
                            if !fields.insert(__FieldTag::__private_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint",
                                ));
                            }
                            result.private_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_endpoint => {
                            if !fields.insert(__FieldTag::__public_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_endpoint",
                                ));
                            }
                            result.public_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__peering_name => {
                            if !fields.insert(__FieldTag::__peering_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for peering_name",
                                ));
                            }
                            result.peering_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__master_global_access_config => {
                            if !fields.insert(__FieldTag::__master_global_access_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_global_access_config",
                                ));
                            }
                            result.master_global_access_config = map
                                .next_value::<std::option::Option<
                                    crate::model::PrivateClusterMasterGlobalAccessConfig,
                                >>()?;
                        }
                        __FieldTag::__private_endpoint_subnetwork => {
                            if !fields.insert(__FieldTag::__private_endpoint_subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint_subnetwork",
                                ));
                            }
                            result.private_endpoint_subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AuthenticatorGroupsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __security_group,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuthenticatorGroupsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "securityGroup" => Ok(__FieldTag::__security_group),
                            "security_group" => Ok(__FieldTag::__security_group),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AuthenticatorGroupsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuthenticatorGroupsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__security_group => {
                            if !fields.insert(__FieldTag::__security_group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_group",
                                ));
                            }
                            result.security_group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CloudRunConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            __load_balancer_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloudRunConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            "loadBalancerType" => Ok(__FieldTag::__load_balancer_type),
                            "load_balancer_type" => Ok(__FieldTag::__load_balancer_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CloudRunConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloudRunConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__load_balancer_type => {
                            if !fields.insert(__FieldTag::__load_balancer_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for load_balancer_type",
                                ));
                            }
                            result.load_balancer_type = map
                                .next_value::<std::option::Option<
                                    crate::model::cloud_run_config::LoadBalancerType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConfigConnectorConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigConnectorConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConfigConnectorConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigConnectorConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcePersistentDiskCsiDriverConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcePersistentDiskCsiDriverConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcePersistentDiskCsiDriverConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcePersistentDiskCsiDriverConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcpFilestoreCsiDriverConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcpFilestoreCsiDriverConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcpFilestoreCsiDriverConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcpFilestoreCsiDriverConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GcsFuseCsiDriverConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcsFuseCsiDriverConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GcsFuseCsiDriverConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcsFuseCsiDriverConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ParallelstoreCsiDriverConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ParallelstoreCsiDriverConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ParallelstoreCsiDriverConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ParallelstoreCsiDriverConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::HighScaleCheckpointingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HighScaleCheckpointingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::HighScaleCheckpointingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HighScaleCheckpointingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LustreCsiDriverConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __enable_legacy_lustre_port,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LustreCsiDriverConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "enableLegacyLustrePort" => Ok(__FieldTag::__enable_legacy_lustre_port),
                            "enable_legacy_lustre_port" => {
                                Ok(__FieldTag::__enable_legacy_lustre_port)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LustreCsiDriverConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LustreCsiDriverConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_legacy_lustre_port => {
                            if !fields.insert(__FieldTag::__enable_legacy_lustre_port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_legacy_lustre_port",
                                ));
                            }
                            result.enable_legacy_lustre_port = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RayOperatorConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __ray_cluster_logging_config,
            __ray_cluster_monitoring_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RayOperatorConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "rayClusterLoggingConfig" => {
                                Ok(__FieldTag::__ray_cluster_logging_config)
                            }
                            "ray_cluster_logging_config" => {
                                Ok(__FieldTag::__ray_cluster_logging_config)
                            }
                            "rayClusterMonitoringConfig" => {
                                Ok(__FieldTag::__ray_cluster_monitoring_config)
                            }
                            "ray_cluster_monitoring_config" => {
                                Ok(__FieldTag::__ray_cluster_monitoring_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RayOperatorConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RayOperatorConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ray_cluster_logging_config => {
                            if !fields.insert(__FieldTag::__ray_cluster_logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ray_cluster_logging_config",
                                ));
                            }
                            result.ray_cluster_logging_config = map.next_value::<std::option::Option<crate::model::RayClusterLoggingConfig>>()?
                                ;
                        }
                        __FieldTag::__ray_cluster_monitoring_config => {
                            if !fields.insert(__FieldTag::__ray_cluster_monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ray_cluster_monitoring_config",
                                ));
                            }
                            result.ray_cluster_monitoring_config = map.next_value::<std::option::Option<crate::model::RayClusterMonitoringConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GkeBackupAgentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GkeBackupAgentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GkeBackupAgentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GkeBackupAgentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StatefulHAConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StatefulHAConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StatefulHAConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StatefulHAConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MasterAuthorizedNetworksConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __cidr_blocks,
            __gcp_public_cidrs_access_enabled,
            __private_endpoint_enforcement_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MasterAuthorizedNetworksConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "cidrBlocks" => Ok(__FieldTag::__cidr_blocks),
                            "cidr_blocks" => Ok(__FieldTag::__cidr_blocks),
                            "gcpPublicCidrsAccessEnabled" => {
                                Ok(__FieldTag::__gcp_public_cidrs_access_enabled)
                            }
                            "gcp_public_cidrs_access_enabled" => {
                                Ok(__FieldTag::__gcp_public_cidrs_access_enabled)
                            }
                            "privateEndpointEnforcementEnabled" => {
                                Ok(__FieldTag::__private_endpoint_enforcement_enabled)
                            }
                            "private_endpoint_enforcement_enabled" => {
                                Ok(__FieldTag::__private_endpoint_enforcement_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MasterAuthorizedNetworksConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MasterAuthorizedNetworksConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cidr_blocks => {
                            if !fields.insert(__FieldTag::__cidr_blocks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cidr_blocks",
                                ));
                            }
                            result.cidr_blocks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::master_authorized_networks_config::CidrBlock,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gcp_public_cidrs_access_enabled => {
                            if !fields.insert(__FieldTag::__gcp_public_cidrs_access_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_public_cidrs_access_enabled",
                                ));
                            }
                            result.gcp_public_cidrs_access_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__private_endpoint_enforcement_enabled => {
                            if !fields.insert(__FieldTag::__private_endpoint_enforcement_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint_enforcement_enabled",
                                ));
                            }
                            result.private_endpoint_enforcement_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::master_authorized_networks_config::CidrBlock {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __display_name,
            __cidr_block,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CidrBlock")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "cidrBlock" => Ok(__FieldTag::__cidr_block),
                            "cidr_block" => Ok(__FieldTag::__cidr_block),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::master_authorized_networks_config::CidrBlock;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CidrBlock")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cidr_block => {
                            if !fields.insert(__FieldTag::__cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cidr_block",
                                ));
                            }
                            result.cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LegacyAbac {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LegacyAbac")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LegacyAbac;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LegacyAbac")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NetworkPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __provider,
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "provider" => Ok(__FieldTag::__provider),
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NetworkPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__provider => {
                            if !fields.insert(__FieldTag::__provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provider",
                                ));
                            }
                            result.provider = map.next_value::<std::option::Option<crate::model::network_policy::Provider>>()?.unwrap_or_default();
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BinaryAuthorization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __evaluation_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BinaryAuthorization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "evaluationMode" => Ok(__FieldTag::__evaluation_mode),
                            "evaluation_mode" => Ok(__FieldTag::__evaluation_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BinaryAuthorization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BinaryAuthorization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__evaluation_mode => {
                            if !fields.insert(__FieldTag::__evaluation_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for evaluation_mode",
                                ));
                            }
                            result.evaluation_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::binary_authorization::EvaluationMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PodCIDROverprovisionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PodCIDROverprovisionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disable" => Ok(__FieldTag::__disable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PodCIDROverprovisionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PodCIDROverprovisionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disable => {
                            if !fields.insert(__FieldTag::__disable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable",
                                ));
                            }
                            result.disable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::IPAllocationPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __use_ip_aliases,
            __create_subnetwork,
            __subnetwork_name,
            __cluster_ipv4_cidr,
            __node_ipv4_cidr,
            __services_ipv4_cidr,
            __cluster_secondary_range_name,
            __services_secondary_range_name,
            __cluster_ipv4_cidr_block,
            __node_ipv4_cidr_block,
            __services_ipv4_cidr_block,
            __tpu_ipv4_cidr_block,
            __use_routes,
            __stack_type,
            __ipv6_access_type,
            __pod_cidr_overprovision_config,
            __subnet_ipv6_cidr_block,
            __services_ipv6_cidr_block,
            __additional_pod_ranges_config,
            __default_pod_ipv4_range_utilization,
            __additional_ip_ranges_configs,
            __auto_ipam_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IPAllocationPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "useIpAliases" => Ok(__FieldTag::__use_ip_aliases),
                            "use_ip_aliases" => Ok(__FieldTag::__use_ip_aliases),
                            "createSubnetwork" => Ok(__FieldTag::__create_subnetwork),
                            "create_subnetwork" => Ok(__FieldTag::__create_subnetwork),
                            "subnetworkName" => Ok(__FieldTag::__subnetwork_name),
                            "subnetwork_name" => Ok(__FieldTag::__subnetwork_name),
                            "clusterIpv4Cidr" => Ok(__FieldTag::__cluster_ipv4_cidr),
                            "cluster_ipv4_cidr" => Ok(__FieldTag::__cluster_ipv4_cidr),
                            "nodeIpv4Cidr" => Ok(__FieldTag::__node_ipv4_cidr),
                            "node_ipv4_cidr" => Ok(__FieldTag::__node_ipv4_cidr),
                            "servicesIpv4Cidr" => Ok(__FieldTag::__services_ipv4_cidr),
                            "services_ipv4_cidr" => Ok(__FieldTag::__services_ipv4_cidr),
                            "clusterSecondaryRangeName" => {
                                Ok(__FieldTag::__cluster_secondary_range_name)
                            }
                            "cluster_secondary_range_name" => {
                                Ok(__FieldTag::__cluster_secondary_range_name)
                            }
                            "servicesSecondaryRangeName" => {
                                Ok(__FieldTag::__services_secondary_range_name)
                            }
                            "services_secondary_range_name" => {
                                Ok(__FieldTag::__services_secondary_range_name)
                            }
                            "clusterIpv4CidrBlock" => Ok(__FieldTag::__cluster_ipv4_cidr_block),
                            "cluster_ipv4_cidr_block" => Ok(__FieldTag::__cluster_ipv4_cidr_block),
                            "nodeIpv4CidrBlock" => Ok(__FieldTag::__node_ipv4_cidr_block),
                            "node_ipv4_cidr_block" => Ok(__FieldTag::__node_ipv4_cidr_block),
                            "servicesIpv4CidrBlock" => Ok(__FieldTag::__services_ipv4_cidr_block),
                            "services_ipv4_cidr_block" => {
                                Ok(__FieldTag::__services_ipv4_cidr_block)
                            }
                            "tpuIpv4CidrBlock" => Ok(__FieldTag::__tpu_ipv4_cidr_block),
                            "tpu_ipv4_cidr_block" => Ok(__FieldTag::__tpu_ipv4_cidr_block),
                            "useRoutes" => Ok(__FieldTag::__use_routes),
                            "use_routes" => Ok(__FieldTag::__use_routes),
                            "stackType" => Ok(__FieldTag::__stack_type),
                            "stack_type" => Ok(__FieldTag::__stack_type),
                            "ipv6AccessType" => Ok(__FieldTag::__ipv6_access_type),
                            "ipv6_access_type" => Ok(__FieldTag::__ipv6_access_type),
                            "podCidrOverprovisionConfig" => {
                                Ok(__FieldTag::__pod_cidr_overprovision_config)
                            }
                            "pod_cidr_overprovision_config" => {
                                Ok(__FieldTag::__pod_cidr_overprovision_config)
                            }
                            "subnetIpv6CidrBlock" => Ok(__FieldTag::__subnet_ipv6_cidr_block),
                            "subnet_ipv6_cidr_block" => Ok(__FieldTag::__subnet_ipv6_cidr_block),
                            "servicesIpv6CidrBlock" => Ok(__FieldTag::__services_ipv6_cidr_block),
                            "services_ipv6_cidr_block" => {
                                Ok(__FieldTag::__services_ipv6_cidr_block)
                            }
                            "additionalPodRangesConfig" => {
                                Ok(__FieldTag::__additional_pod_ranges_config)
                            }
                            "additional_pod_ranges_config" => {
                                Ok(__FieldTag::__additional_pod_ranges_config)
                            }
                            "defaultPodIpv4RangeUtilization" => {
                                Ok(__FieldTag::__default_pod_ipv4_range_utilization)
                            }
                            "default_pod_ipv4_range_utilization" => {
                                Ok(__FieldTag::__default_pod_ipv4_range_utilization)
                            }
                            "additionalIpRangesConfigs" => {
                                Ok(__FieldTag::__additional_ip_ranges_configs)
                            }
                            "additional_ip_ranges_configs" => {
                                Ok(__FieldTag::__additional_ip_ranges_configs)
                            }
                            "autoIpamConfig" => Ok(__FieldTag::__auto_ipam_config),
                            "auto_ipam_config" => Ok(__FieldTag::__auto_ipam_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::IPAllocationPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IPAllocationPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__use_ip_aliases => {
                            if !fields.insert(__FieldTag::__use_ip_aliases) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_ip_aliases",
                                ));
                            }
                            result.use_ip_aliases = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_subnetwork => {
                            if !fields.insert(__FieldTag::__create_subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_subnetwork",
                                ));
                            }
                            result.create_subnetwork = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork_name => {
                            if !fields.insert(__FieldTag::__subnetwork_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork_name",
                                ));
                            }
                            result.subnetwork_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_ipv4_cidr => {
                            if !fields.insert(__FieldTag::__cluster_ipv4_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ipv4_cidr",
                                ));
                            }
                            result.cluster_ipv4_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_ipv4_cidr => {
                            if !fields.insert(__FieldTag::__node_ipv4_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_ipv4_cidr",
                                ));
                            }
                            result.node_ipv4_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__services_ipv4_cidr => {
                            if !fields.insert(__FieldTag::__services_ipv4_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_ipv4_cidr",
                                ));
                            }
                            result.services_ipv4_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_secondary_range_name => {
                            if !fields.insert(__FieldTag::__cluster_secondary_range_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_secondary_range_name",
                                ));
                            }
                            result.cluster_secondary_range_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__services_secondary_range_name => {
                            if !fields.insert(__FieldTag::__services_secondary_range_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_secondary_range_name",
                                ));
                            }
                            result.services_secondary_range_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__cluster_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ipv4_cidr_block",
                                ));
                            }
                            result.cluster_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__node_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_ipv4_cidr_block",
                                ));
                            }
                            result.node_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__services_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__services_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_ipv4_cidr_block",
                                ));
                            }
                            result.services_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tpu_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__tpu_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tpu_ipv4_cidr_block",
                                ));
                            }
                            result.tpu_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use_routes => {
                            if !fields.insert(__FieldTag::__use_routes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use_routes",
                                ));
                            }
                            result.use_routes = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stack_type => {
                            if !fields.insert(__FieldTag::__stack_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stack_type",
                                ));
                            }
                            result.stack_type = map
                                .next_value::<std::option::Option<crate::model::StackType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ipv6_access_type => {
                            if !fields.insert(__FieldTag::__ipv6_access_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ipv6_access_type",
                                ));
                            }
                            result.ipv6_access_type = map
                                .next_value::<std::option::Option<crate::model::IPv6AccessType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_cidr_overprovision_config => {
                            if !fields.insert(__FieldTag::__pod_cidr_overprovision_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_cidr_overprovision_config",
                                ));
                            }
                            result.pod_cidr_overprovision_config = map.next_value::<std::option::Option<crate::model::PodCIDROverprovisionConfig>>()?
                                ;
                        }
                        __FieldTag::__subnet_ipv6_cidr_block => {
                            if !fields.insert(__FieldTag::__subnet_ipv6_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet_ipv6_cidr_block",
                                ));
                            }
                            result.subnet_ipv6_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__services_ipv6_cidr_block => {
                            if !fields.insert(__FieldTag::__services_ipv6_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_ipv6_cidr_block",
                                ));
                            }
                            result.services_ipv6_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_pod_ranges_config => {
                            if !fields.insert(__FieldTag::__additional_pod_ranges_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_pod_ranges_config",
                                ));
                            }
                            result.additional_pod_ranges_config = map.next_value::<std::option::Option<crate::model::AdditionalPodRangesConfig>>()?
                                ;
                        }
                        __FieldTag::__default_pod_ipv4_range_utilization => {
                            if !fields.insert(__FieldTag::__default_pod_ipv4_range_utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_pod_ipv4_range_utilization",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.default_pod_ipv4_range_utilization =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__additional_ip_ranges_configs => {
                            if !fields.insert(__FieldTag::__additional_ip_ranges_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_ip_ranges_configs",
                                ));
                            }
                            result.additional_ip_ranges_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdditionalIPRangesConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_ipam_config => {
                            if !fields.insert(__FieldTag::__auto_ipam_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_ipam_config",
                                ));
                            }
                            result.auto_ipam_config = map
                                .next_value::<std::option::Option<crate::model::AutoIpamConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Cluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __description,
            __initial_node_count,
            __node_config,
            __master_auth,
            __logging_service,
            __monitoring_service,
            __network,
            __cluster_ipv4_cidr,
            __addons_config,
            __subnetwork,
            __node_pools,
            __locations,
            __enable_kubernetes_alpha,
            __alpha_cluster_feature_gates,
            __resource_labels,
            __label_fingerprint,
            __legacy_abac,
            __network_policy,
            __ip_allocation_policy,
            __master_authorized_networks_config,
            __maintenance_policy,
            __binary_authorization,
            __autoscaling,
            __network_config,
            __default_max_pods_constraint,
            __resource_usage_export_config,
            __authenticator_groups_config,
            __private_cluster_config,
            __database_encryption,
            __vertical_pod_autoscaling,
            __shielded_nodes,
            __release_channel,
            __workload_identity_config,
            __mesh_certificates,
            __cost_management_config,
            __notification_config,
            __confidential_nodes,
            __identity_service_config,
            __self_link,
            __zone,
            __endpoint,
            __initial_cluster_version,
            __current_master_version,
            __current_node_version,
            __create_time,
            __status,
            __status_message,
            __node_ipv4_cidr_size,
            __services_ipv4_cidr,
            __instance_group_urls,
            __current_node_count,
            __expire_time,
            __location,
            __enable_tpu,
            __tpu_ipv4_cidr_block,
            __conditions,
            __autopilot,
            __id,
            __node_pool_defaults,
            __logging_config,
            __monitoring_config,
            __node_pool_auto_config,
            __pod_autoscaling,
            __etag,
            __fleet,
            __security_posture_config,
            __control_plane_endpoints_config,
            __enable_k8s_beta_apis,
            __enterprise_config,
            __secret_manager_config,
            __compliance_posture_config,
            __satisfies_pzs,
            __satisfies_pzi,
            __user_managed_keys_config,
            __rbac_binding_config,
            __gke_auto_upgrade_config,
            __anonymous_authentication_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "description" => Ok(__FieldTag::__description),
                            "initialNodeCount" => Ok(__FieldTag::__initial_node_count),
                            "initial_node_count" => Ok(__FieldTag::__initial_node_count),
                            "nodeConfig" => Ok(__FieldTag::__node_config),
                            "node_config" => Ok(__FieldTag::__node_config),
                            "masterAuth" => Ok(__FieldTag::__master_auth),
                            "master_auth" => Ok(__FieldTag::__master_auth),
                            "loggingService" => Ok(__FieldTag::__logging_service),
                            "logging_service" => Ok(__FieldTag::__logging_service),
                            "monitoringService" => Ok(__FieldTag::__monitoring_service),
                            "monitoring_service" => Ok(__FieldTag::__monitoring_service),
                            "network" => Ok(__FieldTag::__network),
                            "clusterIpv4Cidr" => Ok(__FieldTag::__cluster_ipv4_cidr),
                            "cluster_ipv4_cidr" => Ok(__FieldTag::__cluster_ipv4_cidr),
                            "addonsConfig" => Ok(__FieldTag::__addons_config),
                            "addons_config" => Ok(__FieldTag::__addons_config),
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "nodePools" => Ok(__FieldTag::__node_pools),
                            "node_pools" => Ok(__FieldTag::__node_pools),
                            "locations" => Ok(__FieldTag::__locations),
                            "enableKubernetesAlpha" => Ok(__FieldTag::__enable_kubernetes_alpha),
                            "enable_kubernetes_alpha" => Ok(__FieldTag::__enable_kubernetes_alpha),
                            "alphaClusterFeatureGates" => {
                                Ok(__FieldTag::__alpha_cluster_feature_gates)
                            }
                            "alpha_cluster_feature_gates" => {
                                Ok(__FieldTag::__alpha_cluster_feature_gates)
                            }
                            "resourceLabels" => Ok(__FieldTag::__resource_labels),
                            "resource_labels" => Ok(__FieldTag::__resource_labels),
                            "labelFingerprint" => Ok(__FieldTag::__label_fingerprint),
                            "label_fingerprint" => Ok(__FieldTag::__label_fingerprint),
                            "legacyAbac" => Ok(__FieldTag::__legacy_abac),
                            "legacy_abac" => Ok(__FieldTag::__legacy_abac),
                            "networkPolicy" => Ok(__FieldTag::__network_policy),
                            "network_policy" => Ok(__FieldTag::__network_policy),
                            "ipAllocationPolicy" => Ok(__FieldTag::__ip_allocation_policy),
                            "ip_allocation_policy" => Ok(__FieldTag::__ip_allocation_policy),
                            "masterAuthorizedNetworksConfig" => {
                                Ok(__FieldTag::__master_authorized_networks_config)
                            }
                            "master_authorized_networks_config" => {
                                Ok(__FieldTag::__master_authorized_networks_config)
                            }
                            "maintenancePolicy" => Ok(__FieldTag::__maintenance_policy),
                            "maintenance_policy" => Ok(__FieldTag::__maintenance_policy),
                            "binaryAuthorization" => Ok(__FieldTag::__binary_authorization),
                            "binary_authorization" => Ok(__FieldTag::__binary_authorization),
                            "autoscaling" => Ok(__FieldTag::__autoscaling),
                            "networkConfig" => Ok(__FieldTag::__network_config),
                            "network_config" => Ok(__FieldTag::__network_config),
                            "defaultMaxPodsConstraint" => {
                                Ok(__FieldTag::__default_max_pods_constraint)
                            }
                            "default_max_pods_constraint" => {
                                Ok(__FieldTag::__default_max_pods_constraint)
                            }
                            "resourceUsageExportConfig" => {
                                Ok(__FieldTag::__resource_usage_export_config)
                            }
                            "resource_usage_export_config" => {
                                Ok(__FieldTag::__resource_usage_export_config)
                            }
                            "authenticatorGroupsConfig" => {
                                Ok(__FieldTag::__authenticator_groups_config)
                            }
                            "authenticator_groups_config" => {
                                Ok(__FieldTag::__authenticator_groups_config)
                            }
                            "privateClusterConfig" => Ok(__FieldTag::__private_cluster_config),
                            "private_cluster_config" => Ok(__FieldTag::__private_cluster_config),
                            "databaseEncryption" => Ok(__FieldTag::__database_encryption),
                            "database_encryption" => Ok(__FieldTag::__database_encryption),
                            "verticalPodAutoscaling" => Ok(__FieldTag::__vertical_pod_autoscaling),
                            "vertical_pod_autoscaling" => {
                                Ok(__FieldTag::__vertical_pod_autoscaling)
                            }
                            "shieldedNodes" => Ok(__FieldTag::__shielded_nodes),
                            "shielded_nodes" => Ok(__FieldTag::__shielded_nodes),
                            "releaseChannel" => Ok(__FieldTag::__release_channel),
                            "release_channel" => Ok(__FieldTag::__release_channel),
                            "workloadIdentityConfig" => Ok(__FieldTag::__workload_identity_config),
                            "workload_identity_config" => {
                                Ok(__FieldTag::__workload_identity_config)
                            }
                            "meshCertificates" => Ok(__FieldTag::__mesh_certificates),
                            "mesh_certificates" => Ok(__FieldTag::__mesh_certificates),
                            "costManagementConfig" => Ok(__FieldTag::__cost_management_config),
                            "cost_management_config" => Ok(__FieldTag::__cost_management_config),
                            "notificationConfig" => Ok(__FieldTag::__notification_config),
                            "notification_config" => Ok(__FieldTag::__notification_config),
                            "confidentialNodes" => Ok(__FieldTag::__confidential_nodes),
                            "confidential_nodes" => Ok(__FieldTag::__confidential_nodes),
                            "identityServiceConfig" => Ok(__FieldTag::__identity_service_config),
                            "identity_service_config" => Ok(__FieldTag::__identity_service_config),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "zone" => Ok(__FieldTag::__zone),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "initialClusterVersion" => Ok(__FieldTag::__initial_cluster_version),
                            "initial_cluster_version" => Ok(__FieldTag::__initial_cluster_version),
                            "currentMasterVersion" => Ok(__FieldTag::__current_master_version),
                            "current_master_version" => Ok(__FieldTag::__current_master_version),
                            "currentNodeVersion" => Ok(__FieldTag::__current_node_version),
                            "current_node_version" => Ok(__FieldTag::__current_node_version),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "status" => Ok(__FieldTag::__status),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "nodeIpv4CidrSize" => Ok(__FieldTag::__node_ipv4_cidr_size),
                            "node_ipv4_cidr_size" => Ok(__FieldTag::__node_ipv4_cidr_size),
                            "servicesIpv4Cidr" => Ok(__FieldTag::__services_ipv4_cidr),
                            "services_ipv4_cidr" => Ok(__FieldTag::__services_ipv4_cidr),
                            "instanceGroupUrls" => Ok(__FieldTag::__instance_group_urls),
                            "instance_group_urls" => Ok(__FieldTag::__instance_group_urls),
                            "currentNodeCount" => Ok(__FieldTag::__current_node_count),
                            "current_node_count" => Ok(__FieldTag::__current_node_count),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "location" => Ok(__FieldTag::__location),
                            "enableTpu" => Ok(__FieldTag::__enable_tpu),
                            "enable_tpu" => Ok(__FieldTag::__enable_tpu),
                            "tpuIpv4CidrBlock" => Ok(__FieldTag::__tpu_ipv4_cidr_block),
                            "tpu_ipv4_cidr_block" => Ok(__FieldTag::__tpu_ipv4_cidr_block),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "autopilot" => Ok(__FieldTag::__autopilot),
                            "id" => Ok(__FieldTag::__id),
                            "nodePoolDefaults" => Ok(__FieldTag::__node_pool_defaults),
                            "node_pool_defaults" => Ok(__FieldTag::__node_pool_defaults),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "monitoringConfig" => Ok(__FieldTag::__monitoring_config),
                            "monitoring_config" => Ok(__FieldTag::__monitoring_config),
                            "nodePoolAutoConfig" => Ok(__FieldTag::__node_pool_auto_config),
                            "node_pool_auto_config" => Ok(__FieldTag::__node_pool_auto_config),
                            "podAutoscaling" => Ok(__FieldTag::__pod_autoscaling),
                            "pod_autoscaling" => Ok(__FieldTag::__pod_autoscaling),
                            "etag" => Ok(__FieldTag::__etag),
                            "fleet" => Ok(__FieldTag::__fleet),
                            "securityPostureConfig" => Ok(__FieldTag::__security_posture_config),
                            "security_posture_config" => Ok(__FieldTag::__security_posture_config),
                            "controlPlaneEndpointsConfig" => {
                                Ok(__FieldTag::__control_plane_endpoints_config)
                            }
                            "control_plane_endpoints_config" => {
                                Ok(__FieldTag::__control_plane_endpoints_config)
                            }
                            "enableK8sBetaApis" => Ok(__FieldTag::__enable_k8s_beta_apis),
                            "enable_k8s_beta_apis" => Ok(__FieldTag::__enable_k8s_beta_apis),
                            "enterpriseConfig" => Ok(__FieldTag::__enterprise_config),
                            "enterprise_config" => Ok(__FieldTag::__enterprise_config),
                            "secretManagerConfig" => Ok(__FieldTag::__secret_manager_config),
                            "secret_manager_config" => Ok(__FieldTag::__secret_manager_config),
                            "compliancePostureConfig" => {
                                Ok(__FieldTag::__compliance_posture_config)
                            }
                            "compliance_posture_config" => {
                                Ok(__FieldTag::__compliance_posture_config)
                            }
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            "userManagedKeysConfig" => Ok(__FieldTag::__user_managed_keys_config),
                            "user_managed_keys_config" => {
                                Ok(__FieldTag::__user_managed_keys_config)
                            }
                            "rbacBindingConfig" => Ok(__FieldTag::__rbac_binding_config),
                            "rbac_binding_config" => Ok(__FieldTag::__rbac_binding_config),
                            "gkeAutoUpgradeConfig" => Ok(__FieldTag::__gke_auto_upgrade_config),
                            "gke_auto_upgrade_config" => Ok(__FieldTag::__gke_auto_upgrade_config),
                            "anonymousAuthenticationConfig" => {
                                Ok(__FieldTag::__anonymous_authentication_config)
                            }
                            "anonymous_authentication_config" => {
                                Ok(__FieldTag::__anonymous_authentication_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Cluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__initial_node_count => {
                            if !fields.insert(__FieldTag::__initial_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initial_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__node_config => {
                            if !fields.insert(__FieldTag::__node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_config",
                                ));
                            }
                            result.node_config =
                                map.next_value::<std::option::Option<crate::model::NodeConfig>>()?;
                        }
                        __FieldTag::__master_auth => {
                            if !fields.insert(__FieldTag::__master_auth) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_auth",
                                ));
                            }
                            result.master_auth =
                                map.next_value::<std::option::Option<crate::model::MasterAuth>>()?;
                        }
                        __FieldTag::__logging_service => {
                            if !fields.insert(__FieldTag::__logging_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_service",
                                ));
                            }
                            result.logging_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monitoring_service => {
                            if !fields.insert(__FieldTag::__monitoring_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitoring_service",
                                ));
                            }
                            result.monitoring_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_ipv4_cidr => {
                            if !fields.insert(__FieldTag::__cluster_ipv4_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ipv4_cidr",
                                ));
                            }
                            result.cluster_ipv4_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__addons_config => {
                            if !fields.insert(__FieldTag::__addons_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for addons_config",
                                ));
                            }
                            result.addons_config = map
                                .next_value::<std::option::Option<crate::model::AddonsConfig>>()?;
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pools => {
                            if !fields.insert(__FieldTag::__node_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pools",
                                ));
                            }
                            result.node_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NodePool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__enable_kubernetes_alpha => {
                            if !fields.insert(__FieldTag::__enable_kubernetes_alpha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_kubernetes_alpha",
                                ));
                            }
                            result.enable_kubernetes_alpha = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__alpha_cluster_feature_gates => {
                            if !fields.insert(__FieldTag::__alpha_cluster_feature_gates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alpha_cluster_feature_gates",
                                ));
                            }
                            result.alpha_cluster_feature_gates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__resource_labels => {
                            if !fields.insert(__FieldTag::__resource_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_labels",
                                ));
                            }
                            result.resource_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__label_fingerprint => {
                            if !fields.insert(__FieldTag::__label_fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_fingerprint",
                                ));
                            }
                            result.label_fingerprint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__legacy_abac => {
                            if !fields.insert(__FieldTag::__legacy_abac) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for legacy_abac",
                                ));
                            }
                            result.legacy_abac =
                                map.next_value::<std::option::Option<crate::model::LegacyAbac>>()?;
                        }
                        __FieldTag::__network_policy => {
                            if !fields.insert(__FieldTag::__network_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_policy",
                                ));
                            }
                            result.network_policy = map
                                .next_value::<std::option::Option<crate::model::NetworkPolicy>>()?;
                        }
                        __FieldTag::__ip_allocation_policy => {
                            if !fields.insert(__FieldTag::__ip_allocation_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_allocation_policy",
                                ));
                            }
                            result.ip_allocation_policy = map.next_value::<std::option::Option<crate::model::IPAllocationPolicy>>()?
                                ;
                        }
                        __FieldTag::__master_authorized_networks_config => {
                            if !fields.insert(__FieldTag::__master_authorized_networks_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_authorized_networks_config",
                                ));
                            }
                            result.master_authorized_networks_config =
                                map.next_value::<std::option::Option<
                                    crate::model::MasterAuthorizedNetworksConfig,
                                >>()?;
                        }
                        __FieldTag::__maintenance_policy => {
                            if !fields.insert(__FieldTag::__maintenance_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_policy",
                                ));
                            }
                            result.maintenance_policy = map
                                .next_value::<std::option::Option<crate::model::MaintenancePolicy>>(
                                )?;
                        }
                        __FieldTag::__binary_authorization => {
                            if !fields.insert(__FieldTag::__binary_authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binary_authorization",
                                ));
                            }
                            result.binary_authorization = map.next_value::<std::option::Option<crate::model::BinaryAuthorization>>()?
                                ;
                        }
                        __FieldTag::__autoscaling => {
                            if !fields.insert(__FieldTag::__autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling",
                                ));
                            }
                            result.autoscaling = map.next_value::<std::option::Option<crate::model::ClusterAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__network_config => {
                            if !fields.insert(__FieldTag::__network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_config",
                                ));
                            }
                            result.network_config = map
                                .next_value::<std::option::Option<crate::model::NetworkConfig>>()?;
                        }
                        __FieldTag::__default_max_pods_constraint => {
                            if !fields.insert(__FieldTag::__default_max_pods_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_max_pods_constraint",
                                ));
                            }
                            result.default_max_pods_constraint = map
                                .next_value::<std::option::Option<crate::model::MaxPodsConstraint>>(
                                )?;
                        }
                        __FieldTag::__resource_usage_export_config => {
                            if !fields.insert(__FieldTag::__resource_usage_export_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_usage_export_config",
                                ));
                            }
                            result.resource_usage_export_config = map.next_value::<std::option::Option<crate::model::ResourceUsageExportConfig>>()?
                                ;
                        }
                        __FieldTag::__authenticator_groups_config => {
                            if !fields.insert(__FieldTag::__authenticator_groups_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authenticator_groups_config",
                                ));
                            }
                            result.authenticator_groups_config = map.next_value::<std::option::Option<crate::model::AuthenticatorGroupsConfig>>()?
                                ;
                        }
                        __FieldTag::__private_cluster_config => {
                            if !fields.insert(__FieldTag::__private_cluster_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_cluster_config",
                                ));
                            }
                            result.private_cluster_config = map.next_value::<std::option::Option<crate::model::PrivateClusterConfig>>()?
                                ;
                        }
                        __FieldTag::__database_encryption => {
                            if !fields.insert(__FieldTag::__database_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_encryption",
                                ));
                            }
                            result.database_encryption = map.next_value::<std::option::Option<crate::model::DatabaseEncryption>>()?
                                ;
                        }
                        __FieldTag::__vertical_pod_autoscaling => {
                            if !fields.insert(__FieldTag::__vertical_pod_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vertical_pod_autoscaling",
                                ));
                            }
                            result.vertical_pod_autoscaling = map.next_value::<std::option::Option<crate::model::VerticalPodAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__shielded_nodes => {
                            if !fields.insert(__FieldTag::__shielded_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shielded_nodes",
                                ));
                            }
                            result.shielded_nodes = map
                                .next_value::<std::option::Option<crate::model::ShieldedNodes>>()?;
                        }
                        __FieldTag::__release_channel => {
                            if !fields.insert(__FieldTag::__release_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_channel",
                                ));
                            }
                            result.release_channel = map
                                .next_value::<std::option::Option<crate::model::ReleaseChannel>>(
                                )?;
                        }
                        __FieldTag::__workload_identity_config => {
                            if !fields.insert(__FieldTag::__workload_identity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_identity_config",
                                ));
                            }
                            result.workload_identity_config = map.next_value::<std::option::Option<crate::model::WorkloadIdentityConfig>>()?
                                ;
                        }
                        __FieldTag::__mesh_certificates => {
                            if !fields.insert(__FieldTag::__mesh_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mesh_certificates",
                                ));
                            }
                            result.mesh_certificates = map
                                .next_value::<std::option::Option<crate::model::MeshCertificates>>(
                                )?;
                        }
                        __FieldTag::__cost_management_config => {
                            if !fields.insert(__FieldTag::__cost_management_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cost_management_config",
                                ));
                            }
                            result.cost_management_config = map.next_value::<std::option::Option<crate::model::CostManagementConfig>>()?
                                ;
                        }
                        __FieldTag::__notification_config => {
                            if !fields.insert(__FieldTag::__notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notification_config",
                                ));
                            }
                            result.notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__confidential_nodes => {
                            if !fields.insert(__FieldTag::__confidential_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidential_nodes",
                                ));
                            }
                            result.confidential_nodes = map
                                .next_value::<std::option::Option<crate::model::ConfidentialNodes>>(
                                )?;
                        }
                        __FieldTag::__identity_service_config => {
                            if !fields.insert(__FieldTag::__identity_service_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for identity_service_config",
                                ));
                            }
                            result.identity_service_config = map.next_value::<std::option::Option<crate::model::IdentityServiceConfig>>()?
                                ;
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__initial_cluster_version => {
                            if !fields.insert(__FieldTag::__initial_cluster_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_cluster_version",
                                ));
                            }
                            result.initial_cluster_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__current_master_version => {
                            if !fields.insert(__FieldTag::__current_master_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_master_version",
                                ));
                            }
                            result.current_master_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__current_node_version => {
                            if !fields.insert(__FieldTag::__current_node_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_node_version",
                                ));
                            }
                            result.current_node_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::cluster::Status>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_ipv4_cidr_size => {
                            if !fields.insert(__FieldTag::__node_ipv4_cidr_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_ipv4_cidr_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.node_ipv4_cidr_size =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__services_ipv4_cidr => {
                            if !fields.insert(__FieldTag::__services_ipv4_cidr) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_ipv4_cidr",
                                ));
                            }
                            result.services_ipv4_cidr = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_group_urls => {
                            if !fields.insert(__FieldTag::__instance_group_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_group_urls",
                                ));
                            }
                            result.instance_group_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__current_node_count => {
                            if !fields.insert(__FieldTag::__current_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.current_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_tpu => {
                            if !fields.insert(__FieldTag::__enable_tpu) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_tpu",
                                ));
                            }
                            result.enable_tpu = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tpu_ipv4_cidr_block => {
                            if !fields.insert(__FieldTag::__tpu_ipv4_cidr_block) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tpu_ipv4_cidr_block",
                                ));
                            }
                            result.tpu_ipv4_cidr_block = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StatusCondition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autopilot => {
                            if !fields.insert(__FieldTag::__autopilot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autopilot",
                                ));
                            }
                            result.autopilot =
                                map.next_value::<std::option::Option<crate::model::Autopilot>>()?;
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_defaults => {
                            if !fields.insert(__FieldTag::__node_pool_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_defaults",
                                ));
                            }
                            result.node_pool_defaults = map
                                .next_value::<std::option::Option<crate::model::NodePoolDefaults>>(
                                )?;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__monitoring_config => {
                            if !fields.insert(__FieldTag::__monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitoring_config",
                                ));
                            }
                            result.monitoring_config = map
                                .next_value::<std::option::Option<crate::model::MonitoringConfig>>(
                                )?;
                        }
                        __FieldTag::__node_pool_auto_config => {
                            if !fields.insert(__FieldTag::__node_pool_auto_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_auto_config",
                                ));
                            }
                            result.node_pool_auto_config = map.next_value::<std::option::Option<crate::model::NodePoolAutoConfig>>()?
                                ;
                        }
                        __FieldTag::__pod_autoscaling => {
                            if !fields.insert(__FieldTag::__pod_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_autoscaling",
                                ));
                            }
                            result.pod_autoscaling = map
                                .next_value::<std::option::Option<crate::model::PodAutoscaling>>(
                                )?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fleet => {
                            if !fields.insert(__FieldTag::__fleet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fleet",
                                ));
                            }
                            result.fleet =
                                map.next_value::<std::option::Option<crate::model::Fleet>>()?;
                        }
                        __FieldTag::__security_posture_config => {
                            if !fields.insert(__FieldTag::__security_posture_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_posture_config",
                                ));
                            }
                            result.security_posture_config = map.next_value::<std::option::Option<crate::model::SecurityPostureConfig>>()?
                                ;
                        }
                        __FieldTag::__control_plane_endpoints_config => {
                            if !fields.insert(__FieldTag::__control_plane_endpoints_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane_endpoints_config",
                                ));
                            }
                            result.control_plane_endpoints_config = map.next_value::<std::option::Option<crate::model::ControlPlaneEndpointsConfig>>()?
                                ;
                        }
                        __FieldTag::__enable_k8s_beta_apis => {
                            if !fields.insert(__FieldTag::__enable_k8s_beta_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_k8s_beta_apis",
                                ));
                            }
                            result.enable_k8s_beta_apis = map
                                .next_value::<std::option::Option<crate::model::K8sBetaAPIConfig>>(
                                )?;
                        }
                        __FieldTag::__enterprise_config => {
                            if !fields.insert(__FieldTag::__enterprise_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enterprise_config",
                                ));
                            }
                            result.enterprise_config = map
                                .next_value::<std::option::Option<crate::model::EnterpriseConfig>>(
                                )?;
                        }
                        __FieldTag::__secret_manager_config => {
                            if !fields.insert(__FieldTag::__secret_manager_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secret_manager_config",
                                ));
                            }
                            result.secret_manager_config = map.next_value::<std::option::Option<crate::model::SecretManagerConfig>>()?
                                ;
                        }
                        __FieldTag::__compliance_posture_config => {
                            if !fields.insert(__FieldTag::__compliance_posture_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance_posture_config",
                                ));
                            }
                            result.compliance_posture_config = map.next_value::<std::option::Option<crate::model::CompliancePostureConfig>>()?
                                ;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__user_managed_keys_config => {
                            if !fields.insert(__FieldTag::__user_managed_keys_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_managed_keys_config",
                                ));
                            }
                            result.user_managed_keys_config = map.next_value::<std::option::Option<crate::model::UserManagedKeysConfig>>()?
                                ;
                        }
                        __FieldTag::__rbac_binding_config => {
                            if !fields.insert(__FieldTag::__rbac_binding_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rbac_binding_config",
                                ));
                            }
                            result.rbac_binding_config = map
                                .next_value::<std::option::Option<crate::model::RBACBindingConfig>>(
                                )?;
                        }
                        __FieldTag::__gke_auto_upgrade_config => {
                            if !fields.insert(__FieldTag::__gke_auto_upgrade_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_auto_upgrade_config",
                                ));
                            }
                            result.gke_auto_upgrade_config = map.next_value::<std::option::Option<crate::model::GkeAutoUpgradeConfig>>()?
                                ;
                        }
                        __FieldTag::__anonymous_authentication_config => {
                            if !fields.insert(__FieldTag::__anonymous_authentication_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for anonymous_authentication_config",
                                ));
                            }
                            result.anonymous_authentication_config =
                                map.next_value::<std::option::Option<
                                    crate::model::AnonymousAuthenticationConfig,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RBACBindingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_insecure_binding_system_unauthenticated,
            __enable_insecure_binding_system_authenticated,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RBACBindingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableInsecureBindingSystemUnauthenticated" => {
                                Ok(__FieldTag::__enable_insecure_binding_system_unauthenticated)
                            }
                            "enable_insecure_binding_system_unauthenticated" => {
                                Ok(__FieldTag::__enable_insecure_binding_system_unauthenticated)
                            }
                            "enableInsecureBindingSystemAuthenticated" => {
                                Ok(__FieldTag::__enable_insecure_binding_system_authenticated)
                            }
                            "enable_insecure_binding_system_authenticated" => {
                                Ok(__FieldTag::__enable_insecure_binding_system_authenticated)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RBACBindingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RBACBindingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_insecure_binding_system_unauthenticated => {
                            if !fields.insert(
                                __FieldTag::__enable_insecure_binding_system_unauthenticated,
                            ) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_insecure_binding_system_unauthenticated",
                                ));
                            }
                            result.enable_insecure_binding_system_unauthenticated =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__enable_insecure_binding_system_authenticated => {
                            if !fields
                                .insert(__FieldTag::__enable_insecure_binding_system_authenticated)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_insecure_binding_system_authenticated",
                                ));
                            }
                            result.enable_insecure_binding_system_authenticated =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UserManagedKeysConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_ca,
            __etcd_api_ca,
            __etcd_peer_ca,
            __service_account_signing_keys,
            __service_account_verification_keys,
            __aggregation_ca,
            __control_plane_disk_encryption_key,
            __gkeops_etcd_backup_encryption_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UserManagedKeysConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterCa" => Ok(__FieldTag::__cluster_ca),
                            "cluster_ca" => Ok(__FieldTag::__cluster_ca),
                            "etcdApiCa" => Ok(__FieldTag::__etcd_api_ca),
                            "etcd_api_ca" => Ok(__FieldTag::__etcd_api_ca),
                            "etcdPeerCa" => Ok(__FieldTag::__etcd_peer_ca),
                            "etcd_peer_ca" => Ok(__FieldTag::__etcd_peer_ca),
                            "serviceAccountSigningKeys" => {
                                Ok(__FieldTag::__service_account_signing_keys)
                            }
                            "service_account_signing_keys" => {
                                Ok(__FieldTag::__service_account_signing_keys)
                            }
                            "serviceAccountVerificationKeys" => {
                                Ok(__FieldTag::__service_account_verification_keys)
                            }
                            "service_account_verification_keys" => {
                                Ok(__FieldTag::__service_account_verification_keys)
                            }
                            "aggregationCa" => Ok(__FieldTag::__aggregation_ca),
                            "aggregation_ca" => Ok(__FieldTag::__aggregation_ca),
                            "controlPlaneDiskEncryptionKey" => {
                                Ok(__FieldTag::__control_plane_disk_encryption_key)
                            }
                            "control_plane_disk_encryption_key" => {
                                Ok(__FieldTag::__control_plane_disk_encryption_key)
                            }
                            "gkeopsEtcdBackupEncryptionKey" => {
                                Ok(__FieldTag::__gkeops_etcd_backup_encryption_key)
                            }
                            "gkeops_etcd_backup_encryption_key" => {
                                Ok(__FieldTag::__gkeops_etcd_backup_encryption_key)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UserManagedKeysConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UserManagedKeysConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_ca => {
                            if !fields.insert(__FieldTag::__cluster_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ca",
                                ));
                            }
                            result.cluster_ca = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etcd_api_ca => {
                            if !fields.insert(__FieldTag::__etcd_api_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etcd_api_ca",
                                ));
                            }
                            result.etcd_api_ca = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etcd_peer_ca => {
                            if !fields.insert(__FieldTag::__etcd_peer_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etcd_peer_ca",
                                ));
                            }
                            result.etcd_peer_ca = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account_signing_keys => {
                            if !fields.insert(__FieldTag::__service_account_signing_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_signing_keys",
                                ));
                            }
                            result.service_account_signing_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_account_verification_keys => {
                            if !fields.insert(__FieldTag::__service_account_verification_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account_verification_keys",
                                ));
                            }
                            result.service_account_verification_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__aggregation_ca => {
                            if !fields.insert(__FieldTag::__aggregation_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregation_ca",
                                ));
                            }
                            result.aggregation_ca = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_plane_disk_encryption_key => {
                            if !fields.insert(__FieldTag::__control_plane_disk_encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane_disk_encryption_key",
                                ));
                            }
                            result.control_plane_disk_encryption_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gkeops_etcd_backup_encryption_key => {
                            if !fields.insert(__FieldTag::__gkeops_etcd_backup_encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gkeops_etcd_backup_encryption_key",
                                ));
                            }
                            result.gkeops_etcd_backup_encryption_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AnonymousAuthenticationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AnonymousAuthenticationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AnonymousAuthenticationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AnonymousAuthenticationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<
                                    crate::model::anonymous_authentication_config::Mode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CompliancePostureConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __compliance_standards,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompliancePostureConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "complianceStandards" => Ok(__FieldTag::__compliance_standards),
                            "compliance_standards" => Ok(__FieldTag::__compliance_standards),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CompliancePostureConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompliancePostureConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<
                                crate::model::compliance_posture_config::Mode,
                            >>()?;
                        }
                        __FieldTag::__compliance_standards => {
                            if !fields.insert(__FieldTag::__compliance_standards) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compliance_standards",
                                ));
                            }
                            result.compliance_standards = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::compliance_posture_config::ComplianceStandard,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::compliance_posture_config::ComplianceStandard {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __standard,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceStandard")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "standard" => Ok(__FieldTag::__standard),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::compliance_posture_config::ComplianceStandard;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceStandard")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__standard => {
                            if !fields.insert(__FieldTag::__standard) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard",
                                ));
                            }
                            result.standard =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::K8sBetaAPIConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled_apis,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for K8sBetaAPIConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabledApis" => Ok(__FieldTag::__enabled_apis),
                            "enabled_apis" => Ok(__FieldTag::__enabled_apis),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::K8sBetaAPIConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct K8sBetaAPIConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled_apis => {
                            if !fields.insert(__FieldTag::__enabled_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled_apis",
                                ));
                            }
                            result.enabled_apis = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SecurityPostureConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __vulnerability_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecurityPostureConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "vulnerabilityMode" => Ok(__FieldTag::__vulnerability_mode),
                            "vulnerability_mode" => Ok(__FieldTag::__vulnerability_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SecurityPostureConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecurityPostureConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode =
                                map.next_value::<std::option::Option<
                                    crate::model::security_posture_config::Mode,
                                >>()?;
                        }
                        __FieldTag::__vulnerability_mode => {
                            if !fields.insert(__FieldTag::__vulnerability_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vulnerability_mode",
                                ));
                            }
                            result.vulnerability_mode = map.next_value::<std::option::Option<
                                crate::model::security_posture_config::VulnerabilityMode,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodePoolAutoConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network_tags,
            __resource_manager_tags,
            __node_kubelet_config,
            __linux_node_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePoolAutoConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "resourceManagerTags" => Ok(__FieldTag::__resource_manager_tags),
                            "resource_manager_tags" => Ok(__FieldTag::__resource_manager_tags),
                            "nodeKubeletConfig" => Ok(__FieldTag::__node_kubelet_config),
                            "node_kubelet_config" => Ok(__FieldTag::__node_kubelet_config),
                            "linuxNodeConfig" => Ok(__FieldTag::__linux_node_config),
                            "linux_node_config" => Ok(__FieldTag::__linux_node_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodePoolAutoConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePoolAutoConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tags",
                                ));
                            }
                            result.network_tags =
                                map.next_value::<std::option::Option<crate::model::NetworkTags>>()?;
                        }
                        __FieldTag::__resource_manager_tags => {
                            if !fields.insert(__FieldTag::__resource_manager_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_manager_tags",
                                ));
                            }
                            result.resource_manager_tags = map.next_value::<std::option::Option<crate::model::ResourceManagerTags>>()?
                                ;
                        }
                        __FieldTag::__node_kubelet_config => {
                            if !fields.insert(__FieldTag::__node_kubelet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_kubelet_config",
                                ));
                            }
                            result.node_kubelet_config = map
                                .next_value::<std::option::Option<crate::model::NodeKubeletConfig>>(
                                )?;
                        }
                        __FieldTag::__linux_node_config => {
                            if !fields.insert(__FieldTag::__linux_node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linux_node_config",
                                ));
                            }
                            result.linux_node_config = map
                                .next_value::<std::option::Option<crate::model::LinuxNodeConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodePoolDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_config_defaults,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePoolDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodeConfigDefaults" => Ok(__FieldTag::__node_config_defaults),
                            "node_config_defaults" => Ok(__FieldTag::__node_config_defaults),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodePoolDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePoolDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_config_defaults => {
                            if !fields.insert(__FieldTag::__node_config_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_config_defaults",
                                ));
                            }
                            result.node_config_defaults = map.next_value::<std::option::Option<crate::model::NodeConfigDefaults>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodeConfigDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcfs_config,
            __logging_config,
            __containerd_config,
            __node_kubelet_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeConfigDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcfsConfig" => Ok(__FieldTag::__gcfs_config),
                            "gcfs_config" => Ok(__FieldTag::__gcfs_config),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "containerdConfig" => Ok(__FieldTag::__containerd_config),
                            "containerd_config" => Ok(__FieldTag::__containerd_config),
                            "nodeKubeletConfig" => Ok(__FieldTag::__node_kubelet_config),
                            "node_kubelet_config" => Ok(__FieldTag::__node_kubelet_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodeConfigDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeConfigDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcfs_config => {
                            if !fields.insert(__FieldTag::__gcfs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcfs_config",
                                ));
                            }
                            result.gcfs_config =
                                map.next_value::<std::option::Option<crate::model::GcfsConfig>>()?;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map.next_value::<std::option::Option<crate::model::NodePoolLoggingConfig>>()?
                                ;
                        }
                        __FieldTag::__containerd_config => {
                            if !fields.insert(__FieldTag::__containerd_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containerd_config",
                                ));
                            }
                            result.containerd_config = map
                                .next_value::<std::option::Option<crate::model::ContainerdConfig>>(
                                )?;
                        }
                        __FieldTag::__node_kubelet_config => {
                            if !fields.insert(__FieldTag::__node_kubelet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_kubelet_config",
                                ));
                            }
                            result.node_kubelet_config = map
                                .next_value::<std::option::Option<crate::model::NodeKubeletConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ClusterUpdate {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __desired_node_version,
            __desired_monitoring_service,
            __desired_addons_config,
            __desired_node_pool_id,
            __desired_image_type,
            __desired_database_encryption,
            __desired_workload_identity_config,
            __desired_mesh_certificates,
            __desired_shielded_nodes,
            __desired_cost_management_config,
            __desired_dns_config,
            __desired_node_pool_autoscaling,
            __desired_locations,
            __desired_master_authorized_networks_config,
            __desired_cluster_autoscaling,
            __desired_binary_authorization,
            __desired_logging_service,
            __desired_resource_usage_export_config,
            __desired_vertical_pod_autoscaling,
            __desired_private_cluster_config,
            __desired_intra_node_visibility_config,
            __desired_default_snat_status,
            __desired_release_channel,
            __desired_l4ilb_subsetting_config,
            __desired_datapath_provider,
            __desired_private_ipv6_google_access,
            __desired_notification_config,
            __desired_authenticator_groups_config,
            __desired_logging_config,
            __desired_monitoring_config,
            __desired_identity_service_config,
            __desired_service_external_ips_config,
            __desired_enable_private_endpoint,
            __desired_default_enable_private_nodes,
            __desired_control_plane_endpoints_config,
            __desired_master_version,
            __desired_gcfs_config,
            __desired_node_pool_auto_config_network_tags,
            __desired_pod_autoscaling,
            __desired_gateway_api_config,
            __etag,
            __desired_node_pool_logging_config,
            __desired_fleet,
            __desired_stack_type,
            __additional_pod_ranges_config,
            __removed_additional_pod_ranges_config,
            __enable_k8s_beta_apis,
            __desired_security_posture_config,
            __desired_network_performance_config,
            __desired_enable_fqdn_network_policy,
            __desired_autopilot_workload_policy_config,
            __desired_k8s_beta_apis,
            __desired_containerd_config,
            __desired_enable_multi_networking,
            __desired_node_pool_auto_config_resource_manager_tags,
            __desired_in_transit_encryption_config,
            __desired_enable_cilium_clusterwide_network_policy,
            __desired_secret_manager_config,
            __desired_compliance_posture_config,
            __desired_node_kubelet_config,
            __desired_node_pool_auto_config_kubelet_config,
            __user_managed_keys_config,
            __desired_rbac_binding_config,
            __desired_additional_ip_ranges_config,
            __desired_enterprise_config,
            __desired_auto_ipam_config,
            __desired_disable_l4_lb_firewall_reconciliation,
            __desired_node_pool_auto_config_linux_node_config,
            __desired_user_managed_keys_config,
            __desired_anonymous_authentication_config,
            __gke_auto_upgrade_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterUpdate")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "desiredNodeVersion" => Ok(__FieldTag::__desired_node_version),
                            "desired_node_version" => Ok(__FieldTag::__desired_node_version),
                            "desiredMonitoringService" => {
                                Ok(__FieldTag::__desired_monitoring_service)
                            }
                            "desired_monitoring_service" => {
                                Ok(__FieldTag::__desired_monitoring_service)
                            }
                            "desiredAddonsConfig" => Ok(__FieldTag::__desired_addons_config),
                            "desired_addons_config" => Ok(__FieldTag::__desired_addons_config),
                            "desiredNodePoolId" => Ok(__FieldTag::__desired_node_pool_id),
                            "desired_node_pool_id" => Ok(__FieldTag::__desired_node_pool_id),
                            "desiredImageType" => Ok(__FieldTag::__desired_image_type),
                            "desired_image_type" => Ok(__FieldTag::__desired_image_type),
                            "desiredDatabaseEncryption" => {
                                Ok(__FieldTag::__desired_database_encryption)
                            }
                            "desired_database_encryption" => {
                                Ok(__FieldTag::__desired_database_encryption)
                            }
                            "desiredWorkloadIdentityConfig" => {
                                Ok(__FieldTag::__desired_workload_identity_config)
                            }
                            "desired_workload_identity_config" => {
                                Ok(__FieldTag::__desired_workload_identity_config)
                            }
                            "desiredMeshCertificates" => {
                                Ok(__FieldTag::__desired_mesh_certificates)
                            }
                            "desired_mesh_certificates" => {
                                Ok(__FieldTag::__desired_mesh_certificates)
                            }
                            "desiredShieldedNodes" => Ok(__FieldTag::__desired_shielded_nodes),
                            "desired_shielded_nodes" => Ok(__FieldTag::__desired_shielded_nodes),
                            "desiredCostManagementConfig" => {
                                Ok(__FieldTag::__desired_cost_management_config)
                            }
                            "desired_cost_management_config" => {
                                Ok(__FieldTag::__desired_cost_management_config)
                            }
                            "desiredDnsConfig" => Ok(__FieldTag::__desired_dns_config),
                            "desired_dns_config" => Ok(__FieldTag::__desired_dns_config),
                            "desiredNodePoolAutoscaling" => {
                                Ok(__FieldTag::__desired_node_pool_autoscaling)
                            }
                            "desired_node_pool_autoscaling" => {
                                Ok(__FieldTag::__desired_node_pool_autoscaling)
                            }
                            "desiredLocations" => Ok(__FieldTag::__desired_locations),
                            "desired_locations" => Ok(__FieldTag::__desired_locations),
                            "desiredMasterAuthorizedNetworksConfig" => {
                                Ok(__FieldTag::__desired_master_authorized_networks_config)
                            }
                            "desired_master_authorized_networks_config" => {
                                Ok(__FieldTag::__desired_master_authorized_networks_config)
                            }
                            "desiredClusterAutoscaling" => {
                                Ok(__FieldTag::__desired_cluster_autoscaling)
                            }
                            "desired_cluster_autoscaling" => {
                                Ok(__FieldTag::__desired_cluster_autoscaling)
                            }
                            "desiredBinaryAuthorization" => {
                                Ok(__FieldTag::__desired_binary_authorization)
                            }
                            "desired_binary_authorization" => {
                                Ok(__FieldTag::__desired_binary_authorization)
                            }
                            "desiredLoggingService" => Ok(__FieldTag::__desired_logging_service),
                            "desired_logging_service" => Ok(__FieldTag::__desired_logging_service),
                            "desiredResourceUsageExportConfig" => {
                                Ok(__FieldTag::__desired_resource_usage_export_config)
                            }
                            "desired_resource_usage_export_config" => {
                                Ok(__FieldTag::__desired_resource_usage_export_config)
                            }
                            "desiredVerticalPodAutoscaling" => {
                                Ok(__FieldTag::__desired_vertical_pod_autoscaling)
                            }
                            "desired_vertical_pod_autoscaling" => {
                                Ok(__FieldTag::__desired_vertical_pod_autoscaling)
                            }
                            "desiredPrivateClusterConfig" => {
                                Ok(__FieldTag::__desired_private_cluster_config)
                            }
                            "desired_private_cluster_config" => {
                                Ok(__FieldTag::__desired_private_cluster_config)
                            }
                            "desiredIntraNodeVisibilityConfig" => {
                                Ok(__FieldTag::__desired_intra_node_visibility_config)
                            }
                            "desired_intra_node_visibility_config" => {
                                Ok(__FieldTag::__desired_intra_node_visibility_config)
                            }
                            "desiredDefaultSnatStatus" => {
                                Ok(__FieldTag::__desired_default_snat_status)
                            }
                            "desired_default_snat_status" => {
                                Ok(__FieldTag::__desired_default_snat_status)
                            }
                            "desiredReleaseChannel" => Ok(__FieldTag::__desired_release_channel),
                            "desired_release_channel" => Ok(__FieldTag::__desired_release_channel),
                            "desiredL4ilbSubsettingConfig" => {
                                Ok(__FieldTag::__desired_l4ilb_subsetting_config)
                            }
                            "desired_l4ilb_subsetting_config" => {
                                Ok(__FieldTag::__desired_l4ilb_subsetting_config)
                            }
                            "desiredDatapathProvider" => {
                                Ok(__FieldTag::__desired_datapath_provider)
                            }
                            "desired_datapath_provider" => {
                                Ok(__FieldTag::__desired_datapath_provider)
                            }
                            "desiredPrivateIpv6GoogleAccess" => {
                                Ok(__FieldTag::__desired_private_ipv6_google_access)
                            }
                            "desired_private_ipv6_google_access" => {
                                Ok(__FieldTag::__desired_private_ipv6_google_access)
                            }
                            "desiredNotificationConfig" => {
                                Ok(__FieldTag::__desired_notification_config)
                            }
                            "desired_notification_config" => {
                                Ok(__FieldTag::__desired_notification_config)
                            }
                            "desiredAuthenticatorGroupsConfig" => {
                                Ok(__FieldTag::__desired_authenticator_groups_config)
                            }
                            "desired_authenticator_groups_config" => {
                                Ok(__FieldTag::__desired_authenticator_groups_config)
                            }
                            "desiredLoggingConfig" => Ok(__FieldTag::__desired_logging_config),
                            "desired_logging_config" => Ok(__FieldTag::__desired_logging_config),
                            "desiredMonitoringConfig" => {
                                Ok(__FieldTag::__desired_monitoring_config)
                            }
                            "desired_monitoring_config" => {
                                Ok(__FieldTag::__desired_monitoring_config)
                            }
                            "desiredIdentityServiceConfig" => {
                                Ok(__FieldTag::__desired_identity_service_config)
                            }
                            "desired_identity_service_config" => {
                                Ok(__FieldTag::__desired_identity_service_config)
                            }
                            "desiredServiceExternalIpsConfig" => {
                                Ok(__FieldTag::__desired_service_external_ips_config)
                            }
                            "desired_service_external_ips_config" => {
                                Ok(__FieldTag::__desired_service_external_ips_config)
                            }
                            "desiredEnablePrivateEndpoint" => {
                                Ok(__FieldTag::__desired_enable_private_endpoint)
                            }
                            "desired_enable_private_endpoint" => {
                                Ok(__FieldTag::__desired_enable_private_endpoint)
                            }
                            "desiredDefaultEnablePrivateNodes" => {
                                Ok(__FieldTag::__desired_default_enable_private_nodes)
                            }
                            "desired_default_enable_private_nodes" => {
                                Ok(__FieldTag::__desired_default_enable_private_nodes)
                            }
                            "desiredControlPlaneEndpointsConfig" => {
                                Ok(__FieldTag::__desired_control_plane_endpoints_config)
                            }
                            "desired_control_plane_endpoints_config" => {
                                Ok(__FieldTag::__desired_control_plane_endpoints_config)
                            }
                            "desiredMasterVersion" => Ok(__FieldTag::__desired_master_version),
                            "desired_master_version" => Ok(__FieldTag::__desired_master_version),
                            "desiredGcfsConfig" => Ok(__FieldTag::__desired_gcfs_config),
                            "desired_gcfs_config" => Ok(__FieldTag::__desired_gcfs_config),
                            "desiredNodePoolAutoConfigNetworkTags" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_network_tags)
                            }
                            "desired_node_pool_auto_config_network_tags" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_network_tags)
                            }
                            "desiredPodAutoscaling" => Ok(__FieldTag::__desired_pod_autoscaling),
                            "desired_pod_autoscaling" => Ok(__FieldTag::__desired_pod_autoscaling),
                            "desiredGatewayApiConfig" => {
                                Ok(__FieldTag::__desired_gateway_api_config)
                            }
                            "desired_gateway_api_config" => {
                                Ok(__FieldTag::__desired_gateway_api_config)
                            }
                            "etag" => Ok(__FieldTag::__etag),
                            "desiredNodePoolLoggingConfig" => {
                                Ok(__FieldTag::__desired_node_pool_logging_config)
                            }
                            "desired_node_pool_logging_config" => {
                                Ok(__FieldTag::__desired_node_pool_logging_config)
                            }
                            "desiredFleet" => Ok(__FieldTag::__desired_fleet),
                            "desired_fleet" => Ok(__FieldTag::__desired_fleet),
                            "desiredStackType" => Ok(__FieldTag::__desired_stack_type),
                            "desired_stack_type" => Ok(__FieldTag::__desired_stack_type),
                            "additionalPodRangesConfig" => {
                                Ok(__FieldTag::__additional_pod_ranges_config)
                            }
                            "additional_pod_ranges_config" => {
                                Ok(__FieldTag::__additional_pod_ranges_config)
                            }
                            "removedAdditionalPodRangesConfig" => {
                                Ok(__FieldTag::__removed_additional_pod_ranges_config)
                            }
                            "removed_additional_pod_ranges_config" => {
                                Ok(__FieldTag::__removed_additional_pod_ranges_config)
                            }
                            "enableK8sBetaApis" => Ok(__FieldTag::__enable_k8s_beta_apis),
                            "enable_k8s_beta_apis" => Ok(__FieldTag::__enable_k8s_beta_apis),
                            "desiredSecurityPostureConfig" => {
                                Ok(__FieldTag::__desired_security_posture_config)
                            }
                            "desired_security_posture_config" => {
                                Ok(__FieldTag::__desired_security_posture_config)
                            }
                            "desiredNetworkPerformanceConfig" => {
                                Ok(__FieldTag::__desired_network_performance_config)
                            }
                            "desired_network_performance_config" => {
                                Ok(__FieldTag::__desired_network_performance_config)
                            }
                            "desiredEnableFqdnNetworkPolicy" => {
                                Ok(__FieldTag::__desired_enable_fqdn_network_policy)
                            }
                            "desired_enable_fqdn_network_policy" => {
                                Ok(__FieldTag::__desired_enable_fqdn_network_policy)
                            }
                            "desiredAutopilotWorkloadPolicyConfig" => {
                                Ok(__FieldTag::__desired_autopilot_workload_policy_config)
                            }
                            "desired_autopilot_workload_policy_config" => {
                                Ok(__FieldTag::__desired_autopilot_workload_policy_config)
                            }
                            "desiredK8sBetaApis" => Ok(__FieldTag::__desired_k8s_beta_apis),
                            "desired_k8s_beta_apis" => Ok(__FieldTag::__desired_k8s_beta_apis),
                            "desiredContainerdConfig" => {
                                Ok(__FieldTag::__desired_containerd_config)
                            }
                            "desired_containerd_config" => {
                                Ok(__FieldTag::__desired_containerd_config)
                            }
                            "desiredEnableMultiNetworking" => {
                                Ok(__FieldTag::__desired_enable_multi_networking)
                            }
                            "desired_enable_multi_networking" => {
                                Ok(__FieldTag::__desired_enable_multi_networking)
                            }
                            "desiredNodePoolAutoConfigResourceManagerTags" => Ok(
                                __FieldTag::__desired_node_pool_auto_config_resource_manager_tags,
                            ),
                            "desired_node_pool_auto_config_resource_manager_tags" => Ok(
                                __FieldTag::__desired_node_pool_auto_config_resource_manager_tags,
                            ),
                            "desiredInTransitEncryptionConfig" => {
                                Ok(__FieldTag::__desired_in_transit_encryption_config)
                            }
                            "desired_in_transit_encryption_config" => {
                                Ok(__FieldTag::__desired_in_transit_encryption_config)
                            }
                            "desiredEnableCiliumClusterwideNetworkPolicy" => {
                                Ok(__FieldTag::__desired_enable_cilium_clusterwide_network_policy)
                            }
                            "desired_enable_cilium_clusterwide_network_policy" => {
                                Ok(__FieldTag::__desired_enable_cilium_clusterwide_network_policy)
                            }
                            "desiredSecretManagerConfig" => {
                                Ok(__FieldTag::__desired_secret_manager_config)
                            }
                            "desired_secret_manager_config" => {
                                Ok(__FieldTag::__desired_secret_manager_config)
                            }
                            "desiredCompliancePostureConfig" => {
                                Ok(__FieldTag::__desired_compliance_posture_config)
                            }
                            "desired_compliance_posture_config" => {
                                Ok(__FieldTag::__desired_compliance_posture_config)
                            }
                            "desiredNodeKubeletConfig" => {
                                Ok(__FieldTag::__desired_node_kubelet_config)
                            }
                            "desired_node_kubelet_config" => {
                                Ok(__FieldTag::__desired_node_kubelet_config)
                            }
                            "desiredNodePoolAutoConfigKubeletConfig" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_kubelet_config)
                            }
                            "desired_node_pool_auto_config_kubelet_config" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_kubelet_config)
                            }
                            "userManagedKeysConfig" => Ok(__FieldTag::__user_managed_keys_config),
                            "user_managed_keys_config" => {
                                Ok(__FieldTag::__user_managed_keys_config)
                            }
                            "desiredRbacBindingConfig" => {
                                Ok(__FieldTag::__desired_rbac_binding_config)
                            }
                            "desired_rbac_binding_config" => {
                                Ok(__FieldTag::__desired_rbac_binding_config)
                            }
                            "desiredAdditionalIpRangesConfig" => {
                                Ok(__FieldTag::__desired_additional_ip_ranges_config)
                            }
                            "desired_additional_ip_ranges_config" => {
                                Ok(__FieldTag::__desired_additional_ip_ranges_config)
                            }
                            "desiredEnterpriseConfig" => {
                                Ok(__FieldTag::__desired_enterprise_config)
                            }
                            "desired_enterprise_config" => {
                                Ok(__FieldTag::__desired_enterprise_config)
                            }
                            "desiredAutoIpamConfig" => Ok(__FieldTag::__desired_auto_ipam_config),
                            "desired_auto_ipam_config" => {
                                Ok(__FieldTag::__desired_auto_ipam_config)
                            }
                            "desiredDisableL4LbFirewallReconciliation" => {
                                Ok(__FieldTag::__desired_disable_l4_lb_firewall_reconciliation)
                            }
                            "desired_disable_l4_lb_firewall_reconciliation" => {
                                Ok(__FieldTag::__desired_disable_l4_lb_firewall_reconciliation)
                            }
                            "desiredNodePoolAutoConfigLinuxNodeConfig" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_linux_node_config)
                            }
                            "desired_node_pool_auto_config_linux_node_config" => {
                                Ok(__FieldTag::__desired_node_pool_auto_config_linux_node_config)
                            }
                            "desiredUserManagedKeysConfig" => {
                                Ok(__FieldTag::__desired_user_managed_keys_config)
                            }
                            "desired_user_managed_keys_config" => {
                                Ok(__FieldTag::__desired_user_managed_keys_config)
                            }
                            "desiredAnonymousAuthenticationConfig" => {
                                Ok(__FieldTag::__desired_anonymous_authentication_config)
                            }
                            "desired_anonymous_authentication_config" => {
                                Ok(__FieldTag::__desired_anonymous_authentication_config)
                            }
                            "gkeAutoUpgradeConfig" => Ok(__FieldTag::__gke_auto_upgrade_config),
                            "gke_auto_upgrade_config" => Ok(__FieldTag::__gke_auto_upgrade_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ClusterUpdate;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterUpdate")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__desired_node_version => {
                            if !fields.insert(__FieldTag::__desired_node_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_version",
                                ));
                            }
                            result.desired_node_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_monitoring_service => {
                            if !fields.insert(__FieldTag::__desired_monitoring_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_monitoring_service",
                                ));
                            }
                            result.desired_monitoring_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_addons_config => {
                            if !fields.insert(__FieldTag::__desired_addons_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_addons_config",
                                ));
                            }
                            result.desired_addons_config = map
                                .next_value::<std::option::Option<crate::model::AddonsConfig>>()?;
                        }
                        __FieldTag::__desired_node_pool_id => {
                            if !fields.insert(__FieldTag::__desired_node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_id",
                                ));
                            }
                            result.desired_node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_image_type => {
                            if !fields.insert(__FieldTag::__desired_image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_image_type",
                                ));
                            }
                            result.desired_image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_database_encryption => {
                            if !fields.insert(__FieldTag::__desired_database_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_database_encryption",
                                ));
                            }
                            result.desired_database_encryption = map.next_value::<std::option::Option<crate::model::DatabaseEncryption>>()?
                                ;
                        }
                        __FieldTag::__desired_workload_identity_config => {
                            if !fields.insert(__FieldTag::__desired_workload_identity_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_workload_identity_config",
                                ));
                            }
                            result.desired_workload_identity_config = map.next_value::<std::option::Option<crate::model::WorkloadIdentityConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_mesh_certificates => {
                            if !fields.insert(__FieldTag::__desired_mesh_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_mesh_certificates",
                                ));
                            }
                            result.desired_mesh_certificates = map
                                .next_value::<std::option::Option<crate::model::MeshCertificates>>(
                                )?;
                        }
                        __FieldTag::__desired_shielded_nodes => {
                            if !fields.insert(__FieldTag::__desired_shielded_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_shielded_nodes",
                                ));
                            }
                            result.desired_shielded_nodes = map
                                .next_value::<std::option::Option<crate::model::ShieldedNodes>>()?;
                        }
                        __FieldTag::__desired_cost_management_config => {
                            if !fields.insert(__FieldTag::__desired_cost_management_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_cost_management_config",
                                ));
                            }
                            result.desired_cost_management_config = map.next_value::<std::option::Option<crate::model::CostManagementConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_dns_config => {
                            if !fields.insert(__FieldTag::__desired_dns_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_dns_config",
                                ));
                            }
                            result.desired_dns_config =
                                map.next_value::<std::option::Option<crate::model::DNSConfig>>()?;
                        }
                        __FieldTag::__desired_node_pool_autoscaling => {
                            if !fields.insert(__FieldTag::__desired_node_pool_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_autoscaling",
                                ));
                            }
                            result.desired_node_pool_autoscaling = map.next_value::<std::option::Option<crate::model::NodePoolAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__desired_locations => {
                            if !fields.insert(__FieldTag::__desired_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_locations",
                                ));
                            }
                            result.desired_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__desired_master_authorized_networks_config => {
                            if !fields
                                .insert(__FieldTag::__desired_master_authorized_networks_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_master_authorized_networks_config",
                                ));
                            }
                            result.desired_master_authorized_networks_config =
                                map.next_value::<std::option::Option<
                                    crate::model::MasterAuthorizedNetworksConfig,
                                >>()?;
                        }
                        __FieldTag::__desired_cluster_autoscaling => {
                            if !fields.insert(__FieldTag::__desired_cluster_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_cluster_autoscaling",
                                ));
                            }
                            result.desired_cluster_autoscaling = map.next_value::<std::option::Option<crate::model::ClusterAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__desired_binary_authorization => {
                            if !fields.insert(__FieldTag::__desired_binary_authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_binary_authorization",
                                ));
                            }
                            result.desired_binary_authorization = map.next_value::<std::option::Option<crate::model::BinaryAuthorization>>()?
                                ;
                        }
                        __FieldTag::__desired_logging_service => {
                            if !fields.insert(__FieldTag::__desired_logging_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_logging_service",
                                ));
                            }
                            result.desired_logging_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_resource_usage_export_config => {
                            if !fields.insert(__FieldTag::__desired_resource_usage_export_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_resource_usage_export_config",
                                ));
                            }
                            result.desired_resource_usage_export_config = map.next_value::<std::option::Option<crate::model::ResourceUsageExportConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_vertical_pod_autoscaling => {
                            if !fields.insert(__FieldTag::__desired_vertical_pod_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_vertical_pod_autoscaling",
                                ));
                            }
                            result.desired_vertical_pod_autoscaling = map.next_value::<std::option::Option<crate::model::VerticalPodAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__desired_private_cluster_config => {
                            if !fields.insert(__FieldTag::__desired_private_cluster_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_private_cluster_config",
                                ));
                            }
                            result.desired_private_cluster_config = map.next_value::<std::option::Option<crate::model::PrivateClusterConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_intra_node_visibility_config => {
                            if !fields.insert(__FieldTag::__desired_intra_node_visibility_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_intra_node_visibility_config",
                                ));
                            }
                            result.desired_intra_node_visibility_config = map.next_value::<std::option::Option<crate::model::IntraNodeVisibilityConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_default_snat_status => {
                            if !fields.insert(__FieldTag::__desired_default_snat_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_default_snat_status",
                                ));
                            }
                            result.desired_default_snat_status = map
                                .next_value::<std::option::Option<crate::model::DefaultSnatStatus>>(
                                )?;
                        }
                        __FieldTag::__desired_release_channel => {
                            if !fields.insert(__FieldTag::__desired_release_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_release_channel",
                                ));
                            }
                            result.desired_release_channel = map
                                .next_value::<std::option::Option<crate::model::ReleaseChannel>>(
                                )?;
                        }
                        __FieldTag::__desired_l4ilb_subsetting_config => {
                            if !fields.insert(__FieldTag::__desired_l4ilb_subsetting_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_l4ilb_subsetting_config",
                                ));
                            }
                            result.desired_l4ilb_subsetting_config = map.next_value::<std::option::Option<crate::model::ILBSubsettingConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_datapath_provider => {
                            if !fields.insert(__FieldTag::__desired_datapath_provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_datapath_provider",
                                ));
                            }
                            result.desired_datapath_provider = map
                                .next_value::<std::option::Option<crate::model::DatapathProvider>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_private_ipv6_google_access => {
                            if !fields.insert(__FieldTag::__desired_private_ipv6_google_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_private_ipv6_google_access",
                                ));
                            }
                            result.desired_private_ipv6_google_access = map.next_value::<std::option::Option<crate::model::PrivateIPv6GoogleAccess>>()?.unwrap_or_default();
                        }
                        __FieldTag::__desired_notification_config => {
                            if !fields.insert(__FieldTag::__desired_notification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_notification_config",
                                ));
                            }
                            result.desired_notification_config = map.next_value::<std::option::Option<crate::model::NotificationConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_authenticator_groups_config => {
                            if !fields.insert(__FieldTag::__desired_authenticator_groups_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_authenticator_groups_config",
                                ));
                            }
                            result.desired_authenticator_groups_config = map.next_value::<std::option::Option<crate::model::AuthenticatorGroupsConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_logging_config => {
                            if !fields.insert(__FieldTag::__desired_logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_logging_config",
                                ));
                            }
                            result.desired_logging_config = map
                                .next_value::<std::option::Option<crate::model::LoggingConfig>>()?;
                        }
                        __FieldTag::__desired_monitoring_config => {
                            if !fields.insert(__FieldTag::__desired_monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_monitoring_config",
                                ));
                            }
                            result.desired_monitoring_config = map
                                .next_value::<std::option::Option<crate::model::MonitoringConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_identity_service_config => {
                            if !fields.insert(__FieldTag::__desired_identity_service_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_identity_service_config",
                                ));
                            }
                            result.desired_identity_service_config = map.next_value::<std::option::Option<crate::model::IdentityServiceConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_service_external_ips_config => {
                            if !fields.insert(__FieldTag::__desired_service_external_ips_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_service_external_ips_config",
                                ));
                            }
                            result.desired_service_external_ips_config = map.next_value::<std::option::Option<crate::model::ServiceExternalIPsConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_enable_private_endpoint => {
                            if !fields.insert(__FieldTag::__desired_enable_private_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_enable_private_endpoint",
                                ));
                            }
                            result.desired_enable_private_endpoint =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_default_enable_private_nodes => {
                            if !fields.insert(__FieldTag::__desired_default_enable_private_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_default_enable_private_nodes",
                                ));
                            }
                            result.desired_default_enable_private_nodes =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_control_plane_endpoints_config => {
                            if !fields.insert(__FieldTag::__desired_control_plane_endpoints_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_control_plane_endpoints_config",
                                ));
                            }
                            result.desired_control_plane_endpoints_config = map
                                .next_value::<std::option::Option<
                                crate::model::ControlPlaneEndpointsConfig,
                            >>(
                            )?;
                        }
                        __FieldTag::__desired_master_version => {
                            if !fields.insert(__FieldTag::__desired_master_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_master_version",
                                ));
                            }
                            result.desired_master_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_gcfs_config => {
                            if !fields.insert(__FieldTag::__desired_gcfs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_gcfs_config",
                                ));
                            }
                            result.desired_gcfs_config =
                                map.next_value::<std::option::Option<crate::model::GcfsConfig>>()?;
                        }
                        __FieldTag::__desired_node_pool_auto_config_network_tags => {
                            if !fields
                                .insert(__FieldTag::__desired_node_pool_auto_config_network_tags)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_auto_config_network_tags",
                                ));
                            }
                            result.desired_node_pool_auto_config_network_tags =
                                map.next_value::<std::option::Option<crate::model::NetworkTags>>()?;
                        }
                        __FieldTag::__desired_pod_autoscaling => {
                            if !fields.insert(__FieldTag::__desired_pod_autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_pod_autoscaling",
                                ));
                            }
                            result.desired_pod_autoscaling = map
                                .next_value::<std::option::Option<crate::model::PodAutoscaling>>(
                                )?;
                        }
                        __FieldTag::__desired_gateway_api_config => {
                            if !fields.insert(__FieldTag::__desired_gateway_api_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_gateway_api_config",
                                ));
                            }
                            result.desired_gateway_api_config = map
                                .next_value::<std::option::Option<crate::model::GatewayAPIConfig>>(
                                )?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_node_pool_logging_config => {
                            if !fields.insert(__FieldTag::__desired_node_pool_logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_logging_config",
                                ));
                            }
                            result.desired_node_pool_logging_config = map.next_value::<std::option::Option<crate::model::NodePoolLoggingConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_fleet => {
                            if !fields.insert(__FieldTag::__desired_fleet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_fleet",
                                ));
                            }
                            result.desired_fleet =
                                map.next_value::<std::option::Option<crate::model::Fleet>>()?;
                        }
                        __FieldTag::__desired_stack_type => {
                            if !fields.insert(__FieldTag::__desired_stack_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_stack_type",
                                ));
                            }
                            result.desired_stack_type = map
                                .next_value::<std::option::Option<crate::model::StackType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_pod_ranges_config => {
                            if !fields.insert(__FieldTag::__additional_pod_ranges_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_pod_ranges_config",
                                ));
                            }
                            result.additional_pod_ranges_config = map.next_value::<std::option::Option<crate::model::AdditionalPodRangesConfig>>()?
                                ;
                        }
                        __FieldTag::__removed_additional_pod_ranges_config => {
                            if !fields.insert(__FieldTag::__removed_additional_pod_ranges_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for removed_additional_pod_ranges_config",
                                ));
                            }
                            result.removed_additional_pod_ranges_config = map.next_value::<std::option::Option<crate::model::AdditionalPodRangesConfig>>()?
                                ;
                        }
                        __FieldTag::__enable_k8s_beta_apis => {
                            if !fields.insert(__FieldTag::__enable_k8s_beta_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_k8s_beta_apis",
                                ));
                            }
                            result.enable_k8s_beta_apis = map
                                .next_value::<std::option::Option<crate::model::K8sBetaAPIConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_security_posture_config => {
                            if !fields.insert(__FieldTag::__desired_security_posture_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_security_posture_config",
                                ));
                            }
                            result.desired_security_posture_config = map.next_value::<std::option::Option<crate::model::SecurityPostureConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_network_performance_config => {
                            if !fields.insert(__FieldTag::__desired_network_performance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_network_performance_config",
                                ));
                            }
                            result.desired_network_performance_config = map
                                .next_value::<std::option::Option<
                                    crate::model::network_config::ClusterNetworkPerformanceConfig,
                                >>()?;
                        }
                        __FieldTag::__desired_enable_fqdn_network_policy => {
                            if !fields.insert(__FieldTag::__desired_enable_fqdn_network_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_enable_fqdn_network_policy",
                                ));
                            }
                            result.desired_enable_fqdn_network_policy =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_autopilot_workload_policy_config => {
                            if !fields
                                .insert(__FieldTag::__desired_autopilot_workload_policy_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_autopilot_workload_policy_config",
                                ));
                            }
                            result.desired_autopilot_workload_policy_config = map
                                .next_value::<std::option::Option<
                                crate::model::WorkloadPolicyConfig,
                            >>(
                            )?;
                        }
                        __FieldTag::__desired_k8s_beta_apis => {
                            if !fields.insert(__FieldTag::__desired_k8s_beta_apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_k8s_beta_apis",
                                ));
                            }
                            result.desired_k8s_beta_apis = map
                                .next_value::<std::option::Option<crate::model::K8sBetaAPIConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_containerd_config => {
                            if !fields.insert(__FieldTag::__desired_containerd_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_containerd_config",
                                ));
                            }
                            result.desired_containerd_config = map
                                .next_value::<std::option::Option<crate::model::ContainerdConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_enable_multi_networking => {
                            if !fields.insert(__FieldTag::__desired_enable_multi_networking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_enable_multi_networking",
                                ));
                            }
                            result.desired_enable_multi_networking =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_node_pool_auto_config_resource_manager_tags => {
                            if !fields.insert(
                                __FieldTag::__desired_node_pool_auto_config_resource_manager_tags,
                            ) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_auto_config_resource_manager_tags",
                                ));
                            }
                            result.desired_node_pool_auto_config_resource_manager_tags = map.next_value::<std::option::Option<crate::model::ResourceManagerTags>>()?
                                ;
                        }
                        __FieldTag::__desired_in_transit_encryption_config => {
                            if !fields.insert(__FieldTag::__desired_in_transit_encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_in_transit_encryption_config",
                                ));
                            }
                            result.desired_in_transit_encryption_config = map.next_value::<std::option::Option<crate::model::InTransitEncryptionConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_enable_cilium_clusterwide_network_policy => {
                            if !fields.insert(
                                __FieldTag::__desired_enable_cilium_clusterwide_network_policy,
                            ) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_enable_cilium_clusterwide_network_policy",
                                ));
                            }
                            result.desired_enable_cilium_clusterwide_network_policy =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_secret_manager_config => {
                            if !fields.insert(__FieldTag::__desired_secret_manager_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_secret_manager_config",
                                ));
                            }
                            result.desired_secret_manager_config = map.next_value::<std::option::Option<crate::model::SecretManagerConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_compliance_posture_config => {
                            if !fields.insert(__FieldTag::__desired_compliance_posture_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_compliance_posture_config",
                                ));
                            }
                            result.desired_compliance_posture_config = map.next_value::<std::option::Option<crate::model::CompliancePostureConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_node_kubelet_config => {
                            if !fields.insert(__FieldTag::__desired_node_kubelet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_kubelet_config",
                                ));
                            }
                            result.desired_node_kubelet_config = map
                                .next_value::<std::option::Option<crate::model::NodeKubeletConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_node_pool_auto_config_kubelet_config => {
                            if !fields
                                .insert(__FieldTag::__desired_node_pool_auto_config_kubelet_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_auto_config_kubelet_config",
                                ));
                            }
                            result.desired_node_pool_auto_config_kubelet_config = map.next_value::<std::option::Option<crate::model::NodeKubeletConfig>>()?
                                ;
                        }
                        __FieldTag::__user_managed_keys_config => {
                            if !fields.insert(__FieldTag::__user_managed_keys_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_managed_keys_config",
                                ));
                            }
                            result.user_managed_keys_config = map.next_value::<std::option::Option<crate::model::UserManagedKeysConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_rbac_binding_config => {
                            if !fields.insert(__FieldTag::__desired_rbac_binding_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_rbac_binding_config",
                                ));
                            }
                            result.desired_rbac_binding_config = map
                                .next_value::<std::option::Option<crate::model::RBACBindingConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_additional_ip_ranges_config => {
                            if !fields.insert(__FieldTag::__desired_additional_ip_ranges_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_additional_ip_ranges_config",
                                ));
                            }
                            result.desired_additional_ip_ranges_config = map
                                .next_value::<std::option::Option<
                                    crate::model::DesiredAdditionalIPRangesConfig,
                                >>()?;
                        }
                        __FieldTag::__desired_enterprise_config => {
                            if !fields.insert(__FieldTag::__desired_enterprise_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_enterprise_config",
                                ));
                            }
                            result.desired_enterprise_config = map.next_value::<std::option::Option<crate::model::DesiredEnterpriseConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_auto_ipam_config => {
                            if !fields.insert(__FieldTag::__desired_auto_ipam_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_auto_ipam_config",
                                ));
                            }
                            result.desired_auto_ipam_config = map
                                .next_value::<std::option::Option<crate::model::AutoIpamConfig>>(
                                )?;
                        }
                        __FieldTag::__desired_disable_l4_lb_firewall_reconciliation => {
                            if !fields
                                .insert(__FieldTag::__desired_disable_l4_lb_firewall_reconciliation)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_disable_l4_lb_firewall_reconciliation",
                                ));
                            }
                            result.desired_disable_l4_lb_firewall_reconciliation =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__desired_node_pool_auto_config_linux_node_config => {
                            if !fields.insert(
                                __FieldTag::__desired_node_pool_auto_config_linux_node_config,
                            ) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_node_pool_auto_config_linux_node_config",
                                ));
                            }
                            result.desired_node_pool_auto_config_linux_node_config = map.next_value::<std::option::Option<crate::model::LinuxNodeConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_user_managed_keys_config => {
                            if !fields.insert(__FieldTag::__desired_user_managed_keys_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_user_managed_keys_config",
                                ));
                            }
                            result.desired_user_managed_keys_config = map.next_value::<std::option::Option<crate::model::UserManagedKeysConfig>>()?
                                ;
                        }
                        __FieldTag::__desired_anonymous_authentication_config => {
                            if !fields.insert(__FieldTag::__desired_anonymous_authentication_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_anonymous_authentication_config",
                                ));
                            }
                            result.desired_anonymous_authentication_config =
                                map.next_value::<std::option::Option<
                                    crate::model::AnonymousAuthenticationConfig,
                                >>()?;
                        }
                        __FieldTag::__gke_auto_upgrade_config => {
                            if !fields.insert(__FieldTag::__gke_auto_upgrade_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gke_auto_upgrade_config",
                                ));
                            }
                            result.gke_auto_upgrade_config = map.next_value::<std::option::Option<crate::model::GkeAutoUpgradeConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AdditionalPodRangesConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pod_range_names,
            __pod_range_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdditionalPodRangesConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "podRangeNames" => Ok(__FieldTag::__pod_range_names),
                            "pod_range_names" => Ok(__FieldTag::__pod_range_names),
                            "podRangeInfo" => Ok(__FieldTag::__pod_range_info),
                            "pod_range_info" => Ok(__FieldTag::__pod_range_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AdditionalPodRangesConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdditionalPodRangesConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pod_range_names => {
                            if !fields.insert(__FieldTag::__pod_range_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_range_names",
                                ));
                            }
                            result.pod_range_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__pod_range_info => {
                            if !fields.insert(__FieldTag::__pod_range_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_range_info",
                                ));
                            }
                            result.pod_range_info = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RangeInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AdditionalIPRangesConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subnetwork,
            __pod_ipv4_range_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdditionalIPRangesConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "podIpv4RangeNames" => Ok(__FieldTag::__pod_ipv4_range_names),
                            "pod_ipv4_range_names" => Ok(__FieldTag::__pod_ipv4_range_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AdditionalIPRangesConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdditionalIPRangesConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_ipv4_range_names => {
                            if !fields.insert(__FieldTag::__pod_ipv4_range_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_ipv4_range_names",
                                ));
                            }
                            result.pod_ipv4_range_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DesiredAdditionalIPRangesConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __additional_ip_ranges_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DesiredAdditionalIPRangesConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "additionalIpRangesConfigs" => {
                                Ok(__FieldTag::__additional_ip_ranges_configs)
                            }
                            "additional_ip_ranges_configs" => {
                                Ok(__FieldTag::__additional_ip_ranges_configs)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DesiredAdditionalIPRangesConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DesiredAdditionalIPRangesConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__additional_ip_ranges_configs => {
                            if !fields.insert(__FieldTag::__additional_ip_ranges_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_ip_ranges_configs",
                                ));
                            }
                            result.additional_ip_ranges_configs = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AdditionalIPRangesConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutoIpamConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoIpamConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutoIpamConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoIpamConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RangeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __range_name,
            __utilization,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RangeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rangeName" => Ok(__FieldTag::__range_name),
                            "range_name" => Ok(__FieldTag::__range_name),
                            "utilization" => Ok(__FieldTag::__utilization),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RangeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RangeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__range_name => {
                            if !fields.insert(__FieldTag::__range_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_name",
                                ));
                            }
                            result.range_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__utilization => {
                            if !fields.insert(__FieldTag::__utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilization",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.utilization = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DesiredEnterpriseConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __desired_tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DesiredEnterpriseConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "desiredTier" => Ok(__FieldTag::__desired_tier),
                            "desired_tier" => Ok(__FieldTag::__desired_tier),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DesiredEnterpriseConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DesiredEnterpriseConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__desired_tier => {
                            if !fields.insert(__FieldTag::__desired_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_tier",
                                ));
                            }
                            result.desired_tier =
                                map.next_value::<std::option::Option<
                                    crate::model::enterprise_config::ClusterTier,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Operation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __zone,
            __operation_type,
            __status,
            __detail,
            __status_message,
            __self_link,
            __target_link,
            __location,
            __start_time,
            __end_time,
            __progress,
            __cluster_conditions,
            __nodepool_conditions,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Operation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "zone" => Ok(__FieldTag::__zone),
                            "operationType" => Ok(__FieldTag::__operation_type),
                            "operation_type" => Ok(__FieldTag::__operation_type),
                            "status" => Ok(__FieldTag::__status),
                            "detail" => Ok(__FieldTag::__detail),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "targetLink" => Ok(__FieldTag::__target_link),
                            "target_link" => Ok(__FieldTag::__target_link),
                            "location" => Ok(__FieldTag::__location),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "progress" => Ok(__FieldTag::__progress),
                            "clusterConditions" => Ok(__FieldTag::__cluster_conditions),
                            "cluster_conditions" => Ok(__FieldTag::__cluster_conditions),
                            "nodepoolConditions" => Ok(__FieldTag::__nodepool_conditions),
                            "nodepool_conditions" => Ok(__FieldTag::__nodepool_conditions),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Operation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Operation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation_type => {
                            if !fields.insert(__FieldTag::__operation_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_type",
                                ));
                            }
                            result.operation_type = map
                                .next_value::<std::option::Option<crate::model::operation::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::operation::Status>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detail => {
                            if !fields.insert(__FieldTag::__detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detail",
                                ));
                            }
                            result.detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_link => {
                            if !fields.insert(__FieldTag::__target_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_link",
                                ));
                            }
                            result.target_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress => {
                            if !fields.insert(__FieldTag::__progress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress",
                                ));
                            }
                            result.progress = map
                                .next_value::<std::option::Option<crate::model::OperationProgress>>(
                                )?;
                        }
                        __FieldTag::__cluster_conditions => {
                            if !fields.insert(__FieldTag::__cluster_conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_conditions",
                                ));
                            }
                            result.cluster_conditions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StatusCondition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nodepool_conditions => {
                            if !fields.insert(__FieldTag::__nodepool_conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nodepool_conditions",
                                ));
                            }
                            result.nodepool_conditions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StatusCondition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::OperationProgress {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __status,
            __metrics,
            __stages,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationProgress")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "status" => Ok(__FieldTag::__status),
                            "metrics" => Ok(__FieldTag::__metrics),
                            "stages" => Ok(__FieldTag::__stages),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::OperationProgress;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationProgress")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::operation::Status>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metrics => {
                            if !fields.insert(__FieldTag::__metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metrics",
                                ));
                            }
                            result.metrics = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::operation_progress::Metric>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__stages => {
                            if !fields.insert(__FieldTag::__stages) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stages",
                                ));
                            }
                            result.stages =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::OperationProgress>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::operation_progress::Metric {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __int_value,
            __double_value,
            __string_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Metric")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "intValue" => Ok(__FieldTag::__int_value),
                            "int_value" => Ok(__FieldTag::__int_value),
                            "doubleValue" => Ok(__FieldTag::__double_value),
                            "double_value" => Ok(__FieldTag::__double_value),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::operation_progress::Metric;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Metric")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__int_value => {
                            if !fields.insert(__FieldTag::__int_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.container.v1.OperationProgress.Metric.int_value, latest field was intValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::operation_progress::metric::Value::IntValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__double_value => {
                            if !fields.insert(__FieldTag::__double_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for double_value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.container.v1.OperationProgress.Metric.double_value, latest field was doubleValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::operation_progress::metric::Value::DoubleValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.container.v1.OperationProgress.Metric.string_value, latest field was stringValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::operation_progress::metric::Value::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __update,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "update" => Ok(__FieldTag::__update),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update => {
                            if !fields.insert(__FieldTag::__update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update",
                                ));
                            }
                            result.update = map
                                .next_value::<std::option::Option<crate::model::ClusterUpdate>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __node_version,
            __image_type,
            __name,
            __locations,
            __workload_metadata_config,
            __upgrade_settings,
            __tags,
            __taints,
            __labels,
            __linux_node_config,
            __kubelet_config,
            __node_network_config,
            __gcfs_config,
            __confidential_nodes,
            __gvnic,
            __etag,
            __fast_socket,
            __logging_config,
            __resource_labels,
            __windows_node_config,
            __accelerators,
            __machine_type,
            __disk_type,
            __disk_size_gb,
            __resource_manager_tags,
            __containerd_config,
            __queued_provisioning,
            __storage_pools,
            __max_run_duration,
            __flex_start,
            __boot_disk,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "nodeVersion" => Ok(__FieldTag::__node_version),
                            "node_version" => Ok(__FieldTag::__node_version),
                            "imageType" => Ok(__FieldTag::__image_type),
                            "image_type" => Ok(__FieldTag::__image_type),
                            "name" => Ok(__FieldTag::__name),
                            "locations" => Ok(__FieldTag::__locations),
                            "workloadMetadataConfig" => Ok(__FieldTag::__workload_metadata_config),
                            "workload_metadata_config" => {
                                Ok(__FieldTag::__workload_metadata_config)
                            }
                            "upgradeSettings" => Ok(__FieldTag::__upgrade_settings),
                            "upgrade_settings" => Ok(__FieldTag::__upgrade_settings),
                            "tags" => Ok(__FieldTag::__tags),
                            "taints" => Ok(__FieldTag::__taints),
                            "labels" => Ok(__FieldTag::__labels),
                            "linuxNodeConfig" => Ok(__FieldTag::__linux_node_config),
                            "linux_node_config" => Ok(__FieldTag::__linux_node_config),
                            "kubeletConfig" => Ok(__FieldTag::__kubelet_config),
                            "kubelet_config" => Ok(__FieldTag::__kubelet_config),
                            "nodeNetworkConfig" => Ok(__FieldTag::__node_network_config),
                            "node_network_config" => Ok(__FieldTag::__node_network_config),
                            "gcfsConfig" => Ok(__FieldTag::__gcfs_config),
                            "gcfs_config" => Ok(__FieldTag::__gcfs_config),
                            "confidentialNodes" => Ok(__FieldTag::__confidential_nodes),
                            "confidential_nodes" => Ok(__FieldTag::__confidential_nodes),
                            "gvnic" => Ok(__FieldTag::__gvnic),
                            "etag" => Ok(__FieldTag::__etag),
                            "fastSocket" => Ok(__FieldTag::__fast_socket),
                            "fast_socket" => Ok(__FieldTag::__fast_socket),
                            "loggingConfig" => Ok(__FieldTag::__logging_config),
                            "logging_config" => Ok(__FieldTag::__logging_config),
                            "resourceLabels" => Ok(__FieldTag::__resource_labels),
                            "resource_labels" => Ok(__FieldTag::__resource_labels),
                            "windowsNodeConfig" => Ok(__FieldTag::__windows_node_config),
                            "windows_node_config" => Ok(__FieldTag::__windows_node_config),
                            "accelerators" => Ok(__FieldTag::__accelerators),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "resourceManagerTags" => Ok(__FieldTag::__resource_manager_tags),
                            "resource_manager_tags" => Ok(__FieldTag::__resource_manager_tags),
                            "containerdConfig" => Ok(__FieldTag::__containerd_config),
                            "containerd_config" => Ok(__FieldTag::__containerd_config),
                            "queuedProvisioning" => Ok(__FieldTag::__queued_provisioning),
                            "queued_provisioning" => Ok(__FieldTag::__queued_provisioning),
                            "storagePools" => Ok(__FieldTag::__storage_pools),
                            "storage_pools" => Ok(__FieldTag::__storage_pools),
                            "maxRunDuration" => Ok(__FieldTag::__max_run_duration),
                            "max_run_duration" => Ok(__FieldTag::__max_run_duration),
                            "flexStart" => Ok(__FieldTag::__flex_start),
                            "flex_start" => Ok(__FieldTag::__flex_start),
                            "bootDisk" => Ok(__FieldTag::__boot_disk),
                            "boot_disk" => Ok(__FieldTag::__boot_disk),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_version => {
                            if !fields.insert(__FieldTag::__node_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_version",
                                ));
                            }
                            result.node_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_type => {
                            if !fields.insert(__FieldTag::__image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_type",
                                ));
                            }
                            result.image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__workload_metadata_config => {
                            if !fields.insert(__FieldTag::__workload_metadata_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_metadata_config",
                                ));
                            }
                            result.workload_metadata_config = map.next_value::<std::option::Option<crate::model::WorkloadMetadataConfig>>()?
                                ;
                        }
                        __FieldTag::__upgrade_settings => {
                            if !fields.insert(__FieldTag::__upgrade_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_settings",
                                ));
                            }
                            result.upgrade_settings = map.next_value::<std::option::Option<crate::model::node_pool::UpgradeSettings>>()?
                                ;
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags =
                                map.next_value::<std::option::Option<crate::model::NetworkTags>>()?;
                        }
                        __FieldTag::__taints => {
                            if !fields.insert(__FieldTag::__taints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for taints",
                                ));
                            }
                            result.taints =
                                map.next_value::<std::option::Option<crate::model::NodeTaints>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels =
                                map.next_value::<std::option::Option<crate::model::NodeLabels>>()?;
                        }
                        __FieldTag::__linux_node_config => {
                            if !fields.insert(__FieldTag::__linux_node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linux_node_config",
                                ));
                            }
                            result.linux_node_config = map
                                .next_value::<std::option::Option<crate::model::LinuxNodeConfig>>(
                                )?;
                        }
                        __FieldTag::__kubelet_config => {
                            if !fields.insert(__FieldTag::__kubelet_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kubelet_config",
                                ));
                            }
                            result.kubelet_config = map
                                .next_value::<std::option::Option<crate::model::NodeKubeletConfig>>(
                                )?;
                        }
                        __FieldTag::__node_network_config => {
                            if !fields.insert(__FieldTag::__node_network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_network_config",
                                ));
                            }
                            result.node_network_config = map
                                .next_value::<std::option::Option<crate::model::NodeNetworkConfig>>(
                                )?;
                        }
                        __FieldTag::__gcfs_config => {
                            if !fields.insert(__FieldTag::__gcfs_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcfs_config",
                                ));
                            }
                            result.gcfs_config =
                                map.next_value::<std::option::Option<crate::model::GcfsConfig>>()?;
                        }
                        __FieldTag::__confidential_nodes => {
                            if !fields.insert(__FieldTag::__confidential_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidential_nodes",
                                ));
                            }
                            result.confidential_nodes = map
                                .next_value::<std::option::Option<crate::model::ConfidentialNodes>>(
                                )?;
                        }
                        __FieldTag::__gvnic => {
                            if !fields.insert(__FieldTag::__gvnic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gvnic",
                                ));
                            }
                            result.gvnic =
                                map.next_value::<std::option::Option<crate::model::VirtualNIC>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fast_socket => {
                            if !fields.insert(__FieldTag::__fast_socket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fast_socket",
                                ));
                            }
                            result.fast_socket =
                                map.next_value::<std::option::Option<crate::model::FastSocket>>()?;
                        }
                        __FieldTag::__logging_config => {
                            if !fields.insert(__FieldTag::__logging_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_config",
                                ));
                            }
                            result.logging_config = map.next_value::<std::option::Option<crate::model::NodePoolLoggingConfig>>()?
                                ;
                        }
                        __FieldTag::__resource_labels => {
                            if !fields.insert(__FieldTag::__resource_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_labels",
                                ));
                            }
                            result.resource_labels = map
                                .next_value::<std::option::Option<crate::model::ResourceLabels>>(
                                )?;
                        }
                        __FieldTag::__windows_node_config => {
                            if !fields.insert(__FieldTag::__windows_node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for windows_node_config",
                                ));
                            }
                            result.windows_node_config = map
                                .next_value::<std::option::Option<crate::model::WindowsNodeConfig>>(
                                )?;
                        }
                        __FieldTag::__accelerators => {
                            if !fields.insert(__FieldTag::__accelerators) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerators",
                                ));
                            }
                            result.accelerators =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AcceleratorConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__resource_manager_tags => {
                            if !fields.insert(__FieldTag::__resource_manager_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_manager_tags",
                                ));
                            }
                            result.resource_manager_tags = map.next_value::<std::option::Option<crate::model::ResourceManagerTags>>()?
                                ;
                        }
                        __FieldTag::__containerd_config => {
                            if !fields.insert(__FieldTag::__containerd_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for containerd_config",
                                ));
                            }
                            result.containerd_config = map
                                .next_value::<std::option::Option<crate::model::ContainerdConfig>>(
                                )?;
                        }
                        __FieldTag::__queued_provisioning => {
                            if !fields.insert(__FieldTag::__queued_provisioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queued_provisioning",
                                ));
                            }
                            result.queued_provisioning =
                                map.next_value::<std::option::Option<
                                    crate::model::node_pool::QueuedProvisioning,
                                >>()?;
                        }
                        __FieldTag::__storage_pools => {
                            if !fields.insert(__FieldTag::__storage_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_pools",
                                ));
                            }
                            result.storage_pools = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__max_run_duration => {
                            if !fields.insert(__FieldTag::__max_run_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_run_duration",
                                ));
                            }
                            result.max_run_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__flex_start => {
                            if !fields.insert(__FieldTag::__flex_start) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for flex_start",
                                ));
                            }
                            result.flex_start = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__boot_disk => {
                            if !fields.insert(__FieldTag::__boot_disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk",
                                ));
                            }
                            result.boot_disk =
                                map.next_value::<std::option::Option<crate::model::BootDisk>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetNodePoolAutoscalingRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __autoscaling,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetNodePoolAutoscalingRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "autoscaling" => Ok(__FieldTag::__autoscaling),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetNodePoolAutoscalingRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetNodePoolAutoscalingRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autoscaling => {
                            if !fields.insert(__FieldTag::__autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling",
                                ));
                            }
                            result.autoscaling = map.next_value::<std::option::Option<crate::model::NodePoolAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetLoggingServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __logging_service,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetLoggingServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "loggingService" => Ok(__FieldTag::__logging_service),
                            "logging_service" => Ok(__FieldTag::__logging_service),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetLoggingServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetLoggingServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logging_service => {
                            if !fields.insert(__FieldTag::__logging_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logging_service",
                                ));
                            }
                            result.logging_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetMonitoringServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __monitoring_service,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetMonitoringServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "monitoringService" => Ok(__FieldTag::__monitoring_service),
                            "monitoring_service" => Ok(__FieldTag::__monitoring_service),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetMonitoringServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetMonitoringServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monitoring_service => {
                            if !fields.insert(__FieldTag::__monitoring_service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitoring_service",
                                ));
                            }
                            result.monitoring_service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetAddonsConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __addons_config,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetAddonsConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "addonsConfig" => Ok(__FieldTag::__addons_config),
                            "addons_config" => Ok(__FieldTag::__addons_config),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetAddonsConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetAddonsConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__addons_config => {
                            if !fields.insert(__FieldTag::__addons_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for addons_config",
                                ));
                            }
                            result.addons_config = map
                                .next_value::<std::option::Option<crate::model::AddonsConfig>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetLocationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __locations,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetLocationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "locations" => Ok(__FieldTag::__locations),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetLocationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetLocationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpdateMasterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __master_version,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateMasterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "masterVersion" => Ok(__FieldTag::__master_version),
                            "master_version" => Ok(__FieldTag::__master_version),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpdateMasterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateMasterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__master_version => {
                            if !fields.insert(__FieldTag::__master_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for master_version",
                                ));
                            }
                            result.master_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetMasterAuthRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __action,
            __update,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetMasterAuthRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "action" => Ok(__FieldTag::__action),
                            "update" => Ok(__FieldTag::__update),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetMasterAuthRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetMasterAuthRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action =
                                map.next_value::<std::option::Option<
                                    crate::model::set_master_auth_request::Action,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update => {
                            if !fields.insert(__FieldTag::__update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update",
                                ));
                            }
                            result.update =
                                map.next_value::<std::option::Option<crate::model::MasterAuth>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clusters,
            __missing_zones,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusters" => Ok(__FieldTag::__clusters),
                            "missingZones" => Ok(__FieldTag::__missing_zones),
                            "missing_zones" => Ok(__FieldTag::__missing_zones),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clusters => {
                            if !fields.insert(__FieldTag::__clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clusters",
                                ));
                            }
                            result.clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Cluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__missing_zones => {
                            if !fields.insert(__FieldTag::__missing_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for missing_zones",
                                ));
                            }
                            result.missing_zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __operation_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "operationId" => Ok(__FieldTag::__operation_id),
                            "operation_id" => Ok(__FieldTag::__operation_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation_id => {
                            if !fields.insert(__FieldTag::__operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_id",
                                ));
                            }
                            result.operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListOperationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOperationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListOperationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOperationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CancelOperationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __operation_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelOperationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "operationId" => Ok(__FieldTag::__operation_id),
                            "operation_id" => Ok(__FieldTag::__operation_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CancelOperationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelOperationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation_id => {
                            if !fields.insert(__FieldTag::__operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_id",
                                ));
                            }
                            result.operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListOperationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operations,
            __missing_zones,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListOperationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operations" => Ok(__FieldTag::__operations),
                            "missingZones" => Ok(__FieldTag::__missing_zones),
                            "missing_zones" => Ok(__FieldTag::__missing_zones),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListOperationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListOperationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operations => {
                            if !fields.insert(__FieldTag::__operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations",
                                ));
                            }
                            result.operations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Operation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__missing_zones => {
                            if !fields.insert(__FieldTag::__missing_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for missing_zones",
                                ));
                            }
                            result.missing_zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetServerConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServerConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetServerConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServerConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ServerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __default_cluster_version,
            __valid_node_versions,
            __default_image_type,
            __valid_image_types,
            __valid_master_versions,
            __channels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "defaultClusterVersion" => Ok(__FieldTag::__default_cluster_version),
                            "default_cluster_version" => Ok(__FieldTag::__default_cluster_version),
                            "validNodeVersions" => Ok(__FieldTag::__valid_node_versions),
                            "valid_node_versions" => Ok(__FieldTag::__valid_node_versions),
                            "defaultImageType" => Ok(__FieldTag::__default_image_type),
                            "default_image_type" => Ok(__FieldTag::__default_image_type),
                            "validImageTypes" => Ok(__FieldTag::__valid_image_types),
                            "valid_image_types" => Ok(__FieldTag::__valid_image_types),
                            "validMasterVersions" => Ok(__FieldTag::__valid_master_versions),
                            "valid_master_versions" => Ok(__FieldTag::__valid_master_versions),
                            "channels" => Ok(__FieldTag::__channels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ServerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__default_cluster_version => {
                            if !fields.insert(__FieldTag::__default_cluster_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_cluster_version",
                                ));
                            }
                            result.default_cluster_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__valid_node_versions => {
                            if !fields.insert(__FieldTag::__valid_node_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid_node_versions",
                                ));
                            }
                            result.valid_node_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_image_type => {
                            if !fields.insert(__FieldTag::__default_image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_image_type",
                                ));
                            }
                            result.default_image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__valid_image_types => {
                            if !fields.insert(__FieldTag::__valid_image_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid_image_types",
                                ));
                            }
                            result.valid_image_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__valid_master_versions => {
                            if !fields.insert(__FieldTag::__valid_master_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid_master_versions",
                                ));
                            }
                            result.valid_master_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__channels => {
                            if !fields.insert(__FieldTag::__channels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channels",
                                ));
                            }
                            result.channels = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::server_config::ReleaseChannelConfig,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::server_config::ReleaseChannelConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channel,
            __default_version,
            __valid_versions,
            __upgrade_target_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReleaseChannelConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channel" => Ok(__FieldTag::__channel),
                            "defaultVersion" => Ok(__FieldTag::__default_version),
                            "default_version" => Ok(__FieldTag::__default_version),
                            "validVersions" => Ok(__FieldTag::__valid_versions),
                            "valid_versions" => Ok(__FieldTag::__valid_versions),
                            "upgradeTargetVersion" => Ok(__FieldTag::__upgrade_target_version),
                            "upgrade_target_version" => Ok(__FieldTag::__upgrade_target_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::server_config::ReleaseChannelConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReleaseChannelConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel = map.next_value::<std::option::Option<crate::model::release_channel::Channel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_version => {
                            if !fields.insert(__FieldTag::__default_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_version",
                                ));
                            }
                            result.default_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__valid_versions => {
                            if !fields.insert(__FieldTag::__valid_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for valid_versions",
                                ));
                            }
                            result.valid_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__upgrade_target_version => {
                            if !fields.insert(__FieldTag::__upgrade_target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_target_version",
                                ));
                            }
                            result.upgrade_target_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CreateNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePool" => Ok(__FieldTag::__node_pool),
                            "node_pool" => Ok(__FieldTag::__node_pool),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CreateNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool => {
                            if !fields.insert(__FieldTag::__node_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool",
                                ));
                            }
                            result.node_pool =
                                map.next_value::<std::option::Option<crate::model::NodePool>>()?;
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DeleteNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DeleteNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListNodePoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNodePoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListNodePoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNodePoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BlueGreenSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __standard_rollout_policy,
            __node_pool_soak_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BlueGreenSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "standardRolloutPolicy" => Ok(__FieldTag::__standard_rollout_policy),
                            "standard_rollout_policy" => Ok(__FieldTag::__standard_rollout_policy),
                            "nodePoolSoakDuration" => Ok(__FieldTag::__node_pool_soak_duration),
                            "node_pool_soak_duration" => Ok(__FieldTag::__node_pool_soak_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BlueGreenSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BlueGreenSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__standard_rollout_policy => {
                            if !fields.insert(__FieldTag::__standard_rollout_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard_rollout_policy",
                                ));
                            }
                            if result.rollout_policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rollout_policy`, a oneof with full ID .google.container.v1.BlueGreenSettings.standard_rollout_policy, latest field was standardRolloutPolicy",
                                ));
                            }
                            result.rollout_policy = std::option::Option::Some(
                                crate::model::blue_green_settings::RolloutPolicy::StandardRolloutPolicy(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::blue_green_settings::StandardRolloutPolicy>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__node_pool_soak_duration => {
                            if !fields.insert(__FieldTag::__node_pool_soak_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_soak_duration",
                                ));
                            }
                            result.node_pool_soak_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::blue_green_settings::StandardRolloutPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __batch_percentage,
            __batch_node_count,
            __batch_soak_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardRolloutPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "batchPercentage" => Ok(__FieldTag::__batch_percentage),
                            "batch_percentage" => Ok(__FieldTag::__batch_percentage),
                            "batchNodeCount" => Ok(__FieldTag::__batch_node_count),
                            "batch_node_count" => Ok(__FieldTag::__batch_node_count),
                            "batchSoakDuration" => Ok(__FieldTag::__batch_soak_duration),
                            "batch_soak_duration" => Ok(__FieldTag::__batch_soak_duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::blue_green_settings::StandardRolloutPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardRolloutPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__batch_percentage => {
                            if !fields.insert(__FieldTag::__batch_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch_percentage",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.update_batch_size.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `update_batch_size`, a oneof with full ID .google.container.v1.BlueGreenSettings.StandardRolloutPolicy.batch_percentage, latest field was batchPercentage",
                                ));
                            }
                            result.update_batch_size = std::option::Option::Some(
                                crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchPercentage(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__batch_node_count => {
                            if !fields.insert(__FieldTag::__batch_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.update_batch_size.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `update_batch_size`, a oneof with full ID .google.container.v1.BlueGreenSettings.StandardRolloutPolicy.batch_node_count, latest field was batchNodeCount",
                                ));
                            }
                            result.update_batch_size = std::option::Option::Some(
                                crate::model::blue_green_settings::standard_rollout_policy::UpdateBatchSize::BatchNodeCount(
                                    map.next_value::<__With>()?.0.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__batch_soak_duration => {
                            if !fields.insert(__FieldTag::__batch_soak_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for batch_soak_duration",
                                ));
                            }
                            result.batch_soak_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodePool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __config,
            __initial_node_count,
            __locations,
            __network_config,
            __self_link,
            __version,
            __instance_group_urls,
            __status,
            __status_message,
            __autoscaling,
            __management,
            __max_pods_constraint,
            __conditions,
            __pod_ipv4_cidr_size,
            __upgrade_settings,
            __placement_policy,
            __update_info,
            __etag,
            __queued_provisioning,
            __best_effort_provisioning,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "config" => Ok(__FieldTag::__config),
                            "initialNodeCount" => Ok(__FieldTag::__initial_node_count),
                            "initial_node_count" => Ok(__FieldTag::__initial_node_count),
                            "locations" => Ok(__FieldTag::__locations),
                            "networkConfig" => Ok(__FieldTag::__network_config),
                            "network_config" => Ok(__FieldTag::__network_config),
                            "selfLink" => Ok(__FieldTag::__self_link),
                            "self_link" => Ok(__FieldTag::__self_link),
                            "version" => Ok(__FieldTag::__version),
                            "instanceGroupUrls" => Ok(__FieldTag::__instance_group_urls),
                            "instance_group_urls" => Ok(__FieldTag::__instance_group_urls),
                            "status" => Ok(__FieldTag::__status),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "autoscaling" => Ok(__FieldTag::__autoscaling),
                            "management" => Ok(__FieldTag::__management),
                            "maxPodsConstraint" => Ok(__FieldTag::__max_pods_constraint),
                            "max_pods_constraint" => Ok(__FieldTag::__max_pods_constraint),
                            "conditions" => Ok(__FieldTag::__conditions),
                            "podIpv4CidrSize" => Ok(__FieldTag::__pod_ipv4_cidr_size),
                            "pod_ipv4_cidr_size" => Ok(__FieldTag::__pod_ipv4_cidr_size),
                            "upgradeSettings" => Ok(__FieldTag::__upgrade_settings),
                            "upgrade_settings" => Ok(__FieldTag::__upgrade_settings),
                            "placementPolicy" => Ok(__FieldTag::__placement_policy),
                            "placement_policy" => Ok(__FieldTag::__placement_policy),
                            "updateInfo" => Ok(__FieldTag::__update_info),
                            "update_info" => Ok(__FieldTag::__update_info),
                            "etag" => Ok(__FieldTag::__etag),
                            "queuedProvisioning" => Ok(__FieldTag::__queued_provisioning),
                            "queued_provisioning" => Ok(__FieldTag::__queued_provisioning),
                            "bestEffortProvisioning" => Ok(__FieldTag::__best_effort_provisioning),
                            "best_effort_provisioning" => {
                                Ok(__FieldTag::__best_effort_provisioning)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodePool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config =
                                map.next_value::<std::option::Option<crate::model::NodeConfig>>()?;
                        }
                        __FieldTag::__initial_node_count => {
                            if !fields.insert(__FieldTag::__initial_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.initial_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__network_config => {
                            if !fields.insert(__FieldTag::__network_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_config",
                                ));
                            }
                            result.network_config = map
                                .next_value::<std::option::Option<crate::model::NodeNetworkConfig>>(
                                )?;
                        }
                        __FieldTag::__self_link => {
                            if !fields.insert(__FieldTag::__self_link) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for self_link",
                                ));
                            }
                            result.self_link = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_group_urls => {
                            if !fields.insert(__FieldTag::__instance_group_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_group_urls",
                                ));
                            }
                            result.instance_group_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::node_pool::Status>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autoscaling => {
                            if !fields.insert(__FieldTag::__autoscaling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling",
                                ));
                            }
                            result.autoscaling = map.next_value::<std::option::Option<crate::model::NodePoolAutoscaling>>()?
                                ;
                        }
                        __FieldTag::__management => {
                            if !fields.insert(__FieldTag::__management) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management",
                                ));
                            }
                            result.management = map
                                .next_value::<std::option::Option<crate::model::NodeManagement>>(
                                )?;
                        }
                        __FieldTag::__max_pods_constraint => {
                            if !fields.insert(__FieldTag::__max_pods_constraint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_pods_constraint",
                                ));
                            }
                            result.max_pods_constraint = map
                                .next_value::<std::option::Option<crate::model::MaxPodsConstraint>>(
                                )?;
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::StatusCondition>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pod_ipv4_cidr_size => {
                            if !fields.insert(__FieldTag::__pod_ipv4_cidr_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pod_ipv4_cidr_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.pod_ipv4_cidr_size =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__upgrade_settings => {
                            if !fields.insert(__FieldTag::__upgrade_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_settings",
                                ));
                            }
                            result.upgrade_settings = map.next_value::<std::option::Option<crate::model::node_pool::UpgradeSettings>>()?
                                ;
                        }
                        __FieldTag::__placement_policy => {
                            if !fields.insert(__FieldTag::__placement_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for placement_policy",
                                ));
                            }
                            result.placement_policy = map.next_value::<std::option::Option<crate::model::node_pool::PlacementPolicy>>()?
                                ;
                        }
                        __FieldTag::__update_info => {
                            if !fields.insert(__FieldTag::__update_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_info",
                                ));
                            }
                            result.update_info = map.next_value::<std::option::Option<crate::model::node_pool::UpdateInfo>>()?
                                ;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__queued_provisioning => {
                            if !fields.insert(__FieldTag::__queued_provisioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for queued_provisioning",
                                ));
                            }
                            result.queued_provisioning =
                                map.next_value::<std::option::Option<
                                    crate::model::node_pool::QueuedProvisioning,
                                >>()?;
                        }
                        __FieldTag::__best_effort_provisioning => {
                            if !fields.insert(__FieldTag::__best_effort_provisioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for best_effort_provisioning",
                                ));
                            }
                            result.best_effort_provisioning = map.next_value::<std::option::Option<crate::model::BestEffortProvisioning>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::node_pool::UpgradeSettings {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_surge,
            __max_unavailable,
            __strategy,
            __blue_green_settings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeSettings")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxSurge" => Ok(__FieldTag::__max_surge),
                            "max_surge" => Ok(__FieldTag::__max_surge),
                            "maxUnavailable" => Ok(__FieldTag::__max_unavailable),
                            "max_unavailable" => Ok(__FieldTag::__max_unavailable),
                            "strategy" => Ok(__FieldTag::__strategy),
                            "blueGreenSettings" => Ok(__FieldTag::__blue_green_settings),
                            "blue_green_settings" => Ok(__FieldTag::__blue_green_settings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::node_pool::UpgradeSettings;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeSettings")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_surge => {
                            if !fields.insert(__FieldTag::__max_surge) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_surge",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_surge = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_unavailable => {
                            if !fields.insert(__FieldTag::__max_unavailable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_unavailable",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_unavailable =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__strategy => {
                            if !fields.insert(__FieldTag::__strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for strategy",
                                ));
                            }
                            result.strategy = map.next_value::<std::option::Option<crate::model::NodePoolUpdateStrategy>>()?
                                ;
                        }
                        __FieldTag::__blue_green_settings => {
                            if !fields.insert(__FieldTag::__blue_green_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blue_green_settings",
                                ));
                            }
                            result.blue_green_settings = map
                                .next_value::<std::option::Option<crate::model::BlueGreenSettings>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::node_pool::UpdateInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __blue_green_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "blueGreenInfo" => Ok(__FieldTag::__blue_green_info),
                            "blue_green_info" => Ok(__FieldTag::__blue_green_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::node_pool::UpdateInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__blue_green_info => {
                            if !fields.insert(__FieldTag::__blue_green_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blue_green_info",
                                ));
                            }
                            result.blue_green_info = map.next_value::<std::option::Option<
                                crate::model::node_pool::update_info::BlueGreenInfo,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::node_pool::update_info::BlueGreenInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __phase,
            __blue_instance_group_urls,
            __green_instance_group_urls,
            __blue_pool_deletion_start_time,
            __green_pool_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BlueGreenInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "phase" => Ok(__FieldTag::__phase),
                            "blueInstanceGroupUrls" => Ok(__FieldTag::__blue_instance_group_urls),
                            "blue_instance_group_urls" => {
                                Ok(__FieldTag::__blue_instance_group_urls)
                            }
                            "greenInstanceGroupUrls" => Ok(__FieldTag::__green_instance_group_urls),
                            "green_instance_group_urls" => {
                                Ok(__FieldTag::__green_instance_group_urls)
                            }
                            "bluePoolDeletionStartTime" => {
                                Ok(__FieldTag::__blue_pool_deletion_start_time)
                            }
                            "blue_pool_deletion_start_time" => {
                                Ok(__FieldTag::__blue_pool_deletion_start_time)
                            }
                            "greenPoolVersion" => Ok(__FieldTag::__green_pool_version),
                            "green_pool_version" => Ok(__FieldTag::__green_pool_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::node_pool::update_info::BlueGreenInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BlueGreenInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__phase => {
                            if !fields.insert(__FieldTag::__phase) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for phase",
                                ));
                            }
                            result.phase = map
                                .next_value::<std::option::Option<
                                    crate::model::node_pool::update_info::blue_green_info::Phase,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__blue_instance_group_urls => {
                            if !fields.insert(__FieldTag::__blue_instance_group_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blue_instance_group_urls",
                                ));
                            }
                            result.blue_instance_group_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__green_instance_group_urls => {
                            if !fields.insert(__FieldTag::__green_instance_group_urls) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for green_instance_group_urls",
                                ));
                            }
                            result.green_instance_group_urls = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__blue_pool_deletion_start_time => {
                            if !fields.insert(__FieldTag::__blue_pool_deletion_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blue_pool_deletion_start_time",
                                ));
                            }
                            result.blue_pool_deletion_start_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__green_pool_version => {
                            if !fields.insert(__FieldTag::__green_pool_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for green_pool_version",
                                ));
                            }
                            result.green_pool_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::node_pool::PlacementPolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __tpu_topology,
            __policy_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PlacementPolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "tpuTopology" => Ok(__FieldTag::__tpu_topology),
                            "tpu_topology" => Ok(__FieldTag::__tpu_topology),
                            "policyName" => Ok(__FieldTag::__policy_name),
                            "policy_name" => Ok(__FieldTag::__policy_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::node_pool::PlacementPolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PlacementPolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::node_pool::placement_policy::Type,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tpu_topology => {
                            if !fields.insert(__FieldTag::__tpu_topology) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tpu_topology",
                                ));
                            }
                            result.tpu_topology = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy_name => {
                            if !fields.insert(__FieldTag::__policy_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy_name",
                                ));
                            }
                            result.policy_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::node_pool::QueuedProvisioning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueuedProvisioning")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::node_pool::QueuedProvisioning;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueuedProvisioning")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodeManagement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auto_upgrade,
            __auto_repair,
            __upgrade_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodeManagement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autoUpgrade" => Ok(__FieldTag::__auto_upgrade),
                            "auto_upgrade" => Ok(__FieldTag::__auto_upgrade),
                            "autoRepair" => Ok(__FieldTag::__auto_repair),
                            "auto_repair" => Ok(__FieldTag::__auto_repair),
                            "upgradeOptions" => Ok(__FieldTag::__upgrade_options),
                            "upgrade_options" => Ok(__FieldTag::__upgrade_options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodeManagement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodeManagement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auto_upgrade => {
                            if !fields.insert(__FieldTag::__auto_upgrade) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_upgrade",
                                ));
                            }
                            result.auto_upgrade = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_repair => {
                            if !fields.insert(__FieldTag::__auto_repair) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_repair",
                                ));
                            }
                            result.auto_repair = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgrade_options => {
                            if !fields.insert(__FieldTag::__upgrade_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_options",
                                ));
                            }
                            result.upgrade_options = map.next_value::<std::option::Option<crate::model::AutoUpgradeOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BestEffortProvisioning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __min_provision_nodes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BestEffortProvisioning")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "minProvisionNodes" => Ok(__FieldTag::__min_provision_nodes),
                            "min_provision_nodes" => Ok(__FieldTag::__min_provision_nodes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BestEffortProvisioning;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BestEffortProvisioning")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_provision_nodes => {
                            if !fields.insert(__FieldTag::__min_provision_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_provision_nodes",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_provision_nodes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutoUpgradeOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __auto_upgrade_start_time,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoUpgradeOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "autoUpgradeStartTime" => Ok(__FieldTag::__auto_upgrade_start_time),
                            "auto_upgrade_start_time" => Ok(__FieldTag::__auto_upgrade_start_time),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutoUpgradeOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoUpgradeOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__auto_upgrade_start_time => {
                            if !fields.insert(__FieldTag::__auto_upgrade_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_upgrade_start_time",
                                ));
                            }
                            result.auto_upgrade_start_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MaintenancePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __window,
            __resource_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenancePolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "window" => Ok(__FieldTag::__window),
                            "resourceVersion" => Ok(__FieldTag::__resource_version),
                            "resource_version" => Ok(__FieldTag::__resource_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MaintenancePolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenancePolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__window => {
                            if !fields.insert(__FieldTag::__window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for window",
                                ));
                            }
                            result.window = map
                                .next_value::<std::option::Option<crate::model::MaintenanceWindow>>(
                                )?;
                        }
                        __FieldTag::__resource_version => {
                            if !fields.insert(__FieldTag::__resource_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_version",
                                ));
                            }
                            result.resource_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MaintenanceWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __daily_maintenance_window,
            __recurring_window,
            __maintenance_exclusions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dailyMaintenanceWindow" => Ok(__FieldTag::__daily_maintenance_window),
                            "daily_maintenance_window" => {
                                Ok(__FieldTag::__daily_maintenance_window)
                            }
                            "recurringWindow" => Ok(__FieldTag::__recurring_window),
                            "recurring_window" => Ok(__FieldTag::__recurring_window),
                            "maintenanceExclusions" => Ok(__FieldTag::__maintenance_exclusions),
                            "maintenance_exclusions" => Ok(__FieldTag::__maintenance_exclusions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MaintenanceWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__daily_maintenance_window => {
                            if !fields.insert(__FieldTag::__daily_maintenance_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for daily_maintenance_window",
                                ));
                            }
                            if result.policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `policy`, a oneof with full ID .google.container.v1.MaintenanceWindow.daily_maintenance_window, latest field was dailyMaintenanceWindow",
                                ));
                            }
                            result.policy = std::option::Option::Some(
                                crate::model::maintenance_window::Policy::DailyMaintenanceWindow(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DailyMaintenanceWindow>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__recurring_window => {
                            if !fields.insert(__FieldTag::__recurring_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurring_window",
                                ));
                            }
                            if result.policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `policy`, a oneof with full ID .google.container.v1.MaintenanceWindow.recurring_window, latest field was recurringWindow",
                                ));
                            }
                            result.policy = std::option::Option::Some(
                                crate::model::maintenance_window::Policy::RecurringWindow(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::RecurringTimeWindow>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__maintenance_exclusions => {
                            if !fields.insert(__FieldTag::__maintenance_exclusions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_exclusions",
                                ));
                            }
                            result.maintenance_exclusions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::TimeWindow,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TimeWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __maintenance_exclusion_options,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maintenanceExclusionOptions" => {
                                Ok(__FieldTag::__maintenance_exclusion_options)
                            }
                            "maintenance_exclusion_options" => {
                                Ok(__FieldTag::__maintenance_exclusion_options)
                            }
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TimeWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__maintenance_exclusion_options => {
                            if !fields.insert(__FieldTag::__maintenance_exclusion_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_exclusion_options",
                                ));
                            }
                            if result.options.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `options`, a oneof with full ID .google.container.v1.TimeWindow.maintenance_exclusion_options, latest field was maintenanceExclusionOptions",
                                ));
                            }
                            result.options = std::option::Option::Some(
                                crate::model::time_window::Options::MaintenanceExclusionOptions(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::MaintenanceExclusionOptions>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MaintenanceExclusionOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceExclusionOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MaintenanceExclusionOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceExclusionOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope = map
                                .next_value::<std::option::Option<
                                    crate::model::maintenance_exclusion_options::Scope,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RecurringTimeWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __window,
            __recurrence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecurringTimeWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "window" => Ok(__FieldTag::__window),
                            "recurrence" => Ok(__FieldTag::__recurrence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RecurringTimeWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecurringTimeWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__window => {
                            if !fields.insert(__FieldTag::__window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for window",
                                ));
                            }
                            result.window =
                                map.next_value::<std::option::Option<crate::model::TimeWindow>>()?;
                        }
                        __FieldTag::__recurrence => {
                            if !fields.insert(__FieldTag::__recurrence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurrence",
                                ));
                            }
                            result.recurrence = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DailyMaintenanceWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DailyMaintenanceWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "duration" => Ok(__FieldTag::__duration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DailyMaintenanceWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DailyMaintenanceWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__duration => {
                            if !fields.insert(__FieldTag::__duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for duration",
                                ));
                            }
                            result.duration = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetNodePoolManagementRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __management,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetNodePoolManagementRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "management" => Ok(__FieldTag::__management),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetNodePoolManagementRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetNodePoolManagementRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__management => {
                            if !fields.insert(__FieldTag::__management) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management",
                                ));
                            }
                            result.management = map
                                .next_value::<std::option::Option<crate::model::NodeManagement>>(
                                )?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetNodePoolSizeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __node_count,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetNodePoolSizeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "nodeCount" => Ok(__FieldTag::__node_count),
                            "node_count" => Ok(__FieldTag::__node_count),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetNodePoolSizeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetNodePoolSizeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_count => {
                            if !fields.insert(__FieldTag::__node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.node_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CompleteNodePoolUpgradeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompleteNodePoolUpgradeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CompleteNodePoolUpgradeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompleteNodePoolUpgradeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RollbackNodePoolUpgradeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __node_pool_id,
            __name,
            __respect_pdb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RollbackNodePoolUpgradeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "name" => Ok(__FieldTag::__name),
                            "respectPdb" => Ok(__FieldTag::__respect_pdb),
                            "respect_pdb" => Ok(__FieldTag::__respect_pdb),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RollbackNodePoolUpgradeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RollbackNodePoolUpgradeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__respect_pdb => {
                            if !fields.insert(__FieldTag::__respect_pdb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for respect_pdb",
                                ));
                            }
                            result.respect_pdb = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListNodePoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_pools,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNodePoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodePools" => Ok(__FieldTag::__node_pools),
                            "node_pools" => Ok(__FieldTag::__node_pools),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListNodePoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNodePoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_pools => {
                            if !fields.insert(__FieldTag::__node_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pools",
                                ));
                            }
                            result.node_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NodePool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ClusterAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_node_autoprovisioning,
            __resource_limits,
            __autoscaling_profile,
            __autoprovisioning_node_pool_defaults,
            __autoprovisioning_locations,
            __default_compute_class_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableNodeAutoprovisioning" => {
                                Ok(__FieldTag::__enable_node_autoprovisioning)
                            }
                            "enable_node_autoprovisioning" => {
                                Ok(__FieldTag::__enable_node_autoprovisioning)
                            }
                            "resourceLimits" => Ok(__FieldTag::__resource_limits),
                            "resource_limits" => Ok(__FieldTag::__resource_limits),
                            "autoscalingProfile" => Ok(__FieldTag::__autoscaling_profile),
                            "autoscaling_profile" => Ok(__FieldTag::__autoscaling_profile),
                            "autoprovisioningNodePoolDefaults" => {
                                Ok(__FieldTag::__autoprovisioning_node_pool_defaults)
                            }
                            "autoprovisioning_node_pool_defaults" => {
                                Ok(__FieldTag::__autoprovisioning_node_pool_defaults)
                            }
                            "autoprovisioningLocations" => {
                                Ok(__FieldTag::__autoprovisioning_locations)
                            }
                            "autoprovisioning_locations" => {
                                Ok(__FieldTag::__autoprovisioning_locations)
                            }
                            "defaultComputeClassConfig" => {
                                Ok(__FieldTag::__default_compute_class_config)
                            }
                            "default_compute_class_config" => {
                                Ok(__FieldTag::__default_compute_class_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ClusterAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_node_autoprovisioning => {
                            if !fields.insert(__FieldTag::__enable_node_autoprovisioning) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_node_autoprovisioning",
                                ));
                            }
                            result.enable_node_autoprovisioning = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_limits => {
                            if !fields.insert(__FieldTag::__resource_limits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_limits",
                                ));
                            }
                            result.resource_limits = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ResourceLimit>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__autoscaling_profile => {
                            if !fields.insert(__FieldTag::__autoscaling_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoscaling_profile",
                                ));
                            }
                            result.autoscaling_profile = map
                                .next_value::<std::option::Option<
                                    crate::model::cluster_autoscaling::AutoscalingProfile,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__autoprovisioning_node_pool_defaults => {
                            if !fields.insert(__FieldTag::__autoprovisioning_node_pool_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoprovisioning_node_pool_defaults",
                                ));
                            }
                            result.autoprovisioning_node_pool_defaults = map
                                .next_value::<std::option::Option<
                                    crate::model::AutoprovisioningNodePoolDefaults,
                                >>()?;
                        }
                        __FieldTag::__autoprovisioning_locations => {
                            if !fields.insert(__FieldTag::__autoprovisioning_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoprovisioning_locations",
                                ));
                            }
                            result.autoprovisioning_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_compute_class_config => {
                            if !fields.insert(__FieldTag::__default_compute_class_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_compute_class_config",
                                ));
                            }
                            result.default_compute_class_config = map.next_value::<std::option::Option<crate::model::DefaultComputeClassConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutoprovisioningNodePoolDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __oauth_scopes,
            __service_account,
            __upgrade_settings,
            __management,
            __min_cpu_platform,
            __disk_size_gb,
            __disk_type,
            __shielded_instance_config,
            __boot_disk_kms_key,
            __image_type,
            __insecure_kubelet_readonly_port_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoprovisioningNodePoolDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "oauthScopes" => Ok(__FieldTag::__oauth_scopes),
                            "oauth_scopes" => Ok(__FieldTag::__oauth_scopes),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "upgradeSettings" => Ok(__FieldTag::__upgrade_settings),
                            "upgrade_settings" => Ok(__FieldTag::__upgrade_settings),
                            "management" => Ok(__FieldTag::__management),
                            "minCpuPlatform" => Ok(__FieldTag::__min_cpu_platform),
                            "min_cpu_platform" => Ok(__FieldTag::__min_cpu_platform),
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "shieldedInstanceConfig" => Ok(__FieldTag::__shielded_instance_config),
                            "shielded_instance_config" => {
                                Ok(__FieldTag::__shielded_instance_config)
                            }
                            "bootDiskKmsKey" => Ok(__FieldTag::__boot_disk_kms_key),
                            "boot_disk_kms_key" => Ok(__FieldTag::__boot_disk_kms_key),
                            "imageType" => Ok(__FieldTag::__image_type),
                            "image_type" => Ok(__FieldTag::__image_type),
                            "insecureKubeletReadonlyPortEnabled" => {
                                Ok(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            }
                            "insecure_kubelet_readonly_port_enabled" => {
                                Ok(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutoprovisioningNodePoolDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoprovisioningNodePoolDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__oauth_scopes => {
                            if !fields.insert(__FieldTag::__oauth_scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for oauth_scopes",
                                ));
                            }
                            result.oauth_scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgrade_settings => {
                            if !fields.insert(__FieldTag::__upgrade_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_settings",
                                ));
                            }
                            result.upgrade_settings = map.next_value::<std::option::Option<crate::model::node_pool::UpgradeSettings>>()?
                                ;
                        }
                        __FieldTag::__management => {
                            if !fields.insert(__FieldTag::__management) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for management",
                                ));
                            }
                            result.management = map
                                .next_value::<std::option::Option<crate::model::NodeManagement>>(
                                )?;
                        }
                        __FieldTag::__min_cpu_platform => {
                            if !fields.insert(__FieldTag::__min_cpu_platform) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_cpu_platform",
                                ));
                            }
                            result.min_cpu_platform = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__shielded_instance_config => {
                            if !fields.insert(__FieldTag::__shielded_instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shielded_instance_config",
                                ));
                            }
                            result.shielded_instance_config = map.next_value::<std::option::Option<crate::model::ShieldedInstanceConfig>>()?
                                ;
                        }
                        __FieldTag::__boot_disk_kms_key => {
                            if !fields.insert(__FieldTag::__boot_disk_kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk_kms_key",
                                ));
                            }
                            result.boot_disk_kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_type => {
                            if !fields.insert(__FieldTag::__image_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_type",
                                ));
                            }
                            result.image_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__insecure_kubelet_readonly_port_enabled => {
                            if !fields.insert(__FieldTag::__insecure_kubelet_readonly_port_enabled)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insecure_kubelet_readonly_port_enabled",
                                ));
                            }
                            result.insecure_kubelet_readonly_port_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResourceLimit {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_type,
            __minimum,
            __maximum,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceLimit")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "minimum" => Ok(__FieldTag::__minimum),
                            "maximum" => Ok(__FieldTag::__maximum),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResourceLimit;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceLimit")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__minimum => {
                            if !fields.insert(__FieldTag::__minimum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minimum",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.minimum = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__maximum => {
                            if !fields.insert(__FieldTag::__maximum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maximum",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.maximum = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DefaultComputeClassConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DefaultComputeClassConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DefaultComputeClassConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DefaultComputeClassConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodePoolAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __min_node_count,
            __max_node_count,
            __autoprovisioned,
            __location_policy,
            __total_min_node_count,
            __total_max_node_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePoolAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "minNodeCount" => Ok(__FieldTag::__min_node_count),
                            "min_node_count" => Ok(__FieldTag::__min_node_count),
                            "maxNodeCount" => Ok(__FieldTag::__max_node_count),
                            "max_node_count" => Ok(__FieldTag::__max_node_count),
                            "autoprovisioned" => Ok(__FieldTag::__autoprovisioned),
                            "locationPolicy" => Ok(__FieldTag::__location_policy),
                            "location_policy" => Ok(__FieldTag::__location_policy),
                            "totalMinNodeCount" => Ok(__FieldTag::__total_min_node_count),
                            "total_min_node_count" => Ok(__FieldTag::__total_min_node_count),
                            "totalMaxNodeCount" => Ok(__FieldTag::__total_max_node_count),
                            "total_max_node_count" => Ok(__FieldTag::__total_max_node_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodePoolAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePoolAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_node_count => {
                            if !fields.insert(__FieldTag::__min_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_node_count => {
                            if !fields.insert(__FieldTag::__max_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__autoprovisioned => {
                            if !fields.insert(__FieldTag::__autoprovisioned) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autoprovisioned",
                                ));
                            }
                            result.autoprovisioned = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location_policy => {
                            if !fields.insert(__FieldTag::__location_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location_policy",
                                ));
                            }
                            result.location_policy = map
                                .next_value::<std::option::Option<
                                    crate::model::node_pool_autoscaling::LocationPolicy,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_min_node_count => {
                            if !fields.insert(__FieldTag::__total_min_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_min_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_min_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__total_max_node_count => {
                            if !fields.insert(__FieldTag::__total_max_node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_max_node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_max_node_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetLabelsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __resource_labels,
            __label_fingerprint,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetLabelsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "resourceLabels" => Ok(__FieldTag::__resource_labels),
                            "resource_labels" => Ok(__FieldTag::__resource_labels),
                            "labelFingerprint" => Ok(__FieldTag::__label_fingerprint),
                            "label_fingerprint" => Ok(__FieldTag::__label_fingerprint),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetLabelsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetLabelsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_labels => {
                            if !fields.insert(__FieldTag::__resource_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_labels",
                                ));
                            }
                            result.resource_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__label_fingerprint => {
                            if !fields.insert(__FieldTag::__label_fingerprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for label_fingerprint",
                                ));
                            }
                            result.label_fingerprint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetLegacyAbacRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __enabled,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetLegacyAbacRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "enabled" => Ok(__FieldTag::__enabled),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetLegacyAbacRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetLegacyAbacRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StartIPRotationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __name,
            __rotate_credentials,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartIPRotationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "name" => Ok(__FieldTag::__name),
                            "rotateCredentials" => Ok(__FieldTag::__rotate_credentials),
                            "rotate_credentials" => Ok(__FieldTag::__rotate_credentials),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StartIPRotationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartIPRotationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rotate_credentials => {
                            if !fields.insert(__FieldTag::__rotate_credentials) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rotate_credentials",
                                ));
                            }
                            result.rotate_credentials = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CompleteIPRotationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompleteIPRotationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CompleteIPRotationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompleteIPRotationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AcceleratorConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __accelerator_count,
            __accelerator_type,
            __gpu_partition_size,
            __gpu_sharing_config,
            __gpu_driver_installation_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AcceleratorConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "acceleratorCount" => Ok(__FieldTag::__accelerator_count),
                            "accelerator_count" => Ok(__FieldTag::__accelerator_count),
                            "acceleratorType" => Ok(__FieldTag::__accelerator_type),
                            "accelerator_type" => Ok(__FieldTag::__accelerator_type),
                            "gpuPartitionSize" => Ok(__FieldTag::__gpu_partition_size),
                            "gpu_partition_size" => Ok(__FieldTag::__gpu_partition_size),
                            "gpuSharingConfig" => Ok(__FieldTag::__gpu_sharing_config),
                            "gpu_sharing_config" => Ok(__FieldTag::__gpu_sharing_config),
                            "gpuDriverInstallationConfig" => {
                                Ok(__FieldTag::__gpu_driver_installation_config)
                            }
                            "gpu_driver_installation_config" => {
                                Ok(__FieldTag::__gpu_driver_installation_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AcceleratorConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AcceleratorConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__accelerator_count => {
                            if !fields.insert(__FieldTag::__accelerator_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.accelerator_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__accelerator_type => {
                            if !fields.insert(__FieldTag::__accelerator_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_type",
                                ));
                            }
                            result.accelerator_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gpu_partition_size => {
                            if !fields.insert(__FieldTag::__gpu_partition_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_partition_size",
                                ));
                            }
                            result.gpu_partition_size = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gpu_sharing_config => {
                            if !fields.insert(__FieldTag::__gpu_sharing_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_sharing_config",
                                ));
                            }
                            result.gpu_sharing_config = map
                                .next_value::<std::option::Option<crate::model::GPUSharingConfig>>(
                                )?;
                        }
                        __FieldTag::__gpu_driver_installation_config => {
                            if !fields.insert(__FieldTag::__gpu_driver_installation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_driver_installation_config",
                                ));
                            }
                            result.gpu_driver_installation_config = map.next_value::<std::option::Option<crate::model::GPUDriverInstallationConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GPUSharingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_shared_clients_per_gpu,
            __gpu_sharing_strategy,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GPUSharingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxSharedClientsPerGpu" => {
                                Ok(__FieldTag::__max_shared_clients_per_gpu)
                            }
                            "max_shared_clients_per_gpu" => {
                                Ok(__FieldTag::__max_shared_clients_per_gpu)
                            }
                            "gpuSharingStrategy" => Ok(__FieldTag::__gpu_sharing_strategy),
                            "gpu_sharing_strategy" => Ok(__FieldTag::__gpu_sharing_strategy),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GPUSharingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GPUSharingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_shared_clients_per_gpu => {
                            if !fields.insert(__FieldTag::__max_shared_clients_per_gpu) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_shared_clients_per_gpu",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_shared_clients_per_gpu =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__gpu_sharing_strategy => {
                            if !fields.insert(__FieldTag::__gpu_sharing_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_sharing_strategy",
                                ));
                            }
                            result.gpu_sharing_strategy = map.next_value::<std::option::Option<
                                crate::model::gpu_sharing_config::GPUSharingStrategy,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GPUDriverInstallationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gpu_driver_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GPUDriverInstallationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gpuDriverVersion" => Ok(__FieldTag::__gpu_driver_version),
                            "gpu_driver_version" => Ok(__FieldTag::__gpu_driver_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GPUDriverInstallationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GPUDriverInstallationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gpu_driver_version => {
                            if !fields.insert(__FieldTag::__gpu_driver_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_driver_version",
                                ));
                            }
                            result.gpu_driver_version = map.next_value::<std::option::Option<
                                crate::model::gpu_driver_installation_config::GPUDriverVersion,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WorkloadMetadataConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkloadMetadataConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WorkloadMetadataConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkloadMetadataConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode =
                                map.next_value::<std::option::Option<
                                    crate::model::workload_metadata_config::Mode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetNetworkPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __network_policy,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetNetworkPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "networkPolicy" => Ok(__FieldTag::__network_policy),
                            "network_policy" => Ok(__FieldTag::__network_policy),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetNetworkPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetNetworkPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_policy => {
                            if !fields.insert(__FieldTag::__network_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_policy",
                                ));
                            }
                            result.network_policy = map
                                .next_value::<std::option::Option<crate::model::NetworkPolicy>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetMaintenancePolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project_id,
            __zone,
            __cluster_id,
            __maintenance_policy,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetMaintenancePolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "maintenancePolicy" => Ok(__FieldTag::__maintenance_policy),
                            "maintenance_policy" => Ok(__FieldTag::__maintenance_policy),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetMaintenancePolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetMaintenancePolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maintenance_policy => {
                            if !fields.insert(__FieldTag::__maintenance_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_policy",
                                ));
                            }
                            result.maintenance_policy = map
                                .next_value::<std::option::Option<crate::model::MaintenancePolicy>>(
                                )?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::StatusCondition {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __message,
            __canonical_code,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StatusCondition")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "message" => Ok(__FieldTag::__message),
                            "canonicalCode" => Ok(__FieldTag::__canonical_code),
                            "canonical_code" => Ok(__FieldTag::__canonical_code),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::StatusCondition;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StatusCondition")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::status_condition::Code>>()?.unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__canonical_code => {
                            if !fields.insert(__FieldTag::__canonical_code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for canonical_code",
                                ));
                            }
                            result.canonical_code = map
                                .next_value::<std::option::Option<rpc::model::Code>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NetworkConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __subnetwork,
            __enable_intra_node_visibility,
            __default_snat_status,
            __enable_l4ilb_subsetting,
            __datapath_provider,
            __private_ipv6_google_access,
            __dns_config,
            __service_external_ips_config,
            __gateway_api_config,
            __enable_multi_networking,
            __network_performance_config,
            __enable_fqdn_network_policy,
            __in_transit_encryption_config,
            __enable_cilium_clusterwide_network_policy,
            __default_enable_private_nodes,
            __disable_l4_lb_firewall_reconciliation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "enableIntraNodeVisibility" => {
                                Ok(__FieldTag::__enable_intra_node_visibility)
                            }
                            "enable_intra_node_visibility" => {
                                Ok(__FieldTag::__enable_intra_node_visibility)
                            }
                            "defaultSnatStatus" => Ok(__FieldTag::__default_snat_status),
                            "default_snat_status" => Ok(__FieldTag::__default_snat_status),
                            "enableL4ilbSubsetting" => Ok(__FieldTag::__enable_l4ilb_subsetting),
                            "enable_l4ilb_subsetting" => Ok(__FieldTag::__enable_l4ilb_subsetting),
                            "datapathProvider" => Ok(__FieldTag::__datapath_provider),
                            "datapath_provider" => Ok(__FieldTag::__datapath_provider),
                            "privateIpv6GoogleAccess" => {
                                Ok(__FieldTag::__private_ipv6_google_access)
                            }
                            "private_ipv6_google_access" => {
                                Ok(__FieldTag::__private_ipv6_google_access)
                            }
                            "dnsConfig" => Ok(__FieldTag::__dns_config),
                            "dns_config" => Ok(__FieldTag::__dns_config),
                            "serviceExternalIpsConfig" => {
                                Ok(__FieldTag::__service_external_ips_config)
                            }
                            "service_external_ips_config" => {
                                Ok(__FieldTag::__service_external_ips_config)
                            }
                            "gatewayApiConfig" => Ok(__FieldTag::__gateway_api_config),
                            "gateway_api_config" => Ok(__FieldTag::__gateway_api_config),
                            "enableMultiNetworking" => Ok(__FieldTag::__enable_multi_networking),
                            "enable_multi_networking" => Ok(__FieldTag::__enable_multi_networking),
                            "networkPerformanceConfig" => {
                                Ok(__FieldTag::__network_performance_config)
                            }
                            "network_performance_config" => {
                                Ok(__FieldTag::__network_performance_config)
                            }
                            "enableFqdnNetworkPolicy" => {
                                Ok(__FieldTag::__enable_fqdn_network_policy)
                            }
                            "enable_fqdn_network_policy" => {
                                Ok(__FieldTag::__enable_fqdn_network_policy)
                            }
                            "inTransitEncryptionConfig" => {
                                Ok(__FieldTag::__in_transit_encryption_config)
                            }
                            "in_transit_encryption_config" => {
                                Ok(__FieldTag::__in_transit_encryption_config)
                            }
                            "enableCiliumClusterwideNetworkPolicy" => {
                                Ok(__FieldTag::__enable_cilium_clusterwide_network_policy)
                            }
                            "enable_cilium_clusterwide_network_policy" => {
                                Ok(__FieldTag::__enable_cilium_clusterwide_network_policy)
                            }
                            "defaultEnablePrivateNodes" => {
                                Ok(__FieldTag::__default_enable_private_nodes)
                            }
                            "default_enable_private_nodes" => {
                                Ok(__FieldTag::__default_enable_private_nodes)
                            }
                            "disableL4LbFirewallReconciliation" => {
                                Ok(__FieldTag::__disable_l4_lb_firewall_reconciliation)
                            }
                            "disable_l4_lb_firewall_reconciliation" => {
                                Ok(__FieldTag::__disable_l4_lb_firewall_reconciliation)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NetworkConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_intra_node_visibility => {
                            if !fields.insert(__FieldTag::__enable_intra_node_visibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_intra_node_visibility",
                                ));
                            }
                            result.enable_intra_node_visibility = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_snat_status => {
                            if !fields.insert(__FieldTag::__default_snat_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_snat_status",
                                ));
                            }
                            result.default_snat_status = map
                                .next_value::<std::option::Option<crate::model::DefaultSnatStatus>>(
                                )?;
                        }
                        __FieldTag::__enable_l4ilb_subsetting => {
                            if !fields.insert(__FieldTag::__enable_l4ilb_subsetting) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_l4ilb_subsetting",
                                ));
                            }
                            result.enable_l4ilb_subsetting = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datapath_provider => {
                            if !fields.insert(__FieldTag::__datapath_provider) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datapath_provider",
                                ));
                            }
                            result.datapath_provider = map
                                .next_value::<std::option::Option<crate::model::DatapathProvider>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_ipv6_google_access => {
                            if !fields.insert(__FieldTag::__private_ipv6_google_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_ipv6_google_access",
                                ));
                            }
                            result.private_ipv6_google_access = map.next_value::<std::option::Option<crate::model::PrivateIPv6GoogleAccess>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dns_config => {
                            if !fields.insert(__FieldTag::__dns_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_config",
                                ));
                            }
                            result.dns_config =
                                map.next_value::<std::option::Option<crate::model::DNSConfig>>()?;
                        }
                        __FieldTag::__service_external_ips_config => {
                            if !fields.insert(__FieldTag::__service_external_ips_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_external_ips_config",
                                ));
                            }
                            result.service_external_ips_config = map.next_value::<std::option::Option<crate::model::ServiceExternalIPsConfig>>()?
                                ;
                        }
                        __FieldTag::__gateway_api_config => {
                            if !fields.insert(__FieldTag::__gateway_api_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gateway_api_config",
                                ));
                            }
                            result.gateway_api_config = map
                                .next_value::<std::option::Option<crate::model::GatewayAPIConfig>>(
                                )?;
                        }
                        __FieldTag::__enable_multi_networking => {
                            if !fields.insert(__FieldTag::__enable_multi_networking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_multi_networking",
                                ));
                            }
                            result.enable_multi_networking = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_performance_config => {
                            if !fields.insert(__FieldTag::__network_performance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_performance_config",
                                ));
                            }
                            result.network_performance_config = map
                                .next_value::<std::option::Option<
                                    crate::model::network_config::ClusterNetworkPerformanceConfig,
                                >>()?;
                        }
                        __FieldTag::__enable_fqdn_network_policy => {
                            if !fields.insert(__FieldTag::__enable_fqdn_network_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_fqdn_network_policy",
                                ));
                            }
                            result.enable_fqdn_network_policy =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__in_transit_encryption_config => {
                            if !fields.insert(__FieldTag::__in_transit_encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for in_transit_encryption_config",
                                ));
                            }
                            result.in_transit_encryption_config = map.next_value::<std::option::Option<crate::model::InTransitEncryptionConfig>>()?
                                ;
                        }
                        __FieldTag::__enable_cilium_clusterwide_network_policy => {
                            if !fields
                                .insert(__FieldTag::__enable_cilium_clusterwide_network_policy)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_cilium_clusterwide_network_policy",
                                ));
                            }
                            result.enable_cilium_clusterwide_network_policy =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__default_enable_private_nodes => {
                            if !fields.insert(__FieldTag::__default_enable_private_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_enable_private_nodes",
                                ));
                            }
                            result.default_enable_private_nodes =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__disable_l4_lb_firewall_reconciliation => {
                            if !fields.insert(__FieldTag::__disable_l4_lb_firewall_reconciliation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_l4_lb_firewall_reconciliation",
                                ));
                            }
                            result.disable_l4_lb_firewall_reconciliation =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::network_config::ClusterNetworkPerformanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_egress_bandwidth_tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterNetworkPerformanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalEgressBandwidthTier" => {
                                Ok(__FieldTag::__total_egress_bandwidth_tier)
                            }
                            "total_egress_bandwidth_tier" => {
                                Ok(__FieldTag::__total_egress_bandwidth_tier)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::network_config::ClusterNetworkPerformanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterNetworkPerformanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_egress_bandwidth_tier => {
                            if !fields.insert(__FieldTag::__total_egress_bandwidth_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_egress_bandwidth_tier",
                                ));
                            }
                            result.total_egress_bandwidth_tier = map.next_value::<std::option::Option<crate::model::network_config::cluster_network_performance_config::Tier>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GatewayAPIConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channel,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GatewayAPIConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channel" => Ok(__FieldTag::__channel),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GatewayAPIConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GatewayAPIConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel = map.next_value::<std::option::Option<crate::model::gateway_api_config::Channel>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ServiceExternalIPsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceExternalIPsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ServiceExternalIPsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceExternalIPsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetOpenIDConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOpenIDConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetOpenIDConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOpenIDConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetOpenIDConfigResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issuer,
            __jwks_uri,
            __response_types_supported,
            __subject_types_supported,
            __id_token_signing_alg_values_supported,
            __claims_supported,
            __grant_types,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetOpenIDConfigResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issuer" => Ok(__FieldTag::__issuer),
                            "jwks_uri" => Ok(__FieldTag::__jwks_uri),
                            "response_types_supported" => {
                                Ok(__FieldTag::__response_types_supported)
                            }
                            "subject_types_supported" => Ok(__FieldTag::__subject_types_supported),
                            "id_token_signing_alg_values_supported" => {
                                Ok(__FieldTag::__id_token_signing_alg_values_supported)
                            }
                            "claims_supported" => Ok(__FieldTag::__claims_supported),
                            "grant_types" => Ok(__FieldTag::__grant_types),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetOpenIDConfigResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetOpenIDConfigResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issuer => {
                            if !fields.insert(__FieldTag::__issuer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issuer",
                                ));
                            }
                            result.issuer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__jwks_uri => {
                            if !fields.insert(__FieldTag::__jwks_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for jwks_uri",
                                ));
                            }
                            result.jwks_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__response_types_supported => {
                            if !fields.insert(__FieldTag::__response_types_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_types_supported",
                                ));
                            }
                            result.response_types_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__subject_types_supported => {
                            if !fields.insert(__FieldTag::__subject_types_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject_types_supported",
                                ));
                            }
                            result.subject_types_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__id_token_signing_alg_values_supported => {
                            if !fields.insert(__FieldTag::__id_token_signing_alg_values_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id_token_signing_alg_values_supported",
                                ));
                            }
                            result.id_token_signing_alg_values_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__claims_supported => {
                            if !fields.insert(__FieldTag::__claims_supported) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for claims_supported",
                                ));
                            }
                            result.claims_supported = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__grant_types => {
                            if !fields.insert(__FieldTag::__grant_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grant_types",
                                ));
                            }
                            result.grant_types = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetJSONWebKeysRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJSONWebKeysRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetJSONWebKeysRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJSONWebKeysRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Jwk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kty,
            __alg,
            __use,
            __kid,
            __n,
            __e,
            __x,
            __y,
            __crv,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Jwk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kty" => Ok(__FieldTag::__kty),
                            "alg" => Ok(__FieldTag::__alg),
                            "use" => Ok(__FieldTag::__use),
                            "kid" => Ok(__FieldTag::__kid),
                            "n" => Ok(__FieldTag::__n),
                            "e" => Ok(__FieldTag::__e),
                            "x" => Ok(__FieldTag::__x),
                            "y" => Ok(__FieldTag::__y),
                            "crv" => Ok(__FieldTag::__crv),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Jwk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Jwk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kty => {
                            if !fields.insert(__FieldTag::__kty) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kty",
                                ));
                            }
                            result.kty = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__alg => {
                            if !fields.insert(__FieldTag::__alg) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alg",
                                ));
                            }
                            result.alg = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__use => {
                            if !fields.insert(__FieldTag::__use) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for use",
                                ));
                            }
                            result.r#use = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kid => {
                            if !fields.insert(__FieldTag::__kid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kid",
                                ));
                            }
                            result.kid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__n => {
                            if !fields.insert(__FieldTag::__n) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for n",
                                ));
                            }
                            result.n = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__e => {
                            if !fields.insert(__FieldTag::__e) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for e",
                                ));
                            }
                            result.e = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__x => {
                            if !fields.insert(__FieldTag::__x) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for x",
                                ));
                            }
                            result.x = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__y => {
                            if !fields.insert(__FieldTag::__y) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for y",
                                ));
                            }
                            result.y = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__crv => {
                            if !fields.insert(__FieldTag::__crv) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for crv",
                                ));
                            }
                            result.crv = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetJSONWebKeysResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __keys,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetJSONWebKeysResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keys" => Ok(__FieldTag::__keys),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetJSONWebKeysResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetJSONWebKeysResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__keys => {
                            if !fields.insert(__FieldTag::__keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for keys",
                                ));
                            }
                            result.keys = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Jwk>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CheckAutopilotCompatibilityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckAutopilotCompatibilityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CheckAutopilotCompatibilityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckAutopilotCompatibilityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutopilotCompatibilityIssue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __last_observation,
            __constraint_type,
            __incompatibility_type,
            __subjects,
            __documentation_url,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutopilotCompatibilityIssue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lastObservation" => Ok(__FieldTag::__last_observation),
                            "last_observation" => Ok(__FieldTag::__last_observation),
                            "constraintType" => Ok(__FieldTag::__constraint_type),
                            "constraint_type" => Ok(__FieldTag::__constraint_type),
                            "incompatibilityType" => Ok(__FieldTag::__incompatibility_type),
                            "incompatibility_type" => Ok(__FieldTag::__incompatibility_type),
                            "subjects" => Ok(__FieldTag::__subjects),
                            "documentationUrl" => Ok(__FieldTag::__documentation_url),
                            "documentation_url" => Ok(__FieldTag::__documentation_url),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutopilotCompatibilityIssue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutopilotCompatibilityIssue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__last_observation => {
                            if !fields.insert(__FieldTag::__last_observation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_observation",
                                ));
                            }
                            result.last_observation =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__constraint_type => {
                            if !fields.insert(__FieldTag::__constraint_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for constraint_type",
                                ));
                            }
                            result.constraint_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__incompatibility_type => {
                            if !fields.insert(__FieldTag::__incompatibility_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for incompatibility_type",
                                ));
                            }
                            result.incompatibility_type = map
                                .next_value::<std::option::Option<
                                    crate::model::autopilot_compatibility_issue::IssueType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subjects => {
                            if !fields.insert(__FieldTag::__subjects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subjects",
                                ));
                            }
                            result.subjects = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__documentation_url => {
                            if !fields.insert(__FieldTag::__documentation_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation_url",
                                ));
                            }
                            result.documentation_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CheckAutopilotCompatibilityResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issues,
            __summary,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckAutopilotCompatibilityResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issues" => Ok(__FieldTag::__issues),
                            "summary" => Ok(__FieldTag::__summary),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CheckAutopilotCompatibilityResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckAutopilotCompatibilityResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issues => {
                            if !fields.insert(__FieldTag::__issues) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issues",
                                ));
                            }
                            result.issues = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AutopilotCompatibilityIssue>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__summary => {
                            if !fields.insert(__FieldTag::__summary) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for summary",
                                ));
                            }
                            result.summary = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ReleaseChannel {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channel,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReleaseChannel")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channel" => Ok(__FieldTag::__channel),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ReleaseChannel;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReleaseChannel")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channel => {
                            if !fields.insert(__FieldTag::__channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channel",
                                ));
                            }
                            result.channel = map.next_value::<std::option::Option<crate::model::release_channel::Channel>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::CostManagementConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CostManagementConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::CostManagementConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CostManagementConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::IntraNodeVisibilityConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IntraNodeVisibilityConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::IntraNodeVisibilityConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IntraNodeVisibilityConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ILBSubsettingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ILBSubsettingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ILBSubsettingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ILBSubsettingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DNSConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_dns,
            __cluster_dns_scope,
            __cluster_dns_domain,
            __additive_vpc_scope_dns_domain,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DNSConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterDns" => Ok(__FieldTag::__cluster_dns),
                            "cluster_dns" => Ok(__FieldTag::__cluster_dns),
                            "clusterDnsScope" => Ok(__FieldTag::__cluster_dns_scope),
                            "cluster_dns_scope" => Ok(__FieldTag::__cluster_dns_scope),
                            "clusterDnsDomain" => Ok(__FieldTag::__cluster_dns_domain),
                            "cluster_dns_domain" => Ok(__FieldTag::__cluster_dns_domain),
                            "additiveVpcScopeDnsDomain" => {
                                Ok(__FieldTag::__additive_vpc_scope_dns_domain)
                            }
                            "additive_vpc_scope_dns_domain" => {
                                Ok(__FieldTag::__additive_vpc_scope_dns_domain)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DNSConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DNSConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_dns => {
                            if !fields.insert(__FieldTag::__cluster_dns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_dns",
                                ));
                            }
                            result.cluster_dns = map.next_value::<std::option::Option<crate::model::dns_config::Provider>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cluster_dns_scope => {
                            if !fields.insert(__FieldTag::__cluster_dns_scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_dns_scope",
                                ));
                            }
                            result.cluster_dns_scope = map.next_value::<std::option::Option<crate::model::dns_config::DNSScope>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cluster_dns_domain => {
                            if !fields.insert(__FieldTag::__cluster_dns_domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_dns_domain",
                                ));
                            }
                            result.cluster_dns_domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additive_vpc_scope_dns_domain => {
                            if !fields.insert(__FieldTag::__additive_vpc_scope_dns_domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additive_vpc_scope_dns_domain",
                                ));
                            }
                            result.additive_vpc_scope_dns_domain = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MaxPodsConstraint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_pods_per_node,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaxPodsConstraint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxPodsPerNode" => Ok(__FieldTag::__max_pods_per_node),
                            "max_pods_per_node" => Ok(__FieldTag::__max_pods_per_node),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MaxPodsConstraint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaxPodsConstraint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_pods_per_node => {
                            if !fields.insert(__FieldTag::__max_pods_per_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_pods_per_node",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_pods_per_node =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WorkloadIdentityConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workload_pool,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkloadIdentityConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workloadPool" => Ok(__FieldTag::__workload_pool),
                            "workload_pool" => Ok(__FieldTag::__workload_pool),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WorkloadIdentityConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkloadIdentityConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workload_pool => {
                            if !fields.insert(__FieldTag::__workload_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_pool",
                                ));
                            }
                            result.workload_pool = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::IdentityServiceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IdentityServiceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::IdentityServiceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IdentityServiceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MeshCertificates {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_certificates,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MeshCertificates")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableCertificates" => Ok(__FieldTag::__enable_certificates),
                            "enable_certificates" => Ok(__FieldTag::__enable_certificates),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MeshCertificates;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MeshCertificates")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_certificates => {
                            if !fields.insert(__FieldTag::__enable_certificates) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_certificates",
                                ));
                            }
                            result.enable_certificates =
                                map.next_value::<std::option::Option<wkt::BoolValue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DatabaseEncryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_name,
            __state,
            __current_state,
            __decryption_keys,
            __last_operation_errors,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatabaseEncryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyName" => Ok(__FieldTag::__key_name),
                            "key_name" => Ok(__FieldTag::__key_name),
                            "state" => Ok(__FieldTag::__state),
                            "currentState" => Ok(__FieldTag::__current_state),
                            "current_state" => Ok(__FieldTag::__current_state),
                            "decryptionKeys" => Ok(__FieldTag::__decryption_keys),
                            "decryption_keys" => Ok(__FieldTag::__decryption_keys),
                            "lastOperationErrors" => Ok(__FieldTag::__last_operation_errors),
                            "last_operation_errors" => Ok(__FieldTag::__last_operation_errors),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DatabaseEncryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatabaseEncryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_name => {
                            if !fields.insert(__FieldTag::__key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_name",
                                ));
                            }
                            result.key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::database_encryption::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__current_state => {
                            if !fields.insert(__FieldTag::__current_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_state",
                                ));
                            }
                            result.current_state = map.next_value::<std::option::Option<
                                crate::model::database_encryption::CurrentState,
                            >>()?;
                        }
                        __FieldTag::__decryption_keys => {
                            if !fields.insert(__FieldTag::__decryption_keys) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for decryption_keys",
                                ));
                            }
                            result.decryption_keys = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__last_operation_errors => {
                            if !fields.insert(__FieldTag::__last_operation_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_operation_errors",
                                ));
                            }
                            result.last_operation_errors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::database_encryption::OperationError,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::database_encryption::OperationError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key_name,
            __error_message,
            __timestamp,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "keyName" => Ok(__FieldTag::__key_name),
                            "key_name" => Ok(__FieldTag::__key_name),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "timestamp" => Ok(__FieldTag::__timestamp),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::database_encryption::OperationError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key_name => {
                            if !fields.insert(__FieldTag::__key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key_name",
                                ));
                            }
                            result.key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timestamp => {
                            if !fields.insert(__FieldTag::__timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp",
                                ));
                            }
                            result.timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListUsableSubnetworksRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsableSubnetworksRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListUsableSubnetworksRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsableSubnetworksRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ListUsableSubnetworksResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subnetworks,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsableSubnetworksResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subnetworks" => Ok(__FieldTag::__subnetworks),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ListUsableSubnetworksResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsableSubnetworksResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subnetworks => {
                            if !fields.insert(__FieldTag::__subnetworks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetworks",
                                ));
                            }
                            result.subnetworks =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UsableSubnetwork>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UsableSubnetworkSecondaryRange {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __range_name,
            __ip_cidr_range,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UsableSubnetworkSecondaryRange")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rangeName" => Ok(__FieldTag::__range_name),
                            "range_name" => Ok(__FieldTag::__range_name),
                            "ipCidrRange" => Ok(__FieldTag::__ip_cidr_range),
                            "ip_cidr_range" => Ok(__FieldTag::__ip_cidr_range),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UsableSubnetworkSecondaryRange;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UsableSubnetworkSecondaryRange")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__range_name => {
                            if !fields.insert(__FieldTag::__range_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for range_name",
                                ));
                            }
                            result.range_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_cidr_range => {
                            if !fields.insert(__FieldTag::__ip_cidr_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_cidr_range",
                                ));
                            }
                            result.ip_cidr_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<
                                    crate::model::usable_subnetwork_secondary_range::Status,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UsableSubnetwork {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __subnetwork,
            __network,
            __ip_cidr_range,
            __secondary_ip_ranges,
            __status_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UsableSubnetwork")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "network" => Ok(__FieldTag::__network),
                            "ipCidrRange" => Ok(__FieldTag::__ip_cidr_range),
                            "ip_cidr_range" => Ok(__FieldTag::__ip_cidr_range),
                            "secondaryIpRanges" => Ok(__FieldTag::__secondary_ip_ranges),
                            "secondary_ip_ranges" => Ok(__FieldTag::__secondary_ip_ranges),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UsableSubnetwork;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UsableSubnetwork")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ip_cidr_range => {
                            if !fields.insert(__FieldTag::__ip_cidr_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_cidr_range",
                                ));
                            }
                            result.ip_cidr_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__secondary_ip_ranges => {
                            if !fields.insert(__FieldTag::__secondary_ip_ranges) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_ip_ranges",
                                ));
                            }
                            result.secondary_ip_ranges = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UsableSubnetworkSecondaryRange>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResourceUsageExportConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bigquery_destination,
            __enable_network_egress_metering,
            __consumption_metering_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceUsageExportConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigqueryDestination" => Ok(__FieldTag::__bigquery_destination),
                            "bigquery_destination" => Ok(__FieldTag::__bigquery_destination),
                            "enableNetworkEgressMetering" => {
                                Ok(__FieldTag::__enable_network_egress_metering)
                            }
                            "enable_network_egress_metering" => {
                                Ok(__FieldTag::__enable_network_egress_metering)
                            }
                            "consumptionMeteringConfig" => {
                                Ok(__FieldTag::__consumption_metering_config)
                            }
                            "consumption_metering_config" => {
                                Ok(__FieldTag::__consumption_metering_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResourceUsageExportConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceUsageExportConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bigquery_destination => {
                            if !fields.insert(__FieldTag::__bigquery_destination) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_destination",
                                ));
                            }
                            result.bigquery_destination = map.next_value::<std::option::Option<
                                crate::model::resource_usage_export_config::BigQueryDestination,
                            >>()?;
                        }
                        __FieldTag::__enable_network_egress_metering => {
                            if !fields.insert(__FieldTag::__enable_network_egress_metering) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_network_egress_metering",
                                ));
                            }
                            result.enable_network_egress_metering = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__consumption_metering_config => {
                            if !fields.insert(__FieldTag::__consumption_metering_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consumption_metering_config",
                                ));
                            }
                            result.consumption_metering_config = map.next_value::<std::option::Option<crate::model::resource_usage_export_config::ConsumptionMeteringConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::resource_usage_export_config::BigQueryDestination {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dataset_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BigQueryDestination")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datasetId" => Ok(__FieldTag::__dataset_id),
                            "dataset_id" => Ok(__FieldTag::__dataset_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::resource_usage_export_config::BigQueryDestination;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BigQueryDestination")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dataset_id => {
                            if !fields.insert(__FieldTag::__dataset_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataset_id",
                                ));
                            }
                            result.dataset_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de>
    for super::resource_usage_export_config::ConsumptionMeteringConfig
{
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConsumptionMeteringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::resource_usage_export_config::ConsumptionMeteringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConsumptionMeteringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VerticalPodAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerticalPodAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VerticalPodAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerticalPodAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::DefaultSnatStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DefaultSnatStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::DefaultSnatStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DefaultSnatStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ShieldedNodes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShieldedNodes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ShieldedNodes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShieldedNodes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::VirtualNIC {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VirtualNIC")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::VirtualNIC;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VirtualNIC")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FastSocket {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FastSocket")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FastSocket;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FastSocket")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NotificationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __pubsub,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NotificationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pubsub" => Ok(__FieldTag::__pubsub),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NotificationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NotificationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__pubsub => {
                            if !fields.insert(__FieldTag::__pubsub) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pubsub",
                                ));
                            }
                            result.pubsub = map.next_value::<std::option::Option<crate::model::notification_config::PubSub>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::notification_config::PubSub {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __topic,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PubSub")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "topic" => Ok(__FieldTag::__topic),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::notification_config::PubSub;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PubSub")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__topic => {
                            if !fields.insert(__FieldTag::__topic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for topic",
                                ));
                            }
                            result.topic = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map.next_value::<std::option::Option<crate::model::notification_config::Filter>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::notification_config::Filter {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __event_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Filter")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "eventType" => Ok(__FieldTag::__event_type),
                            "event_type" => Ok(__FieldTag::__event_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::notification_config::Filter;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Filter")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__event_type => {
                            if !fields.insert(__FieldTag::__event_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_type",
                                ));
                            }
                            result.event_type = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::notification_config::EventType>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ConfidentialNodes {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __confidential_instance_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfidentialNodes")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "confidentialInstanceType" => {
                                Ok(__FieldTag::__confidential_instance_type)
                            }
                            "confidential_instance_type" => {
                                Ok(__FieldTag::__confidential_instance_type)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ConfidentialNodes;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfidentialNodes")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__confidential_instance_type => {
                            if !fields.insert(__FieldTag::__confidential_instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for confidential_instance_type",
                                ));
                            }
                            result.confidential_instance_type = map
                                .next_value::<std::option::Option<
                                    crate::model::confidential_nodes::ConfidentialInstanceType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpgradeEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_type,
            __operation,
            __operation_start_time,
            __current_version,
            __target_version,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "operation" => Ok(__FieldTag::__operation),
                            "operationStartTime" => Ok(__FieldTag::__operation_start_time),
                            "operation_start_time" => Ok(__FieldTag::__operation_start_time),
                            "currentVersion" => Ok(__FieldTag::__current_version),
                            "current_version" => Ok(__FieldTag::__current_version),
                            "targetVersion" => Ok(__FieldTag::__target_version),
                            "target_version" => Ok(__FieldTag::__target_version),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpgradeEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map.next_value::<std::option::Option<crate::model::UpgradeResourceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation_start_time => {
                            if !fields.insert(__FieldTag::__operation_start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_start_time",
                                ));
                            }
                            result.operation_start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__current_version => {
                            if !fields.insert(__FieldTag::__current_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_version",
                                ));
                            }
                            result.current_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version => {
                            if !fields.insert(__FieldTag::__target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version",
                                ));
                            }
                            result.target_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpgradeInfoEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_type,
            __operation,
            __start_time,
            __end_time,
            __current_version,
            __target_version,
            __resource,
            __state,
            __standard_support_end_time,
            __extended_support_end_time,
            __description,
            __event_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeInfoEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "operation" => Ok(__FieldTag::__operation),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "currentVersion" => Ok(__FieldTag::__current_version),
                            "current_version" => Ok(__FieldTag::__current_version),
                            "targetVersion" => Ok(__FieldTag::__target_version),
                            "target_version" => Ok(__FieldTag::__target_version),
                            "resource" => Ok(__FieldTag::__resource),
                            "state" => Ok(__FieldTag::__state),
                            "standardSupportEndTime" => Ok(__FieldTag::__standard_support_end_time),
                            "standard_support_end_time" => {
                                Ok(__FieldTag::__standard_support_end_time)
                            }
                            "extendedSupportEndTime" => Ok(__FieldTag::__extended_support_end_time),
                            "extended_support_end_time" => {
                                Ok(__FieldTag::__extended_support_end_time)
                            }
                            "description" => Ok(__FieldTag::__description),
                            "eventType" => Ok(__FieldTag::__event_type),
                            "event_type" => Ok(__FieldTag::__event_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpgradeInfoEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeInfoEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map.next_value::<std::option::Option<crate::model::UpgradeResourceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__current_version => {
                            if !fields.insert(__FieldTag::__current_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_version",
                                ));
                            }
                            result.current_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version => {
                            if !fields.insert(__FieldTag::__target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version",
                                ));
                            }
                            result.target_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::upgrade_info_event::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__standard_support_end_time => {
                            if !fields.insert(__FieldTag::__standard_support_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard_support_end_time",
                                ));
                            }
                            result.standard_support_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__extended_support_end_time => {
                            if !fields.insert(__FieldTag::__extended_support_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extended_support_end_time",
                                ));
                            }
                            result.extended_support_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__event_type => {
                            if !fields.insert(__FieldTag::__event_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for event_type",
                                ));
                            }
                            result.event_type =
                                map.next_value::<std::option::Option<
                                    crate::model::upgrade_info_event::EventType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpgradeAvailableEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __resource_type,
            __release_channel,
            __resource,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeAvailableEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "resourceType" => Ok(__FieldTag::__resource_type),
                            "resource_type" => Ok(__FieldTag::__resource_type),
                            "releaseChannel" => Ok(__FieldTag::__release_channel),
                            "release_channel" => Ok(__FieldTag::__release_channel),
                            "resource" => Ok(__FieldTag::__resource),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpgradeAvailableEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeAvailableEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_type => {
                            if !fields.insert(__FieldTag::__resource_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type",
                                ));
                            }
                            result.resource_type = map.next_value::<std::option::Option<crate::model::UpgradeResourceType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__release_channel => {
                            if !fields.insert(__FieldTag::__release_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_channel",
                                ));
                            }
                            result.release_channel = map
                                .next_value::<std::option::Option<crate::model::ReleaseChannel>>(
                                )?;
                        }
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SecurityBulletinEvent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_type_affected,
            __bulletin_id,
            __cve_ids,
            __severity,
            __bulletin_uri,
            __brief_description,
            __affected_supported_minors,
            __patched_versions,
            __suggested_upgrade_target,
            __manual_steps_required,
            __mitigated_versions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecurityBulletinEvent")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceTypeAffected" => Ok(__FieldTag::__resource_type_affected),
                            "resource_type_affected" => Ok(__FieldTag::__resource_type_affected),
                            "bulletinId" => Ok(__FieldTag::__bulletin_id),
                            "bulletin_id" => Ok(__FieldTag::__bulletin_id),
                            "cveIds" => Ok(__FieldTag::__cve_ids),
                            "cve_ids" => Ok(__FieldTag::__cve_ids),
                            "severity" => Ok(__FieldTag::__severity),
                            "bulletinUri" => Ok(__FieldTag::__bulletin_uri),
                            "bulletin_uri" => Ok(__FieldTag::__bulletin_uri),
                            "briefDescription" => Ok(__FieldTag::__brief_description),
                            "brief_description" => Ok(__FieldTag::__brief_description),
                            "affectedSupportedMinors" => {
                                Ok(__FieldTag::__affected_supported_minors)
                            }
                            "affected_supported_minors" => {
                                Ok(__FieldTag::__affected_supported_minors)
                            }
                            "patchedVersions" => Ok(__FieldTag::__patched_versions),
                            "patched_versions" => Ok(__FieldTag::__patched_versions),
                            "suggestedUpgradeTarget" => Ok(__FieldTag::__suggested_upgrade_target),
                            "suggested_upgrade_target" => {
                                Ok(__FieldTag::__suggested_upgrade_target)
                            }
                            "manualStepsRequired" => Ok(__FieldTag::__manual_steps_required),
                            "manual_steps_required" => Ok(__FieldTag::__manual_steps_required),
                            "mitigatedVersions" => Ok(__FieldTag::__mitigated_versions),
                            "mitigated_versions" => Ok(__FieldTag::__mitigated_versions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SecurityBulletinEvent;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecurityBulletinEvent")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_type_affected => {
                            if !fields.insert(__FieldTag::__resource_type_affected) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_type_affected",
                                ));
                            }
                            result.resource_type_affected = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bulletin_id => {
                            if !fields.insert(__FieldTag::__bulletin_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bulletin_id",
                                ));
                            }
                            result.bulletin_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cve_ids => {
                            if !fields.insert(__FieldTag::__cve_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cve_ids",
                                ));
                            }
                            result.cve_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bulletin_uri => {
                            if !fields.insert(__FieldTag::__bulletin_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bulletin_uri",
                                ));
                            }
                            result.bulletin_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__brief_description => {
                            if !fields.insert(__FieldTag::__brief_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for brief_description",
                                ));
                            }
                            result.brief_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__affected_supported_minors => {
                            if !fields.insert(__FieldTag::__affected_supported_minors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for affected_supported_minors",
                                ));
                            }
                            result.affected_supported_minors = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__patched_versions => {
                            if !fields.insert(__FieldTag::__patched_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patched_versions",
                                ));
                            }
                            result.patched_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__suggested_upgrade_target => {
                            if !fields.insert(__FieldTag::__suggested_upgrade_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for suggested_upgrade_target",
                                ));
                            }
                            result.suggested_upgrade_target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__manual_steps_required => {
                            if !fields.insert(__FieldTag::__manual_steps_required) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manual_steps_required",
                                ));
                            }
                            result.manual_steps_required = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__mitigated_versions => {
                            if !fields.insert(__FieldTag::__mitigated_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mitigated_versions",
                                ));
                            }
                            result.mitigated_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Autopilot {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __workload_policy_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Autopilot")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "workloadPolicyConfig" => Ok(__FieldTag::__workload_policy_config),
                            "workload_policy_config" => Ok(__FieldTag::__workload_policy_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Autopilot;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Autopilot")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workload_policy_config => {
                            if !fields.insert(__FieldTag::__workload_policy_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workload_policy_config",
                                ));
                            }
                            result.workload_policy_config = map.next_value::<std::option::Option<crate::model::WorkloadPolicyConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::WorkloadPolicyConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __allow_net_admin,
            __autopilot_compatibility_auditing_enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkloadPolicyConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "allowNetAdmin" => Ok(__FieldTag::__allow_net_admin),
                            "allow_net_admin" => Ok(__FieldTag::__allow_net_admin),
                            "autopilotCompatibilityAuditingEnabled" => {
                                Ok(__FieldTag::__autopilot_compatibility_auditing_enabled)
                            }
                            "autopilot_compatibility_auditing_enabled" => {
                                Ok(__FieldTag::__autopilot_compatibility_auditing_enabled)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::WorkloadPolicyConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkloadPolicyConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__allow_net_admin => {
                            if !fields.insert(__FieldTag::__allow_net_admin) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_net_admin",
                                ));
                            }
                            result.allow_net_admin =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__autopilot_compatibility_auditing_enabled => {
                            if !fields
                                .insert(__FieldTag::__autopilot_compatibility_auditing_enabled)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for autopilot_compatibility_auditing_enabled",
                                ));
                            }
                            result.autopilot_compatibility_auditing_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __component_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "componentConfig" => Ok(__FieldTag::__component_config),
                            "component_config" => Ok(__FieldTag::__component_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__component_config => {
                            if !fields.insert(__FieldTag::__component_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for component_config",
                                ));
                            }
                            result.component_config = map.next_value::<std::option::Option<crate::model::LoggingComponentConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoggingComponentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_components,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingComponentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableComponents" => Ok(__FieldTag::__enable_components),
                            "enable_components" => Ok(__FieldTag::__enable_components),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoggingComponentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingComponentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_components => {
                            if !fields.insert(__FieldTag::__enable_components) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_components",
                                ));
                            }
                            result.enable_components = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::logging_component_config::Component,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RayClusterLoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RayClusterLoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RayClusterLoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RayClusterLoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MonitoringConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __component_config,
            __managed_prometheus_config,
            __advanced_datapath_observability_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MonitoringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "componentConfig" => Ok(__FieldTag::__component_config),
                            "component_config" => Ok(__FieldTag::__component_config),
                            "managedPrometheusConfig" => {
                                Ok(__FieldTag::__managed_prometheus_config)
                            }
                            "managed_prometheus_config" => {
                                Ok(__FieldTag::__managed_prometheus_config)
                            }
                            "advancedDatapathObservabilityConfig" => {
                                Ok(__FieldTag::__advanced_datapath_observability_config)
                            }
                            "advanced_datapath_observability_config" => {
                                Ok(__FieldTag::__advanced_datapath_observability_config)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MonitoringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MonitoringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__component_config => {
                            if !fields.insert(__FieldTag::__component_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for component_config",
                                ));
                            }
                            result.component_config = map.next_value::<std::option::Option<crate::model::MonitoringComponentConfig>>()?
                                ;
                        }
                        __FieldTag::__managed_prometheus_config => {
                            if !fields.insert(__FieldTag::__managed_prometheus_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_prometheus_config",
                                ));
                            }
                            result.managed_prometheus_config = map.next_value::<std::option::Option<crate::model::ManagedPrometheusConfig>>()?
                                ;
                        }
                        __FieldTag::__advanced_datapath_observability_config => {
                            if !fields.insert(__FieldTag::__advanced_datapath_observability_config)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for advanced_datapath_observability_config",
                                ));
                            }
                            result.advanced_datapath_observability_config =
                                map.next_value::<std::option::Option<
                                    crate::model::AdvancedDatapathObservabilityConfig,
                                >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AdvancedDatapathObservabilityConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_metrics,
            __relay_mode,
            __enable_relay,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdvancedDatapathObservabilityConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableMetrics" => Ok(__FieldTag::__enable_metrics),
                            "enable_metrics" => Ok(__FieldTag::__enable_metrics),
                            "relayMode" => Ok(__FieldTag::__relay_mode),
                            "relay_mode" => Ok(__FieldTag::__relay_mode),
                            "enableRelay" => Ok(__FieldTag::__enable_relay),
                            "enable_relay" => Ok(__FieldTag::__enable_relay),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AdvancedDatapathObservabilityConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdvancedDatapathObservabilityConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_metrics => {
                            if !fields.insert(__FieldTag::__enable_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_metrics",
                                ));
                            }
                            result.enable_metrics = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relay_mode => {
                            if !fields.insert(__FieldTag::__relay_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relay_mode",
                                ));
                            }
                            result.relay_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::advanced_datapath_observability_config::RelayMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_relay => {
                            if !fields.insert(__FieldTag::__enable_relay) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_relay",
                                ));
                            }
                            result.enable_relay = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::RayClusterMonitoringConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RayClusterMonitoringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::RayClusterMonitoringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RayClusterMonitoringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodePoolLoggingConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __variant_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePoolLoggingConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "variantConfig" => Ok(__FieldTag::__variant_config),
                            "variant_config" => Ok(__FieldTag::__variant_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodePoolLoggingConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePoolLoggingConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__variant_config => {
                            if !fields.insert(__FieldTag::__variant_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for variant_config",
                                ));
                            }
                            result.variant_config = map.next_value::<std::option::Option<crate::model::LoggingVariantConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LoggingVariantConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __variant,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoggingVariantConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "variant" => Ok(__FieldTag::__variant),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LoggingVariantConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoggingVariantConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__variant => {
                            if !fields.insert(__FieldTag::__variant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for variant",
                                ));
                            }
                            result.variant =
                                map.next_value::<std::option::Option<
                                    crate::model::logging_variant_config::Variant,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::MonitoringComponentConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_components,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MonitoringComponentConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableComponents" => Ok(__FieldTag::__enable_components),
                            "enable_components" => Ok(__FieldTag::__enable_components),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::MonitoringComponentConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MonitoringComponentConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_components => {
                            if !fields.insert(__FieldTag::__enable_components) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_components",
                                ));
                            }
                            result.enable_components = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::monitoring_component_config::Component,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ManagedPrometheusConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __auto_monitoring_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedPrometheusConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "autoMonitoringConfig" => Ok(__FieldTag::__auto_monitoring_config),
                            "auto_monitoring_config" => Ok(__FieldTag::__auto_monitoring_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ManagedPrometheusConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedPrometheusConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__auto_monitoring_config => {
                            if !fields.insert(__FieldTag::__auto_monitoring_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_monitoring_config",
                                ));
                            }
                            result.auto_monitoring_config = map.next_value::<std::option::Option<crate::model::AutoMonitoringConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AutoMonitoringConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __scope,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoMonitoringConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "scope" => Ok(__FieldTag::__scope),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AutoMonitoringConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoMonitoringConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__scope => {
                            if !fields.insert(__FieldTag::__scope) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scope",
                                ));
                            }
                            result.scope =
                                map.next_value::<std::option::Option<
                                    crate::model::auto_monitoring_config::Scope,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PodAutoscaling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hpa_profile,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PodAutoscaling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hpaProfile" => Ok(__FieldTag::__hpa_profile),
                            "hpa_profile" => Ok(__FieldTag::__hpa_profile),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PodAutoscaling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PodAutoscaling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hpa_profile => {
                            if !fields.insert(__FieldTag::__hpa_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hpa_profile",
                                ));
                            }
                            result.hpa_profile = map.next_value::<std::option::Option<crate::model::pod_autoscaling::HPAProfile>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Fleet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __membership,
            __pre_registered,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fleet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "membership" => Ok(__FieldTag::__membership),
                            "preRegistered" => Ok(__FieldTag::__pre_registered),
                            "pre_registered" => Ok(__FieldTag::__pre_registered),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Fleet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fleet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__membership => {
                            if !fields.insert(__FieldTag::__membership) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for membership",
                                ));
                            }
                            result.membership = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__pre_registered => {
                            if !fields.insert(__FieldTag::__pre_registered) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for pre_registered",
                                ));
                            }
                            result.pre_registered = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ControlPlaneEndpointsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dns_endpoint_config,
            __ip_endpoints_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ControlPlaneEndpointsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dnsEndpointConfig" => Ok(__FieldTag::__dns_endpoint_config),
                            "dns_endpoint_config" => Ok(__FieldTag::__dns_endpoint_config),
                            "ipEndpointsConfig" => Ok(__FieldTag::__ip_endpoints_config),
                            "ip_endpoints_config" => Ok(__FieldTag::__ip_endpoints_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ControlPlaneEndpointsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ControlPlaneEndpointsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dns_endpoint_config => {
                            if !fields.insert(__FieldTag::__dns_endpoint_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dns_endpoint_config",
                                ));
                            }
                            result.dns_endpoint_config = map.next_value::<std::option::Option<
                                crate::model::control_plane_endpoints_config::DNSEndpointConfig,
                            >>()?;
                        }
                        __FieldTag::__ip_endpoints_config => {
                            if !fields.insert(__FieldTag::__ip_endpoints_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ip_endpoints_config",
                                ));
                            }
                            result.ip_endpoints_config = map.next_value::<std::option::Option<
                                crate::model::control_plane_endpoints_config::IPEndpointsConfig,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::control_plane_endpoints_config::DNSEndpointConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __endpoint,
            __allow_external_traffic,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DNSEndpointConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "allowExternalTraffic" => Ok(__FieldTag::__allow_external_traffic),
                            "allow_external_traffic" => Ok(__FieldTag::__allow_external_traffic),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::control_plane_endpoints_config::DNSEndpointConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DNSEndpointConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_external_traffic => {
                            if !fields.insert(__FieldTag::__allow_external_traffic) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_external_traffic",
                                ));
                            }
                            result.allow_external_traffic =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::control_plane_endpoints_config::IPEndpointsConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            __enable_public_endpoint,
            __global_access,
            __authorized_networks_config,
            __public_endpoint,
            __private_endpoint,
            __private_endpoint_subnetwork,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for IPEndpointsConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            "enablePublicEndpoint" => Ok(__FieldTag::__enable_public_endpoint),
                            "enable_public_endpoint" => Ok(__FieldTag::__enable_public_endpoint),
                            "globalAccess" => Ok(__FieldTag::__global_access),
                            "global_access" => Ok(__FieldTag::__global_access),
                            "authorizedNetworksConfig" => {
                                Ok(__FieldTag::__authorized_networks_config)
                            }
                            "authorized_networks_config" => {
                                Ok(__FieldTag::__authorized_networks_config)
                            }
                            "publicEndpoint" => Ok(__FieldTag::__public_endpoint),
                            "public_endpoint" => Ok(__FieldTag::__public_endpoint),
                            "privateEndpoint" => Ok(__FieldTag::__private_endpoint),
                            "private_endpoint" => Ok(__FieldTag::__private_endpoint),
                            "privateEndpointSubnetwork" => {
                                Ok(__FieldTag::__private_endpoint_subnetwork)
                            }
                            "private_endpoint_subnetwork" => {
                                Ok(__FieldTag::__private_endpoint_subnetwork)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::control_plane_endpoints_config::IPEndpointsConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct IPEndpointsConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__enable_public_endpoint => {
                            if !fields.insert(__FieldTag::__enable_public_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_public_endpoint",
                                ));
                            }
                            result.enable_public_endpoint =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__global_access => {
                            if !fields.insert(__FieldTag::__global_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for global_access",
                                ));
                            }
                            result.global_access = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__authorized_networks_config => {
                            if !fields.insert(__FieldTag::__authorized_networks_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorized_networks_config",
                                ));
                            }
                            result.authorized_networks_config =
                                map.next_value::<std::option::Option<
                                    crate::model::MasterAuthorizedNetworksConfig,
                                >>()?;
                        }
                        __FieldTag::__public_endpoint => {
                            if !fields.insert(__FieldTag::__public_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_endpoint",
                                ));
                            }
                            result.public_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_endpoint => {
                            if !fields.insert(__FieldTag::__private_endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint",
                                ));
                            }
                            result.private_endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_endpoint_subnetwork => {
                            if !fields.insert(__FieldTag::__private_endpoint_subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_endpoint_subnetwork",
                                ));
                            }
                            result.private_endpoint_subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::LocalNvmeSsdBlockConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __local_ssd_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocalNvmeSsdBlockConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "localSsdCount" => Ok(__FieldTag::__local_ssd_count),
                            "local_ssd_count" => Ok(__FieldTag::__local_ssd_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::LocalNvmeSsdBlockConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocalNvmeSsdBlockConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__local_ssd_count => {
                            if !fields.insert(__FieldTag::__local_ssd_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_ssd_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.local_ssd_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EphemeralStorageLocalSsdConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __local_ssd_count,
            __data_cache_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EphemeralStorageLocalSsdConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "localSsdCount" => Ok(__FieldTag::__local_ssd_count),
                            "local_ssd_count" => Ok(__FieldTag::__local_ssd_count),
                            "dataCacheCount" => Ok(__FieldTag::__data_cache_count),
                            "data_cache_count" => Ok(__FieldTag::__data_cache_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EphemeralStorageLocalSsdConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EphemeralStorageLocalSsdConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__local_ssd_count => {
                            if !fields.insert(__FieldTag::__local_ssd_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_ssd_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.local_ssd_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__data_cache_count => {
                            if !fields.insert(__FieldTag::__data_cache_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_cache_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_cache_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResourceManagerTags {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourceManagerTags")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResourceManagerTags;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourceManagerTags")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::EnterpriseConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_tier,
            __desired_tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnterpriseConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterTier" => Ok(__FieldTag::__cluster_tier),
                            "cluster_tier" => Ok(__FieldTag::__cluster_tier),
                            "desiredTier" => Ok(__FieldTag::__desired_tier),
                            "desired_tier" => Ok(__FieldTag::__desired_tier),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::EnterpriseConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnterpriseConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_tier => {
                            if !fields.insert(__FieldTag::__cluster_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_tier",
                                ));
                            }
                            result.cluster_tier =
                                map.next_value::<std::option::Option<
                                    crate::model::enterprise_config::ClusterTier,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__desired_tier => {
                            if !fields.insert(__FieldTag::__desired_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for desired_tier",
                                ));
                            }
                            result.desired_tier =
                                map.next_value::<std::option::Option<
                                    crate::model::enterprise_config::ClusterTier,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SecretManagerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecretManagerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enabled" => Ok(__FieldTag::__enabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SecretManagerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecretManagerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enabled => {
                            if !fields.insert(__FieldTag::__enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enabled",
                                ));
                            }
                            result.enabled = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BootDisk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disk_type,
            __size_gb,
            __provisioned_iops,
            __provisioned_throughput,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BootDisk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "sizeGb" => Ok(__FieldTag::__size_gb),
                            "size_gb" => Ok(__FieldTag::__size_gb),
                            "provisionedIops" => Ok(__FieldTag::__provisioned_iops),
                            "provisioned_iops" => Ok(__FieldTag::__provisioned_iops),
                            "provisionedThroughput" => Ok(__FieldTag::__provisioned_throughput),
                            "provisioned_throughput" => Ok(__FieldTag::__provisioned_throughput),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BootDisk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BootDisk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_gb => {
                            if !fields.insert(__FieldTag::__size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__provisioned_iops => {
                            if !fields.insert(__FieldTag::__provisioned_iops) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioned_iops",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.provisioned_iops =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__provisioned_throughput => {
                            if !fields.insert(__FieldTag::__provisioned_throughput) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioned_throughput",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.provisioned_throughput =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SecondaryBootDisk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __disk_image,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecondaryBootDisk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "diskImage" => Ok(__FieldTag::__disk_image),
                            "disk_image" => Ok(__FieldTag::__disk_image),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SecondaryBootDisk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecondaryBootDisk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map.next_value::<std::option::Option<crate::model::secondary_boot_disk::Mode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__disk_image => {
                            if !fields.insert(__FieldTag::__disk_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_image",
                                ));
                            }
                            result.disk_image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SecondaryBootDiskUpdateStrategy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SecondaryBootDiskUpdateStrategy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SecondaryBootDiskUpdateStrategy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SecondaryBootDiskUpdateStrategy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FetchClusterUpgradeInfoRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchClusterUpgradeInfoRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FetchClusterUpgradeInfoRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchClusterUpgradeInfoRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ClusterUpgradeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __minor_target_version,
            __patch_target_version,
            __auto_upgrade_status,
            __paused_reason,
            __upgrade_details,
            __end_of_standard_support_timestamp,
            __end_of_extended_support_timestamp,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterUpgradeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minorTargetVersion" => Ok(__FieldTag::__minor_target_version),
                            "minor_target_version" => Ok(__FieldTag::__minor_target_version),
                            "patchTargetVersion" => Ok(__FieldTag::__patch_target_version),
                            "patch_target_version" => Ok(__FieldTag::__patch_target_version),
                            "autoUpgradeStatus" => Ok(__FieldTag::__auto_upgrade_status),
                            "auto_upgrade_status" => Ok(__FieldTag::__auto_upgrade_status),
                            "pausedReason" => Ok(__FieldTag::__paused_reason),
                            "paused_reason" => Ok(__FieldTag::__paused_reason),
                            "upgradeDetails" => Ok(__FieldTag::__upgrade_details),
                            "upgrade_details" => Ok(__FieldTag::__upgrade_details),
                            "endOfStandardSupportTimestamp" => {
                                Ok(__FieldTag::__end_of_standard_support_timestamp)
                            }
                            "end_of_standard_support_timestamp" => {
                                Ok(__FieldTag::__end_of_standard_support_timestamp)
                            }
                            "endOfExtendedSupportTimestamp" => {
                                Ok(__FieldTag::__end_of_extended_support_timestamp)
                            }
                            "end_of_extended_support_timestamp" => {
                                Ok(__FieldTag::__end_of_extended_support_timestamp)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ClusterUpgradeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterUpgradeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__minor_target_version => {
                            if !fields.insert(__FieldTag::__minor_target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minor_target_version",
                                ));
                            }
                            result.minor_target_version =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__patch_target_version => {
                            if !fields.insert(__FieldTag::__patch_target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_target_version",
                                ));
                            }
                            result.patch_target_version =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__auto_upgrade_status => {
                            if !fields.insert(__FieldTag::__auto_upgrade_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_upgrade_status",
                                ));
                            }
                            result.auto_upgrade_status = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::cluster_upgrade_info::AutoUpgradeStatus,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__paused_reason => {
                            if !fields.insert(__FieldTag::__paused_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paused_reason",
                                ));
                            }
                            result.paused_reason = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::cluster_upgrade_info::AutoUpgradePausedReason,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgrade_details => {
                            if !fields.insert(__FieldTag::__upgrade_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_details",
                                ));
                            }
                            result.upgrade_details =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UpgradeDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_of_standard_support_timestamp => {
                            if !fields.insert(__FieldTag::__end_of_standard_support_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_standard_support_timestamp",
                                ));
                            }
                            result.end_of_standard_support_timestamp =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__end_of_extended_support_timestamp => {
                            if !fields.insert(__FieldTag::__end_of_extended_support_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_extended_support_timestamp",
                                ));
                            }
                            result.end_of_extended_support_timestamp =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::UpgradeDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __state,
            __start_time,
            __end_time,
            __initial_version,
            __target_version,
            __start_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "state" => Ok(__FieldTag::__state),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "initialVersion" => Ok(__FieldTag::__initial_version),
                            "initial_version" => Ok(__FieldTag::__initial_version),
                            "targetVersion" => Ok(__FieldTag::__target_version),
                            "target_version" => Ok(__FieldTag::__target_version),
                            "startType" => Ok(__FieldTag::__start_type),
                            "start_type" => Ok(__FieldTag::__start_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::UpgradeDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::upgrade_details::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__initial_version => {
                            if !fields.insert(__FieldTag::__initial_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_version",
                                ));
                            }
                            result.initial_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version => {
                            if !fields.insert(__FieldTag::__target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version",
                                ));
                            }
                            result.target_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_type => {
                            if !fields.insert(__FieldTag::__start_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_type",
                                ));
                            }
                            result.start_type = map.next_value::<std::option::Option<crate::model::upgrade_details::StartType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::FetchNodePoolUpgradeInfoRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchNodePoolUpgradeInfoRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::FetchNodePoolUpgradeInfoRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchNodePoolUpgradeInfoRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::NodePoolUpgradeInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __minor_target_version,
            __patch_target_version,
            __auto_upgrade_status,
            __paused_reason,
            __upgrade_details,
            __end_of_standard_support_timestamp,
            __end_of_extended_support_timestamp,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePoolUpgradeInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minorTargetVersion" => Ok(__FieldTag::__minor_target_version),
                            "minor_target_version" => Ok(__FieldTag::__minor_target_version),
                            "patchTargetVersion" => Ok(__FieldTag::__patch_target_version),
                            "patch_target_version" => Ok(__FieldTag::__patch_target_version),
                            "autoUpgradeStatus" => Ok(__FieldTag::__auto_upgrade_status),
                            "auto_upgrade_status" => Ok(__FieldTag::__auto_upgrade_status),
                            "pausedReason" => Ok(__FieldTag::__paused_reason),
                            "paused_reason" => Ok(__FieldTag::__paused_reason),
                            "upgradeDetails" => Ok(__FieldTag::__upgrade_details),
                            "upgrade_details" => Ok(__FieldTag::__upgrade_details),
                            "endOfStandardSupportTimestamp" => {
                                Ok(__FieldTag::__end_of_standard_support_timestamp)
                            }
                            "end_of_standard_support_timestamp" => {
                                Ok(__FieldTag::__end_of_standard_support_timestamp)
                            }
                            "endOfExtendedSupportTimestamp" => {
                                Ok(__FieldTag::__end_of_extended_support_timestamp)
                            }
                            "end_of_extended_support_timestamp" => {
                                Ok(__FieldTag::__end_of_extended_support_timestamp)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::NodePoolUpgradeInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePoolUpgradeInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__minor_target_version => {
                            if !fields.insert(__FieldTag::__minor_target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minor_target_version",
                                ));
                            }
                            result.minor_target_version =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__patch_target_version => {
                            if !fields.insert(__FieldTag::__patch_target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_target_version",
                                ));
                            }
                            result.patch_target_version =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__auto_upgrade_status => {
                            if !fields.insert(__FieldTag::__auto_upgrade_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for auto_upgrade_status",
                                ));
                            }
                            result.auto_upgrade_status = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::node_pool_upgrade_info::AutoUpgradeStatus,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__paused_reason => {
                            if !fields.insert(__FieldTag::__paused_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paused_reason",
                                ));
                            }
                            result.paused_reason = map.next_value::<std::option::Option<std::vec::Vec<crate::model::node_pool_upgrade_info::AutoUpgradePausedReason>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__upgrade_details => {
                            if !fields.insert(__FieldTag::__upgrade_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_details",
                                ));
                            }
                            result.upgrade_details =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UpgradeDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_of_standard_support_timestamp => {
                            if !fields.insert(__FieldTag::__end_of_standard_support_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_standard_support_timestamp",
                                ));
                            }
                            result.end_of_standard_support_timestamp =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__end_of_extended_support_timestamp => {
                            if !fields.insert(__FieldTag::__end_of_extended_support_timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_of_extended_support_timestamp",
                                ));
                            }
                            result.end_of_extended_support_timestamp =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GkeAutoUpgradeConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __patch_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GkeAutoUpgradeConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "patchMode" => Ok(__FieldTag::__patch_mode),
                            "patch_mode" => Ok(__FieldTag::__patch_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GkeAutoUpgradeConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GkeAutoUpgradeConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__patch_mode => {
                            if !fields.insert(__FieldTag::__patch_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for patch_mode",
                                ));
                            }
                            result.patch_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::gke_auto_upgrade_config::PatchMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
