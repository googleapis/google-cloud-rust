// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [ClusterManager](super::stub::ClusterManager) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct ClusterManager {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for ClusterManager {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ClusterManager")
            .field("inner", &self.inner)
            .finish()
    }
}

impl ClusterManager {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        #[cfg(google_cloud_unstable_tracing)]
        let tracing_is_enabled = gaxi::options::tracing_enabled(&config);
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        #[cfg(google_cloud_unstable_tracing)]
        let inner = if tracing_is_enabled {
            inner.with_instrumentation(&super::tracing::info::INSTRUMENTATION_CLIENT_INFO)
        } else {
            inner
        };
        Ok(Self { inner })
    }
}

impl super::stub::ClusterManager for ClusterManager {
    async fn list_clusters(
        &self,
        req: crate::model::ListClustersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListClustersResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/clusters",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/clusters";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("projectId", &req.project_id)]);
                let builder = builder.query(&[("zone", &req.zone)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("parent", &req.parent)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_cluster(
        &self,
        req: crate::model::GetClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Cluster>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("projectId", &req.project_id)]);
                let builder = builder.query(&[("zone", &req.zone)]);
                let builder = builder.query(&[("clusterId", &req.cluster_id)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("name", &req.name)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn create_cluster(
        &self,
        req: crate::model::CreateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/clusters",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/clusters";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_cluster(
        &self,
        req: crate::model::UpdateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}";

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_node_pool(
        &self,
        req: crate::model::UpdateNodePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard])?,
            );
            let path_template = "/v1/{name}";

            let builder = self
                .inner
                .builder(reqwest::Method::PUT, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PUT, path_template)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}/update",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );
            let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools/{node_pool_id}/update";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/clusters/*/nodePools/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "cluster_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "node_pool_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_node_pool_autoscaling(
        &self,
        req: crate::model::SetNodePoolAutoscalingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:setAutoscaling",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard])?,
            );
            let path_template = "/v1/{name}:setAutoscaling";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}/autoscaling",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );
            let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools/{node_pool_id}/autoscaling";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/clusters/*/nodePools/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "cluster_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "node_pool_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_logging_service(
        &self,
        req: crate::model::SetLoggingServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:setLogging",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:setLogging";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/logging",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/logging";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_monitoring_service(
        &self,
        req: crate::model::SetMonitoringServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:setMonitoring",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:setMonitoring";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/monitoring",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/monitoring";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_addons_config(
        &self,
        req: crate::model::SetAddonsConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:setAddons",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:setAddons";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/addons",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/addons";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_locations(
        &self,
        req: crate::model::SetLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:setLocations",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:setLocations";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/locations",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/locations";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_master(
        &self,
        req: crate::model::UpdateMasterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:updateMaster",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:updateMaster";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/master",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/master";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_master_auth(
        &self,
        req: crate::model::SetMasterAuthRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:setMasterAuth",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:setMasterAuth";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}:setMasterAuth",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}:setMasterAuth";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_cluster(
        &self,
        req: crate::model::DeleteClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = builder.query(&[("projectId", &req.project_id)]);
                let builder = builder.query(&[("zone", &req.zone)]);
                let builder = builder.query(&[("clusterId", &req.cluster_id)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}";

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = builder.query(&[("name", &req.name)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_operations(
        &self,
        req: crate::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListOperationsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/operations",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/operations";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("projectId", &req.project_id)]);
                let builder = builder.query(&[("zone", &req.zone)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/operations",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template = "/v1/projects/{project_id}/zones/{zone}/operations";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("parent", &req.parent)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("projectId", &req.project_id)]);
                let builder = builder.query(&[("zone", &req.zone)]);
                let builder = builder.query(&[("operationId", &req.operation_id)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/operations/{operation_id}";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("name", &req.name)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn cancel_operation(
        &self,
        req: crate::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:cancel",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:cancel";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/operations/{}:cancel",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/operations/{operation_id}:cancel";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/operations/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/operations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn get_server_config(
        &self,
        req: crate::model::GetServerConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServerConfig>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/serverConfig",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}/serverConfig";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("projectId", &req.project_id)]);
                let builder = builder.query(&[("zone", &req.zone)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/serverconfig",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template = "/v1/projects/{project_id}/zones/{zone}/serverconfig";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("name", &req.name)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_json_web_keys(
        &self,
        req: crate::model::GetJSONWebKeysRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GetJSONWebKeysResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/jwks",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/jwks";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_node_pools(
        &self,
        req: crate::model::ListNodePoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListNodePoolsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/nodePools",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/nodePools";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("projectId", &req.project_id)]);
                let builder = builder.query(&[("zone", &req.zone)]);
                let builder = builder.query(&[("clusterId", &req.cluster_id)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/nodePools",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("parent", &req.parent)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_node_pool(
        &self,
        req: crate::model::GetNodePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodePool>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard])?,
            );
            let path_template = "/v1/{name}";

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("projectId", &req.project_id)]);
            let builder = builder.query(&[("zone", &req.zone)]);
            let builder = builder.query(&[("clusterId", &req.cluster_id)]);
            let builder = builder.query(&[("nodePoolId", &req.node_pool_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );
            let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools/{node_pool_id}";

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = builder.query(&[("name", &req.name)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/clusters/*/nodePools/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "cluster_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "node_pool_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn create_node_pool(
        &self,
        req: crate::model::CreateNodePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/nodePools",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{parent}/nodePools";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/nodePools",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "parent",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_node_pool(
        &self,
        req: crate::model::DeleteNodePoolRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard])?,
            );
            let path_template = "/v1/{name}";

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = builder.query(&[("projectId", &req.project_id)]);
            let builder = builder.query(&[("zone", &req.zone)]);
            let builder = builder.query(&[("clusterId", &req.cluster_id)]);
            let builder = builder.query(&[("nodePoolId", &req.node_pool_id)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE, path_template)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );
            let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools/{node_pool_id}";

            let builder = self
                .inner
                .builder(reqwest::Method::DELETE, path);
            let builder = builder.query(&[("name", &req.name)]);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::DELETE, path_template)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/clusters/*/nodePools/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "cluster_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "node_pool_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn complete_node_pool_upgrade(
        &self,
        req: crate::model::CompleteNodePoolUpgradeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:completeUpgrade",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/nodePools/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:completeUpgrade";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/nodePools/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn rollback_node_pool_upgrade(
        &self,
        req: crate::model::RollbackNodePoolUpgradeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:rollback",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard])?,
            );
            let path_template = "/v1/{name}:rollback";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}:rollback",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );
            let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools/{node_pool_id}:rollback";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/clusters/*/nodePools/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "cluster_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "node_pool_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_node_pool_management(
        &self,
        req: crate::model::SetNodePoolManagementRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:setManagement",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard])?,
            );
            let path_template = "/v1/{name}:setManagement";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}/setManagement",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );
            let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools/{node_pool_id}/setManagement";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/clusters/*/nodePools/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "cluster_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "node_pool_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:setResourceLabels",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:setResourceLabels";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/resourceLabels",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/resourceLabels";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_legacy_abac(
        &self,
        req: crate::model::SetLegacyAbacRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:setLegacyAbac",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:setLegacyAbac";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}/legacyAbac",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/legacyAbac";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start_ip_rotation(
        &self,
        req: crate::model::StartIPRotationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:startIpRotation",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:startIpRotation";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}:startIpRotation",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}:startIpRotation";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn complete_ip_rotation(
        &self,
        req: crate::model::CompleteIPRotationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:completeIpRotation",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard])?,
            );
            let path_template = "/v1/{name}:completeIpRotation";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/zones/{}/clusters/{}:completeIpRotation",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );
            let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}:completeIpRotation";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/clusters/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "cluster_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_node_pool_size(
        &self,
        req: crate::model::SetNodePoolSizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:setSize",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard])?,
            );
            let path_template = "/v1/{name}:setSize";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/zones/{}/clusters/{}/nodePools/{}/setSize",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );
            let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools/{node_pool_id}/setSize";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard, Segment::Literal("/nodePools/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/clusters/*/nodePools/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "cluster_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.node_pool_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "node_pool_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_network_policy(
        &self,
        req: crate::model::SetNetworkPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:setNetworkPolicy",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:setNetworkPolicy";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/projects/{}/zones/{}/clusters/{}:setNetworkPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );
                let path_template =
                    "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}:setNetworkPolicy";

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project_id",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cluster_id",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_maintenance_policy(
        &self,
        req: crate::model::SetMaintenancePolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
        .or_else(|| {
            let path = format!(
                "/v1/{}:setMaintenancePolicy",
                try_match(Some(&req).map(|m| &m.name).map(|s| s.as_str()), &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard])?,
            );
            let path_template = "/v1/{name}:setMaintenancePolicy";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .or_else(|| {
            let path = format!(
                "/v1/projects/{}/zones/{}/clusters/{}:setMaintenancePolicy",
                try_match(Some(&req).map(|m| &m.project_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );
            let path_template = "/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}:setMaintenancePolicy";

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST, path_template)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                    &[Segment::Literal("projects/"), Segment::SingleWildcard, Segment::Literal("/locations/"), Segment::SingleWildcard, Segment::Literal("/clusters/"), Segment::SingleWildcard],
                    "name",
                    "projects/*/locations/*/clusters/*");
                paths.push(builder.build());
            }
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project_id",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.cluster_id).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "cluster_id",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(Some(req), &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_usable_subnetworks(
        &self,
        req: crate::model::ListUsableSubnetworksRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUsableSubnetworksResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}/aggregated/usableSubnetworks",
                    try_match(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard]
                    )?,
                );
                let path_template = "/v1/{parent}/aggregated/usableSubnetworks";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("filter", &req.filter)]);
                let builder = builder.query(&[("pageSize", &req.page_size)]);
                let builder = builder.query(&[("pageToken", &req.page_token)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent).map(|s| s.as_str()),
                        &[Segment::Literal("projects/"), Segment::SingleWildcard],
                        "parent",
                        "projects/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn check_autopilot_compatibility(
        &self,
        req: crate::model::CheckAutopilotCompatibilityRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CheckAutopilotCompatibilityResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:checkAutopilotCompatibility",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:checkAutopilotCompatibility";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn fetch_cluster_upgrade_info(
        &self,
        req: crate::model::FetchClusterUpgradeInfoRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ClusterUpgradeInfo>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:fetchClusterUpgradeInfo",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:fetchClusterUpgradeInfo";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("version", &req.version)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/{}:fetchClusterUpgradeInfo",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:fetchClusterUpgradeInfo";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("version", &req.version)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/zones/*/clusters/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn fetch_node_pool_upgrade_info(
        &self,
        req: crate::model::FetchNodePoolUpgradeInfoRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodePoolUpgradeInfo>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method, _path_template) = None
            .or_else(|| {
                let path = format!(
                    "/v1/{}:fetchNodePoolUpgradeInfo",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/nodePools/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:fetchNodePoolUpgradeInfo";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("version", &req.version)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .or_else(|| {
                let path = format!(
                    "/v1/{}:fetchNodePoolUpgradeInfo",
                    try_match(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/nodePools/"),
                            Segment::SingleWildcard
                        ]
                    )?,
                );
                let path_template = "/v1/{name}:fetchNodePoolUpgradeInfo";

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("version", &req.version)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET, path_template)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/locations/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/nodePools/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/locations/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.name).map(|s| s.as_str()),
                        &[
                            Segment::Literal("projects/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/zones/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/clusters/"),
                            Segment::SingleWildcard,
                            Segment::Literal("/nodePools/"),
                            Segment::SingleWildcard,
                        ],
                        "name",
                        "projects/*/zones/*/clusters/*/nodePools/*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        #[cfg(google_cloud_unstable_tracing)]
        let options = gax::options::internal::set_path_template(options, _path_template);
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json;enum-encoding=int")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}
