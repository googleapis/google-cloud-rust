// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
use crate::Result;

/// Implements a [BigtableInstanceAdmin](super::stub::BigtableInstanceAdmin) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct BigtableInstanceAdmin<T>
where
    T: super::stub::BigtableInstanceAdmin + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> BigtableInstanceAdmin<T>
where
    T: super::stub::BigtableInstanceAdmin + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::BigtableInstanceAdmin for BigtableInstanceAdmin<T>
where
    T: super::stub::BigtableInstanceAdmin + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_instance(
        &self,
        req: crate::model::CreateInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::create_instance"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_instance",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_instance(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_instance(
        &self,
        req: crate::model::CreateInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_instance(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_instance(
        &self,
        req: crate::model::GetInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Instance>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::get_instance"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_instance",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_instance(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_instance(
        &self,
        req: crate::model::GetInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Instance>> {
        self.inner.get_instance(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_instances(
        &self,
        req: crate::model::ListInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListInstancesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::list_instances"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_instances",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_instances(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_instances(
        &self,
        req: crate::model::ListInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListInstancesResponse>> {
        self.inner.list_instances(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_instance(
        &self,
        req: crate::model::Instance,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Instance>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::update_instance"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_instance",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_instance(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_instance(
        &self,
        req: crate::model::Instance,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Instance>> {
        self.inner.update_instance(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn partial_update_instance(
        &self,
        req: crate::model::PartialUpdateInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::partial_update_instance"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "partial_update_instance",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .partial_update_instance(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn partial_update_instance(
        &self,
        req: crate::model::PartialUpdateInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.partial_update_instance(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_instance(
        &self,
        req: crate::model::DeleteInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::delete_instance"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_instance",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_instance(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_instance(
        &self,
        req: crate::model::DeleteInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_instance(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_cluster(
        &self,
        req: crate::model::CreateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::create_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_cluster",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_cluster(
        &self,
        req: crate::model::CreateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_cluster(
        &self,
        req: crate::model::GetClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Cluster>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::get_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_cluster",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_cluster(
        &self,
        req: crate::model::GetClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Cluster>> {
        self.inner.get_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_clusters(
        &self,
        req: crate::model::ListClustersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListClustersResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::list_clusters"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_clusters",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_clusters(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_clusters(
        &self,
        req: crate::model::ListClustersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListClustersResponse>> {
        self.inner.list_clusters(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_cluster(
        &self,
        req: crate::model::Cluster,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::update_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_cluster",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_cluster(
        &self,
        req: crate::model::Cluster,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn partial_update_cluster(
        &self,
        req: crate::model::PartialUpdateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::partial_update_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "partial_update_cluster",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .partial_update_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn partial_update_cluster(
        &self,
        req: crate::model::PartialUpdateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.partial_update_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_cluster(
        &self,
        req: crate::model::DeleteClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::delete_cluster"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_cluster",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_cluster(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_cluster(
        &self,
        req: crate::model::DeleteClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_cluster(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_app_profile(
        &self,
        req: crate::model::CreateAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AppProfile>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::create_app_profile"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_app_profile",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_app_profile(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_app_profile(
        &self,
        req: crate::model::CreateAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AppProfile>> {
        self.inner.create_app_profile(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_app_profile(
        &self,
        req: crate::model::GetAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AppProfile>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::get_app_profile"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_app_profile",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_app_profile(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_app_profile(
        &self,
        req: crate::model::GetAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AppProfile>> {
        self.inner.get_app_profile(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_app_profiles(
        &self,
        req: crate::model::ListAppProfilesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAppProfilesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::list_app_profiles"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_app_profiles",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_app_profiles(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_app_profiles(
        &self,
        req: crate::model::ListAppProfilesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAppProfilesResponse>> {
        self.inner.list_app_profiles(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_app_profile(
        &self,
        req: crate::model::UpdateAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::update_app_profile"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_app_profile",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_app_profile(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_app_profile(
        &self,
        req: crate::model::UpdateAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_app_profile(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_app_profile(
        &self,
        req: crate::model::DeleteAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::delete_app_profile"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_app_profile",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_app_profile(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_app_profile(
        &self,
        req: crate::model::DeleteAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_app_profile(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_hot_tablets(
        &self,
        req: crate::model::ListHotTabletsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListHotTabletsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::list_hot_tablets"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_hot_tablets",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_hot_tablets(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_hot_tablets(
        &self,
        req: crate::model::ListHotTabletsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListHotTabletsResponse>> {
        self.inner.list_hot_tablets(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_logical_view(
        &self,
        req: crate::model::CreateLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::create_logical_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_logical_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_logical_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_logical_view(
        &self,
        req: crate::model::CreateLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_logical_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_logical_view(
        &self,
        req: crate::model::GetLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LogicalView>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::get_logical_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_logical_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_logical_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_logical_view(
        &self,
        req: crate::model::GetLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LogicalView>> {
        self.inner.get_logical_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_logical_views(
        &self,
        req: crate::model::ListLogicalViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListLogicalViewsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::list_logical_views"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_logical_views",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_logical_views(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_logical_views(
        &self,
        req: crate::model::ListLogicalViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListLogicalViewsResponse>> {
        self.inner.list_logical_views(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_logical_view(
        &self,
        req: crate::model::UpdateLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::update_logical_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_logical_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_logical_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_logical_view(
        &self,
        req: crate::model::UpdateLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_logical_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_logical_view(
        &self,
        req: crate::model::DeleteLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::delete_logical_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_logical_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_logical_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_logical_view(
        &self,
        req: crate::model::DeleteLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_logical_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_materialized_view(
        &self,
        req: crate::model::CreateMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::create_materialized_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_materialized_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_materialized_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_materialized_view(
        &self,
        req: crate::model::CreateMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_materialized_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_materialized_view(
        &self,
        req: crate::model::GetMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MaterializedView>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::get_materialized_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_materialized_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_materialized_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_materialized_view(
        &self,
        req: crate::model::GetMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MaterializedView>> {
        self.inner.get_materialized_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_materialized_views(
        &self,
        req: crate::model::ListMaterializedViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMaterializedViewsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::list_materialized_views"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_materialized_views",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_materialized_views(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_materialized_views(
        &self,
        req: crate::model::ListMaterializedViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMaterializedViewsResponse>> {
        self.inner.list_materialized_views(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_materialized_view(
        &self,
        req: crate::model::UpdateMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::update_materialized_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_materialized_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_materialized_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_materialized_view(
        &self,
        req: crate::model::UpdateMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_materialized_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_materialized_view(
        &self,
        req: crate::model::DeleteMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::delete_materialized_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_materialized_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_materialized_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_materialized_view(
        &self,
        req: crate::model::DeleteMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_materialized_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableInstanceAdmin",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements a [BigtableTableAdmin](super::stub::BigtableTableAdmin) decorator for logging and tracing.
#[derive(Clone, Debug)]
pub struct BigtableTableAdmin<T>
where
    T: super::stub::BigtableTableAdmin + std::fmt::Debug + Send + Sync,
{
    inner: T,
}

impl<T> BigtableTableAdmin<T>
where
    T: super::stub::BigtableTableAdmin + std::fmt::Debug + Send + Sync,
{
    pub fn new(inner: T) -> Self {
        Self { inner }
    }
}

impl<T> super::stub::BigtableTableAdmin for BigtableTableAdmin<T>
where
    T: super::stub::BigtableTableAdmin + std::fmt::Debug + Send + Sync,
{
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_table(
        &self,
        req: crate::model::CreateTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::create_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_table(
        &self,
        req: crate::model::CreateTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        self.inner.create_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_table_from_snapshot(
        &self,
        req: crate::model::CreateTableFromSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::create_table_from_snapshot"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_table_from_snapshot",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_table_from_snapshot(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_table_from_snapshot(
        &self,
        req: crate::model::CreateTableFromSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_table_from_snapshot(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_tables(
        &self,
        req: crate::model::ListTablesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTablesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::list_tables"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_tables",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_tables(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_tables(
        &self,
        req: crate::model::ListTablesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTablesResponse>> {
        self.inner.list_tables(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_table(
        &self,
        req: crate::model::GetTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::get_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_table(
        &self,
        req: crate::model::GetTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        self.inner.get_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_table(
        &self,
        req: crate::model::UpdateTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::update_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_table(
        &self,
        req: crate::model::UpdateTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_table(
        &self,
        req: crate::model::DeleteTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::delete_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_table(
        &self,
        req: crate::model::DeleteTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn undelete_table(
        &self,
        req: crate::model::UndeleteTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::undelete_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "undelete_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .undelete_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn undelete_table(
        &self,
        req: crate::model::UndeleteTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.undelete_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_authorized_view(
        &self,
        req: crate::model::CreateAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::create_authorized_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_authorized_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_authorized_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_authorized_view(
        &self,
        req: crate::model::CreateAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_authorized_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_authorized_views(
        &self,
        req: crate::model::ListAuthorizedViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAuthorizedViewsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::list_authorized_views"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_authorized_views",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_authorized_views(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_authorized_views(
        &self,
        req: crate::model::ListAuthorizedViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAuthorizedViewsResponse>> {
        self.inner.list_authorized_views(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_authorized_view(
        &self,
        req: crate::model::GetAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AuthorizedView>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::get_authorized_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_authorized_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_authorized_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_authorized_view(
        &self,
        req: crate::model::GetAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AuthorizedView>> {
        self.inner.get_authorized_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_authorized_view(
        &self,
        req: crate::model::UpdateAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::update_authorized_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_authorized_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_authorized_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_authorized_view(
        &self,
        req: crate::model::UpdateAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_authorized_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_authorized_view(
        &self,
        req: crate::model::DeleteAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::delete_authorized_view"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_authorized_view",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_authorized_view(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_authorized_view(
        &self,
        req: crate::model::DeleteAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_authorized_view(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn modify_column_families(
        &self,
        req: crate::model::ModifyColumnFamiliesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::modify_column_families"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "modify_column_families",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .modify_column_families(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn modify_column_families(
        &self,
        req: crate::model::ModifyColumnFamiliesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        self.inner.modify_column_families(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn drop_row_range(
        &self,
        req: crate::model::DropRowRangeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::drop_row_range"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "drop_row_range",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .drop_row_range(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn drop_row_range(
        &self,
        req: crate::model::DropRowRangeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.drop_row_range(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn generate_consistency_token(
        &self,
        req: crate::model::GenerateConsistencyTokenRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateConsistencyTokenResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::generate_consistency_token"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "generate_consistency_token",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .generate_consistency_token(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn generate_consistency_token(
        &self,
        req: crate::model::GenerateConsistencyTokenRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateConsistencyTokenResponse>> {
        self.inner.generate_consistency_token(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn check_consistency(
        &self,
        req: crate::model::CheckConsistencyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CheckConsistencyResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::check_consistency"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "check_consistency",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .check_consistency(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn check_consistency(
        &self,
        req: crate::model::CheckConsistencyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CheckConsistencyResponse>> {
        self.inner.check_consistency(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn snapshot_table(
        &self,
        req: crate::model::SnapshotTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::snapshot_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "snapshot_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .snapshot_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn snapshot_table(
        &self,
        req: crate::model::SnapshotTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.snapshot_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_snapshot(
        &self,
        req: crate::model::GetSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snapshot>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::get_snapshot"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_snapshot",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_snapshot(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_snapshot(
        &self,
        req: crate::model::GetSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snapshot>> {
        self.inner.get_snapshot(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_snapshots(
        &self,
        req: crate::model::ListSnapshotsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSnapshotsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::list_snapshots"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_snapshots",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_snapshots(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_snapshots(
        &self,
        req: crate::model::ListSnapshotsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSnapshotsResponse>> {
        self.inner.list_snapshots(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_snapshot(
        &self,
        req: crate::model::DeleteSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::delete_snapshot"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_snapshot",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_snapshot(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_snapshot(
        &self,
        req: crate::model::DeleteSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_snapshot(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_backup(
        &self,
        req: crate::model::CreateBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::create_backup"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_backup",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_backup(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_backup(
        &self,
        req: crate::model::CreateBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_backup(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_backup(
        &self,
        req: crate::model::GetBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Backup>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::get_backup"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_backup",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_backup(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_backup(
        &self,
        req: crate::model::GetBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Backup>> {
        self.inner.get_backup(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_backup(
        &self,
        req: crate::model::UpdateBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Backup>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::update_backup"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_backup",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_backup(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_backup(
        &self,
        req: crate::model::UpdateBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Backup>> {
        self.inner.update_backup(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_backup(
        &self,
        req: crate::model::DeleteBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::delete_backup"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_backup",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_backup(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_backup(
        &self,
        req: crate::model::DeleteBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_backup(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_backups(
        &self,
        req: crate::model::ListBackupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListBackupsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::list_backups"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_backups",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_backups(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_backups(
        &self,
        req: crate::model::ListBackupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListBackupsResponse>> {
        self.inner.list_backups(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn restore_table(
        &self,
        req: crate::model::RestoreTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::restore_table"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "restore_table",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .restore_table(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn restore_table(
        &self,
        req: crate::model::RestoreTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.restore_table(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn copy_backup(
        &self,
        req: crate::model::CopyBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::copy_backup"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "copy_backup",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .copy_backup(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn copy_backup(
        &self,
        req: crate::model::CopyBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.copy_backup(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::get_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.get_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::set_iam_policy"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "set_iam_policy",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .set_iam_policy(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        self.inner.set_iam_policy(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::test_iam_permissions"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "test_iam_permissions",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .test_iam_permissions(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        self.inner.test_iam_permissions(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn create_schema_bundle(
        &self,
        req: crate::model::CreateSchemaBundleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::create_schema_bundle"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "create_schema_bundle",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .create_schema_bundle(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn create_schema_bundle(
        &self,
        req: crate::model::CreateSchemaBundleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.create_schema_bundle(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn update_schema_bundle(
        &self,
        req: crate::model::UpdateSchemaBundleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::update_schema_bundle"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "update_schema_bundle",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .update_schema_bundle(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn update_schema_bundle(
        &self,
        req: crate::model::UpdateSchemaBundleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.update_schema_bundle(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_schema_bundle(
        &self,
        req: crate::model::GetSchemaBundleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SchemaBundle>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::get_schema_bundle"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_schema_bundle",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_schema_bundle(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_schema_bundle(
        &self,
        req: crate::model::GetSchemaBundleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SchemaBundle>> {
        self.inner.get_schema_bundle(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_schema_bundles(
        &self,
        req: crate::model::ListSchemaBundlesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSchemaBundlesResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::list_schema_bundles"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_schema_bundles",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_schema_bundles(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_schema_bundles(
        &self,
        req: crate::model::ListSchemaBundlesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSchemaBundlesResponse>> {
        self.inner.list_schema_bundles(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_schema_bundle(
        &self,
        req: crate::model::DeleteSchemaBundleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::delete_schema_bundle"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_schema_bundle",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_schema_bundle(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_schema_bundle(
        &self,
        req: crate::model::DeleteSchemaBundleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_schema_bundle(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::list_operations"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "list_operations",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .list_operations(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        self.inner.list_operations(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::get_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "get_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .get_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        self.inner.get_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::delete_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "delete_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .delete_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.delete_operation(req, options).await
    }
    #[cfg(google_cloud_unstable_tracing)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        use tracing::Instrument;
        let span_name = concat!(
            env!("CARGO_PKG_NAME"),
            "::client::",
            "BigtableTableAdmin",
            "::cancel_operation"
        );
        let client_request_span = gaxi::observability::create_client_request_span(
            span_name,
            "cancel_operation",
            &crate::info::INSTRUMENTATION_CLIENT_INFO,
        );

        let result = self
            .inner
            .cancel_operation(req, options)
            .instrument(client_request_span.clone())
            .await;

        gaxi::observability::record_client_request_span(&result, &client_request_span);
        result
    }

    #[cfg(not(google_cloud_unstable_tracing))]
    #[tracing::instrument(ret)]
    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        self.inner.cancel_operation(req, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}
