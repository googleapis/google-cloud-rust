// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for BigtableInstanceAdmin.CreateInstance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The unique name of the project in which to create the new
    /// instance. Values are of the form `projects/{project}`.
    pub parent: std::string::String,

    /// Required. The ID to be used when referring to the new instance within its
    /// project, e.g., just `myinstance` rather than
    /// `projects/myproject/instances/myinstance`.
    pub instance_id: std::string::String,

    /// Required. The instance to create.
    /// Fields marked `OutputOnly` must be left blank.
    pub instance: std::option::Option<crate::model::Instance>,

    /// Required. The clusters to be created within the instance, mapped by desired
    /// cluster ID, e.g., just `mycluster` rather than
    /// `projects/myproject/instances/myinstance/clusters/mycluster`.
    /// Fields marked `OutputOnly` must be left blank.
    pub clusters: std::collections::HashMap<std::string::String, crate::model::Cluster>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [clusters][crate::model::CreateInstanceRequest::clusters].
    pub fn set_clusters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __instance_id,
            __instance,
            __clusters,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "instanceId" => Ok(__FieldTag::__instance_id),
                            "instance_id" => Ok(__FieldTag::__instance_id),
                            "instance" => Ok(__FieldTag::__instance),
                            "clusters" => Ok(__FieldTag::__clusters),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_id => {
                            if !fields.insert(__FieldTag::__instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_id",
                                ));
                            }
                            result.instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::__clusters => {
                            if !fields.insert(__FieldTag::__clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clusters",
                                ));
                            }
                            result.clusters = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::Cluster,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.clusters.is_empty() {
            state.serialize_entry("clusters", &self.clusters)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.GetInstance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The unique name of the requested instance. Values are of the form
    /// `projects/{project}/instances/{instance}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.ListInstances.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The unique name of the project for which a list of instances is
    /// requested. Values are of the form `projects/{project}`.
    pub parent: std::string::String,

    /// DEPRECATED: This field is unused and ignored.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListInstancesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for BigtableInstanceAdmin.ListInstances.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The list of requested instances.
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// Locations from which Instance information could not be retrieved,
    /// due to an outage or some other transient condition.
    /// Instances whose Clusters are all in one of the failed locations
    /// may be missing from `instances`, and Instances with at least one
    /// Cluster in a failed location may only have partial information returned.
    /// Values are of the form `projects/<project>/locations/<zone_id>`
    pub failed_locations: std::vec::Vec<std::string::String>,

    /// DEPRECATED: This field is unused and ignored.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [failed_locations][crate::model::ListInstancesResponse::failed_locations].
    pub fn set_failed_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.failed_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instances,
            __failed_locations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instances" => Ok(__FieldTag::__instances),
                            "failedLocations" => Ok(__FieldTag::__failed_locations),
                            "failed_locations" => Ok(__FieldTag::__failed_locations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Instance>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__failed_locations => {
                            if !fields.insert(__FieldTag::__failed_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_locations",
                                ));
                            }
                            result.failed_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self.failed_locations.is_empty() {
            state.serialize_entry("failedLocations", &self.failed_locations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.PartialUpdateInstance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PartialUpdateInstanceRequest {
    /// Required. The Instance which will (partially) replace the current value.
    pub instance: std::option::Option<crate::model::Instance>,

    /// Required. The subset of Instance fields which should be replaced.
    /// Must be explicitly set.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PartialUpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::PartialUpdateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::PartialUpdateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::PartialUpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::PartialUpdateInstanceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PartialUpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.PartialUpdateInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PartialUpdateInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartialUpdateInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PartialUpdateInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartialUpdateInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PartialUpdateInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.DeleteInstance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The unique name of the instance to be deleted.
    /// Values are of the form `projects/{project}/instances/{instance}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.CreateCluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The unique name of the instance in which to create the new
    /// cluster. Values are of the form `projects/{project}/instances/{instance}`.
    pub parent: std::string::String,

    /// Required. The ID to be used when referring to the new cluster within its
    /// instance, e.g., just `mycluster` rather than
    /// `projects/myproject/instances/myinstance/clusters/mycluster`.
    pub cluster_id: std::string::String,

    /// Required. The cluster to be created.
    /// Fields marked `OutputOnly` must be left blank.
    pub cluster: std::option::Option<crate::model::Cluster>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cluster_id,
            __cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "cluster" => Ok(__FieldTag::__cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.GetCluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. The unique name of the requested cluster. Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.ListClusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The unique name of the instance for which a list of clusters is
    /// requested. Values are of the form
    /// `projects/{project}/instances/{instance}`. Use `{instance} = '-'` to list
    /// Clusters for all Instances in a project, e.g.,
    /// `projects/myproject/instances/-`.
    pub parent: std::string::String,

    /// DEPRECATED: This field is unused and ignored.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListClustersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for BigtableInstanceAdmin.ListClusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// The list of requested clusters.
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// Locations from which Cluster information could not be retrieved,
    /// due to an outage or some other transient condition.
    /// Clusters from these locations may be missing from `clusters`,
    /// or may only have partial information returned.
    /// Values are of the form `projects/<project>/locations/<zone_id>`
    pub failed_locations: std::vec::Vec<std::string::String>,

    /// DEPRECATED: This field is unused and ignored.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [failed_locations][crate::model::ListClustersResponse::failed_locations].
    pub fn set_failed_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.failed_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListClustersResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clusters,
            __failed_locations,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusters" => Ok(__FieldTag::__clusters),
                            "failedLocations" => Ok(__FieldTag::__failed_locations),
                            "failed_locations" => Ok(__FieldTag::__failed_locations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clusters => {
                            if !fields.insert(__FieldTag::__clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clusters",
                                ));
                            }
                            result.clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Cluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__failed_locations => {
                            if !fields.insert(__FieldTag::__failed_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_locations",
                                ));
                            }
                            result.failed_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.clusters.is_empty() {
            state.serialize_entry("clusters", &self.clusters)?;
        }
        if !self.failed_locations.is_empty() {
            state.serialize_entry("failedLocations", &self.failed_locations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.DeleteCluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. The unique name of the cluster to be deleted. Values are of the
    /// form `projects/{project}/instances/{instance}/clusters/{cluster}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by CreateInstance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceMetadata {
    /// The request that prompted the initiation of this CreateInstance operation.
    pub original_request: std::option::Option<crate::model::CreateInstanceRequest>,

    /// The time at which the original request was received.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    pub finish_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::CreateInstanceMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CreateInstanceRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::CreateInstanceMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CreateInstanceRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_time][crate::model::CreateInstanceMetadata::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::CreateInstanceMetadata::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::CreateInstanceMetadata::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::CreateInstanceMetadata::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateInstanceMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInstanceMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __request_time,
            __finish_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInstanceMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInstanceMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInstanceMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request = map.next_value::<std::option::Option<crate::model::CreateInstanceRequest>>()?
                                ;
                        }
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInstanceMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.finish_time.is_some() {
            state.serialize_entry("finishTime", &self.finish_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by UpdateInstance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceMetadata {
    /// The request that prompted the initiation of this UpdateInstance operation.
    pub original_request: std::option::Option<crate::model::PartialUpdateInstanceRequest>,

    /// The time at which the original request was received.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    pub finish_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::UpdateInstanceMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PartialUpdateInstanceRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::UpdateInstanceMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PartialUpdateInstanceRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_time][crate::model::UpdateInstanceMetadata::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::UpdateInstanceMetadata::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::UpdateInstanceMetadata::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::UpdateInstanceMetadata::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateInstanceMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInstanceMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __request_time,
            __finish_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInstanceMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInstanceMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInstanceMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request = map.next_value::<std::option::Option<crate::model::PartialUpdateInstanceRequest>>()?
                                ;
                        }
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInstanceMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.finish_time.is_some() {
            state.serialize_entry("finishTime", &self.finish_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by CreateCluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateClusterMetadata {
    /// The request that prompted the initiation of this CreateCluster operation.
    pub original_request: std::option::Option<crate::model::CreateClusterRequest>,

    /// The time at which the original request was received.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    pub finish_time: std::option::Option<wkt::Timestamp>,

    /// Keys: the full `name` of each table that existed in the instance when
    /// CreateCluster was first called, i.e.
    /// `projects/<project>/instances/<instance>/tables/<table>`. Any table added
    /// to the instance by a later API call will be created in the new cluster by
    /// that API call, not this one.
    ///
    /// Values: information on how much of a table's data has been copied to the
    /// newly-created cluster so far.
    pub tables: std::collections::HashMap<
        std::string::String,
        crate::model::create_cluster_metadata::TableProgress,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::CreateClusterMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CreateClusterRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::CreateClusterMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CreateClusterRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_time][crate::model::CreateClusterMetadata::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::CreateClusterMetadata::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::CreateClusterMetadata::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::CreateClusterMetadata::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tables][crate::model::CreateClusterMetadata::tables].
    pub fn set_tables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::create_cluster_metadata::TableProgress>,
    {
        use std::iter::Iterator;
        self.tables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CreateClusterMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateClusterMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateClusterMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __request_time,
            __finish_time,
            __tables,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateClusterMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            "tables" => Ok(__FieldTag::__tables),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateClusterMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateClusterMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request = map.next_value::<std::option::Option<crate::model::CreateClusterRequest>>()?
                                ;
                        }
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__tables => {
                            if !fields.insert(__FieldTag::__tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tables",
                                ));
                            }
                            result.tables = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::create_cluster_metadata::TableProgress,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateClusterMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.finish_time.is_some() {
            state.serialize_entry("finishTime", &self.finish_time)?;
        }
        if !self.tables.is_empty() {
            state.serialize_entry("tables", &self.tables)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CreateClusterMetadata].
pub mod create_cluster_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Progress info for copying a table's data to the new cluster.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TableProgress {
        /// Estimate of the size of the table to be copied.
        pub estimated_size_bytes: i64,

        /// Estimate of the number of bytes copied so far for this table.
        /// This will eventually reach 'estimated_size_bytes' unless the table copy
        /// is CANCELLED.
        pub estimated_copied_bytes: i64,

        pub state: crate::model::create_cluster_metadata::table_progress::State,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TableProgress {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [estimated_size_bytes][crate::model::create_cluster_metadata::TableProgress::estimated_size_bytes].
        pub fn set_estimated_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.estimated_size_bytes = v.into();
            self
        }

        /// Sets the value of [estimated_copied_bytes][crate::model::create_cluster_metadata::TableProgress::estimated_copied_bytes].
        pub fn set_estimated_copied_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.estimated_copied_bytes = v.into();
            self
        }

        /// Sets the value of [state][crate::model::create_cluster_metadata::TableProgress::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::create_cluster_metadata::table_progress::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }
    }

    impl wkt::message::Message for TableProgress {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.CreateClusterMetadata.TableProgress"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TableProgress {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __estimated_size_bytes,
                __estimated_copied_bytes,
                __state,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TableProgress")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "estimatedSizeBytes" => Ok(__FieldTag::__estimated_size_bytes),
                                "estimated_size_bytes" => Ok(__FieldTag::__estimated_size_bytes),
                                "estimatedCopiedBytes" => Ok(__FieldTag::__estimated_copied_bytes),
                                "estimated_copied_bytes" => {
                                    Ok(__FieldTag::__estimated_copied_bytes)
                                }
                                "state" => Ok(__FieldTag::__state),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TableProgress;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TableProgress")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__estimated_size_bytes => {
                                if !fields.insert(__FieldTag::__estimated_size_bytes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for estimated_size_bytes",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.estimated_size_bytes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__estimated_copied_bytes => {
                                if !fields.insert(__FieldTag::__estimated_copied_bytes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for estimated_copied_bytes",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.estimated_copied_bytes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::create_cluster_metadata::table_progress::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TableProgress {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.estimated_size_bytes) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("estimatedSizeBytes", &__With(&self.estimated_size_bytes))?;
            }
            if !wkt::internal::is_default(&self.estimated_copied_bytes) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "estimatedCopiedBytes",
                    &__With(&self.estimated_copied_bytes),
                )?;
            }
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [TableProgress].
    pub mod table_progress {
        #[allow(unused_imports)]
        use super::*;

        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            Unspecified,
            /// The table has not yet begun copying to the new cluster.
            Pending,
            /// The table is actively being copied to the new cluster.
            Copying,
            /// The table has been fully copied to the new cluster.
            Completed,
            /// The table was deleted before it finished copying to the new cluster.
            /// Note that tables deleted after completion will stay marked as
            /// COMPLETED, not CANCELLED.
            Cancelled,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Pending => std::option::Option::Some(1),
                    Self::Copying => std::option::Option::Some(2),
                    Self::Completed => std::option::Option::Some(3),
                    Self::Cancelled => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Pending => std::option::Option::Some("PENDING"),
                    Self::Copying => std::option::Option::Some("COPYING"),
                    Self::Completed => std::option::Option::Some("COMPLETED"),
                    Self::Cancelled => std::option::Option::Some("CANCELLED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Pending,
                    2 => Self::Copying,
                    3 => Self::Completed,
                    4 => Self::Cancelled,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "PENDING" => Self::Pending,
                    "COPYING" => Self::Copying,
                    "COMPLETED" => Self::Completed,
                    "CANCELLED" => Self::Cancelled,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Pending => serializer.serialize_i32(1),
                    Self::Copying => serializer.serialize_i32(2),
                    Self::Completed => serializer.serialize_i32(3),
                    Self::Cancelled => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.bigtable.admin.v2.CreateClusterMetadata.TableProgress.State",
                ))
            }
        }
    }
}

/// The metadata for the Operation returned by UpdateCluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateClusterMetadata {
    /// The request that prompted the initiation of this UpdateCluster operation.
    pub original_request: std::option::Option<crate::model::Cluster>,

    /// The time at which the original request was received.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    pub finish_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::UpdateClusterMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::UpdateClusterMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_time][crate::model::UpdateClusterMetadata::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::UpdateClusterMetadata::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::UpdateClusterMetadata::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::UpdateClusterMetadata::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateClusterMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateClusterMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateClusterMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __request_time,
            __finish_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateClusterMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateClusterMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateClusterMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateClusterMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.finish_time.is_some() {
            state.serialize_entry("finishTime", &self.finish_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by PartialUpdateCluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PartialUpdateClusterMetadata {
    /// The time at which the original request was received.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    pub finish_time: std::option::Option<wkt::Timestamp>,

    /// The original request for PartialUpdateCluster.
    pub original_request: std::option::Option<crate::model::PartialUpdateClusterRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PartialUpdateClusterMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_time][crate::model::PartialUpdateClusterMetadata::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::PartialUpdateClusterMetadata::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::PartialUpdateClusterMetadata::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::PartialUpdateClusterMetadata::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [original_request][crate::model::PartialUpdateClusterMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PartialUpdateClusterRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::PartialUpdateClusterMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PartialUpdateClusterRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PartialUpdateClusterMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.PartialUpdateClusterMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PartialUpdateClusterMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request_time,
            __finish_time,
            __original_request,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartialUpdateClusterMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PartialUpdateClusterMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartialUpdateClusterMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request = map.next_value::<std::option::Option<crate::model::PartialUpdateClusterRequest>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PartialUpdateClusterMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.finish_time.is_some() {
            state.serialize_entry("finishTime", &self.finish_time)?;
        }
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.PartialUpdateCluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PartialUpdateClusterRequest {
    /// Required. The Cluster which contains the partial updates to be applied,
    /// subject to the update_mask.
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Required. The subset of Cluster fields which should be replaced.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PartialUpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::PartialUpdateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::PartialUpdateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::PartialUpdateClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::PartialUpdateClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PartialUpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.PartialUpdateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PartialUpdateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PartialUpdateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cluster" => Ok(__FieldTag::__cluster),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PartialUpdateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PartialUpdateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PartialUpdateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.CreateAppProfile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAppProfileRequest {
    /// Required. The unique name of the instance in which to create the new app
    /// profile. Values are of the form `projects/{project}/instances/{instance}`.
    pub parent: std::string::String,

    /// Required. The ID to be used when referring to the new app profile within
    /// its instance, e.g., just `myprofile` rather than
    /// `projects/myproject/instances/myinstance/appProfiles/myprofile`.
    pub app_profile_id: std::string::String,

    /// Required. The app profile to be created.
    /// Fields marked `OutputOnly` will be ignored.
    pub app_profile: std::option::Option<crate::model::AppProfile>,

    /// If true, ignore safety checks when creating the app profile.
    pub ignore_warnings: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAppProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAppProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [app_profile_id][crate::model::CreateAppProfileRequest::app_profile_id].
    pub fn set_app_profile_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.app_profile_id = v.into();
        self
    }

    /// Sets the value of [app_profile][crate::model::CreateAppProfileRequest::app_profile].
    pub fn set_app_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppProfile>,
    {
        self.app_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [app_profile][crate::model::CreateAppProfileRequest::app_profile].
    pub fn set_or_clear_app_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppProfile>,
    {
        self.app_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ignore_warnings][crate::model::CreateAppProfileRequest::ignore_warnings].
    pub fn set_ignore_warnings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_warnings = v.into();
        self
    }
}

impl wkt::message::Message for CreateAppProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateAppProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAppProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __app_profile_id,
            __app_profile,
            __ignore_warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAppProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "appProfileId" => Ok(__FieldTag::__app_profile_id),
                            "app_profile_id" => Ok(__FieldTag::__app_profile_id),
                            "appProfile" => Ok(__FieldTag::__app_profile),
                            "app_profile" => Ok(__FieldTag::__app_profile),
                            "ignoreWarnings" => Ok(__FieldTag::__ignore_warnings),
                            "ignore_warnings" => Ok(__FieldTag::__ignore_warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAppProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAppProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_profile_id => {
                            if !fields.insert(__FieldTag::__app_profile_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_profile_id",
                                ));
                            }
                            result.app_profile_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__app_profile => {
                            if !fields.insert(__FieldTag::__app_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_profile",
                                ));
                            }
                            result.app_profile =
                                map.next_value::<std::option::Option<crate::model::AppProfile>>()?;
                        }
                        __FieldTag::__ignore_warnings => {
                            if !fields.insert(__FieldTag::__ignore_warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_warnings",
                                ));
                            }
                            result.ignore_warnings = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAppProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.app_profile_id.is_empty() {
            state.serialize_entry("appProfileId", &self.app_profile_id)?;
        }
        if self.app_profile.is_some() {
            state.serialize_entry("appProfile", &self.app_profile)?;
        }
        if !wkt::internal::is_default(&self.ignore_warnings) {
            state.serialize_entry("ignoreWarnings", &self.ignore_warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.GetAppProfile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAppProfileRequest {
    /// Required. The unique name of the requested app profile. Values are of the
    /// form `projects/{project}/instances/{instance}/appProfiles/{app_profile}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAppProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAppProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAppProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetAppProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAppProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAppProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAppProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAppProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAppProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.ListAppProfiles.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAppProfilesRequest {
    /// Required. The unique name of the instance for which a list of app profiles
    /// is requested. Values are of the form
    /// `projects/{project}/instances/{instance}`.
    /// Use `{instance} = '-'` to list AppProfiles for all Instances in a project,
    /// e.g., `projects/myproject/instances/-`.
    pub parent: std::string::String,

    /// Maximum number of results per page.
    ///
    /// A page_size of zero lets the server choose the number of items to return.
    /// A page_size which is strictly positive will return at most that many items.
    /// A negative page_size will cause an error.
    ///
    /// Following the first request, subsequent paginated calls are not required
    /// to pass a page_size. If a page_size is set in subsequent calls, it must
    /// match the page_size given in the first request.
    pub page_size: i32,

    /// The value of `next_page_token` returned by a previous call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAppProfilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAppProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAppProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAppProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAppProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListAppProfilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAppProfilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAppProfilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAppProfilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAppProfilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAppProfilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for BigtableInstanceAdmin.ListAppProfiles.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAppProfilesResponse {
    /// The list of requested app profiles.
    pub app_profiles: std::vec::Vec<crate::model::AppProfile>,

    /// Set if not all app profiles could be returned in a single response.
    /// Pass this value to `page_token` in another request to get the next
    /// page of results.
    pub next_page_token: std::string::String,

    /// Locations from which AppProfile information could not be retrieved,
    /// due to an outage or some other transient condition.
    /// AppProfiles from these locations may be missing from `app_profiles`.
    /// Values are of the form `projects/<project>/locations/<zone_id>`
    pub failed_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAppProfilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [app_profiles][crate::model::ListAppProfilesResponse::app_profiles].
    pub fn set_app_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AppProfile>,
    {
        use std::iter::Iterator;
        self.app_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAppProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [failed_locations][crate::model::ListAppProfilesResponse::failed_locations].
    pub fn set_failed_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.failed_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAppProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListAppProfilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAppProfilesResponse {
    type PageItem = crate::model::AppProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.app_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAppProfilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __app_profiles,
            __next_page_token,
            __failed_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAppProfilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "appProfiles" => Ok(__FieldTag::__app_profiles),
                            "app_profiles" => Ok(__FieldTag::__app_profiles),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "failedLocations" => Ok(__FieldTag::__failed_locations),
                            "failed_locations" => Ok(__FieldTag::__failed_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAppProfilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAppProfilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__app_profiles => {
                            if !fields.insert(__FieldTag::__app_profiles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_profiles",
                                ));
                            }
                            result.app_profiles = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AppProfile>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failed_locations => {
                            if !fields.insert(__FieldTag::__failed_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failed_locations",
                                ));
                            }
                            result.failed_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAppProfilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.app_profiles.is_empty() {
            state.serialize_entry("appProfiles", &self.app_profiles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.failed_locations.is_empty() {
            state.serialize_entry("failedLocations", &self.failed_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.UpdateAppProfile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAppProfileRequest {
    /// Required. The app profile which will (partially) replace the current value.
    pub app_profile: std::option::Option<crate::model::AppProfile>,

    /// Required. The subset of app profile fields which should be replaced.
    /// If unset, all fields will be replaced.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If true, ignore safety checks when updating the app profile.
    pub ignore_warnings: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAppProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [app_profile][crate::model::UpdateAppProfileRequest::app_profile].
    pub fn set_app_profile<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppProfile>,
    {
        self.app_profile = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [app_profile][crate::model::UpdateAppProfileRequest::app_profile].
    pub fn set_or_clear_app_profile<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppProfile>,
    {
        self.app_profile = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAppProfileRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAppProfileRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ignore_warnings][crate::model::UpdateAppProfileRequest::ignore_warnings].
    pub fn set_ignore_warnings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_warnings = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAppProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateAppProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAppProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __app_profile,
            __update_mask,
            __ignore_warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAppProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "appProfile" => Ok(__FieldTag::__app_profile),
                            "app_profile" => Ok(__FieldTag::__app_profile),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "ignoreWarnings" => Ok(__FieldTag::__ignore_warnings),
                            "ignore_warnings" => Ok(__FieldTag::__ignore_warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAppProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAppProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__app_profile => {
                            if !fields.insert(__FieldTag::__app_profile) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for app_profile",
                                ));
                            }
                            result.app_profile =
                                map.next_value::<std::option::Option<crate::model::AppProfile>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__ignore_warnings => {
                            if !fields.insert(__FieldTag::__ignore_warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_warnings",
                                ));
                            }
                            result.ignore_warnings = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAppProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.app_profile.is_some() {
            state.serialize_entry("appProfile", &self.app_profile)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.ignore_warnings) {
            state.serialize_entry("ignoreWarnings", &self.ignore_warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.DeleteAppProfile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAppProfileRequest {
    /// Required. The unique name of the app profile to be deleted. Values are of
    /// the form
    /// `projects/{project}/instances/{instance}/appProfiles/{app_profile}`.
    pub name: std::string::String,

    /// Required. If true, ignore safety checks when deleting the app profile.
    pub ignore_warnings: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAppProfileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAppProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ignore_warnings][crate::model::DeleteAppProfileRequest::ignore_warnings].
    pub fn set_ignore_warnings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_warnings = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAppProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteAppProfileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAppProfileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ignore_warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAppProfileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ignoreWarnings" => Ok(__FieldTag::__ignore_warnings),
                            "ignore_warnings" => Ok(__FieldTag::__ignore_warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAppProfileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAppProfileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_warnings => {
                            if !fields.insert(__FieldTag::__ignore_warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_warnings",
                                ));
                            }
                            result.ignore_warnings = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAppProfileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.ignore_warnings) {
            state.serialize_entry("ignoreWarnings", &self.ignore_warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by UpdateAppProfile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAppProfileMetadata {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAppProfileMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UpdateAppProfileMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateAppProfileMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAppProfileMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAppProfileMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAppProfileMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAppProfileMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAppProfileMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.ListHotTablets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListHotTabletsRequest {
    /// Required. The cluster name to list hot tablets.
    /// Value is in the following form:
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    pub parent: std::string::String,

    /// The start time to list hot tablets. The hot tablets in the response will
    /// have start times between the requested start time and end time. Start time
    /// defaults to Now if it is unset, and end time defaults to Now - 24 hours if
    /// it is unset. The start time should be less than the end time, and the
    /// maximum allowed time range between start time and end time is 48 hours.
    /// Start time and end time should have values between Now and Now - 14 days.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end time to list hot tablets.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Maximum number of results per page.
    ///
    /// A page_size that is empty or zero lets the server choose the number of
    /// items to return. A page_size which is strictly positive will return at most
    /// that many items. A negative page_size will cause an error.
    ///
    /// Following the first request, subsequent paginated calls do not need a
    /// page_size field. If a page_size is set in subsequent calls, it must match
    /// the page_size given in the first request.
    pub page_size: i32,

    /// The value of `next_page_token` returned by a previous call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListHotTabletsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListHotTabletsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ListHotTabletsRequest::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ListHotTabletsRequest::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ListHotTabletsRequest::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ListHotTabletsRequest::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [page_size][crate::model::ListHotTabletsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListHotTabletsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListHotTabletsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListHotTabletsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListHotTabletsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __start_time,
            __end_time,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListHotTabletsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListHotTabletsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListHotTabletsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListHotTabletsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for BigtableInstanceAdmin.ListHotTablets.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListHotTabletsResponse {
    /// List of hot tablets in the tables of the requested cluster that fall
    /// within the requested time range. Hot tablets are ordered by node cpu usage
    /// percent. If there are multiple hot tablets that correspond to the same
    /// tablet within a 15-minute interval, only the hot tablet with the highest
    /// node cpu usage will be included in the response.
    pub hot_tablets: std::vec::Vec<crate::model::HotTablet>,

    /// Set if not all hot tablets could be returned in a single response.
    /// Pass this value to `page_token` in another request to get the next
    /// page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListHotTabletsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hot_tablets][crate::model::ListHotTabletsResponse::hot_tablets].
    pub fn set_hot_tablets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HotTablet>,
    {
        use std::iter::Iterator;
        self.hot_tablets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListHotTabletsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListHotTabletsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListHotTabletsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListHotTabletsResponse {
    type PageItem = crate::model::HotTablet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.hot_tablets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListHotTabletsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __hot_tablets,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListHotTabletsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "hotTablets" => Ok(__FieldTag::__hot_tablets),
                            "hot_tablets" => Ok(__FieldTag::__hot_tablets),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListHotTabletsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListHotTabletsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__hot_tablets => {
                            if !fields.insert(__FieldTag::__hot_tablets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hot_tablets",
                                ));
                            }
                            result.hot_tablets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::HotTablet>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListHotTabletsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.hot_tablets.is_empty() {
            state.serialize_entry("hotTablets", &self.hot_tablets)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.CreateLogicalView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateLogicalViewRequest {
    /// Required. The parent instance where this logical view will be created.
    /// Format: `projects/{project}/instances/{instance}`.
    pub parent: std::string::String,

    /// Required. The ID to use for the logical view, which will become the final
    /// component of the logical view's resource name.
    pub logical_view_id: std::string::String,

    /// Required. The logical view to create.
    pub logical_view: std::option::Option<crate::model::LogicalView>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLogicalViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateLogicalViewRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [logical_view_id][crate::model::CreateLogicalViewRequest::logical_view_id].
    pub fn set_logical_view_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.logical_view_id = v.into();
        self
    }

    /// Sets the value of [logical_view][crate::model::CreateLogicalViewRequest::logical_view].
    pub fn set_logical_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogicalView>,
    {
        self.logical_view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logical_view][crate::model::CreateLogicalViewRequest::logical_view].
    pub fn set_or_clear_logical_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogicalView>,
    {
        self.logical_view = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateLogicalViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateLogicalViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateLogicalViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __logical_view_id,
            __logical_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateLogicalViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "logicalViewId" => Ok(__FieldTag::__logical_view_id),
                            "logical_view_id" => Ok(__FieldTag::__logical_view_id),
                            "logicalView" => Ok(__FieldTag::__logical_view),
                            "logical_view" => Ok(__FieldTag::__logical_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateLogicalViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateLogicalViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logical_view_id => {
                            if !fields.insert(__FieldTag::__logical_view_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logical_view_id",
                                ));
                            }
                            result.logical_view_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__logical_view => {
                            if !fields.insert(__FieldTag::__logical_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logical_view",
                                ));
                            }
                            result.logical_view =
                                map.next_value::<std::option::Option<crate::model::LogicalView>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateLogicalViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.logical_view_id.is_empty() {
            state.serialize_entry("logicalViewId", &self.logical_view_id)?;
        }
        if self.logical_view.is_some() {
            state.serialize_entry("logicalView", &self.logical_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by CreateLogicalView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateLogicalViewMetadata {
    /// The request that prompted the initiation of this CreateLogicalView
    /// operation.
    pub original_request: std::option::Option<crate::model::CreateLogicalViewRequest>,

    /// The time at which this operation started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation finished or was canceled.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateLogicalViewMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::CreateLogicalViewMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CreateLogicalViewRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::CreateLogicalViewMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CreateLogicalViewRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::CreateLogicalViewMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CreateLogicalViewMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CreateLogicalViewMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CreateLogicalViewMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateLogicalViewMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateLogicalViewMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateLogicalViewMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateLogicalViewMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateLogicalViewMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateLogicalViewMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request = map.next_value::<std::option::Option<crate::model::CreateLogicalViewRequest>>()?
                                ;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateLogicalViewMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.GetLogicalView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetLogicalViewRequest {
    /// Required. The unique name of the requested logical view. Values are of the
    /// form `projects/{project}/instances/{instance}/logicalViews/{logical_view}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLogicalViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetLogicalViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetLogicalViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetLogicalViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetLogicalViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetLogicalViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetLogicalViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetLogicalViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetLogicalViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.ListLogicalViews.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLogicalViewsRequest {
    /// Required. The unique name of the instance for which the list of logical
    /// views is requested. Values are of the form
    /// `projects/{project}/instances/{instance}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of logical views to return. The service may
    /// return fewer than this value
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListLogicalViews` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListLogicalViews` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogicalViewsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListLogicalViewsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLogicalViewsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLogicalViewsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogicalViewsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListLogicalViewsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLogicalViewsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLogicalViewsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLogicalViewsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLogicalViewsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLogicalViewsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for BigtableInstanceAdmin.ListLogicalViews.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListLogicalViewsResponse {
    /// The list of requested logical views.
    pub logical_views: std::vec::Vec<crate::model::LogicalView>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLogicalViewsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [logical_views][crate::model::ListLogicalViewsResponse::logical_views].
    pub fn set_logical_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogicalView>,
    {
        use std::iter::Iterator;
        self.logical_views = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLogicalViewsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLogicalViewsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListLogicalViewsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLogicalViewsResponse {
    type PageItem = crate::model::LogicalView;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.logical_views
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListLogicalViewsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __logical_views,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListLogicalViewsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logicalViews" => Ok(__FieldTag::__logical_views),
                            "logical_views" => Ok(__FieldTag::__logical_views),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListLogicalViewsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListLogicalViewsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__logical_views => {
                            if !fields.insert(__FieldTag::__logical_views) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logical_views",
                                ));
                            }
                            result.logical_views = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogicalView>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListLogicalViewsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.logical_views.is_empty() {
            state.serialize_entry("logicalViews", &self.logical_views)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.UpdateLogicalView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateLogicalViewRequest {
    /// Required. The logical view to update.
    ///
    /// The logical view's `name` field is used to identify the view to update.
    /// Format:
    /// `projects/{project}/instances/{instance}/logicalViews/{logical_view}`.
    pub logical_view: std::option::Option<crate::model::LogicalView>,

    /// Optional. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateLogicalViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [logical_view][crate::model::UpdateLogicalViewRequest::logical_view].
    pub fn set_logical_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogicalView>,
    {
        self.logical_view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [logical_view][crate::model::UpdateLogicalViewRequest::logical_view].
    pub fn set_or_clear_logical_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogicalView>,
    {
        self.logical_view = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateLogicalViewRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateLogicalViewRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateLogicalViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateLogicalViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateLogicalViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __logical_view,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateLogicalViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logicalView" => Ok(__FieldTag::__logical_view),
                            "logical_view" => Ok(__FieldTag::__logical_view),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateLogicalViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateLogicalViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__logical_view => {
                            if !fields.insert(__FieldTag::__logical_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for logical_view",
                                ));
                            }
                            result.logical_view =
                                map.next_value::<std::option::Option<crate::model::LogicalView>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateLogicalViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.logical_view.is_some() {
            state.serialize_entry("logicalView", &self.logical_view)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by UpdateLogicalView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateLogicalViewMetadata {
    /// The request that prompted the initiation of this UpdateLogicalView
    /// operation.
    pub original_request: std::option::Option<crate::model::UpdateLogicalViewRequest>,

    /// The time at which this operation was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation finished or was canceled.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateLogicalViewMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::UpdateLogicalViewMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpdateLogicalViewRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::UpdateLogicalViewMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpdateLogicalViewRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::UpdateLogicalViewMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpdateLogicalViewMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UpdateLogicalViewMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UpdateLogicalViewMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateLogicalViewMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateLogicalViewMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateLogicalViewMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateLogicalViewMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateLogicalViewMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateLogicalViewMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request = map.next_value::<std::option::Option<crate::model::UpdateLogicalViewRequest>>()?
                                ;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateLogicalViewMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.DeleteLogicalView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteLogicalViewRequest {
    /// Required. The unique name of the logical view to be deleted.
    /// Format:
    /// `projects/{project}/instances/{instance}/logicalViews/{logical_view}`.
    pub name: std::string::String,

    /// Optional. The current etag of the logical view.
    /// If an etag is provided and does not match the current etag of the
    /// logical view, deletion will be blocked and an ABORTED error will be
    /// returned.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteLogicalViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteLogicalViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteLogicalViewRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteLogicalViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteLogicalViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteLogicalViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteLogicalViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteLogicalViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteLogicalViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteLogicalViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.CreateMaterializedView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMaterializedViewRequest {
    /// Required. The parent instance where this materialized view will be created.
    /// Format: `projects/{project}/instances/{instance}`.
    pub parent: std::string::String,

    /// Required. The ID to use for the materialized view, which will become the
    /// final component of the materialized view's resource name.
    pub materialized_view_id: std::string::String,

    /// Required. The materialized view to create.
    pub materialized_view: std::option::Option<crate::model::MaterializedView>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMaterializedViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMaterializedViewRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [materialized_view_id][crate::model::CreateMaterializedViewRequest::materialized_view_id].
    pub fn set_materialized_view_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.materialized_view_id = v.into();
        self
    }

    /// Sets the value of [materialized_view][crate::model::CreateMaterializedViewRequest::materialized_view].
    pub fn set_materialized_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaterializedView>,
    {
        self.materialized_view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [materialized_view][crate::model::CreateMaterializedViewRequest::materialized_view].
    pub fn set_or_clear_materialized_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaterializedView>,
    {
        self.materialized_view = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateMaterializedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateMaterializedViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMaterializedViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __materialized_view_id,
            __materialized_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMaterializedViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "materializedViewId" => Ok(__FieldTag::__materialized_view_id),
                            "materialized_view_id" => Ok(__FieldTag::__materialized_view_id),
                            "materializedView" => Ok(__FieldTag::__materialized_view),
                            "materialized_view" => Ok(__FieldTag::__materialized_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMaterializedViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMaterializedViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__materialized_view_id => {
                            if !fields.insert(__FieldTag::__materialized_view_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materialized_view_id",
                                ));
                            }
                            result.materialized_view_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__materialized_view => {
                            if !fields.insert(__FieldTag::__materialized_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materialized_view",
                                ));
                            }
                            result.materialized_view = map
                                .next_value::<std::option::Option<crate::model::MaterializedView>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMaterializedViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.materialized_view_id.is_empty() {
            state.serialize_entry("materializedViewId", &self.materialized_view_id)?;
        }
        if self.materialized_view.is_some() {
            state.serialize_entry("materializedView", &self.materialized_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by CreateMaterializedView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMaterializedViewMetadata {
    /// The request that prompted the initiation of this CreateMaterializedView
    /// operation.
    pub original_request: std::option::Option<crate::model::CreateMaterializedViewRequest>,

    /// The time at which this operation started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation finished or was canceled.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMaterializedViewMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::CreateMaterializedViewMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CreateMaterializedViewRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::CreateMaterializedViewMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CreateMaterializedViewRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::CreateMaterializedViewMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CreateMaterializedViewMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CreateMaterializedViewMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CreateMaterializedViewMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateMaterializedViewMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateMaterializedViewMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMaterializedViewMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMaterializedViewMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMaterializedViewMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMaterializedViewMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request =
                                map.next_value::<std::option::Option<
                                    crate::model::CreateMaterializedViewRequest,
                                >>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMaterializedViewMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.GetMaterializedView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMaterializedViewRequest {
    /// Required. The unique name of the requested materialized view. Values are of
    /// the form
    /// `projects/{project}/instances/{instance}/materializedViews/{materialized_view}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMaterializedViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMaterializedViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMaterializedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetMaterializedViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMaterializedViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMaterializedViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMaterializedViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMaterializedViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMaterializedViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.ListMaterializedViews.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMaterializedViewsRequest {
    /// Required. The unique name of the instance for which the list of
    /// materialized views is requested. Values are of the form
    /// `projects/{project}/instances/{instance}`.
    pub parent: std::string::String,

    /// Optional. The maximum number of materialized views to return. The service
    /// may return fewer than this value
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListMaterializedViews`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMaterializedViews`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMaterializedViewsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMaterializedViewsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMaterializedViewsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMaterializedViewsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMaterializedViewsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListMaterializedViewsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMaterializedViewsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMaterializedViewsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMaterializedViewsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMaterializedViewsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMaterializedViewsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for BigtableInstanceAdmin.ListMaterializedViews.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMaterializedViewsResponse {
    /// The list of requested materialized views.
    pub materialized_views: std::vec::Vec<crate::model::MaterializedView>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMaterializedViewsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [materialized_views][crate::model::ListMaterializedViewsResponse::materialized_views].
    pub fn set_materialized_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MaterializedView>,
    {
        use std::iter::Iterator;
        self.materialized_views = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMaterializedViewsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListMaterializedViewsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListMaterializedViewsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMaterializedViewsResponse {
    type PageItem = crate::model::MaterializedView;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.materialized_views
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMaterializedViewsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __materialized_views,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMaterializedViewsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "materializedViews" => Ok(__FieldTag::__materialized_views),
                            "materialized_views" => Ok(__FieldTag::__materialized_views),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMaterializedViewsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMaterializedViewsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__materialized_views => {
                            if !fields.insert(__FieldTag::__materialized_views) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materialized_views",
                                ));
                            }
                            result.materialized_views =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MaterializedView>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMaterializedViewsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.materialized_views.is_empty() {
            state.serialize_entry("materializedViews", &self.materialized_views)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.UpdateMaterializedView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateMaterializedViewRequest {
    /// Required. The materialized view to update.
    ///
    /// The materialized view's `name` field is used to identify the view to
    /// update. Format:
    /// `projects/{project}/instances/{instance}/materializedViews/{materialized_view}`.
    pub materialized_view: std::option::Option<crate::model::MaterializedView>,

    /// Optional. The list of fields to update.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMaterializedViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [materialized_view][crate::model::UpdateMaterializedViewRequest::materialized_view].
    pub fn set_materialized_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaterializedView>,
    {
        self.materialized_view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [materialized_view][crate::model::UpdateMaterializedViewRequest::materialized_view].
    pub fn set_or_clear_materialized_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaterializedView>,
    {
        self.materialized_view = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateMaterializedViewRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateMaterializedViewRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateMaterializedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateMaterializedViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateMaterializedViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __materialized_view,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateMaterializedViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "materializedView" => Ok(__FieldTag::__materialized_view),
                            "materialized_view" => Ok(__FieldTag::__materialized_view),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateMaterializedViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateMaterializedViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__materialized_view => {
                            if !fields.insert(__FieldTag::__materialized_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for materialized_view",
                                ));
                            }
                            result.materialized_view = map
                                .next_value::<std::option::Option<crate::model::MaterializedView>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateMaterializedViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.materialized_view.is_some() {
            state.serialize_entry("materializedView", &self.materialized_view)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by UpdateMaterializedView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateMaterializedViewMetadata {
    /// The request that prompted the initiation of this UpdateMaterializedView
    /// operation.
    pub original_request: std::option::Option<crate::model::UpdateMaterializedViewRequest>,

    /// The time at which this operation was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation finished or was canceled.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMaterializedViewMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::UpdateMaterializedViewMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpdateMaterializedViewRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::UpdateMaterializedViewMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpdateMaterializedViewRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::UpdateMaterializedViewMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpdateMaterializedViewMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UpdateMaterializedViewMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UpdateMaterializedViewMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateMaterializedViewMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateMaterializedViewMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateMaterializedViewMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateMaterializedViewMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateMaterializedViewMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateMaterializedViewMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request =
                                map.next_value::<std::option::Option<
                                    crate::model::UpdateMaterializedViewRequest,
                                >>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateMaterializedViewMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for BigtableInstanceAdmin.DeleteMaterializedView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteMaterializedViewRequest {
    /// Required. The unique name of the materialized view to be deleted.
    /// Format:
    /// `projects/{project}/instances/{instance}/materializedViews/{materialized_view}`.
    pub name: std::string::String,

    /// Optional. The current etag of the materialized view.
    /// If an etag is provided and does not match the current etag of the
    /// materialized view, deletion will be blocked and an ABORTED error will be
    /// returned.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMaterializedViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMaterializedViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteMaterializedViewRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMaterializedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteMaterializedViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteMaterializedViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteMaterializedViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteMaterializedViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteMaterializedViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteMaterializedViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [RestoreTable][google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable]: crate::client::BigtableTableAdmin::restore_table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreTableRequest {
    /// Required. The name of the instance in which to create the restored
    /// table. Values are of the form `projects/<project>/instances/<instance>`.
    pub parent: std::string::String,

    /// Required. The id of the table to create and restore to. This
    /// table must not already exist. The `table_id` appended to
    /// `parent` forms the full table name of the form
    /// `projects/<project>/instances/<instance>/tables/<table_id>`.
    pub table_id: std::string::String,

    /// Required. The source from which to restore.
    pub source: std::option::Option<crate::model::restore_table_request::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::RestoreTableRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::RestoreTableRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [source][crate::model::RestoreTableRequest::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::restore_table_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::RestoreTableRequest::source]
    /// if it holds a `Backup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::restore_table_request::Source::Backup(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::RestoreTableRequest::source]
    /// to hold a `Backup`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::restore_table_request::Source::Backup(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.RestoreTableRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __table_id,
            __backup,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "backup" => Ok(__FieldTag::__backup),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.bigtable.admin.v2.RestoreTableRequest.backup, latest field was backup",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::restore_table_request::Source::Backup(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreTableRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if let Some(value) = self.backup() {
            state.serialize_entry("backup", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestoreTableRequest].
pub mod restore_table_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The source from which to restore.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Name of the backup from which to restore.  Values are of the form
        /// `projects/<project>/instances/<instance>/clusters/<cluster>/backups/<backup>`.
        Backup(std::string::String),
    }
}

/// Metadata type for the long-running operation returned by
/// [RestoreTable][google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable]: crate::client::BigtableTableAdmin::restore_table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreTableMetadata {
    /// Name of the table being created and restored to.
    pub name: std::string::String,

    /// The type of the restore source.
    pub source_type: crate::model::RestoreSourceType,

    /// If exists, the name of the long-running operation that will be used to
    /// track the post-restore optimization process to optimize the performance of
    /// the restored table. The metadata type of the long-running operation is
    /// [OptimizeRestoreTableMetadata][]. The response type is
    /// [Empty][google.protobuf.Empty]. This long-running operation may be
    /// automatically created by the system if applicable after the
    /// RestoreTable long-running operation completes successfully. This operation
    /// may not be created if the table is already optimized or the restore was
    /// not successful.
    ///
    /// [google.protobuf.Empty]: wkt::Empty
    pub optimize_table_operation_name: std::string::String,

    /// The progress of the
    /// [RestoreTable][google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable]
    /// operation.
    ///
    /// [google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable]: crate::client::BigtableTableAdmin::restore_table
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// Information about the source used to restore the table, as specified by
    /// `source` in
    /// [RestoreTableRequest][google.bigtable.admin.v2.RestoreTableRequest].
    ///
    /// [google.bigtable.admin.v2.RestoreTableRequest]: crate::model::RestoreTableRequest
    pub source_info: std::option::Option<crate::model::restore_table_metadata::SourceInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreTableMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RestoreTableMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::RestoreTableMetadata::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::RestoreSourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [optimize_table_operation_name][crate::model::RestoreTableMetadata::optimize_table_operation_name].
    pub fn set_optimize_table_operation_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.optimize_table_operation_name = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::RestoreTableMetadata::progress].
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::RestoreTableMetadata::progress].
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_info][crate::model::RestoreTableMetadata::source_info].
    ///
    /// Note that all the setters affecting `source_info` are mutually
    /// exclusive.
    pub fn set_source_info<
        T: std::convert::Into<std::option::Option<crate::model::restore_table_metadata::SourceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_info = v.into();
        self
    }

    /// The value of [source_info][crate::model::RestoreTableMetadata::source_info]
    /// if it holds a `BackupInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_info(&self) -> std::option::Option<&std::boxed::Box<crate::model::BackupInfo>> {
        #[allow(unreachable_patterns)]
        self.source_info.as_ref().and_then(|v| match v {
            crate::model::restore_table_metadata::SourceInfo::BackupInfo(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_info][crate::model::RestoreTableMetadata::source_info]
    /// to hold a `BackupInfo`.
    ///
    /// Note that all the setters affecting `source_info` are
    /// mutually exclusive.
    pub fn set_backup_info<T: std::convert::Into<std::boxed::Box<crate::model::BackupInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_info = std::option::Option::Some(
            crate::model::restore_table_metadata::SourceInfo::BackupInfo(v.into()),
        );
        self
    }
}

impl wkt::message::Message for RestoreTableMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.RestoreTableMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreTableMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __source_type,
            __backup_info,
            __optimize_table_operation_name,
            __progress,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreTableMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sourceType" => Ok(__FieldTag::__source_type),
                            "source_type" => Ok(__FieldTag::__source_type),
                            "backupInfo" => Ok(__FieldTag::__backup_info),
                            "backup_info" => Ok(__FieldTag::__backup_info),
                            "optimizeTableOperationName" => {
                                Ok(__FieldTag::__optimize_table_operation_name)
                            }
                            "optimize_table_operation_name" => {
                                Ok(__FieldTag::__optimize_table_operation_name)
                            }
                            "progress" => Ok(__FieldTag::__progress),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreTableMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreTableMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_type => {
                            if !fields.insert(__FieldTag::__source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_type",
                                ));
                            }
                            result.source_type = map
                                .next_value::<std::option::Option<crate::model::RestoreSourceType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_info => {
                            if !fields.insert(__FieldTag::__backup_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_info",
                                ));
                            }
                            if result.source_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_info`, a oneof with full ID .google.bigtable.admin.v2.RestoreTableMetadata.backup_info, latest field was backupInfo",
                                ));
                            }
                            result.source_info = std::option::Option::Some(
                                crate::model::restore_table_metadata::SourceInfo::BackupInfo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BackupInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__optimize_table_operation_name => {
                            if !fields.insert(__FieldTag::__optimize_table_operation_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for optimize_table_operation_name",
                                ));
                            }
                            result.optimize_table_operation_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress => {
                            if !fields.insert(__FieldTag::__progress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress",
                                ));
                            }
                            result.progress = map
                                .next_value::<std::option::Option<crate::model::OperationProgress>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreTableMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.source_type) {
            state.serialize_entry("sourceType", &self.source_type)?;
        }
        if let Some(value) = self.backup_info() {
            state.serialize_entry("backupInfo", value)?;
        }
        if !self.optimize_table_operation_name.is_empty() {
            state.serialize_entry(
                "optimizeTableOperationName",
                &self.optimize_table_operation_name,
            )?;
        }
        if self.progress.is_some() {
            state.serialize_entry("progress", &self.progress)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestoreTableMetadata].
pub mod restore_table_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Information about the source used to restore the table, as specified by
    /// `source` in
    /// [RestoreTableRequest][google.bigtable.admin.v2.RestoreTableRequest].
    ///
    /// [google.bigtable.admin.v2.RestoreTableRequest]: crate::model::RestoreTableRequest
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceInfo {
        BackupInfo(std::boxed::Box<crate::model::BackupInfo>),
    }
}

/// Metadata type for the long-running operation used to track the progress
/// of optimizations performed on a newly restored table. This long-running
/// operation is automatically created by the system after the successful
/// completion of a table restore, and cannot be cancelled.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OptimizeRestoredTableMetadata {
    /// Name of the restored table being optimized.
    pub name: std::string::String,

    /// The progress of the post-restore optimizations.
    pub progress: std::option::Option<crate::model::OperationProgress>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OptimizeRestoredTableMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::OptimizeRestoredTableMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::OptimizeRestoredTableMetadata::progress].
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::OptimizeRestoredTableMetadata::progress].
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OptimizeRestoredTableMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.OptimizeRestoredTableMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OptimizeRestoredTableMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __progress,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OptimizeRestoredTableMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "progress" => Ok(__FieldTag::__progress),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OptimizeRestoredTableMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OptimizeRestoredTableMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress => {
                            if !fields.insert(__FieldTag::__progress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress",
                                ));
                            }
                            result.progress = map
                                .next_value::<std::option::Option<crate::model::OperationProgress>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OptimizeRestoredTableMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.progress.is_some() {
            state.serialize_entry("progress", &self.progress)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateTable][google.bigtable.admin.v2.BigtableTableAdmin.CreateTable]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateTable]: crate::client::BigtableTableAdmin::create_table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTableRequest {
    /// Required. The unique name of the instance in which to create the table.
    /// Values are of the form `projects/{project}/instances/{instance}`.
    pub parent: std::string::String,

    /// Required. The name by which the new table should be referred to within the
    /// parent instance, e.g., `foobar` rather than `{parent}/tables/foobar`.
    /// Maximum 50 characters.
    pub table_id: std::string::String,

    /// Required. The Table to create.
    pub table: std::option::Option<crate::model::Table>,

    /// The optional list of row keys that will be used to initially split the
    /// table into several tablets (tablets are similar to HBase regions).
    /// Given two split keys, `s1` and `s2`, three tablets will be created,
    /// spanning the key ranges: `[, s1), [s1, s2), [s2, )`.
    ///
    /// Example:
    ///
    /// * Row keys := `["a", "apple", "custom", "customer_1", "customer_2",`
    ///   `"other", "zz"]`
    /// * initial_split_keys := `["apple", "customer_1", "customer_2", "other"]`
    /// * Key assignment:
    ///   - Tablet 1 `[, apple)                => {"a"}.`
    ///   - Tablet 2 `[apple, customer_1)      => {"apple", "custom"}.`
    ///   - Tablet 3 `[customer_1, customer_2) => {"customer_1"}.`
    ///   - Tablet 4 `[customer_2, other)      => {"customer_2"}.`
    ///   - Tablet 5 `[other, )                => {"other", "zz"}.`
    pub initial_splits: std::vec::Vec<crate::model::create_table_request::Split>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTableRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::CreateTableRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [table][crate::model::CreateTableRequest::table].
    pub fn set_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Table>,
    {
        self.table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table][crate::model::CreateTableRequest::table].
    pub fn set_or_clear_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Table>,
    {
        self.table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initial_splits][crate::model::CreateTableRequest::initial_splits].
    pub fn set_initial_splits<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::create_table_request::Split>,
    {
        use std::iter::Iterator;
        self.initial_splits = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateTableRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __table_id,
            __table,
            __initial_splits,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "table" => Ok(__FieldTag::__table),
                            "initialSplits" => Ok(__FieldTag::__initial_splits),
                            "initial_splits" => Ok(__FieldTag::__initial_splits),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table =
                                map.next_value::<std::option::Option<crate::model::Table>>()?;
                        }
                        __FieldTag::__initial_splits => {
                            if !fields.insert(__FieldTag::__initial_splits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initial_splits",
                                ));
                            }
                            result.initial_splits = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::create_table_request::Split>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTableRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if self.table.is_some() {
            state.serialize_entry("table", &self.table)?;
        }
        if !self.initial_splits.is_empty() {
            state.serialize_entry("initialSplits", &self.initial_splits)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CreateTableRequest].
pub mod create_table_request {
    #[allow(unused_imports)]
    use super::*;

    /// An initial split point for a newly created table.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Split {
        /// Row key to use as an initial tablet boundary.
        pub key: ::bytes::Bytes,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Split {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::create_table_request::Split::key].
        pub fn set_key<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }
    }

    impl wkt::message::Message for Split {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.CreateTableRequest.Split"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Split {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Split")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "key" => Ok(__FieldTag::__key),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Split;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Split")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                struct __With(std::option::Option<::bytes::Bytes>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<serde_with::base64::Base64>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.key = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Split {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.key.is_empty() {
                struct __With<'a>(&'a ::bytes::Bytes);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("key", &__With(&self.key))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateTableFromSnapshot][google.bigtable.admin.v2.BigtableTableAdmin.CreateTableFromSnapshot]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateTableFromSnapshot]: crate::client::BigtableTableAdmin::create_table_from_snapshot
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTableFromSnapshotRequest {
    /// Required. The unique name of the instance in which to create the table.
    /// Values are of the form `projects/{project}/instances/{instance}`.
    pub parent: std::string::String,

    /// Required. The name by which the new table should be referred to within the
    /// parent instance, e.g., `foobar` rather than `{parent}/tables/foobar`.
    pub table_id: std::string::String,

    /// Required. The unique name of the snapshot from which to restore the table.
    /// The snapshot and the table must be in the same instance. Values are of the
    /// form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/{snapshot}`.
    pub source_snapshot: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTableFromSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTableFromSnapshotRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::CreateTableFromSnapshotRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [source_snapshot][crate::model::CreateTableFromSnapshotRequest::source_snapshot].
    pub fn set_source_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_snapshot = v.into();
        self
    }
}

impl wkt::message::Message for CreateTableFromSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateTableFromSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTableFromSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __table_id,
            __source_snapshot,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTableFromSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "tableId" => Ok(__FieldTag::__table_id),
                            "table_id" => Ok(__FieldTag::__table_id),
                            "sourceSnapshot" => Ok(__FieldTag::__source_snapshot),
                            "source_snapshot" => Ok(__FieldTag::__source_snapshot),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTableFromSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTableFromSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_id => {
                            if !fields.insert(__FieldTag::__table_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_id",
                                ));
                            }
                            result.table_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_snapshot => {
                            if !fields.insert(__FieldTag::__source_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_snapshot",
                                ));
                            }
                            result.source_snapshot = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTableFromSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.table_id.is_empty() {
            state.serialize_entry("tableId", &self.table_id)?;
        }
        if !self.source_snapshot.is_empty() {
            state.serialize_entry("sourceSnapshot", &self.source_snapshot)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.DropRowRange][google.bigtable.admin.v2.BigtableTableAdmin.DropRowRange]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.DropRowRange]: crate::client::BigtableTableAdmin::drop_row_range
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DropRowRangeRequest {
    /// Required. The unique name of the table on which to drop a range of rows.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    pub name: std::string::String,

    /// Delete all rows or by prefix.
    pub target: std::option::Option<crate::model::drop_row_range_request::Target>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DropRowRangeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DropRowRangeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target][crate::model::DropRowRangeRequest::target].
    ///
    /// Note that all the setters affecting `target` are mutually
    /// exclusive.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::drop_row_range_request::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }

    /// The value of [target][crate::model::DropRowRangeRequest::target]
    /// if it holds a `RowKeyPrefix`, `None` if the field is not set or
    /// holds a different branch.
    pub fn row_key_prefix(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::drop_row_range_request::Target::RowKeyPrefix(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DropRowRangeRequest::target]
    /// to hold a `RowKeyPrefix`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_row_key_prefix<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.target = std::option::Option::Some(
            crate::model::drop_row_range_request::Target::RowKeyPrefix(v.into()),
        );
        self
    }

    /// The value of [target][crate::model::DropRowRangeRequest::target]
    /// if it holds a `DeleteAllDataFromTable`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_all_data_from_table(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.target.as_ref().and_then(|v| match v {
            crate::model::drop_row_range_request::Target::DeleteAllDataFromTable(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target][crate::model::DropRowRangeRequest::target]
    /// to hold a `DeleteAllDataFromTable`.
    ///
    /// Note that all the setters affecting `target` are
    /// mutually exclusive.
    pub fn set_delete_all_data_from_table<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.target = std::option::Option::Some(
            crate::model::drop_row_range_request::Target::DeleteAllDataFromTable(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DropRowRangeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DropRowRangeRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DropRowRangeRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __row_key_prefix,
            __delete_all_data_from_table,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DropRowRangeRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "rowKeyPrefix" => Ok(__FieldTag::__row_key_prefix),
                            "row_key_prefix" => Ok(__FieldTag::__row_key_prefix),
                            "deleteAllDataFromTable" => {
                                Ok(__FieldTag::__delete_all_data_from_table)
                            }
                            "delete_all_data_from_table" => {
                                Ok(__FieldTag::__delete_all_data_from_table)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DropRowRangeRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DropRowRangeRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__row_key_prefix => {
                            if !fields.insert(__FieldTag::__row_key_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_key_prefix",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.bigtable.admin.v2.DropRowRangeRequest.row_key_prefix, latest field was rowKeyPrefix",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::drop_row_range_request::Target::RowKeyPrefix(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__delete_all_data_from_table => {
                            if !fields.insert(__FieldTag::__delete_all_data_from_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_all_data_from_table",
                                ));
                            }
                            if result.target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target`, a oneof with full ID .google.bigtable.admin.v2.DropRowRangeRequest.delete_all_data_from_table, latest field was deleteAllDataFromTable",
                                ));
                            }
                            result.target = std::option::Option::Some(
                                crate::model::drop_row_range_request::Target::DeleteAllDataFromTable(
                                    map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DropRowRangeRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.row_key_prefix() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("rowKeyPrefix", &__With(value))?;
        }
        if let Some(value) = self.delete_all_data_from_table() {
            state.serialize_entry("deleteAllDataFromTable", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DropRowRangeRequest].
pub mod drop_row_range_request {
    #[allow(unused_imports)]
    use super::*;

    /// Delete all rows or by prefix.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Target {
        /// Delete all rows that start with this row key prefix. Prefix cannot be
        /// zero length.
        RowKeyPrefix(::bytes::Bytes),
        /// Delete all rows in the table. Setting this to false is a no-op.
        DeleteAllDataFromTable(bool),
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListTables][google.bigtable.admin.v2.BigtableTableAdmin.ListTables]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListTables]: crate::client::BigtableTableAdmin::list_tables
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTablesRequest {
    /// Required. The unique name of the instance for which tables should be
    /// listed. Values are of the form `projects/{project}/instances/{instance}`.
    pub parent: std::string::String,

    /// The view to be applied to the returned tables' fields.
    /// NAME_ONLY view (default) and REPLICATION_VIEW are supported.
    pub view: crate::model::table::View,

    /// Maximum number of results per page.
    ///
    /// A page_size of zero lets the server choose the number of items to return.
    /// A page_size which is strictly positive will return at most that many items.
    /// A negative page_size will cause an error.
    ///
    /// Following the first request, subsequent paginated calls are not required
    /// to pass a page_size. If a page_size is set in subsequent calls, it must
    /// match the page_size given in the first request.
    pub page_size: i32,

    /// The value of `next_page_token` returned by a previous call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTablesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTablesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListTablesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::table::View>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTablesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTablesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTablesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListTablesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTablesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __view,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTablesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "view" => Ok(__FieldTag::__view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTablesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTablesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::table::View>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTablesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListTables][google.bigtable.admin.v2.BigtableTableAdmin.ListTables]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListTables]: crate::client::BigtableTableAdmin::list_tables
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTablesResponse {
    /// The tables present in the requested instance.
    pub tables: std::vec::Vec<crate::model::Table>,

    /// Set if not all tables could be returned in a single response.
    /// Pass this value to `page_token` in another request to get the next
    /// page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTablesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tables][crate::model::ListTablesResponse::tables].
    pub fn set_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Table>,
    {
        use std::iter::Iterator;
        self.tables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTablesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTablesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListTablesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTablesResponse {
    type PageItem = crate::model::Table;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tables
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTablesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tables,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTablesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tables" => Ok(__FieldTag::__tables),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTablesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTablesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tables => {
                            if !fields.insert(__FieldTag::__tables) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tables",
                                ));
                            }
                            result.tables = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Table>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTablesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tables.is_empty() {
            state.serialize_entry("tables", &self.tables)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetTable][google.bigtable.admin.v2.BigtableTableAdmin.GetTable]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetTable]: crate::client::BigtableTableAdmin::get_table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTableRequest {
    /// Required. The unique name of the requested table.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    pub name: std::string::String,

    /// The view to be applied to the returned table's fields.
    /// Defaults to `SCHEMA_VIEW` if unspecified.
    pub view: crate::model::table::View,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTableRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetTableRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::table::View>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetTableRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::table::View>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTableRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [UpdateTable][google.bigtable.admin.v2.BigtableTableAdmin.UpdateTable].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UpdateTable]: crate::client::BigtableTableAdmin::update_table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTableRequest {
    /// Required. The table to update.
    /// The table's `name` field is used to identify the table to update.
    pub table: std::option::Option<crate::model::Table>,

    /// Required. The list of fields to update.
    /// A mask specifying which fields (e.g. `change_stream_config`) in the `table`
    /// field should be updated. This mask is relative to the `table` field, not to
    /// the request message. The wildcard (*) path is currently not supported.
    /// Currently UpdateTable is only supported for the following fields:
    ///
    /// * `change_stream_config`
    /// * `change_stream_config.retention_period`
    /// * `deletion_protection`
    /// * `row_key_schema`
    ///
    /// If `column_families` is set in `update_mask`, it will return an
    /// UNIMPLEMENTED error.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If true, ignore safety checks when updating the table.
    pub ignore_warnings: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table][crate::model::UpdateTableRequest::table].
    pub fn set_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Table>,
    {
        self.table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [table][crate::model::UpdateTableRequest::table].
    pub fn set_or_clear_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Table>,
    {
        self.table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTableRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTableRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ignore_warnings][crate::model::UpdateTableRequest::ignore_warnings].
    pub fn set_ignore_warnings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_warnings = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateTableRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __table,
            __update_mask,
            __ignore_warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "table" => Ok(__FieldTag::__table),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "ignoreWarnings" => Ok(__FieldTag::__ignore_warnings),
                            "ignore_warnings" => Ok(__FieldTag::__ignore_warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__table => {
                            if !fields.insert(__FieldTag::__table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table",
                                ));
                            }
                            result.table =
                                map.next_value::<std::option::Option<crate::model::Table>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__ignore_warnings => {
                            if !fields.insert(__FieldTag::__ignore_warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_warnings",
                                ));
                            }
                            result.ignore_warnings = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTableRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.table.is_some() {
            state.serialize_entry("table", &self.table)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.ignore_warnings) {
            state.serialize_entry("ignoreWarnings", &self.ignore_warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata type for the operation returned by
/// [UpdateTable][google.bigtable.admin.v2.BigtableTableAdmin.UpdateTable].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UpdateTable]: crate::client::BigtableTableAdmin::update_table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTableMetadata {
    /// The name of the table being updated.
    pub name: std::string::String,

    /// The time at which this operation started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation finished or was canceled.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTableMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpdateTableMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::UpdateTableMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpdateTableMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UpdateTableMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UpdateTableMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateTableMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateTableMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTableMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTableMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTableMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTableMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTableMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteTable][google.bigtable.admin.v2.BigtableTableAdmin.DeleteTable]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteTable]: crate::client::BigtableTableAdmin::delete_table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTableRequest {
    /// Required. The unique name of the table to be deleted.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTableRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteTableRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTableRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable][google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable]: crate::client::BigtableTableAdmin::undelete_table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeleteTableRequest {
    /// Required. The unique name of the table to be restored.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeleteTableRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UndeleteTableRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeleteTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeleteTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeleteTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeleteTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeleteTableRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata type for the operation returned by
/// [google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable][google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable]: crate::client::BigtableTableAdmin::undelete_table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeleteTableMetadata {
    /// The name of the table being restored.
    pub name: std::string::String,

    /// The time at which this operation started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation finished or was cancelled.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteTableMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UndeleteTableMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::UndeleteTableMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UndeleteTableMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::UndeleteTableMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::UndeleteTableMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UndeleteTableMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UndeleteTableMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeleteTableMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeleteTableMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeleteTableMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeleteTableMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeleteTableMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ModifyColumnFamilies][google.bigtable.admin.v2.BigtableTableAdmin.ModifyColumnFamilies]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ModifyColumnFamilies]: crate::client::BigtableTableAdmin::modify_column_families
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ModifyColumnFamiliesRequest {
    /// Required. The unique name of the table whose families should be modified.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    pub name: std::string::String,

    /// Required. Modifications to be atomically applied to the specified table's
    /// families. Entries are applied in order, meaning that earlier modifications
    /// can be masked by later ones (in the case of repeated updates to the same
    /// family, for example).
    pub modifications: std::vec::Vec<crate::model::modify_column_families_request::Modification>,

    /// Optional. If true, ignore safety checks when modifying the column families.
    pub ignore_warnings: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ModifyColumnFamiliesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ModifyColumnFamiliesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [modifications][crate::model::ModifyColumnFamiliesRequest::modifications].
    pub fn set_modifications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::modify_column_families_request::Modification>,
    {
        use std::iter::Iterator;
        self.modifications = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ignore_warnings][crate::model::ModifyColumnFamiliesRequest::ignore_warnings].
    pub fn set_ignore_warnings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_warnings = v.into();
        self
    }
}

impl wkt::message::Message for ModifyColumnFamiliesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ModifyColumnFamiliesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ModifyColumnFamiliesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __modifications,
            __ignore_warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ModifyColumnFamiliesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "modifications" => Ok(__FieldTag::__modifications),
                            "ignoreWarnings" => Ok(__FieldTag::__ignore_warnings),
                            "ignore_warnings" => Ok(__FieldTag::__ignore_warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ModifyColumnFamiliesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ModifyColumnFamiliesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__modifications => {
                            if !fields.insert(__FieldTag::__modifications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for modifications",
                                ));
                            }
                            result.modifications = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::modify_column_families_request::Modification,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_warnings => {
                            if !fields.insert(__FieldTag::__ignore_warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_warnings",
                                ));
                            }
                            result.ignore_warnings = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ModifyColumnFamiliesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.modifications.is_empty() {
            state.serialize_entry("modifications", &self.modifications)?;
        }
        if !wkt::internal::is_default(&self.ignore_warnings) {
            state.serialize_entry("ignoreWarnings", &self.ignore_warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ModifyColumnFamiliesRequest].
pub mod modify_column_families_request {
    #[allow(unused_imports)]
    use super::*;

    /// A create, update, or delete of a particular column family.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Modification {
        /// The ID of the column family to be modified.
        pub id: std::string::String,

        /// Optional. A mask specifying which fields (e.g. `gc_rule`) in the `update`
        /// mod should be updated, ignored for other modification types. If unset or
        /// empty, we treat it as updating `gc_rule` to be backward compatible.
        pub update_mask: std::option::Option<wkt::FieldMask>,

        /// Column family modifications.
        pub r#mod:
            std::option::Option<crate::model::modify_column_families_request::modification::Mod>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Modification {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::modify_column_families_request::Modification::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [update_mask][crate::model::modify_column_families_request::Modification::update_mask].
        pub fn set_update_mask<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.update_mask = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_mask][crate::model::modify_column_families_request::Modification::update_mask].
        pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::FieldMask>,
        {
            self.update_mask = v.map(|x| x.into());
            self
        }

        /// Sets the value of [r#mod][crate::model::modify_column_families_request::Modification::mod].
        ///
        /// Note that all the setters affecting `r#mod` are mutually
        /// exclusive.
        pub fn set_mod<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::modify_column_families_request::modification::Mod,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#mod = v.into();
            self
        }

        /// The value of [r#mod][crate::model::modify_column_families_request::Modification::r#mod]
        /// if it holds a `Create`, `None` if the field is not set or
        /// holds a different branch.
        pub fn create(&self) -> std::option::Option<&std::boxed::Box<crate::model::ColumnFamily>> {
            #[allow(unreachable_patterns)]
            self.r#mod.as_ref().and_then(|v| match v {
                crate::model::modify_column_families_request::modification::Mod::Create(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#mod][crate::model::modify_column_families_request::Modification::r#mod]
        /// to hold a `Create`.
        ///
        /// Note that all the setters affecting `r#mod` are
        /// mutually exclusive.
        pub fn set_create<T: std::convert::Into<std::boxed::Box<crate::model::ColumnFamily>>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#mod = std::option::Option::Some(
                crate::model::modify_column_families_request::modification::Mod::Create(v.into()),
            );
            self
        }

        /// The value of [r#mod][crate::model::modify_column_families_request::Modification::r#mod]
        /// if it holds a `Update`, `None` if the field is not set or
        /// holds a different branch.
        pub fn update(&self) -> std::option::Option<&std::boxed::Box<crate::model::ColumnFamily>> {
            #[allow(unreachable_patterns)]
            self.r#mod.as_ref().and_then(|v| match v {
                crate::model::modify_column_families_request::modification::Mod::Update(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#mod][crate::model::modify_column_families_request::Modification::r#mod]
        /// to hold a `Update`.
        ///
        /// Note that all the setters affecting `r#mod` are
        /// mutually exclusive.
        pub fn set_update<T: std::convert::Into<std::boxed::Box<crate::model::ColumnFamily>>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#mod = std::option::Option::Some(
                crate::model::modify_column_families_request::modification::Mod::Update(v.into()),
            );
            self
        }

        /// The value of [r#mod][crate::model::modify_column_families_request::Modification::r#mod]
        /// if it holds a `Drop`, `None` if the field is not set or
        /// holds a different branch.
        pub fn drop(&self) -> std::option::Option<&bool> {
            #[allow(unreachable_patterns)]
            self.r#mod.as_ref().and_then(|v| match v {
                crate::model::modify_column_families_request::modification::Mod::Drop(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [r#mod][crate::model::modify_column_families_request::Modification::r#mod]
        /// to hold a `Drop`.
        ///
        /// Note that all the setters affecting `r#mod` are
        /// mutually exclusive.
        pub fn set_drop<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.r#mod = std::option::Option::Some(
                crate::model::modify_column_families_request::modification::Mod::Drop(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Modification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.ModifyColumnFamiliesRequest.Modification"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Modification {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __id,
                __create,
                __update,
                __drop,
                __update_mask,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Modification")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "id" => Ok(__FieldTag::__id),
                                "create" => Ok(__FieldTag::__create),
                                "update" => Ok(__FieldTag::__update),
                                "drop" => Ok(__FieldTag::__drop),
                                "updateMask" => Ok(__FieldTag::__update_mask),
                                "update_mask" => Ok(__FieldTag::__update_mask),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Modification;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Modification")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__id => {
                                if !fields.insert(__FieldTag::__id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for id",
                                    ));
                                }
                                result.id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__create => {
                                if !fields.insert(__FieldTag::__create) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for create",
                                    ));
                                }
                                if result.r#mod.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `r#mod`, a oneof with full ID .google.bigtable.admin.v2.ModifyColumnFamiliesRequest.Modification.create, latest field was create",
                                    ));
                                }
                                result.r#mod = std::option::Option::Some(
                                    crate::model::modify_column_families_request::modification::Mod::Create(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::ColumnFamily>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__update => {
                                if !fields.insert(__FieldTag::__update) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update",
                                    ));
                                }
                                if result.r#mod.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `r#mod`, a oneof with full ID .google.bigtable.admin.v2.ModifyColumnFamiliesRequest.Modification.update, latest field was update",
                                    ));
                                }
                                result.r#mod = std::option::Option::Some(
                                    crate::model::modify_column_families_request::modification::Mod::Update(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::ColumnFamily>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__drop => {
                                if !fields.insert(__FieldTag::__drop) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for drop",
                                    ));
                                }
                                if result.r#mod.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `r#mod`, a oneof with full ID .google.bigtable.admin.v2.ModifyColumnFamiliesRequest.Modification.drop, latest field was drop",
                                    ));
                                }
                                result.r#mod = std::option::Option::Some(
                                    crate::model::modify_column_families_request::modification::Mod::Drop(
                                        map.next_value::<std::option::Option<bool>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__update_mask => {
                                if !fields.insert(__FieldTag::__update_mask) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_mask",
                                    ));
                                }
                                result.update_mask =
                                    map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Modification {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.id.is_empty() {
                state.serialize_entry("id", &self.id)?;
            }
            if let Some(value) = self.create() {
                state.serialize_entry("create", value)?;
            }
            if let Some(value) = self.update() {
                state.serialize_entry("update", value)?;
            }
            if let Some(value) = self.drop() {
                state.serialize_entry("drop", value)?;
            }
            if self.update_mask.is_some() {
                state.serialize_entry("updateMask", &self.update_mask)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Modification].
    pub mod modification {
        #[allow(unused_imports)]
        use super::*;

        /// Column family modifications.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Mod {
            /// Create a new column family with the specified schema, or fail if
            /// one already exists with the given ID.
            Create(std::boxed::Box<crate::model::ColumnFamily>),
            /// Update an existing column family to the specified schema, or fail
            /// if no column family exists with the given ID.
            Update(std::boxed::Box<crate::model::ColumnFamily>),
            /// Drop (delete) the column family with the given ID, or fail if no such
            /// family exists.
            Drop(bool),
        }
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken][google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken]: crate::client::BigtableTableAdmin::generate_consistency_token
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateConsistencyTokenRequest {
    /// Required. The unique name of the Table for which to create a consistency
    /// token. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateConsistencyTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GenerateConsistencyTokenRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GenerateConsistencyTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GenerateConsistencyTokenRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateConsistencyTokenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateConsistencyTokenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateConsistencyTokenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateConsistencyTokenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateConsistencyTokenRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken][google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken]: crate::client::BigtableTableAdmin::generate_consistency_token
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateConsistencyTokenResponse {
    /// The generated consistency token.
    pub consistency_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateConsistencyTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consistency_token][crate::model::GenerateConsistencyTokenResponse::consistency_token].
    pub fn set_consistency_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.consistency_token = v.into();
        self
    }
}

impl wkt::message::Message for GenerateConsistencyTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GenerateConsistencyTokenResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateConsistencyTokenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __consistency_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateConsistencyTokenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "consistencyToken" => Ok(__FieldTag::__consistency_token),
                            "consistency_token" => Ok(__FieldTag::__consistency_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateConsistencyTokenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateConsistencyTokenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__consistency_token => {
                            if !fields.insert(__FieldTag::__consistency_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consistency_token",
                                ));
                            }
                            result.consistency_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateConsistencyTokenResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.consistency_token.is_empty() {
            state.serialize_entry("consistencyToken", &self.consistency_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency][google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency]: crate::client::BigtableTableAdmin::check_consistency
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckConsistencyRequest {
    /// Required. The unique name of the Table for which to check replication
    /// consistency. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    pub name: std::string::String,

    /// Required. The token created using GenerateConsistencyToken for the Table.
    pub consistency_token: std::string::String,

    /// Which type of read needs to consistently observe which type of write?
    /// Default: `standard_read_remote_writes`
    pub mode: std::option::Option<crate::model::check_consistency_request::Mode>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckConsistencyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CheckConsistencyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [consistency_token][crate::model::CheckConsistencyRequest::consistency_token].
    pub fn set_consistency_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.consistency_token = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::CheckConsistencyRequest::mode].
    ///
    /// Note that all the setters affecting `mode` are mutually
    /// exclusive.
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::check_consistency_request::Mode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// The value of [mode][crate::model::CheckConsistencyRequest::mode]
    /// if it holds a `StandardReadRemoteWrites`, `None` if the field is not set or
    /// holds a different branch.
    pub fn standard_read_remote_writes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::StandardReadRemoteWrites>> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::check_consistency_request::Mode::StandardReadRemoteWrites(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::CheckConsistencyRequest::mode]
    /// to hold a `StandardReadRemoteWrites`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_standard_read_remote_writes<
        T: std::convert::Into<std::boxed::Box<crate::model::StandardReadRemoteWrites>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::check_consistency_request::Mode::StandardReadRemoteWrites(v.into()),
        );
        self
    }

    /// The value of [mode][crate::model::CheckConsistencyRequest::mode]
    /// if it holds a `DataBoostReadLocalWrites`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_boost_read_local_writes(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataBoostReadLocalWrites>> {
        #[allow(unreachable_patterns)]
        self.mode.as_ref().and_then(|v| match v {
            crate::model::check_consistency_request::Mode::DataBoostReadLocalWrites(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [mode][crate::model::CheckConsistencyRequest::mode]
    /// to hold a `DataBoostReadLocalWrites`.
    ///
    /// Note that all the setters affecting `mode` are
    /// mutually exclusive.
    pub fn set_data_boost_read_local_writes<
        T: std::convert::Into<std::boxed::Box<crate::model::DataBoostReadLocalWrites>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = std::option::Option::Some(
            crate::model::check_consistency_request::Mode::DataBoostReadLocalWrites(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CheckConsistencyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CheckConsistencyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckConsistencyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __consistency_token,
            __standard_read_remote_writes,
            __data_boost_read_local_writes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckConsistencyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "consistencyToken" => Ok(__FieldTag::__consistency_token),
                            "consistency_token" => Ok(__FieldTag::__consistency_token),
                            "standardReadRemoteWrites" => {
                                Ok(__FieldTag::__standard_read_remote_writes)
                            }
                            "standard_read_remote_writes" => {
                                Ok(__FieldTag::__standard_read_remote_writes)
                            }
                            "dataBoostReadLocalWrites" => {
                                Ok(__FieldTag::__data_boost_read_local_writes)
                            }
                            "data_boost_read_local_writes" => {
                                Ok(__FieldTag::__data_boost_read_local_writes)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckConsistencyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckConsistencyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__consistency_token => {
                            if !fields.insert(__FieldTag::__consistency_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consistency_token",
                                ));
                            }
                            result.consistency_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__standard_read_remote_writes => {
                            if !fields.insert(__FieldTag::__standard_read_remote_writes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard_read_remote_writes",
                                ));
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.bigtable.admin.v2.CheckConsistencyRequest.standard_read_remote_writes, latest field was standardReadRemoteWrites",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::check_consistency_request::Mode::StandardReadRemoteWrites(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::StandardReadRemoteWrites>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__data_boost_read_local_writes => {
                            if !fields.insert(__FieldTag::__data_boost_read_local_writes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_boost_read_local_writes",
                                ));
                            }
                            if result.mode.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `mode`, a oneof with full ID .google.bigtable.admin.v2.CheckConsistencyRequest.data_boost_read_local_writes, latest field was dataBoostReadLocalWrites",
                                ));
                            }
                            result.mode = std::option::Option::Some(
                                crate::model::check_consistency_request::Mode::DataBoostReadLocalWrites(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DataBoostReadLocalWrites>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckConsistencyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.consistency_token.is_empty() {
            state.serialize_entry("consistencyToken", &self.consistency_token)?;
        }
        if let Some(value) = self.standard_read_remote_writes() {
            state.serialize_entry("standardReadRemoteWrites", value)?;
        }
        if let Some(value) = self.data_boost_read_local_writes() {
            state.serialize_entry("dataBoostReadLocalWrites", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CheckConsistencyRequest].
pub mod check_consistency_request {
    #[allow(unused_imports)]
    use super::*;

    /// Which type of read needs to consistently observe which type of write?
    /// Default: `standard_read_remote_writes`
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Checks that reads using an app profile with `StandardIsolation` can
        /// see all writes committed before the token was created, even if the
        /// read and write target different clusters.
        StandardReadRemoteWrites(std::boxed::Box<crate::model::StandardReadRemoteWrites>),
        /// Checks that reads using an app profile with `DataBoostIsolationReadOnly`
        /// can see all writes committed before the token was created, but only if
        /// the read and write target the same cluster.
        DataBoostReadLocalWrites(std::boxed::Box<crate::model::DataBoostReadLocalWrites>),
    }
}

/// Checks that all writes before the consistency token was generated are
/// replicated in every cluster and readable.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StandardReadRemoteWrites {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StandardReadRemoteWrites {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StandardReadRemoteWrites {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.StandardReadRemoteWrites"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StandardReadRemoteWrites {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StandardReadRemoteWrites")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StandardReadRemoteWrites;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StandardReadRemoteWrites")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StandardReadRemoteWrites {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Checks that all writes before the consistency token was generated in the same
/// cluster are readable by Databoost.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataBoostReadLocalWrites {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataBoostReadLocalWrites {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DataBoostReadLocalWrites {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DataBoostReadLocalWrites"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataBoostReadLocalWrites {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataBoostReadLocalWrites")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataBoostReadLocalWrites;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataBoostReadLocalWrites")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataBoostReadLocalWrites {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency][google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency]: crate::client::BigtableTableAdmin::check_consistency
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckConsistencyResponse {
    /// True only if the token is consistent. A token is consistent if replication
    /// has caught up with the restrictions specified in the request.
    pub consistent: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckConsistencyResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consistent][crate::model::CheckConsistencyResponse::consistent].
    pub fn set_consistent<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.consistent = v.into();
        self
    }
}

impl wkt::message::Message for CheckConsistencyResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CheckConsistencyResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckConsistencyResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __consistent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckConsistencyResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "consistent" => Ok(__FieldTag::__consistent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckConsistencyResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckConsistencyResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__consistent => {
                            if !fields.insert(__FieldTag::__consistent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consistent",
                                ));
                            }
                            result.consistent = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckConsistencyResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.consistent) {
            state.serialize_entry("consistent", &self.consistent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.SnapshotTable][google.bigtable.admin.v2.BigtableTableAdmin.SnapshotTable]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.SnapshotTable]: crate::client::BigtableTableAdmin::snapshot_table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SnapshotTableRequest {
    /// Required. The unique name of the table to have the snapshot taken.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    pub name: std::string::String,

    /// Required. The name of the cluster where the snapshot will be created in.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    pub cluster: std::string::String,

    /// Required. The ID by which the new snapshot should be referred to within the
    /// parent cluster, e.g., `mysnapshot` of the form:
    /// `[_a-zA-Z0-9][-_.a-zA-Z0-9]*` rather than
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/mysnapshot`.
    pub snapshot_id: std::string::String,

    /// The amount of time that the new snapshot can stay active after it is
    /// created. Once 'ttl' expires, the snapshot will get deleted. The maximum
    /// amount of time a snapshot can stay active is 7 days. If 'ttl' is not
    /// specified, the default value of 24 hours will be used.
    pub ttl: std::option::Option<wkt::Duration>,

    /// Description of the snapshot.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SnapshotTableRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SnapshotTableRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::SnapshotTableRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [snapshot_id][crate::model::SnapshotTableRequest::snapshot_id].
    pub fn set_snapshot_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_id = v.into();
        self
    }

    /// Sets the value of [ttl][crate::model::SnapshotTableRequest::ttl].
    pub fn set_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ttl][crate::model::SnapshotTableRequest::ttl].
    pub fn set_or_clear_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::SnapshotTableRequest::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for SnapshotTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.SnapshotTableRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SnapshotTableRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __cluster,
            __snapshot_id,
            __ttl,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SnapshotTableRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "snapshotId" => Ok(__FieldTag::__snapshot_id),
                            "snapshot_id" => Ok(__FieldTag::__snapshot_id),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SnapshotTableRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SnapshotTableRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__snapshot_id => {
                            if !fields.insert(__FieldTag::__snapshot_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot_id",
                                ));
                            }
                            result.snapshot_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            result.ttl = map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SnapshotTableRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.snapshot_id.is_empty() {
            state.serialize_entry("snapshotId", &self.snapshot_id)?;
        }
        if self.ttl.is_some() {
            state.serialize_entry("ttl", &self.ttl)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetSnapshot][google.bigtable.admin.v2.BigtableTableAdmin.GetSnapshot]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetSnapshot]: crate::client::BigtableTableAdmin::get_snapshot
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSnapshotRequest {
    /// Required. The unique name of the requested snapshot.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/{snapshot}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots][google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots]: crate::client::BigtableTableAdmin::list_snapshots
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSnapshotsRequest {
    /// Required. The unique name of the cluster for which snapshots should be
    /// listed. Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    /// Use `{cluster} = '-'` to list snapshots for all clusters in an instance,
    /// e.g., `projects/{project}/instances/{instance}/clusters/-`.
    pub parent: std::string::String,

    /// The maximum number of snapshots to return per page.
    /// CURRENTLY UNIMPLEMENTED AND IGNORED.
    pub page_size: i32,

    /// The value of `next_page_token` returned by a previous call.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnapshotsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSnapshotsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListSnapshotsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSnapshotsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSnapshotsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSnapshotsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSnapshotsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSnapshotsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots][google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots]: crate::client::BigtableTableAdmin::list_snapshots
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSnapshotsResponse {
    /// The snapshots present in the requested cluster.
    pub snapshots: std::vec::Vec<crate::model::Snapshot>,

    /// Set if not all snapshots could be returned in a single response.
    /// Pass this value to `page_token` in another request to get the next
    /// page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSnapshotsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshots][crate::model::ListSnapshotsResponse::snapshots].
    pub fn set_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Snapshot>,
    {
        use std::iter::Iterator;
        self.snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListSnapshotsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSnapshotsResponse {
    type PageItem = crate::model::Snapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSnapshotsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshots,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSnapshotsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshots" => Ok(__FieldTag::__snapshots),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSnapshotsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSnapshotsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshots => {
                            if !fields.insert(__FieldTag::__snapshots) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshots",
                                ));
                            }
                            result.snapshots = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Snapshot>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSnapshotsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.snapshots.is_empty() {
            state.serialize_entry("snapshots", &self.snapshots)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteSnapshot][google.bigtable.admin.v2.BigtableTableAdmin.DeleteSnapshot]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteSnapshot]: crate::client::BigtableTableAdmin::delete_snapshot
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSnapshotRequest {
    /// Required. The unique name of the snapshot to be deleted.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/{snapshot}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSnapshotRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteSnapshotRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSnapshotRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSnapshotRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSnapshotRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSnapshotRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSnapshotRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by SnapshotTable.
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SnapshotTableMetadata {
    /// The request that prompted the initiation of this SnapshotTable operation.
    pub original_request: std::option::Option<crate::model::SnapshotTableRequest>,

    /// The time at which the original request was received.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    pub finish_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SnapshotTableMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::SnapshotTableMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SnapshotTableRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::SnapshotTableMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SnapshotTableRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_time][crate::model::SnapshotTableMetadata::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::SnapshotTableMetadata::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::SnapshotTableMetadata::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::SnapshotTableMetadata::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SnapshotTableMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.SnapshotTableMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SnapshotTableMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __request_time,
            __finish_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SnapshotTableMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SnapshotTableMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SnapshotTableMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request = map.next_value::<std::option::Option<crate::model::SnapshotTableRequest>>()?
                                ;
                        }
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SnapshotTableMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.finish_time.is_some() {
            state.serialize_entry("finishTime", &self.finish_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by CreateTableFromSnapshot.
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTableFromSnapshotMetadata {
    /// The request that prompted the initiation of this CreateTableFromSnapshot
    /// operation.
    pub original_request: std::option::Option<crate::model::CreateTableFromSnapshotRequest>,

    /// The time at which the original request was received.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    pub finish_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTableFromSnapshotMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::CreateTableFromSnapshotMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CreateTableFromSnapshotRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::CreateTableFromSnapshotMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CreateTableFromSnapshotRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_time][crate::model::CreateTableFromSnapshotMetadata::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::CreateTableFromSnapshotMetadata::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::CreateTableFromSnapshotMetadata::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::CreateTableFromSnapshotMetadata::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateTableFromSnapshotMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateTableFromSnapshotMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTableFromSnapshotMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __request_time,
            __finish_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTableFromSnapshotMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTableFromSnapshotMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTableFromSnapshotMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request =
                                map.next_value::<std::option::Option<
                                    crate::model::CreateTableFromSnapshotRequest,
                                >>()?;
                        }
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTableFromSnapshotMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.finish_time.is_some() {
            state.serialize_entry("finishTime", &self.finish_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [CreateBackup][google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup]: crate::client::BigtableTableAdmin::create_backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupRequest {
    /// Required. This must be one of the clusters in the instance in which this
    /// table is located. The backup will be stored in this cluster. Values are
    /// of the form `projects/{project}/instances/{instance}/clusters/{cluster}`.
    pub parent: std::string::String,

    /// Required. The id of the backup to be created. The `backup_id` along with
    /// the parent `parent` are combined as {parent}/backups/{backup_id} to create
    /// the full backup name, of the form:
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup_id}`.
    /// This string must be between 1 and 50 characters in length and match the
    /// regex [_a-zA-Z0-9][-_.a-zA-Z0-9]*.
    pub backup_id: std::string::String,

    /// Required. The backup to create.
    pub backup: std::option::Option<crate::model::Backup>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_backup<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_id,
            __backup,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupId" => Ok(__FieldTag::__backup_id),
                            "backup_id" => Ok(__FieldTag::__backup_id),
                            "backup" => Ok(__FieldTag::__backup),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_id => {
                            if !fields.insert(__FieldTag::__backup_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_id",
                                ));
                            }
                            result.backup_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup =
                                map.next_value::<std::option::Option<crate::model::Backup>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.backup_id.is_empty() {
            state.serialize_entry("backupId", &self.backup_id)?;
        }
        if self.backup.is_some() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata type for the operation returned by
/// [CreateBackup][google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup]: crate::client::BigtableTableAdmin::create_backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBackupMetadata {
    /// The name of the backup being created.
    pub name: std::string::String,

    /// The name of the table the backup is created from.
    pub source_table: std::string::String,

    /// The time at which this operation started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation finished or was cancelled.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBackupMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CreateBackupMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_table][crate::model::CreateBackupMetadata::source_table].
    pub fn set_source_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_table = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::CreateBackupMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CreateBackupMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CreateBackupMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CreateBackupMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBackupMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateBackupMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBackupMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __source_table,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBackupMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sourceTable" => Ok(__FieldTag::__source_table),
                            "source_table" => Ok(__FieldTag::__source_table),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBackupMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBackupMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_table => {
                            if !fields.insert(__FieldTag::__source_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_table",
                                ));
                            }
                            result.source_table = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBackupMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.source_table.is_empty() {
            state.serialize_entry("sourceTable", &self.source_table)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [UpdateBackup][google.bigtable.admin.v2.BigtableTableAdmin.UpdateBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UpdateBackup]: crate::client::BigtableTableAdmin::update_backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Required. The backup to update. `backup.name`, and the fields to be updated
    /// as specified by `update_mask` are required. Other fields are ignored.
    /// Update is only supported for the following fields:
    ///
    /// * `backup.expire_time`.
    pub backup: std::option::Option<crate::model::Backup>,

    /// Required. A mask specifying which fields (e.g. `expire_time`) in the
    /// Backup resource should be updated. This mask is relative to the Backup
    /// resource, not to the request message. The field mask must always be
    /// specified; this prevents any future fields from being erased accidentally
    /// by clients that do not know about them.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_or_clear_backup<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Backup>,
    {
        self.backup = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backup" => Ok(__FieldTag::__backup),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup =
                                map.next_value::<std::option::Option<crate::model::Backup>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.backup.is_some() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [GetBackup][google.bigtable.admin.v2.BigtableTableAdmin.GetBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetBackup]: crate::client::BigtableTableAdmin::get_backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Name of the backup.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [DeleteBackup][google.bigtable.admin.v2.BigtableTableAdmin.DeleteBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteBackup]: crate::client::BigtableTableAdmin::delete_backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Name of the backup to delete.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup}`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [ListBackups][google.bigtable.admin.v2.BigtableTableAdmin.ListBackups].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListBackups]: crate::client::BigtableTableAdmin::list_backups
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The cluster to list backups from.  Values are of the
    /// form `projects/{project}/instances/{instance}/clusters/{cluster}`.
    /// Use `{cluster} = '-'` to list backups for all clusters in an instance,
    /// e.g., `projects/{project}/instances/{instance}/clusters/-`.
    pub parent: std::string::String,

    /// A filter expression that filters backups listed in the response.
    /// The expression must specify the field name, a comparison operator,
    /// and the value that you want to use for filtering. The value must be a
    /// string, a number, or a boolean. The comparison operator must be
    /// <, >, <=, >=, !=, =, or :. Colon ':' represents a HAS operator which is
    /// roughly synonymous with equality. Filter rules are case insensitive.
    ///
    /// The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `source_table`
    /// * `state`
    /// * `start_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)
    /// * `end_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)
    /// * `expire_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)
    /// * `size_bytes`
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. By default, each expression is an AND expression. However,
    /// you can include AND, OR, and NOT expressions explicitly.
    ///
    /// Some examples of using filters are:
    ///
    /// * `name:"exact"` --> The backup's name is the string "exact".
    /// * `name:howl` --> The backup's name contains the string "howl".
    /// * `source_table:prod`
    ///   --> The source_table's name contains the string "prod".
    /// * `state:CREATING` --> The backup is pending creation.
    /// * `state:READY` --> The backup is fully created and ready for use.
    /// * `(name:howl) AND (start_time < \"2018-03-28T14:50:00Z\")`
    ///   --> The backup name contains the string "howl" and start_time
    ///   of the backup is before 2018-03-28T14:50:00Z.
    /// * `size_bytes > 10000000000` --> The backup's size is greater than 10GB
    pub filter: std::string::String,

    /// An expression for specifying the sort order of the results of the request.
    /// The string value should specify one or more fields in
    /// [Backup][google.bigtable.admin.v2.Backup]. The full syntax is described at
    /// <https://aip.dev/132#ordering>.
    ///
    /// Fields supported are:
    ///
    /// * name
    /// * source_table
    /// * expire_time
    /// * start_time
    /// * end_time
    /// * size_bytes
    /// * state
    ///
    /// For example, "start_time". The default sorting order is ascending.
    /// To specify descending order for the field, a suffix " desc" should
    /// be appended to the field name. For example, "start_time desc".
    /// Redundant space characters in the syntax are insigificant.
    ///
    /// If order_by is empty, results will be sorted by `start_time` in descending
    /// order starting from the most recently created backup.
    ///
    /// [google.bigtable.admin.v2.Backup]: crate::model::Backup
    pub order_by: std::string::String,

    /// Number of backups to be returned in the response. If 0 or
    /// less, defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.bigtable.admin.v2.ListBackupsResponse.next_page_token]
    /// from a previous
    /// [ListBackupsResponse][google.bigtable.admin.v2.ListBackupsResponse] to the
    /// same `parent` and with the same `filter`.
    ///
    /// [google.bigtable.admin.v2.ListBackupsResponse]: crate::model::ListBackupsResponse
    /// [google.bigtable.admin.v2.ListBackupsResponse.next_page_token]: crate::model::ListBackupsResponse::next_page_token
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListBackupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __filter,
            __order_by,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response for
/// [ListBackups][google.bigtable.admin.v2.BigtableTableAdmin.ListBackups].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListBackups]: crate::client::BigtableTableAdmin::list_backups
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// The list of matching backups.
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListBackups][google.bigtable.admin.v2.BigtableTableAdmin.ListBackups] call
    /// to fetch more of the matching backups.
    ///
    /// [google.bigtable.admin.v2.BigtableTableAdmin.ListBackups]: crate::client::BigtableTableAdmin::list_backups
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backups,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backups" => Ok(__FieldTag::__backups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backups => {
                            if !fields.insert(__FieldTag::__backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backups",
                                ));
                            }
                            result.backups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Backup>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backups.is_empty() {
            state.serialize_entry("backups", &self.backups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [CopyBackup][google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup]: crate::client::BigtableTableAdmin::copy_backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CopyBackupRequest {
    /// Required. The name of the destination cluster that will contain the backup
    /// copy. The cluster must already exist. Values are of the form:
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    pub parent: std::string::String,

    /// Required. The id of the new backup. The `backup_id` along with `parent`
    /// are combined as {parent}/backups/{backup_id} to create the full backup
    /// name, of the form:
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup_id}`.
    /// This string must be between 1 and 50 characters in length and match the
    /// regex [_a-zA-Z0-9][-_.a-zA-Z0-9]*.
    pub backup_id: std::string::String,

    /// Required. The source backup to be copied from.
    /// The source backup needs to be in READY state for it to be copied.
    /// Copying a copied backup is not allowed.
    /// Once CopyBackup is in progress, the source backup cannot be deleted or
    /// cleaned up on expiration until CopyBackup is finished.
    /// Values are of the form:
    /// `projects/<project>/instances/<instance>/clusters/<cluster>/backups/<backup>`.
    pub source_backup: std::string::String,

    /// Required. Required. The expiration time of the copied backup with
    /// microsecond granularity that must be at least 6 hours and at most 30 days
    /// from the time the request is received. Once the `expire_time` has
    /// passed, Cloud Bigtable will delete the backup and free the resources used
    /// by the backup.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CopyBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CopyBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CopyBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [source_backup][crate::model::CopyBackupRequest::source_backup].
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_backup = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::CopyBackupRequest::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::CopyBackupRequest::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CopyBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CopyBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CopyBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __backup_id,
            __source_backup,
            __expire_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CopyBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "backupId" => Ok(__FieldTag::__backup_id),
                            "backup_id" => Ok(__FieldTag::__backup_id),
                            "sourceBackup" => Ok(__FieldTag::__source_backup),
                            "source_backup" => Ok(__FieldTag::__source_backup),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CopyBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CopyBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_id => {
                            if !fields.insert(__FieldTag::__backup_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_id",
                                ));
                            }
                            result.backup_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_backup => {
                            if !fields.insert(__FieldTag::__source_backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_backup",
                                ));
                            }
                            result.source_backup = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CopyBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.backup_id.is_empty() {
            state.serialize_entry("backupId", &self.backup_id)?;
        }
        if !self.source_backup.is_empty() {
            state.serialize_entry("sourceBackup", &self.source_backup)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata type for the google.longrunning.Operation returned by
/// [CopyBackup][google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup]: crate::client::BigtableTableAdmin::copy_backup
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CopyBackupMetadata {
    /// The name of the backup being created through the copy operation.
    /// Values are of the form
    /// `projects/<project>/instances/<instance>/clusters/<cluster>/backups/<backup>`.
    pub name: std::string::String,

    /// Information about the source backup that is being copied from.
    pub source_backup_info: std::option::Option<crate::model::BackupInfo>,

    /// The progress of the
    /// [CopyBackup][google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup]
    /// operation.
    ///
    /// [google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup]: crate::client::BigtableTableAdmin::copy_backup
    pub progress: std::option::Option<crate::model::OperationProgress>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CopyBackupMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CopyBackupMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_backup_info][crate::model::CopyBackupMetadata::source_backup_info].
    pub fn set_source_backup_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BackupInfo>,
    {
        self.source_backup_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_backup_info][crate::model::CopyBackupMetadata::source_backup_info].
    pub fn set_or_clear_source_backup_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BackupInfo>,
    {
        self.source_backup_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress][crate::model::CopyBackupMetadata::progress].
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::CopyBackupMetadata::progress].
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OperationProgress>,
    {
        self.progress = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CopyBackupMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CopyBackupMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CopyBackupMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __source_backup_info,
            __progress,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CopyBackupMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sourceBackupInfo" => Ok(__FieldTag::__source_backup_info),
                            "source_backup_info" => Ok(__FieldTag::__source_backup_info),
                            "progress" => Ok(__FieldTag::__progress),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CopyBackupMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CopyBackupMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_backup_info => {
                            if !fields.insert(__FieldTag::__source_backup_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_backup_info",
                                ));
                            }
                            result.source_backup_info =
                                map.next_value::<std::option::Option<crate::model::BackupInfo>>()?;
                        }
                        __FieldTag::__progress => {
                            if !fields.insert(__FieldTag::__progress) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress",
                                ));
                            }
                            result.progress = map
                                .next_value::<std::option::Option<crate::model::OperationProgress>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CopyBackupMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.source_backup_info.is_some() {
            state.serialize_entry("sourceBackupInfo", &self.source_backup_info)?;
        }
        if self.progress.is_some() {
            state.serialize_entry("progress", &self.progress)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [CreateAuthorizedView][google.bigtable.admin.v2.BigtableTableAdmin.CreateAuthorizedView]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateAuthorizedView]: crate::client::BigtableTableAdmin::create_authorized_view
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAuthorizedViewRequest {
    /// Required. This is the name of the table the AuthorizedView belongs to.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    pub parent: std::string::String,

    /// Required. The id of the AuthorizedView to create. This AuthorizedView must
    /// not already exist. The `authorized_view_id` appended to `parent` forms the
    /// full AuthorizedView name of the form
    /// `projects/{project}/instances/{instance}/tables/{table}/authorizedView/{authorized_view}`.
    pub authorized_view_id: std::string::String,

    /// Required. The AuthorizedView to create.
    pub authorized_view: std::option::Option<crate::model::AuthorizedView>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAuthorizedViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateAuthorizedViewRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [authorized_view_id][crate::model::CreateAuthorizedViewRequest::authorized_view_id].
    pub fn set_authorized_view_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorized_view_id = v.into();
        self
    }

    /// Sets the value of [authorized_view][crate::model::CreateAuthorizedViewRequest::authorized_view].
    pub fn set_authorized_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedView>,
    {
        self.authorized_view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorized_view][crate::model::CreateAuthorizedViewRequest::authorized_view].
    pub fn set_or_clear_authorized_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedView>,
    {
        self.authorized_view = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAuthorizedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateAuthorizedViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAuthorizedViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __authorized_view_id,
            __authorized_view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAuthorizedViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "authorizedViewId" => Ok(__FieldTag::__authorized_view_id),
                            "authorized_view_id" => Ok(__FieldTag::__authorized_view_id),
                            "authorizedView" => Ok(__FieldTag::__authorized_view),
                            "authorized_view" => Ok(__FieldTag::__authorized_view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAuthorizedViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAuthorizedViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__authorized_view_id => {
                            if !fields.insert(__FieldTag::__authorized_view_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorized_view_id",
                                ));
                            }
                            result.authorized_view_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__authorized_view => {
                            if !fields.insert(__FieldTag::__authorized_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorized_view",
                                ));
                            }
                            result.authorized_view = map
                                .next_value::<std::option::Option<crate::model::AuthorizedView>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAuthorizedViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.authorized_view_id.is_empty() {
            state.serialize_entry("authorizedViewId", &self.authorized_view_id)?;
        }
        if self.authorized_view.is_some() {
            state.serialize_entry("authorizedView", &self.authorized_view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for the Operation returned by CreateAuthorizedView.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateAuthorizedViewMetadata {
    /// The request that prompted the initiation of this CreateInstance operation.
    pub original_request: std::option::Option<crate::model::CreateAuthorizedViewRequest>,

    /// The time at which the original request was received.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    pub finish_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateAuthorizedViewMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::CreateAuthorizedViewMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CreateAuthorizedViewRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::CreateAuthorizedViewMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CreateAuthorizedViewRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_time][crate::model::CreateAuthorizedViewMetadata::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::CreateAuthorizedViewMetadata::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::CreateAuthorizedViewMetadata::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::CreateAuthorizedViewMetadata::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateAuthorizedViewMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateAuthorizedViewMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateAuthorizedViewMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __request_time,
            __finish_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateAuthorizedViewMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateAuthorizedViewMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateAuthorizedViewMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request = map.next_value::<std::option::Option<crate::model::CreateAuthorizedViewRequest>>()?
                                ;
                        }
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateAuthorizedViewMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.finish_time.is_some() {
            state.serialize_entry("finishTime", &self.finish_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews][google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews]: crate::client::BigtableTableAdmin::list_authorized_views
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAuthorizedViewsRequest {
    /// Required. The unique name of the table for which AuthorizedViews should be
    /// listed. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    pub parent: std::string::String,

    /// Optional. Maximum number of results per page.
    ///
    /// A page_size of zero lets the server choose the number of items to return.
    /// A page_size which is strictly positive will return at most that many items.
    /// A negative page_size will cause an error.
    ///
    /// Following the first request, subsequent paginated calls are not required
    /// to pass a page_size. If a page_size is set in subsequent calls, it must
    /// match the page_size given in the first request.
    pub page_size: i32,

    /// Optional. The value of `next_page_token` returned by a previous call.
    pub page_token: std::string::String,

    /// Optional. The resource_view to be applied to the returned views' fields.
    /// Default to NAME_ONLY.
    pub view: crate::model::authorized_view::ResponseView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedViewsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListAuthorizedViewsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAuthorizedViewsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAuthorizedViewsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListAuthorizedViewsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::authorized_view::ResponseView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedViewsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListAuthorizedViewsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAuthorizedViewsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAuthorizedViewsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAuthorizedViewsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAuthorizedViewsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view =
                                map.next_value::<std::option::Option<
                                    crate::model::authorized_view::ResponseView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAuthorizedViewsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews][google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews]: crate::client::BigtableTableAdmin::list_authorized_views
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListAuthorizedViewsResponse {
    /// The AuthorizedViews present in the requested table.
    pub authorized_views: std::vec::Vec<crate::model::AuthorizedView>,

    /// Set if not all tables could be returned in a single response.
    /// Pass this value to `page_token` in another request to get the next
    /// page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListAuthorizedViewsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [authorized_views][crate::model::ListAuthorizedViewsResponse::authorized_views].
    pub fn set_authorized_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuthorizedView>,
    {
        use std::iter::Iterator;
        self.authorized_views = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListAuthorizedViewsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedViewsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListAuthorizedViewsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListAuthorizedViewsResponse {
    type PageItem = crate::model::AuthorizedView;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.authorized_views
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListAuthorizedViewsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __authorized_views,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListAuthorizedViewsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "authorizedViews" => Ok(__FieldTag::__authorized_views),
                            "authorized_views" => Ok(__FieldTag::__authorized_views),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListAuthorizedViewsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListAuthorizedViewsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__authorized_views => {
                            if !fields.insert(__FieldTag::__authorized_views) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorized_views",
                                ));
                            }
                            result.authorized_views =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AuthorizedView>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListAuthorizedViewsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.authorized_views.is_empty() {
            state.serialize_entry("authorizedViews", &self.authorized_views)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetAuthorizedView][google.bigtable.admin.v2.BigtableTableAdmin.GetAuthorizedView]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetAuthorizedView]: crate::client::BigtableTableAdmin::get_authorized_view
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetAuthorizedViewRequest {
    /// Required. The unique name of the requested AuthorizedView.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}/authorizedViews/{authorized_view}`.
    pub name: std::string::String,

    /// Optional. The resource_view to be applied to the returned AuthorizedView's
    /// fields. Default to BASIC.
    pub view: crate::model::authorized_view::ResponseView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetAuthorizedViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetAuthorizedViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetAuthorizedViewRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::authorized_view::ResponseView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetAuthorizedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetAuthorizedViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetAuthorizedViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetAuthorizedViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetAuthorizedViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetAuthorizedViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view =
                                map.next_value::<std::option::Option<
                                    crate::model::authorized_view::ResponseView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetAuthorizedViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for
/// [UpdateAuthorizedView][google.bigtable.admin.v2.BigtableTableAdmin.UpdateAuthorizedView].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UpdateAuthorizedView]: crate::client::BigtableTableAdmin::update_authorized_view
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAuthorizedViewRequest {
    /// Required. The AuthorizedView to update. The `name` in `authorized_view` is
    /// used to identify the AuthorizedView. AuthorizedView name must in this
    /// format
    /// projects/\<project\>/instances/\<instance\>/tables/\<table\>/authorizedViews/<authorized_view>
    pub authorized_view: std::option::Option<crate::model::AuthorizedView>,

    /// Optional. The list of fields to update.
    /// A mask specifying which fields in the AuthorizedView resource should be
    /// updated. This mask is relative to the AuthorizedView resource, not to the
    /// request message. A field will be overwritten if it is in the mask. If
    /// empty, all fields set in the request will be overwritten. A special value
    /// `*` means to overwrite all fields (including fields not set in the
    /// request).
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If true, ignore the safety checks when updating the
    /// AuthorizedView.
    pub ignore_warnings: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAuthorizedViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [authorized_view][crate::model::UpdateAuthorizedViewRequest::authorized_view].
    pub fn set_authorized_view<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedView>,
    {
        self.authorized_view = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorized_view][crate::model::UpdateAuthorizedViewRequest::authorized_view].
    pub fn set_or_clear_authorized_view<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AuthorizedView>,
    {
        self.authorized_view = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAuthorizedViewRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateAuthorizedViewRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ignore_warnings][crate::model::UpdateAuthorizedViewRequest::ignore_warnings].
    pub fn set_ignore_warnings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_warnings = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAuthorizedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateAuthorizedViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAuthorizedViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __authorized_view,
            __update_mask,
            __ignore_warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAuthorizedViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "authorizedView" => Ok(__FieldTag::__authorized_view),
                            "authorized_view" => Ok(__FieldTag::__authorized_view),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "ignoreWarnings" => Ok(__FieldTag::__ignore_warnings),
                            "ignore_warnings" => Ok(__FieldTag::__ignore_warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAuthorizedViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAuthorizedViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__authorized_view => {
                            if !fields.insert(__FieldTag::__authorized_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorized_view",
                                ));
                            }
                            result.authorized_view = map
                                .next_value::<std::option::Option<crate::model::AuthorizedView>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__ignore_warnings => {
                            if !fields.insert(__FieldTag::__ignore_warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_warnings",
                                ));
                            }
                            result.ignore_warnings = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAuthorizedViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.authorized_view.is_some() {
            state.serialize_entry("authorizedView", &self.authorized_view)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.ignore_warnings) {
            state.serialize_entry("ignoreWarnings", &self.ignore_warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for the google.longrunning.Operation returned by
/// [UpdateAuthorizedView][google.bigtable.admin.v2.BigtableTableAdmin.UpdateAuthorizedView].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UpdateAuthorizedView]: crate::client::BigtableTableAdmin::update_authorized_view
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateAuthorizedViewMetadata {
    /// The request that prompted the initiation of this UpdateAuthorizedView
    /// operation.
    pub original_request: std::option::Option<crate::model::UpdateAuthorizedViewRequest>,

    /// The time at which the original request was received.
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    pub finish_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateAuthorizedViewMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [original_request][crate::model::UpdateAuthorizedViewMetadata::original_request].
    pub fn set_original_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpdateAuthorizedViewRequest>,
    {
        self.original_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [original_request][crate::model::UpdateAuthorizedViewMetadata::original_request].
    pub fn set_or_clear_original_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpdateAuthorizedViewRequest>,
    {
        self.original_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_time][crate::model::UpdateAuthorizedViewMetadata::request_time].
    pub fn set_request_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_time][crate::model::UpdateAuthorizedViewMetadata::request_time].
    pub fn set_or_clear_request_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.request_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [finish_time][crate::model::UpdateAuthorizedViewMetadata::finish_time].
    pub fn set_finish_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [finish_time][crate::model::UpdateAuthorizedViewMetadata::finish_time].
    pub fn set_or_clear_finish_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.finish_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateAuthorizedViewMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateAuthorizedViewMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateAuthorizedViewMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __original_request,
            __request_time,
            __finish_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateAuthorizedViewMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "originalRequest" => Ok(__FieldTag::__original_request),
                            "original_request" => Ok(__FieldTag::__original_request),
                            "requestTime" => Ok(__FieldTag::__request_time),
                            "request_time" => Ok(__FieldTag::__request_time),
                            "finishTime" => Ok(__FieldTag::__finish_time),
                            "finish_time" => Ok(__FieldTag::__finish_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateAuthorizedViewMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateAuthorizedViewMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__original_request => {
                            if !fields.insert(__FieldTag::__original_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for original_request",
                                ));
                            }
                            result.original_request = map.next_value::<std::option::Option<crate::model::UpdateAuthorizedViewRequest>>()?
                                ;
                        }
                        __FieldTag::__request_time => {
                            if !fields.insert(__FieldTag::__request_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_time",
                                ));
                            }
                            result.request_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__finish_time => {
                            if !fields.insert(__FieldTag::__finish_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for finish_time",
                                ));
                            }
                            result.finish_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateAuthorizedViewMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.original_request.is_some() {
            state.serialize_entry("originalRequest", &self.original_request)?;
        }
        if self.request_time.is_some() {
            state.serialize_entry("requestTime", &self.request_time)?;
        }
        if self.finish_time.is_some() {
            state.serialize_entry("finishTime", &self.finish_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteAuthorizedView][google.bigtable.admin.v2.BigtableTableAdmin.DeleteAuthorizedView]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteAuthorizedView]: crate::client::BigtableTableAdmin::delete_authorized_view
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteAuthorizedViewRequest {
    /// Required. The unique name of the AuthorizedView to be deleted.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}/authorizedViews/{authorized_view}`.
    pub name: std::string::String,

    /// Optional. The current etag of the AuthorizedView.
    /// If an etag is provided and does not match the current etag of the
    /// AuthorizedView, deletion will be blocked and an ABORTED error will be
    /// returned.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteAuthorizedViewRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteAuthorizedViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAuthorizedViewRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAuthorizedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteAuthorizedViewRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteAuthorizedViewRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteAuthorizedViewRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteAuthorizedViewRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteAuthorizedViewRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteAuthorizedViewRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Encapsulates progress related information for a Cloud Bigtable long
/// running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationProgress {
    /// Percent completion of the operation.
    /// Values are between 0 and 100 inclusive.
    pub progress_percent: i32,

    /// Time the request was received.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation failed or was completed
    /// successfully.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationProgress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [progress_percent][crate::model::OperationProgress::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::OperationProgress::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::OperationProgress::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationProgress::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationProgress::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OperationProgress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.OperationProgress"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationProgress {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __progress_percent,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationProgress")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "progressPercent" => Ok(__FieldTag::__progress_percent),
                            "progress_percent" => Ok(__FieldTag::__progress_percent),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationProgress;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationProgress")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__progress_percent => {
                            if !fields.insert(__FieldTag::__progress_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationProgress {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.progress_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progressPercent", &__With(&self.progress_percent))?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A collection of Bigtable [Tables][google.bigtable.admin.v2.Table] and
/// the resources that serve them.
/// All tables in an instance are served from all
/// [Clusters][google.bigtable.admin.v2.Cluster] in the instance.
///
/// [google.bigtable.admin.v2.Cluster]: crate::model::Cluster
/// [google.bigtable.admin.v2.Table]: crate::model::Table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    /// The unique name of the instance. Values are of the form
    /// `projects/{project}/instances/[a-z][a-z0-9\\-]+[a-z0-9]`.
    pub name: std::string::String,

    /// Required. The descriptive name for this instance as it appears in UIs.
    /// Can be changed at any time, but should be kept globally unique
    /// to avoid confusion.
    pub display_name: std::string::String,

    /// Output only. The current state of the instance.
    pub state: crate::model::instance::State,

    /// The type of the instance. Defaults to `PRODUCTION`.
    pub r#type: crate::model::instance::Type,

    /// Labels are a flexible and lightweight mechanism for organizing cloud
    /// resources into groups that reflect a customer's organizational needs and
    /// deployment strategies. They can be used to filter resources and aggregate
    /// metrics.
    ///
    /// * Label keys must be between 1 and 63 characters long and must conform to
    ///   the regular expression: `[\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}`.
    /// * Label values must be between 0 and 63 characters long and must conform to
    ///   the regular expression: `[\p{Ll}\p{Lo}\p{N}_-]{0,63}`.
    /// * No more than 64 labels can be associated with a given resource.
    /// * Keys and values must both be under 128 bytes.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. A commit timestamp representing when this Instance was
    /// created. For instances created before this field was added (August 2021),
    /// this value is `seconds: 0, nanos: 1`.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Reserved for future use.
    pub satisfies_pzs: std::option::Option<bool>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Instance::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Instance::type].
    pub fn set_type<T: std::convert::Into<crate::model::instance::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Instance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Instance::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::Instance::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Instance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Instance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __state,
            __type,
            __labels,
            __create_time,
            __satisfies_pzs,
            __satisfies_pzi,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Instance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "type" => Ok(__FieldTag::__type),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "satisfiesPzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfies_pzs" => Ok(__FieldTag::__satisfies_pzs),
                            "satisfiesPzi" => Ok(__FieldTag::__satisfies_pzi),
                            "satisfies_pzi" => Ok(__FieldTag::__satisfies_pzi),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Instance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Instance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::instance::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::instance::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__satisfies_pzs => {
                            if !fields.insert(__FieldTag::__satisfies_pzs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzs",
                                ));
                            }
                            result.satisfies_pzs = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__satisfies_pzi => {
                            if !fields.insert(__FieldTag::__satisfies_pzi) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for satisfies_pzi",
                                ));
                            }
                            result.satisfies_pzi = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Instance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.satisfies_pzs.is_some() {
            state.serialize_entry("satisfiesPzs", &self.satisfies_pzs)?;
        }
        if self.satisfies_pzi.is_some() {
            state.serialize_entry("satisfiesPzi", &self.satisfies_pzi)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of an instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the instance could not be determined.
        NotKnown,
        /// The instance has been successfully created and can serve requests
        /// to its tables.
        Ready,
        /// The instance is currently being created, and may be destroyed
        /// if the creation process encounters an error.
        Creating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::NotKnown => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::NotKnown => std::option::Option::Some("STATE_NOT_KNOWN"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::NotKnown,
                1 => Self::Ready,
                2 => Self::Creating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_NOT_KNOWN" => Self::NotKnown,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::NotKnown => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.bigtable.admin.v2.Instance.State",
            ))
        }
    }

    /// The type of the instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// The type of the instance is unspecified. If set when creating an
        /// instance, a `PRODUCTION` instance will be created. If set when updating
        /// an instance, the type will be left unchanged.
        Unspecified,
        /// An instance meant for production use. `serve_nodes` must be set
        /// on the cluster.
        Production,
        /// DEPRECATED: Prefer PRODUCTION for all use cases, as it no longer enforces
        /// a higher minimum node count than DEVELOPMENT.
        Development,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Production => std::option::Option::Some(1),
                Self::Development => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Production => std::option::Option::Some("PRODUCTION"),
                Self::Development => std::option::Option::Some("DEVELOPMENT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Production,
                2 => Self::Development,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "PRODUCTION" => Self::Production,
                "DEVELOPMENT" => Self::Development,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Production => serializer.serialize_i32(1),
                Self::Development => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.bigtable.admin.v2.Instance.Type",
            ))
        }
    }
}

/// The Autoscaling targets for a Cluster. These determine the recommended nodes.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoscalingTargets {
    /// The cpu utilization that the Autoscaler should be trying to achieve.
    /// This number is on a scale from 0 (no utilization) to
    /// 100 (total utilization), and is limited between 10 and 80, otherwise it
    /// will return INVALID_ARGUMENT error.
    pub cpu_utilization_percent: i32,

    /// The storage utilization that the Autoscaler should be trying to achieve.
    /// This number is limited between 2560 (2.5TiB) and 5120 (5TiB) for a SSD
    /// cluster and between 8192 (8TiB) and 16384 (16TiB) for an HDD cluster,
    /// otherwise it will return INVALID_ARGUMENT error. If this value is set to 0,
    /// it will be treated as if it were set to the default value: 2560 for SSD,
    /// 8192 for HDD.
    pub storage_utilization_gib_per_node: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoscalingTargets {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_utilization_percent][crate::model::AutoscalingTargets::cpu_utilization_percent].
    pub fn set_cpu_utilization_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_utilization_percent = v.into();
        self
    }

    /// Sets the value of [storage_utilization_gib_per_node][crate::model::AutoscalingTargets::storage_utilization_gib_per_node].
    pub fn set_storage_utilization_gib_per_node<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_utilization_gib_per_node = v.into();
        self
    }
}

impl wkt::message::Message for AutoscalingTargets {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.AutoscalingTargets"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutoscalingTargets {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpu_utilization_percent,
            __storage_utilization_gib_per_node,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoscalingTargets")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpuUtilizationPercent" => Ok(__FieldTag::__cpu_utilization_percent),
                            "cpu_utilization_percent" => Ok(__FieldTag::__cpu_utilization_percent),
                            "storageUtilizationGibPerNode" => {
                                Ok(__FieldTag::__storage_utilization_gib_per_node)
                            }
                            "storage_utilization_gib_per_node" => {
                                Ok(__FieldTag::__storage_utilization_gib_per_node)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutoscalingTargets;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoscalingTargets")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpu_utilization_percent => {
                            if !fields.insert(__FieldTag::__cpu_utilization_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_utilization_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_utilization_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__storage_utilization_gib_per_node => {
                            if !fields.insert(__FieldTag::__storage_utilization_gib_per_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for storage_utilization_gib_per_node",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.storage_utilization_gib_per_node =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutoscalingTargets {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cpu_utilization_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "cpuUtilizationPercent",
                &__With(&self.cpu_utilization_percent),
            )?;
        }
        if !wkt::internal::is_default(&self.storage_utilization_gib_per_node) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "storageUtilizationGibPerNode",
                &__With(&self.storage_utilization_gib_per_node),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Limits for the number of nodes a Cluster can autoscale up/down to.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AutoscalingLimits {
    /// Required. Minimum number of nodes to scale down to.
    pub min_serve_nodes: i32,

    /// Required. Maximum number of nodes to scale up to.
    pub max_serve_nodes: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutoscalingLimits {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_serve_nodes][crate::model::AutoscalingLimits::min_serve_nodes].
    pub fn set_min_serve_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_serve_nodes = v.into();
        self
    }

    /// Sets the value of [max_serve_nodes][crate::model::AutoscalingLimits::max_serve_nodes].
    pub fn set_max_serve_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_serve_nodes = v.into();
        self
    }
}

impl wkt::message::Message for AutoscalingLimits {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.AutoscalingLimits"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutoscalingLimits {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __min_serve_nodes,
            __max_serve_nodes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutoscalingLimits")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "minServeNodes" => Ok(__FieldTag::__min_serve_nodes),
                            "min_serve_nodes" => Ok(__FieldTag::__min_serve_nodes),
                            "maxServeNodes" => Ok(__FieldTag::__max_serve_nodes),
                            "max_serve_nodes" => Ok(__FieldTag::__max_serve_nodes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutoscalingLimits;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutoscalingLimits")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__min_serve_nodes => {
                            if !fields.insert(__FieldTag::__min_serve_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_serve_nodes",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_serve_nodes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__max_serve_nodes => {
                            if !fields.insert(__FieldTag::__max_serve_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_serve_nodes",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_serve_nodes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutoscalingLimits {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.min_serve_nodes) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minServeNodes", &__With(&self.min_serve_nodes))?;
        }
        if !wkt::internal::is_default(&self.max_serve_nodes) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxServeNodes", &__With(&self.max_serve_nodes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A resizable group of nodes in a particular cloud location, capable
/// of serving all [Tables][google.bigtable.admin.v2.Table] in the parent
/// [Instance][google.bigtable.admin.v2.Instance].
///
/// [google.bigtable.admin.v2.Instance]: crate::model::Instance
/// [google.bigtable.admin.v2.Table]: crate::model::Table
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Cluster {
    /// The unique name of the cluster. Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/[a-z][-a-z0-9]*`.
    pub name: std::string::String,

    /// Immutable. The location where this cluster's nodes and storage reside. For
    /// best performance, clients should be located as close as possible to this
    /// cluster. Currently only zones are supported, so values should be of the
    /// form `projects/{project}/locations/{zone}`.
    pub location: std::string::String,

    /// Output only. The current state of the cluster.
    pub state: crate::model::cluster::State,

    /// The number of nodes in the cluster. If no value is set,
    /// Cloud Bigtable automatically allocates nodes based on your data footprint
    /// and optimized for 50% storage utilization.
    pub serve_nodes: i32,

    /// Immutable. The node scaling factor of this cluster.
    pub node_scaling_factor: crate::model::cluster::NodeScalingFactor,

    /// Immutable. The type of storage used by this cluster to serve its
    /// parent instance's tables, unless explicitly overridden.
    pub default_storage_type: crate::model::StorageType,

    /// Immutable. The encryption configuration for CMEK-protected clusters.
    pub encryption_config: std::option::Option<crate::model::cluster::EncryptionConfig>,

    pub config: std::option::Option<crate::model::cluster::Config>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Cluster::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Cluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [serve_nodes][crate::model::Cluster::serve_nodes].
    pub fn set_serve_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.serve_nodes = v.into();
        self
    }

    /// Sets the value of [node_scaling_factor][crate::model::Cluster::node_scaling_factor].
    pub fn set_node_scaling_factor<
        T: std::convert::Into<crate::model::cluster::NodeScalingFactor>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_scaling_factor = v.into();
        self
    }

    /// Sets the value of [default_storage_type][crate::model::Cluster::default_storage_type].
    pub fn set_default_storage_type<T: std::convert::Into<crate::model::StorageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_storage_type = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::Cluster::encryption_config].
    pub fn set_encryption_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::EncryptionConfig>,
    {
        self.encryption_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_config][crate::model::Cluster::encryption_config].
    pub fn set_or_clear_encryption_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::EncryptionConfig>,
    {
        self.encryption_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [config][crate::model::Cluster::config].
    ///
    /// Note that all the setters affecting `config` are mutually
    /// exclusive.
    pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::cluster::Config>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }

    /// The value of [config][crate::model::Cluster::config]
    /// if it holds a `ClusterConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cluster_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cluster::ClusterConfig>> {
        #[allow(unreachable_patterns)]
        self.config.as_ref().and_then(|v| match v {
            crate::model::cluster::Config::ClusterConfig(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [config][crate::model::Cluster::config]
    /// to hold a `ClusterConfig`.
    ///
    /// Note that all the setters affecting `config` are
    /// mutually exclusive.
    pub fn set_cluster_config<
        T: std::convert::Into<std::boxed::Box<crate::model::cluster::ClusterConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config =
            std::option::Option::Some(crate::model::cluster::Config::ClusterConfig(v.into()));
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Cluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __location,
            __state,
            __serve_nodes,
            __node_scaling_factor,
            __cluster_config,
            __default_storage_type,
            __encryption_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "location" => Ok(__FieldTag::__location),
                            "state" => Ok(__FieldTag::__state),
                            "serveNodes" => Ok(__FieldTag::__serve_nodes),
                            "serve_nodes" => Ok(__FieldTag::__serve_nodes),
                            "nodeScalingFactor" => Ok(__FieldTag::__node_scaling_factor),
                            "node_scaling_factor" => Ok(__FieldTag::__node_scaling_factor),
                            "clusterConfig" => Ok(__FieldTag::__cluster_config),
                            "cluster_config" => Ok(__FieldTag::__cluster_config),
                            "defaultStorageType" => Ok(__FieldTag::__default_storage_type),
                            "default_storage_type" => Ok(__FieldTag::__default_storage_type),
                            "encryptionConfig" => Ok(__FieldTag::__encryption_config),
                            "encryption_config" => Ok(__FieldTag::__encryption_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::cluster::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__serve_nodes => {
                            if !fields.insert(__FieldTag::__serve_nodes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for serve_nodes",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.serve_nodes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__node_scaling_factor => {
                            if !fields.insert(__FieldTag::__node_scaling_factor) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_scaling_factor",
                                ));
                            }
                            result.node_scaling_factor = map.next_value::<std::option::Option<crate::model::cluster::NodeScalingFactor>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cluster_config => {
                            if !fields.insert(__FieldTag::__cluster_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_config",
                                ));
                            }
                            if result.config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `config`, a oneof with full ID .google.bigtable.admin.v2.Cluster.cluster_config, latest field was clusterConfig",
                                ));
                            }
                            result.config = std::option::Option::Some(
                                crate::model::cluster::Config::ClusterConfig(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::cluster::ClusterConfig>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__default_storage_type => {
                            if !fields.insert(__FieldTag::__default_storage_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_storage_type",
                                ));
                            }
                            result.default_storage_type = map
                                .next_value::<std::option::Option<crate::model::StorageType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_config => {
                            if !fields.insert(__FieldTag::__encryption_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_config",
                                ));
                            }
                            result.encryption_config = map.next_value::<std::option::Option<crate::model::cluster::EncryptionConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !wkt::internal::is_default(&self.serve_nodes) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("serveNodes", &__With(&self.serve_nodes))?;
        }
        if !wkt::internal::is_default(&self.node_scaling_factor) {
            state.serialize_entry("nodeScalingFactor", &self.node_scaling_factor)?;
        }
        if let Some(value) = self.cluster_config() {
            state.serialize_entry("clusterConfig", value)?;
        }
        if !wkt::internal::is_default(&self.default_storage_type) {
            state.serialize_entry("defaultStorageType", &self.default_storage_type)?;
        }
        if self.encryption_config.is_some() {
            state.serialize_entry("encryptionConfig", &self.encryption_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Cluster].
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Autoscaling config for a cluster.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClusterAutoscalingConfig {
        /// Required. Autoscaling limits for this cluster.
        pub autoscaling_limits: std::option::Option<crate::model::AutoscalingLimits>,

        /// Required. Autoscaling targets for this cluster.
        pub autoscaling_targets: std::option::Option<crate::model::AutoscalingTargets>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClusterAutoscalingConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [autoscaling_limits][crate::model::cluster::ClusterAutoscalingConfig::autoscaling_limits].
        pub fn set_autoscaling_limits<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AutoscalingLimits>,
        {
            self.autoscaling_limits = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [autoscaling_limits][crate::model::cluster::ClusterAutoscalingConfig::autoscaling_limits].
        pub fn set_or_clear_autoscaling_limits<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AutoscalingLimits>,
        {
            self.autoscaling_limits = v.map(|x| x.into());
            self
        }

        /// Sets the value of [autoscaling_targets][crate::model::cluster::ClusterAutoscalingConfig::autoscaling_targets].
        pub fn set_autoscaling_targets<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AutoscalingTargets>,
        {
            self.autoscaling_targets = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [autoscaling_targets][crate::model::cluster::ClusterAutoscalingConfig::autoscaling_targets].
        pub fn set_or_clear_autoscaling_targets<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AutoscalingTargets>,
        {
            self.autoscaling_targets = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ClusterAutoscalingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Cluster.ClusterAutoscalingConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClusterAutoscalingConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __autoscaling_limits,
                __autoscaling_targets,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClusterAutoscalingConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "autoscalingLimits" => Ok(__FieldTag::__autoscaling_limits),
                                "autoscaling_limits" => Ok(__FieldTag::__autoscaling_limits),
                                "autoscalingTargets" => Ok(__FieldTag::__autoscaling_targets),
                                "autoscaling_targets" => Ok(__FieldTag::__autoscaling_targets),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClusterAutoscalingConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClusterAutoscalingConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__autoscaling_limits => {
                                if !fields.insert(__FieldTag::__autoscaling_limits) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for autoscaling_limits",
                                    ));
                                }
                                result.autoscaling_limits = map.next_value::<std::option::Option<crate::model::AutoscalingLimits>>()?
                                    ;
                            }
                            __FieldTag::__autoscaling_targets => {
                                if !fields.insert(__FieldTag::__autoscaling_targets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for autoscaling_targets",
                                    ));
                                }
                                result.autoscaling_targets = map.next_value::<std::option::Option<crate::model::AutoscalingTargets>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClusterAutoscalingConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.autoscaling_limits.is_some() {
                state.serialize_entry("autoscalingLimits", &self.autoscaling_limits)?;
            }
            if self.autoscaling_targets.is_some() {
                state.serialize_entry("autoscalingTargets", &self.autoscaling_targets)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Configuration for a cluster.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClusterConfig {
        /// Autoscaling configuration for this cluster.
        pub cluster_autoscaling_config:
            std::option::Option<crate::model::cluster::ClusterAutoscalingConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClusterConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cluster_autoscaling_config][crate::model::cluster::ClusterConfig::cluster_autoscaling_config].
        pub fn set_cluster_autoscaling_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::cluster::ClusterAutoscalingConfig>,
        {
            self.cluster_autoscaling_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [cluster_autoscaling_config][crate::model::cluster::ClusterConfig::cluster_autoscaling_config].
        pub fn set_or_clear_cluster_autoscaling_config<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<crate::model::cluster::ClusterAutoscalingConfig>,
        {
            self.cluster_autoscaling_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ClusterConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Cluster.ClusterConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClusterConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cluster_autoscaling_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClusterConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "clusterAutoscalingConfig" => {
                                    Ok(__FieldTag::__cluster_autoscaling_config)
                                }
                                "cluster_autoscaling_config" => {
                                    Ok(__FieldTag::__cluster_autoscaling_config)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClusterConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClusterConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cluster_autoscaling_config => {
                                if !fields.insert(__FieldTag::__cluster_autoscaling_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_autoscaling_config",
                                    ));
                                }
                                result.cluster_autoscaling_config = map
                                    .next_value::<std::option::Option<
                                        crate::model::cluster::ClusterAutoscalingConfig,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClusterConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.cluster_autoscaling_config.is_some() {
                state.serialize_entry(
                    "clusterAutoscalingConfig",
                    &self.cluster_autoscaling_config,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Cloud Key Management Service (Cloud KMS) settings for a CMEK-protected
    /// cluster.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EncryptionConfig {
        /// Describes the Cloud KMS encryption key that will be used to protect the
        /// destination Bigtable cluster. The requirements for this key are:
        ///
        /// 1. The Cloud Bigtable service account associated with the project that
        ///    contains this cluster must be granted the
        ///    `cloudkms.cryptoKeyEncrypterDecrypter` role on the CMEK key.
        /// 1. Only regional keys can be used and the region of the CMEK key must
        ///    match the region of the cluster.
        ///    Values are of the form
        ///    `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}`
        pub kms_key_name: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EncryptionConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key_name][crate::model::cluster::EncryptionConfig::kms_key_name].
        pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_name = v.into();
            self
        }
    }

    impl wkt::message::Message for EncryptionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Cluster.EncryptionConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EncryptionConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __kms_key_name,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EncryptionConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                                "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EncryptionConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EncryptionConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__kms_key_name => {
                                if !fields.insert(__FieldTag::__kms_key_name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key_name",
                                    ));
                                }
                                result.kms_key_name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EncryptionConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.kms_key_name.is_empty() {
                state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Possible states of a cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the cluster could not be determined.
        NotKnown,
        /// The cluster has been successfully created and is ready to serve requests.
        Ready,
        /// The cluster is currently being created, and may be destroyed
        /// if the creation process encounters an error.
        /// A cluster may not be able to serve requests while being created.
        Creating,
        /// The cluster is currently being resized, and may revert to its previous
        /// node count if the process encounters an error.
        /// A cluster is still capable of serving requests while being resized,
        /// but may exhibit performance as if its number of allocated nodes is
        /// between the starting and requested states.
        Resizing,
        /// The cluster has no backing nodes. The data (tables) still
        /// exist, but no operations can be performed on the cluster.
        Disabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::NotKnown => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Resizing => std::option::Option::Some(3),
                Self::Disabled => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::NotKnown => std::option::Option::Some("STATE_NOT_KNOWN"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Resizing => std::option::Option::Some("RESIZING"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::NotKnown,
                1 => Self::Ready,
                2 => Self::Creating,
                3 => Self::Resizing,
                4 => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_NOT_KNOWN" => Self::NotKnown,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                "RESIZING" => Self::Resizing,
                "DISABLED" => Self::Disabled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::NotKnown => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::Resizing => serializer.serialize_i32(3),
                Self::Disabled => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.bigtable.admin.v2.Cluster.State",
            ))
        }
    }

    /// Possible node scaling factors of the clusters. Node scaling delivers better
    /// latency and more throughput by removing node boundaries.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NodeScalingFactor {
        /// No node scaling specified. Defaults to NODE_SCALING_FACTOR_1X.
        Unspecified,
        /// The cluster is running with a scaling factor of 1.
        NodeScalingFactor1X,
        /// The cluster is running with a scaling factor of 2.
        /// All node count values must be in increments of 2 with this scaling factor
        /// enabled, otherwise an INVALID_ARGUMENT error will be returned.
        NodeScalingFactor2X,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NodeScalingFactor::value] or
        /// [NodeScalingFactor::name].
        UnknownValue(node_scaling_factor::UnknownValue),
    }

    #[doc(hidden)]
    pub mod node_scaling_factor {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NodeScalingFactor {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NodeScalingFactor1X => std::option::Option::Some(1),
                Self::NodeScalingFactor2X => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NODE_SCALING_FACTOR_UNSPECIFIED"),
                Self::NodeScalingFactor1X => std::option::Option::Some("NODE_SCALING_FACTOR_1X"),
                Self::NodeScalingFactor2X => std::option::Option::Some("NODE_SCALING_FACTOR_2X"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NodeScalingFactor {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NodeScalingFactor {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NodeScalingFactor {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NodeScalingFactor1X,
                2 => Self::NodeScalingFactor2X,
                _ => Self::UnknownValue(node_scaling_factor::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NodeScalingFactor {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NODE_SCALING_FACTOR_UNSPECIFIED" => Self::Unspecified,
                "NODE_SCALING_FACTOR_1X" => Self::NodeScalingFactor1X,
                "NODE_SCALING_FACTOR_2X" => Self::NodeScalingFactor2X,
                _ => Self::UnknownValue(node_scaling_factor::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NodeScalingFactor {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NodeScalingFactor1X => serializer.serialize_i32(1),
                Self::NodeScalingFactor2X => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NodeScalingFactor {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NodeScalingFactor>::new(
                ".google.bigtable.admin.v2.Cluster.NodeScalingFactor",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Config {
        /// Configuration for this cluster.
        ClusterConfig(std::boxed::Box<crate::model::cluster::ClusterConfig>),
    }
}

/// A configuration object describing how Cloud Bigtable should treat traffic
/// from a particular end user application.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AppProfile {
    /// The unique name of the app profile. Values are of the form
    /// `projects/{project}/instances/{instance}/appProfiles/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
    pub name: std::string::String,

    /// Strongly validated etag for optimistic concurrency control. Preserve the
    /// value returned from `GetAppProfile` when calling `UpdateAppProfile` to
    /// fail the request if there has been a modification in the mean time. The
    /// `update_mask` of the request need not include `etag` for this protection
    /// to apply.
    /// See [Wikipedia](https://en.wikipedia.org/wiki/HTTP_ETag) and
    /// [RFC 7232](https://tools.ietf.org/html/rfc7232#section-2.3) for more
    /// details.
    pub etag: std::string::String,

    /// Long form description of the use case for this AppProfile.
    pub description: std::string::String,

    /// The routing policy for all read/write requests that use this app profile.
    /// A value must be explicitly set.
    pub routing_policy: std::option::Option<crate::model::app_profile::RoutingPolicy>,

    /// Options for isolating this app profile's traffic from other use cases.
    pub isolation: std::option::Option<crate::model::app_profile::Isolation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppProfile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AppProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AppProfile::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AppProfile::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [routing_policy][crate::model::AppProfile::routing_policy].
    ///
    /// Note that all the setters affecting `routing_policy` are mutually
    /// exclusive.
    pub fn set_routing_policy<
        T: std::convert::Into<std::option::Option<crate::model::app_profile::RoutingPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.routing_policy = v.into();
        self
    }

    /// The value of [routing_policy][crate::model::AppProfile::routing_policy]
    /// if it holds a `MultiClusterRoutingUseAny`, `None` if the field is not set or
    /// holds a different branch.
    pub fn multi_cluster_routing_use_any(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::app_profile::MultiClusterRoutingUseAny>>
    {
        #[allow(unreachable_patterns)]
        self.routing_policy.as_ref().and_then(|v| match v {
            crate::model::app_profile::RoutingPolicy::MultiClusterRoutingUseAny(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [routing_policy][crate::model::AppProfile::routing_policy]
    /// to hold a `MultiClusterRoutingUseAny`.
    ///
    /// Note that all the setters affecting `routing_policy` are
    /// mutually exclusive.
    pub fn set_multi_cluster_routing_use_any<
        T: std::convert::Into<std::boxed::Box<crate::model::app_profile::MultiClusterRoutingUseAny>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.routing_policy = std::option::Option::Some(
            crate::model::app_profile::RoutingPolicy::MultiClusterRoutingUseAny(v.into()),
        );
        self
    }

    /// The value of [routing_policy][crate::model::AppProfile::routing_policy]
    /// if it holds a `SingleClusterRouting`, `None` if the field is not set or
    /// holds a different branch.
    pub fn single_cluster_routing(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::app_profile::SingleClusterRouting>>
    {
        #[allow(unreachable_patterns)]
        self.routing_policy.as_ref().and_then(|v| match v {
            crate::model::app_profile::RoutingPolicy::SingleClusterRouting(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [routing_policy][crate::model::AppProfile::routing_policy]
    /// to hold a `SingleClusterRouting`.
    ///
    /// Note that all the setters affecting `routing_policy` are
    /// mutually exclusive.
    pub fn set_single_cluster_routing<
        T: std::convert::Into<std::boxed::Box<crate::model::app_profile::SingleClusterRouting>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.routing_policy = std::option::Option::Some(
            crate::model::app_profile::RoutingPolicy::SingleClusterRouting(v.into()),
        );
        self
    }

    /// Sets the value of [isolation][crate::model::AppProfile::isolation].
    ///
    /// Note that all the setters affecting `isolation` are mutually
    /// exclusive.
    pub fn set_isolation<
        T: std::convert::Into<std::option::Option<crate::model::app_profile::Isolation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.isolation = v.into();
        self
    }

    /// The value of [isolation][crate::model::AppProfile::isolation]
    /// if it holds a `Priority`, `None` if the field is not set or
    /// holds a different branch.
    #[deprecated]
    pub fn priority(&self) -> std::option::Option<&crate::model::app_profile::Priority> {
        #[allow(unreachable_patterns)]
        self.isolation.as_ref().and_then(|v| match v {
            crate::model::app_profile::Isolation::Priority(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [isolation][crate::model::AppProfile::isolation]
    /// to hold a `Priority`.
    ///
    /// Note that all the setters affecting `isolation` are
    /// mutually exclusive.
    #[deprecated]
    pub fn set_priority<T: std::convert::Into<crate::model::app_profile::Priority>>(
        mut self,
        v: T,
    ) -> Self {
        self.isolation =
            std::option::Option::Some(crate::model::app_profile::Isolation::Priority(v.into()));
        self
    }

    /// The value of [isolation][crate::model::AppProfile::isolation]
    /// if it holds a `StandardIsolation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn standard_isolation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::app_profile::StandardIsolation>> {
        #[allow(unreachable_patterns)]
        self.isolation.as_ref().and_then(|v| match v {
            crate::model::app_profile::Isolation::StandardIsolation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [isolation][crate::model::AppProfile::isolation]
    /// to hold a `StandardIsolation`.
    ///
    /// Note that all the setters affecting `isolation` are
    /// mutually exclusive.
    pub fn set_standard_isolation<
        T: std::convert::Into<std::boxed::Box<crate::model::app_profile::StandardIsolation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.isolation = std::option::Option::Some(
            crate::model::app_profile::Isolation::StandardIsolation(v.into()),
        );
        self
    }

    /// The value of [isolation][crate::model::AppProfile::isolation]
    /// if it holds a `DataBoostIsolationReadOnly`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_boost_isolation_read_only(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::app_profile::DataBoostIsolationReadOnly>>
    {
        #[allow(unreachable_patterns)]
        self.isolation.as_ref().and_then(|v| match v {
            crate::model::app_profile::Isolation::DataBoostIsolationReadOnly(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [isolation][crate::model::AppProfile::isolation]
    /// to hold a `DataBoostIsolationReadOnly`.
    ///
    /// Note that all the setters affecting `isolation` are
    /// mutually exclusive.
    pub fn set_data_boost_isolation_read_only<
        T: std::convert::Into<std::boxed::Box<crate::model::app_profile::DataBoostIsolationReadOnly>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.isolation = std::option::Option::Some(
            crate::model::app_profile::Isolation::DataBoostIsolationReadOnly(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AppProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.AppProfile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppProfile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __etag,
            __description,
            __multi_cluster_routing_use_any,
            __single_cluster_routing,
            __priority,
            __standard_isolation,
            __data_boost_isolation_read_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppProfile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "etag" => Ok(__FieldTag::__etag),
                            "description" => Ok(__FieldTag::__description),
                            "multiClusterRoutingUseAny" => {
                                Ok(__FieldTag::__multi_cluster_routing_use_any)
                            }
                            "multi_cluster_routing_use_any" => {
                                Ok(__FieldTag::__multi_cluster_routing_use_any)
                            }
                            "singleClusterRouting" => Ok(__FieldTag::__single_cluster_routing),
                            "single_cluster_routing" => Ok(__FieldTag::__single_cluster_routing),
                            "priority" => Ok(__FieldTag::__priority),
                            "standardIsolation" => Ok(__FieldTag::__standard_isolation),
                            "standard_isolation" => Ok(__FieldTag::__standard_isolation),
                            "dataBoostIsolationReadOnly" => {
                                Ok(__FieldTag::__data_boost_isolation_read_only)
                            }
                            "data_boost_isolation_read_only" => {
                                Ok(__FieldTag::__data_boost_isolation_read_only)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppProfile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppProfile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__multi_cluster_routing_use_any => {
                            if !fields.insert(__FieldTag::__multi_cluster_routing_use_any) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_cluster_routing_use_any",
                                ));
                            }
                            if result.routing_policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `routing_policy`, a oneof with full ID .google.bigtable.admin.v2.AppProfile.multi_cluster_routing_use_any, latest field was multiClusterRoutingUseAny",
                                ));
                            }
                            result.routing_policy = std::option::Option::Some(
                                crate::model::app_profile::RoutingPolicy::MultiClusterRoutingUseAny(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::app_profile::MultiClusterRoutingUseAny,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__single_cluster_routing => {
                            if !fields.insert(__FieldTag::__single_cluster_routing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_cluster_routing",
                                ));
                            }
                            if result.routing_policy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `routing_policy`, a oneof with full ID .google.bigtable.admin.v2.AppProfile.single_cluster_routing, latest field was singleClusterRouting",
                                ));
                            }
                            result.routing_policy = std::option::Option::Some(
                                crate::model::app_profile::RoutingPolicy::SingleClusterRouting(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::app_profile::SingleClusterRouting,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__priority => {
                            if !fields.insert(__FieldTag::__priority) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for priority",
                                ));
                            }
                            if result.isolation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `isolation`, a oneof with full ID .google.bigtable.admin.v2.AppProfile.priority, latest field was priority",
                                ));
                            }
                            result.isolation =
                                std::option::Option::Some(
                                    crate::model::app_profile::Isolation::Priority(
                                        map.next_value::<std::option::Option<
                                            crate::model::app_profile::Priority,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__standard_isolation => {
                            if !fields.insert(__FieldTag::__standard_isolation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for standard_isolation",
                                ));
                            }
                            if result.isolation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `isolation`, a oneof with full ID .google.bigtable.admin.v2.AppProfile.standard_isolation, latest field was standardIsolation",
                                ));
                            }
                            result.isolation = std::option::Option::Some(
                                crate::model::app_profile::Isolation::StandardIsolation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::app_profile::StandardIsolation,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_boost_isolation_read_only => {
                            if !fields.insert(__FieldTag::__data_boost_isolation_read_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_boost_isolation_read_only",
                                ));
                            }
                            if result.isolation.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `isolation`, a oneof with full ID .google.bigtable.admin.v2.AppProfile.data_boost_isolation_read_only, latest field was dataBoostIsolationReadOnly",
                                ));
                            }
                            result.isolation = std::option::Option::Some(
                                crate::model::app_profile::Isolation::DataBoostIsolationReadOnly(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::app_profile::DataBoostIsolationReadOnly,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppProfile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if let Some(value) = self.multi_cluster_routing_use_any() {
            state.serialize_entry("multiClusterRoutingUseAny", value)?;
        }
        if let Some(value) = self.single_cluster_routing() {
            state.serialize_entry("singleClusterRouting", value)?;
        }
        if let Some(value) = self.priority() {
            state.serialize_entry("priority", value)?;
        }
        if let Some(value) = self.standard_isolation() {
            state.serialize_entry("standardIsolation", value)?;
        }
        if let Some(value) = self.data_boost_isolation_read_only() {
            state.serialize_entry("dataBoostIsolationReadOnly", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AppProfile].
pub mod app_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Read/write requests are routed to the nearest cluster in the instance, and
    /// will fail over to the nearest cluster that is available in the event of
    /// transient errors or delays. Clusters in a region are considered
    /// equidistant. Choosing this option sacrifices read-your-writes consistency
    /// to improve availability.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MultiClusterRoutingUseAny {
        /// The set of clusters to route to. The order is ignored; clusters will be
        /// tried in order of distance. If left empty, all clusters are eligible.
        pub cluster_ids: std::vec::Vec<std::string::String>,

        /// Possible algorithms for routing affinity. If enabled, Bigtable will
        /// route between equidistant clusters in a deterministic order rather than
        /// choosing randomly.
        ///
        /// This mechanism gives read-your-writes consistency for *most* requests
        /// under *most* circumstances, without sacrificing availability. Consistency
        /// is *not* guaranteed, as requests might still fail over between clusters
        /// in the event of errors or latency.
        pub affinity:
            std::option::Option<crate::model::app_profile::multi_cluster_routing_use_any::Affinity>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MultiClusterRoutingUseAny {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cluster_ids][crate::model::app_profile::MultiClusterRoutingUseAny::cluster_ids].
        pub fn set_cluster_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.cluster_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [affinity][crate::model::app_profile::MultiClusterRoutingUseAny::affinity].
        ///
        /// Note that all the setters affecting `affinity` are mutually
        /// exclusive.
        pub fn set_affinity<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::app_profile::multi_cluster_routing_use_any::Affinity,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.affinity = v.into();
            self
        }

        /// The value of [affinity][crate::model::app_profile::MultiClusterRoutingUseAny::affinity]
        /// if it holds a `RowAffinity`, `None` if the field is not set or
        /// holds a different branch.
        pub fn row_affinity(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::app_profile::multi_cluster_routing_use_any::RowAffinity>,
        > {
            #[allow(unreachable_patterns)]
            self.affinity.as_ref().and_then(|v| match v {
                crate::model::app_profile::multi_cluster_routing_use_any::Affinity::RowAffinity(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [affinity][crate::model::app_profile::MultiClusterRoutingUseAny::affinity]
        /// to hold a `RowAffinity`.
        ///
        /// Note that all the setters affecting `affinity` are
        /// mutually exclusive.
        pub fn set_row_affinity<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::app_profile::multi_cluster_routing_use_any::RowAffinity,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.affinity = std::option::Option::Some(
                crate::model::app_profile::multi_cluster_routing_use_any::Affinity::RowAffinity(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for MultiClusterRoutingUseAny {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AppProfile.MultiClusterRoutingUseAny"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MultiClusterRoutingUseAny {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cluster_ids,
                __row_affinity,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MultiClusterRoutingUseAny")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "clusterIds" => Ok(__FieldTag::__cluster_ids),
                                "cluster_ids" => Ok(__FieldTag::__cluster_ids),
                                "rowAffinity" => Ok(__FieldTag::__row_affinity),
                                "row_affinity" => Ok(__FieldTag::__row_affinity),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MultiClusterRoutingUseAny;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MultiClusterRoutingUseAny")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cluster_ids => {
                                if !fields.insert(__FieldTag::__cluster_ids) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_ids",
                                    ));
                                }
                                result.cluster_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__row_affinity => {
                                if !fields.insert(__FieldTag::__row_affinity) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for row_affinity",
                                    ));
                                }
                                if result.affinity.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `affinity`, a oneof with full ID .google.bigtable.admin.v2.AppProfile.MultiClusterRoutingUseAny.row_affinity, latest field was rowAffinity",
                                    ));
                                }
                                result.affinity = std::option::Option::Some(
                                    crate::model::app_profile::multi_cluster_routing_use_any::Affinity::RowAffinity(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::app_profile::multi_cluster_routing_use_any::RowAffinity>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MultiClusterRoutingUseAny {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cluster_ids.is_empty() {
                state.serialize_entry("clusterIds", &self.cluster_ids)?;
            }
            if let Some(value) = self.row_affinity() {
                state.serialize_entry("rowAffinity", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [MultiClusterRoutingUseAny].
    pub mod multi_cluster_routing_use_any {
        #[allow(unused_imports)]
        use super::*;

        /// If enabled, Bigtable will route the request based on the row key of the
        /// request, rather than randomly. Instead, each row key will be assigned
        /// to a cluster, and will stick to that cluster. If clusters are added or
        /// removed, then this may affect which row keys stick to which clusters.
        /// To avoid this, users can use a cluster group to specify which clusters
        /// are to be used. In this case, new clusters that are not a part of the
        /// cluster group will not be routed to, and routing will be unaffected by
        /// the new cluster. Moreover, clusters specified in the cluster group cannot
        /// be deleted unless removed from the cluster group.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct RowAffinity {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl RowAffinity {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for RowAffinity {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.AppProfile.MultiClusterRoutingUseAny.RowAffinity"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for RowAffinity {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for RowAffinity")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = RowAffinity;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct RowAffinity")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for RowAffinity {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Possible algorithms for routing affinity. If enabled, Bigtable will
        /// route between equidistant clusters in a deterministic order rather than
        /// choosing randomly.
        ///
        /// This mechanism gives read-your-writes consistency for *most* requests
        /// under *most* circumstances, without sacrificing availability. Consistency
        /// is *not* guaranteed, as requests might still fail over between clusters
        /// in the event of errors or latency.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Affinity {
            /// Row affinity sticky routing based on the row key of the request.
            /// Requests that span multiple rows are routed non-deterministically.
            RowAffinity(
                std::boxed::Box<
                    crate::model::app_profile::multi_cluster_routing_use_any::RowAffinity,
                >,
            ),
        }
    }

    /// Unconditionally routes all read/write requests to a specific cluster.
    /// This option preserves read-your-writes consistency but does not improve
    /// availability.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SingleClusterRouting {
        /// The cluster to which read/write requests should be routed.
        pub cluster_id: std::string::String,

        /// Whether or not `CheckAndMutateRow` and `ReadModifyWriteRow` requests are
        /// allowed by this app profile. It is unsafe to send these requests to
        /// the same table/row/column in multiple clusters.
        pub allow_transactional_writes: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SingleClusterRouting {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cluster_id][crate::model::app_profile::SingleClusterRouting::cluster_id].
        pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cluster_id = v.into();
            self
        }

        /// Sets the value of [allow_transactional_writes][crate::model::app_profile::SingleClusterRouting::allow_transactional_writes].
        pub fn set_allow_transactional_writes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_transactional_writes = v.into();
            self
        }
    }

    impl wkt::message::Message for SingleClusterRouting {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AppProfile.SingleClusterRouting"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SingleClusterRouting {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cluster_id,
                __allow_transactional_writes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SingleClusterRouting")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "clusterId" => Ok(__FieldTag::__cluster_id),
                                "cluster_id" => Ok(__FieldTag::__cluster_id),
                                "allowTransactionalWrites" => {
                                    Ok(__FieldTag::__allow_transactional_writes)
                                }
                                "allow_transactional_writes" => {
                                    Ok(__FieldTag::__allow_transactional_writes)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SingleClusterRouting;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SingleClusterRouting")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cluster_id => {
                                if !fields.insert(__FieldTag::__cluster_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_id",
                                    ));
                                }
                                result.cluster_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allow_transactional_writes => {
                                if !fields.insert(__FieldTag::__allow_transactional_writes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allow_transactional_writes",
                                    ));
                                }
                                result.allow_transactional_writes = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SingleClusterRouting {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cluster_id.is_empty() {
                state.serialize_entry("clusterId", &self.cluster_id)?;
            }
            if !wkt::internal::is_default(&self.allow_transactional_writes) {
                state.serialize_entry(
                    "allowTransactionalWrites",
                    &self.allow_transactional_writes,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Standard options for isolating this app profile's traffic from other use
    /// cases.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StandardIsolation {
        /// The priority of requests sent using this app profile.
        pub priority: crate::model::app_profile::Priority,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StandardIsolation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [priority][crate::model::app_profile::StandardIsolation::priority].
        pub fn set_priority<T: std::convert::Into<crate::model::app_profile::Priority>>(
            mut self,
            v: T,
        ) -> Self {
            self.priority = v.into();
            self
        }
    }

    impl wkt::message::Message for StandardIsolation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AppProfile.StandardIsolation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StandardIsolation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __priority,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StandardIsolation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "priority" => Ok(__FieldTag::__priority),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StandardIsolation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StandardIsolation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__priority => {
                                if !fields.insert(__FieldTag::__priority) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for priority",
                                    ));
                                }
                                result.priority = map.next_value::<std::option::Option<crate::model::app_profile::Priority>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StandardIsolation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.priority) {
                state.serialize_entry("priority", &self.priority)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Data Boost is a serverless compute capability that lets you run
    /// high-throughput read jobs and queries on your Bigtable data, without
    /// impacting the performance of the clusters that handle your application
    /// traffic. Data Boost supports read-only use cases with single-cluster
    /// routing.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DataBoostIsolationReadOnly {
        /// The Compute Billing Owner for this Data Boost App Profile.
        pub compute_billing_owner: std::option::Option<
            crate::model::app_profile::data_boost_isolation_read_only::ComputeBillingOwner,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataBoostIsolationReadOnly {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [compute_billing_owner][crate::model::app_profile::DataBoostIsolationReadOnly::compute_billing_owner].
        pub fn set_compute_billing_owner<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::app_profile::data_boost_isolation_read_only::ComputeBillingOwner,
                >,
        {
            self.compute_billing_owner = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [compute_billing_owner][crate::model::app_profile::DataBoostIsolationReadOnly::compute_billing_owner].
        pub fn set_or_clear_compute_billing_owner<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::app_profile::data_boost_isolation_read_only::ComputeBillingOwner,
                >,
        {
            self.compute_billing_owner = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for DataBoostIsolationReadOnly {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AppProfile.DataBoostIsolationReadOnly"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DataBoostIsolationReadOnly {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __compute_billing_owner,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DataBoostIsolationReadOnly")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "computeBillingOwner" => Ok(__FieldTag::__compute_billing_owner),
                                "compute_billing_owner" => Ok(__FieldTag::__compute_billing_owner),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DataBoostIsolationReadOnly;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DataBoostIsolationReadOnly")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__compute_billing_owner => {
                                if !fields.insert(__FieldTag::__compute_billing_owner) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for compute_billing_owner",
                                    ));
                                }
                                result.compute_billing_owner = map.next_value::<std::option::Option<crate::model::app_profile::data_boost_isolation_read_only::ComputeBillingOwner>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DataBoostIsolationReadOnly {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.compute_billing_owner.is_some() {
                state.serialize_entry("computeBillingOwner", &self.compute_billing_owner)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [DataBoostIsolationReadOnly].
    pub mod data_boost_isolation_read_only {
        #[allow(unused_imports)]
        use super::*;

        /// Compute Billing Owner specifies how usage should be accounted when using
        /// Data Boost. Compute Billing Owner also configures which Cloud Project is
        /// charged for relevant quota.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ComputeBillingOwner {
            /// Unspecified value.
            Unspecified,
            /// The host Cloud Project containing the targeted Bigtable Instance /
            /// Table pays for compute.
            HostPays,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ComputeBillingOwner::value] or
            /// [ComputeBillingOwner::name].
            UnknownValue(compute_billing_owner::UnknownValue),
        }

        #[doc(hidden)]
        pub mod compute_billing_owner {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ComputeBillingOwner {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::HostPays => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("COMPUTE_BILLING_OWNER_UNSPECIFIED")
                    }
                    Self::HostPays => std::option::Option::Some("HOST_PAYS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ComputeBillingOwner {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ComputeBillingOwner {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ComputeBillingOwner {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::HostPays,
                    _ => Self::UnknownValue(compute_billing_owner::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ComputeBillingOwner {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "COMPUTE_BILLING_OWNER_UNSPECIFIED" => Self::Unspecified,
                    "HOST_PAYS" => Self::HostPays,
                    _ => Self::UnknownValue(compute_billing_owner::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ComputeBillingOwner {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::HostPays => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ComputeBillingOwner {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeBillingOwner>::new(
                    ".google.bigtable.admin.v2.AppProfile.DataBoostIsolationReadOnly.ComputeBillingOwner"))
            }
        }
    }

    /// Possible priorities for an app profile. Note that higher priority writes
    /// can sometimes queue behind lower priority writes to the same tablet, as
    /// writes must be strictly sequenced in the durability log.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Priority {
        /// Default value. Mapped to PRIORITY_HIGH (the legacy behavior) on creation.
        Unspecified,
        Low,
        Medium,
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Priority::value] or
        /// [Priority::name].
        UnknownValue(priority::UnknownValue),
    }

    #[doc(hidden)]
    pub mod priority {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Priority {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Low => std::option::Option::Some(1),
                Self::Medium => std::option::Option::Some(2),
                Self::High => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PRIORITY_UNSPECIFIED"),
                Self::Low => std::option::Option::Some("PRIORITY_LOW"),
                Self::Medium => std::option::Option::Some("PRIORITY_MEDIUM"),
                Self::High => std::option::Option::Some("PRIORITY_HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Priority {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Priority {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Priority {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Low,
                2 => Self::Medium,
                3 => Self::High,
                _ => Self::UnknownValue(priority::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Priority {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PRIORITY_UNSPECIFIED" => Self::Unspecified,
                "PRIORITY_LOW" => Self::Low,
                "PRIORITY_MEDIUM" => Self::Medium,
                "PRIORITY_HIGH" => Self::High,
                _ => Self::UnknownValue(priority::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Priority {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Low => serializer.serialize_i32(1),
                Self::Medium => serializer.serialize_i32(2),
                Self::High => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Priority {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Priority>::new(
                ".google.bigtable.admin.v2.AppProfile.Priority",
            ))
        }
    }

    /// The routing policy for all read/write requests that use this app profile.
    /// A value must be explicitly set.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RoutingPolicy {
        /// Use a multi-cluster routing policy.
        MultiClusterRoutingUseAny(
            std::boxed::Box<crate::model::app_profile::MultiClusterRoutingUseAny>,
        ),
        /// Use a single-cluster routing policy.
        SingleClusterRouting(std::boxed::Box<crate::model::app_profile::SingleClusterRouting>),
    }

    /// Options for isolating this app profile's traffic from other use cases.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Isolation {
        /// This field has been deprecated in favor of `standard_isolation.priority`.
        /// If you set this field, `standard_isolation.priority` will be set instead.
        ///
        /// The priority of requests sent using this app profile.
        #[deprecated]
        Priority(crate::model::app_profile::Priority),
        /// The standard options used for isolating this app profile's traffic from
        /// other use cases.
        StandardIsolation(std::boxed::Box<crate::model::app_profile::StandardIsolation>),
        /// Specifies that this app profile is intended for read-only usage via the
        /// Data Boost feature.
        DataBoostIsolationReadOnly(
            std::boxed::Box<crate::model::app_profile::DataBoostIsolationReadOnly>,
        ),
    }
}

/// A tablet is a defined by a start and end key and is explained in
/// <https://cloud.google.com/bigtable/docs/overview#architecture> and
/// <https://cloud.google.com/bigtable/docs/performance#optimization>.
/// A Hot tablet is a tablet that exhibits high average cpu usage during the time
/// interval from start time to end time.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HotTablet {
    /// The unique name of the hot tablet. Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/hotTablets/[a-zA-Z0-9_-]*`.
    pub name: std::string::String,

    /// Name of the table that contains the tablet. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
    pub table_name: std::string::String,

    /// Output only. The start time of the hot tablet.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The end time of the hot tablet.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Tablet Start Key (inclusive).
    pub start_key: std::string::String,

    /// Tablet End Key (inclusive).
    pub end_key: std::string::String,

    /// Output only. The average CPU usage spent by a node on this tablet over the
    /// start_time to end_time time range. The percentage is the amount of CPU used
    /// by the node to serve the tablet, from 0% (tablet was not interacted with)
    /// to 100% (the node spent all cycles serving the hot tablet).
    pub node_cpu_usage_percent: f32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HotTablet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::HotTablet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [table_name][crate::model::HotTablet::table_name].
    pub fn set_table_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::HotTablet::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::HotTablet::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::HotTablet::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::HotTablet::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_key][crate::model::HotTablet::start_key].
    pub fn set_start_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_key = v.into();
        self
    }

    /// Sets the value of [end_key][crate::model::HotTablet::end_key].
    pub fn set_end_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.end_key = v.into();
        self
    }

    /// Sets the value of [node_cpu_usage_percent][crate::model::HotTablet::node_cpu_usage_percent].
    pub fn set_node_cpu_usage_percent<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.node_cpu_usage_percent = v.into();
        self
    }
}

impl wkt::message::Message for HotTablet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.HotTablet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HotTablet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __table_name,
            __start_time,
            __end_time,
            __start_key,
            __end_key,
            __node_cpu_usage_percent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HotTablet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "tableName" => Ok(__FieldTag::__table_name),
                            "table_name" => Ok(__FieldTag::__table_name),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "startKey" => Ok(__FieldTag::__start_key),
                            "start_key" => Ok(__FieldTag::__start_key),
                            "endKey" => Ok(__FieldTag::__end_key),
                            "end_key" => Ok(__FieldTag::__end_key),
                            "nodeCpuUsagePercent" => Ok(__FieldTag::__node_cpu_usage_percent),
                            "node_cpu_usage_percent" => Ok(__FieldTag::__node_cpu_usage_percent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HotTablet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HotTablet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_name => {
                            if !fields.insert(__FieldTag::__table_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_name",
                                ));
                            }
                            result.table_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_key => {
                            if !fields.insert(__FieldTag::__start_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_key",
                                ));
                            }
                            result.start_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__end_key => {
                            if !fields.insert(__FieldTag::__end_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_key",
                                ));
                            }
                            result.end_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_cpu_usage_percent => {
                            if !fields.insert(__FieldTag::__node_cpu_usage_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_cpu_usage_percent",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.node_cpu_usage_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HotTablet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.table_name.is_empty() {
            state.serialize_entry("tableName", &self.table_name)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.start_key.is_empty() {
            state.serialize_entry("startKey", &self.start_key)?;
        }
        if !self.end_key.is_empty() {
            state.serialize_entry("endKey", &self.end_key)?;
        }
        if !wkt::internal::is_default(&self.node_cpu_usage_percent) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nodeCpuUsagePercent", &__With(&self.node_cpu_usage_percent))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A SQL logical view object that can be referenced in SQL queries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogicalView {
    /// Identifier. The unique name of the logical view.
    /// Format:
    /// `projects/{project}/instances/{instance}/logicalViews/{logical_view}`
    pub name: std::string::String,

    /// Required. The logical view's select query.
    pub query: std::string::String,

    /// Optional. The etag for this logical view.
    /// This may be sent on update requests to ensure that the client has an
    /// up-to-date value before proceeding. The server returns an ABORTED error on
    /// a mismatched etag.
    pub etag: std::string::String,

    /// Optional. Set to true to make the LogicalView protected against deletion.
    pub deletion_protection: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogicalView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogicalView::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [query][crate::model::LogicalView::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::LogicalView::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [deletion_protection][crate::model::LogicalView::deletion_protection].
    pub fn set_deletion_protection<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deletion_protection = v.into();
        self
    }
}

impl wkt::message::Message for LogicalView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.LogicalView"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogicalView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __query,
            __etag,
            __deletion_protection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogicalView")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "query" => Ok(__FieldTag::__query),
                            "etag" => Ok(__FieldTag::__etag),
                            "deletionProtection" => Ok(__FieldTag::__deletion_protection),
                            "deletion_protection" => Ok(__FieldTag::__deletion_protection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogicalView;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogicalView")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deletion_protection => {
                            if !fields.insert(__FieldTag::__deletion_protection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_protection",
                                ));
                            }
                            result.deletion_protection = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogicalView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.deletion_protection) {
            state.serialize_entry("deletionProtection", &self.deletion_protection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A materialized view object that can be referenced in SQL queries.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MaterializedView {
    /// Identifier. The unique name of the materialized view.
    /// Format:
    /// `projects/{project}/instances/{instance}/materializedViews/{materialized_view}`
    pub name: std::string::String,

    /// Required. Immutable. The materialized view's select query.
    pub query: std::string::String,

    /// Optional. The etag for this materialized view.
    /// This may be sent on update requests to ensure that the client has an
    /// up-to-date value before proceeding. The server returns an ABORTED error on
    /// a mismatched etag.
    pub etag: std::string::String,

    /// Set to true to make the MaterializedView protected against deletion.
    pub deletion_protection: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaterializedView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MaterializedView::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [query][crate::model::MaterializedView::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::MaterializedView::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [deletion_protection][crate::model::MaterializedView::deletion_protection].
    pub fn set_deletion_protection<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deletion_protection = v.into();
        self
    }
}

impl wkt::message::Message for MaterializedView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.MaterializedView"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaterializedView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __query,
            __etag,
            __deletion_protection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaterializedView")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "query" => Ok(__FieldTag::__query),
                            "etag" => Ok(__FieldTag::__etag),
                            "deletionProtection" => Ok(__FieldTag::__deletion_protection),
                            "deletion_protection" => Ok(__FieldTag::__deletion_protection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaterializedView;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaterializedView")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deletion_protection => {
                            if !fields.insert(__FieldTag::__deletion_protection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_protection",
                                ));
                            }
                            result.deletion_protection = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaterializedView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.deletion_protection) {
            state.serialize_entry("deletionProtection", &self.deletion_protection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Information about a table restore.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestoreInfo {
    /// The type of the restore source.
    pub source_type: crate::model::RestoreSourceType,

    /// Information about the source used to restore the table.
    pub source_info: std::option::Option<crate::model::restore_info::SourceInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestoreInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_type][crate::model::RestoreInfo::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::RestoreSourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [source_info][crate::model::RestoreInfo::source_info].
    ///
    /// Note that all the setters affecting `source_info` are mutually
    /// exclusive.
    pub fn set_source_info<
        T: std::convert::Into<std::option::Option<crate::model::restore_info::SourceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_info = v.into();
        self
    }

    /// The value of [source_info][crate::model::RestoreInfo::source_info]
    /// if it holds a `BackupInfo`, `None` if the field is not set or
    /// holds a different branch.
    pub fn backup_info(&self) -> std::option::Option<&std::boxed::Box<crate::model::BackupInfo>> {
        #[allow(unreachable_patterns)]
        self.source_info.as_ref().and_then(|v| match v {
            crate::model::restore_info::SourceInfo::BackupInfo(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_info][crate::model::RestoreInfo::source_info]
    /// to hold a `BackupInfo`.
    ///
    /// Note that all the setters affecting `source_info` are
    /// mutually exclusive.
    pub fn set_backup_info<T: std::convert::Into<std::boxed::Box<crate::model::BackupInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_info =
            std::option::Option::Some(crate::model::restore_info::SourceInfo::BackupInfo(v.into()));
        self
    }
}

impl wkt::message::Message for RestoreInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.RestoreInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestoreInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_type,
            __backup_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestoreInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceType" => Ok(__FieldTag::__source_type),
                            "source_type" => Ok(__FieldTag::__source_type),
                            "backupInfo" => Ok(__FieldTag::__backup_info),
                            "backup_info" => Ok(__FieldTag::__backup_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestoreInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestoreInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_type => {
                            if !fields.insert(__FieldTag::__source_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_type",
                                ));
                            }
                            result.source_type = map
                                .next_value::<std::option::Option<crate::model::RestoreSourceType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_info => {
                            if !fields.insert(__FieldTag::__backup_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_info",
                                ));
                            }
                            if result.source_info.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_info`, a oneof with full ID .google.bigtable.admin.v2.RestoreInfo.backup_info, latest field was backupInfo",
                                ));
                            }
                            result.source_info = std::option::Option::Some(
                                crate::model::restore_info::SourceInfo::BackupInfo(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BackupInfo>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestoreInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.source_type) {
            state.serialize_entry("sourceType", &self.source_type)?;
        }
        if let Some(value) = self.backup_info() {
            state.serialize_entry("backupInfo", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestoreInfo].
pub mod restore_info {
    #[allow(unused_imports)]
    use super::*;

    /// Information about the source used to restore the table.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceInfo {
        /// Information about the backup used to restore the table. The backup
        /// may no longer exist.
        BackupInfo(std::boxed::Box<crate::model::BackupInfo>),
    }
}

/// Change stream configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ChangeStreamConfig {
    /// How long the change stream should be retained. Change stream data older
    /// than the retention period will not be returned when reading the change
    /// stream from the table.
    /// Values must be at least 1 day and at most 7 days, and will be truncated to
    /// microsecond granularity.
    pub retention_period: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChangeStreamConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retention_period][crate::model::ChangeStreamConfig::retention_period].
    pub fn set_retention_period<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention_period = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retention_period][crate::model::ChangeStreamConfig::retention_period].
    pub fn set_or_clear_retention_period<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention_period = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ChangeStreamConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ChangeStreamConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ChangeStreamConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __retention_period,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ChangeStreamConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "retentionPeriod" => Ok(__FieldTag::__retention_period),
                            "retention_period" => Ok(__FieldTag::__retention_period),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ChangeStreamConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ChangeStreamConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__retention_period => {
                            if !fields.insert(__FieldTag::__retention_period) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention_period",
                                ));
                            }
                            result.retention_period =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ChangeStreamConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.retention_period.is_some() {
            state.serialize_entry("retentionPeriod", &self.retention_period)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A collection of user data indexed by row, column, and timestamp.
/// Each table is served using the resources of its parent cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Table {
    /// The unique name of the table. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
    /// Views: `NAME_ONLY`, `SCHEMA_VIEW`, `REPLICATION_VIEW`, `FULL`
    pub name: std::string::String,

    /// Output only. Map from cluster ID to per-cluster table state.
    /// If it could not be determined whether or not the table has data in a
    /// particular cluster (for example, if its zone is unavailable), then
    /// there will be an entry for the cluster with UNKNOWN `replication_status`.
    /// Views: `REPLICATION_VIEW`, `ENCRYPTION_VIEW`, `FULL`
    pub cluster_states:
        std::collections::HashMap<std::string::String, crate::model::table::ClusterState>,

    /// The column families configured for this table, mapped by column family ID.
    /// Views: `SCHEMA_VIEW`, `STATS_VIEW`, `FULL`
    pub column_families: std::collections::HashMap<std::string::String, crate::model::ColumnFamily>,

    /// Immutable. The granularity (i.e. `MILLIS`) at which timestamps are stored
    /// in this table. Timestamps not matching the granularity will be rejected. If
    /// unspecified at creation time, the value will be set to `MILLIS`. Views:
    /// `SCHEMA_VIEW`, `FULL`.
    pub granularity: crate::model::table::TimestampGranularity,

    /// Output only. If this table was restored from another data source (e.g. a
    /// backup), this field will be populated with information about the restore.
    pub restore_info: std::option::Option<crate::model::RestoreInfo>,

    /// If specified, enable the change stream on this table.
    /// Otherwise, the change stream is disabled and the change stream is not
    /// retained.
    pub change_stream_config: std::option::Option<crate::model::ChangeStreamConfig>,

    /// Set to true to make the table protected against data loss. i.e. deleting
    /// the following resources through Admin APIs are prohibited:
    ///
    /// * The table.
    /// * The column families in the table.
    /// * The instance containing the table.
    ///
    /// Note one can still delete the data stored in the table through Data APIs.
    pub deletion_protection: bool,

    /// The row key schema for this table. The schema is used to decode the raw row
    /// key bytes into a structured format. The order of field declarations in this
    /// schema is important, as it reflects how the raw row key bytes are
    /// structured. Currently, this only affects how the key is read via a
    /// GoogleSQL query from the ExecuteQuery API.
    ///
    /// For a SQL query, the _key column is still read as raw bytes. But queries
    /// can reference the key fields by name, which will be decoded from _key using
    /// provided type and encoding. Queries that reference key fields will fail if
    /// they encounter an invalid row key.
    ///
    /// For example, if _key = "some_id#2024-04-30#\x00\x13\x00\xf3" with the
    /// following schema:
    /// {
    /// fields {
    /// field_name: "id"
    /// type { string { encoding: utf8_bytes {} } }
    /// }
    /// fields {
    /// field_name: "date"
    /// type { string { encoding: utf8_bytes {} } }
    /// }
    /// fields {
    /// field_name: "product_code"
    /// type { int64 { encoding: big_endian_bytes {} } }
    /// }
    /// encoding { delimited_bytes { delimiter: "#" } }
    /// }
    ///
    /// The decoded key parts would be:
    /// id = "some_id", date = "2024-04-30", product_code = 1245427
    /// The query "SELECT _key, product_code FROM table" will return two columns:
    /// /------------------------------------------------------\
    /// |              _key                     | product_code |
    /// | --------------------------------------|--------------|
    /// | "some_id#2024-04-30#\x00\x13\x00\xf3" |   1245427    |
    /// \------------------------------------------------------/
    ///
    /// The schema has the following invariants:
    /// (1) The decoded field values are order-preserved. For read, the field
    /// values will be decoded in sorted mode from the raw bytes.
    /// (2) Every field in the schema must specify a non-empty name.
    /// (3) Every field must specify a type with an associated encoding. The type
    /// is limited to scalar types only: Array, Map, Aggregate, and Struct are not
    /// allowed.
    /// (4) The field names must not collide with existing column family
    /// names and reserved keywords "_key" and "_timestamp".
    ///
    /// The following update operations are allowed for row_key_schema:
    ///
    /// - Update from an empty schema to a new schema.
    /// - Remove the existing schema. This operation requires setting the
    ///   `ignore_warnings` flag to `true`, since it might be a backward
    ///   incompatible change. Without the flag, the update request will fail with
    ///   an INVALID_ARGUMENT error.
    ///   Any other row key schema update operation (e.g. update existing schema
    ///   columns names or types) is currently unsupported.
    pub row_key_schema: std::option::Option<crate::model::r#type::Struct>,

    pub automated_backup_config: std::option::Option<crate::model::table::AutomatedBackupConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Table {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Table::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cluster_states][crate::model::Table::cluster_states].
    pub fn set_cluster_states<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::table::ClusterState>,
    {
        use std::iter::Iterator;
        self.cluster_states = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [column_families][crate::model::Table::column_families].
    pub fn set_column_families<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ColumnFamily>,
    {
        use std::iter::Iterator;
        self.column_families = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [granularity][crate::model::Table::granularity].
    pub fn set_granularity<T: std::convert::Into<crate::model::table::TimestampGranularity>>(
        mut self,
        v: T,
    ) -> Self {
        self.granularity = v.into();
        self
    }

    /// Sets the value of [restore_info][crate::model::Table::restore_info].
    pub fn set_restore_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RestoreInfo>,
    {
        self.restore_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restore_info][crate::model::Table::restore_info].
    pub fn set_or_clear_restore_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RestoreInfo>,
    {
        self.restore_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [change_stream_config][crate::model::Table::change_stream_config].
    pub fn set_change_stream_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ChangeStreamConfig>,
    {
        self.change_stream_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [change_stream_config][crate::model::Table::change_stream_config].
    pub fn set_or_clear_change_stream_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ChangeStreamConfig>,
    {
        self.change_stream_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deletion_protection][crate::model::Table::deletion_protection].
    pub fn set_deletion_protection<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deletion_protection = v.into();
        self
    }

    /// Sets the value of [row_key_schema][crate::model::Table::row_key_schema].
    pub fn set_row_key_schema<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::r#type::Struct>,
    {
        self.row_key_schema = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [row_key_schema][crate::model::Table::row_key_schema].
    pub fn set_or_clear_row_key_schema<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::r#type::Struct>,
    {
        self.row_key_schema = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automated_backup_config][crate::model::Table::automated_backup_config].
    ///
    /// Note that all the setters affecting `automated_backup_config` are mutually
    /// exclusive.
    pub fn set_automated_backup_config<
        T: std::convert::Into<std::option::Option<crate::model::table::AutomatedBackupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_backup_config = v.into();
        self
    }

    /// The value of [automated_backup_config][crate::model::Table::automated_backup_config]
    /// if it holds a `AutomatedBackupPolicy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn automated_backup_policy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::table::AutomatedBackupPolicy>> {
        #[allow(unreachable_patterns)]
        self.automated_backup_config.as_ref().and_then(|v| match v {
            crate::model::table::AutomatedBackupConfig::AutomatedBackupPolicy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [automated_backup_config][crate::model::Table::automated_backup_config]
    /// to hold a `AutomatedBackupPolicy`.
    ///
    /// Note that all the setters affecting `automated_backup_config` are
    /// mutually exclusive.
    pub fn set_automated_backup_policy<
        T: std::convert::Into<std::boxed::Box<crate::model::table::AutomatedBackupPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_backup_config = std::option::Option::Some(
            crate::model::table::AutomatedBackupConfig::AutomatedBackupPolicy(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Table {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Table"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Table {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __cluster_states,
            __column_families,
            __granularity,
            __restore_info,
            __change_stream_config,
            __deletion_protection,
            __automated_backup_policy,
            __row_key_schema,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Table")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "clusterStates" => Ok(__FieldTag::__cluster_states),
                            "cluster_states" => Ok(__FieldTag::__cluster_states),
                            "columnFamilies" => Ok(__FieldTag::__column_families),
                            "column_families" => Ok(__FieldTag::__column_families),
                            "granularity" => Ok(__FieldTag::__granularity),
                            "restoreInfo" => Ok(__FieldTag::__restore_info),
                            "restore_info" => Ok(__FieldTag::__restore_info),
                            "changeStreamConfig" => Ok(__FieldTag::__change_stream_config),
                            "change_stream_config" => Ok(__FieldTag::__change_stream_config),
                            "deletionProtection" => Ok(__FieldTag::__deletion_protection),
                            "deletion_protection" => Ok(__FieldTag::__deletion_protection),
                            "automatedBackupPolicy" => Ok(__FieldTag::__automated_backup_policy),
                            "automated_backup_policy" => Ok(__FieldTag::__automated_backup_policy),
                            "rowKeySchema" => Ok(__FieldTag::__row_key_schema),
                            "row_key_schema" => Ok(__FieldTag::__row_key_schema),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Table;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Table")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_states => {
                            if !fields.insert(__FieldTag::__cluster_states) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_states",
                                ));
                            }
                            result.cluster_states = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::table::ClusterState,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__column_families => {
                            if !fields.insert(__FieldTag::__column_families) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for column_families",
                                ));
                            }
                            result.column_families = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ColumnFamily,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__granularity => {
                            if !fields.insert(__FieldTag::__granularity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for granularity",
                                ));
                            }
                            result.granularity = map.next_value::<std::option::Option<crate::model::table::TimestampGranularity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__restore_info => {
                            if !fields.insert(__FieldTag::__restore_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restore_info",
                                ));
                            }
                            result.restore_info =
                                map.next_value::<std::option::Option<crate::model::RestoreInfo>>()?;
                        }
                        __FieldTag::__change_stream_config => {
                            if !fields.insert(__FieldTag::__change_stream_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for change_stream_config",
                                ));
                            }
                            result.change_stream_config = map.next_value::<std::option::Option<crate::model::ChangeStreamConfig>>()?
                                ;
                        }
                        __FieldTag::__deletion_protection => {
                            if !fields.insert(__FieldTag::__deletion_protection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_protection",
                                ));
                            }
                            result.deletion_protection = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__automated_backup_policy => {
                            if !fields.insert(__FieldTag::__automated_backup_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automated_backup_policy",
                                ));
                            }
                            if result.automated_backup_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `automated_backup_config`, a oneof with full ID .google.bigtable.admin.v2.Table.automated_backup_policy, latest field was automatedBackupPolicy",
                                ));
                            }
                            result.automated_backup_config = std::option::Option::Some(
                                crate::model::table::AutomatedBackupConfig::AutomatedBackupPolicy(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::table::AutomatedBackupPolicy>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__row_key_schema => {
                            if !fields.insert(__FieldTag::__row_key_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for row_key_schema",
                                ));
                            }
                            result.row_key_schema = map
                                .next_value::<std::option::Option<crate::model::r#type::Struct>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Table {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.cluster_states.is_empty() {
            state.serialize_entry("clusterStates", &self.cluster_states)?;
        }
        if !self.column_families.is_empty() {
            state.serialize_entry("columnFamilies", &self.column_families)?;
        }
        if !wkt::internal::is_default(&self.granularity) {
            state.serialize_entry("granularity", &self.granularity)?;
        }
        if self.restore_info.is_some() {
            state.serialize_entry("restoreInfo", &self.restore_info)?;
        }
        if self.change_stream_config.is_some() {
            state.serialize_entry("changeStreamConfig", &self.change_stream_config)?;
        }
        if !wkt::internal::is_default(&self.deletion_protection) {
            state.serialize_entry("deletionProtection", &self.deletion_protection)?;
        }
        if let Some(value) = self.automated_backup_policy() {
            state.serialize_entry("automatedBackupPolicy", value)?;
        }
        if self.row_key_schema.is_some() {
            state.serialize_entry("rowKeySchema", &self.row_key_schema)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Table].
pub mod table {
    #[allow(unused_imports)]
    use super::*;

    /// The state of a table's data in a particular cluster.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClusterState {
        /// Output only. The state of replication for the table in this cluster.
        pub replication_state: crate::model::table::cluster_state::ReplicationState,

        /// Output only. The encryption information for the table in this cluster.
        /// If the encryption key protecting this resource is customer managed, then
        /// its version can be rotated in Cloud Key Management Service (Cloud KMS).
        /// The primary version of the key and its status will be reflected here when
        /// changes propagate from Cloud KMS.
        pub encryption_info: std::vec::Vec<crate::model::EncryptionInfo>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClusterState {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [replication_state][crate::model::table::ClusterState::replication_state].
        pub fn set_replication_state<
            T: std::convert::Into<crate::model::table::cluster_state::ReplicationState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.replication_state = v.into();
            self
        }

        /// Sets the value of [encryption_info][crate::model::table::ClusterState::encryption_info].
        pub fn set_encryption_info<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::EncryptionInfo>,
        {
            use std::iter::Iterator;
            self.encryption_info = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ClusterState {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Table.ClusterState"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClusterState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __replication_state,
                __encryption_info,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClusterState")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "replicationState" => Ok(__FieldTag::__replication_state),
                                "replication_state" => Ok(__FieldTag::__replication_state),
                                "encryptionInfo" => Ok(__FieldTag::__encryption_info),
                                "encryption_info" => Ok(__FieldTag::__encryption_info),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClusterState;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClusterState")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__replication_state => {
                                if !fields.insert(__FieldTag::__replication_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for replication_state",
                                    ));
                                }
                                result.replication_state = map
                                    .next_value::<std::option::Option<
                                        crate::model::table::cluster_state::ReplicationState,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__encryption_info => {
                                if !fields.insert(__FieldTag::__encryption_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encryption_info",
                                    ));
                                }
                                result.encryption_info = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::EncryptionInfo>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClusterState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.replication_state) {
                state.serialize_entry("replicationState", &self.replication_state)?;
            }
            if !self.encryption_info.is_empty() {
                state.serialize_entry("encryptionInfo", &self.encryption_info)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ClusterState].
    pub mod cluster_state {
        #[allow(unused_imports)]
        use super::*;

        /// Table replication states.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ReplicationState {
            /// The replication state of the table is unknown in this cluster.
            StateNotKnown,
            /// The cluster was recently created, and the table must finish copying
            /// over pre-existing data from other clusters before it can begin
            /// receiving live replication updates and serving Data API requests.
            Initializing,
            /// The table is temporarily unable to serve Data API requests from this
            /// cluster due to planned internal maintenance.
            PlannedMaintenance,
            /// The table is temporarily unable to serve Data API requests from this
            /// cluster due to unplanned or emergency maintenance.
            UnplannedMaintenance,
            /// The table can serve Data API requests from this cluster. Depending on
            /// replication delay, reads may not immediately reflect the state of the
            /// table in other clusters.
            Ready,
            /// The table is fully created and ready for use after a restore, and is
            /// being optimized for performance. When optimizations are complete, the
            /// table will transition to `READY` state.
            ReadyOptimizing,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ReplicationState::value] or
            /// [ReplicationState::name].
            UnknownValue(replication_state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod replication_state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ReplicationState {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::StateNotKnown => std::option::Option::Some(0),
                    Self::Initializing => std::option::Option::Some(1),
                    Self::PlannedMaintenance => std::option::Option::Some(2),
                    Self::UnplannedMaintenance => std::option::Option::Some(3),
                    Self::Ready => std::option::Option::Some(4),
                    Self::ReadyOptimizing => std::option::Option::Some(5),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::StateNotKnown => std::option::Option::Some("STATE_NOT_KNOWN"),
                    Self::Initializing => std::option::Option::Some("INITIALIZING"),
                    Self::PlannedMaintenance => std::option::Option::Some("PLANNED_MAINTENANCE"),
                    Self::UnplannedMaintenance => {
                        std::option::Option::Some("UNPLANNED_MAINTENANCE")
                    }
                    Self::Ready => std::option::Option::Some("READY"),
                    Self::ReadyOptimizing => std::option::Option::Some("READY_OPTIMIZING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ReplicationState {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ReplicationState {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ReplicationState {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::StateNotKnown,
                    1 => Self::Initializing,
                    2 => Self::PlannedMaintenance,
                    3 => Self::UnplannedMaintenance,
                    4 => Self::Ready,
                    5 => Self::ReadyOptimizing,
                    _ => Self::UnknownValue(replication_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ReplicationState {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_NOT_KNOWN" => Self::StateNotKnown,
                    "INITIALIZING" => Self::Initializing,
                    "PLANNED_MAINTENANCE" => Self::PlannedMaintenance,
                    "UNPLANNED_MAINTENANCE" => Self::UnplannedMaintenance,
                    "READY" => Self::Ready,
                    "READY_OPTIMIZING" => Self::ReadyOptimizing,
                    _ => Self::UnknownValue(replication_state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ReplicationState {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::StateNotKnown => serializer.serialize_i32(0),
                    Self::Initializing => serializer.serialize_i32(1),
                    Self::PlannedMaintenance => serializer.serialize_i32(2),
                    Self::UnplannedMaintenance => serializer.serialize_i32(3),
                    Self::Ready => serializer.serialize_i32(4),
                    Self::ReadyOptimizing => serializer.serialize_i32(5),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ReplicationState {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReplicationState>::new(
                    ".google.bigtable.admin.v2.Table.ClusterState.ReplicationState",
                ))
            }
        }
    }

    /// Defines an automated backup policy for a table
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AutomatedBackupPolicy {
        /// Required. How long the automated backups should be retained. The only
        /// supported value at this time is 3 days.
        pub retention_period: std::option::Option<wkt::Duration>,

        /// Required. How frequently automated backups should occur. The only
        /// supported value at this time is 24 hours.
        pub frequency: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AutomatedBackupPolicy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [retention_period][crate::model::table::AutomatedBackupPolicy::retention_period].
        pub fn set_retention_period<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.retention_period = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [retention_period][crate::model::table::AutomatedBackupPolicy::retention_period].
        pub fn set_or_clear_retention_period<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.retention_period = v.map(|x| x.into());
            self
        }

        /// Sets the value of [frequency][crate::model::table::AutomatedBackupPolicy::frequency].
        pub fn set_frequency<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.frequency = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [frequency][crate::model::table::AutomatedBackupPolicy::frequency].
        pub fn set_or_clear_frequency<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.frequency = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AutomatedBackupPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Table.AutomatedBackupPolicy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AutomatedBackupPolicy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __retention_period,
                __frequency,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AutomatedBackupPolicy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "retentionPeriod" => Ok(__FieldTag::__retention_period),
                                "retention_period" => Ok(__FieldTag::__retention_period),
                                "frequency" => Ok(__FieldTag::__frequency),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AutomatedBackupPolicy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AutomatedBackupPolicy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__retention_period => {
                                if !fields.insert(__FieldTag::__retention_period) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for retention_period",
                                    ));
                                }
                                result.retention_period =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__frequency => {
                                if !fields.insert(__FieldTag::__frequency) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for frequency",
                                    ));
                                }
                                result.frequency =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AutomatedBackupPolicy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.retention_period.is_some() {
                state.serialize_entry("retentionPeriod", &self.retention_period)?;
            }
            if self.frequency.is_some() {
                state.serialize_entry("frequency", &self.frequency)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Possible timestamp granularities to use when keeping multiple versions
    /// of data in a table.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimestampGranularity {
        /// The user did not specify a granularity. Should not be returned.
        /// When specified during table creation, MILLIS will be used.
        Unspecified,
        /// The table keeps data versioned at a granularity of 1ms.
        Millis,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimestampGranularity::value] or
        /// [TimestampGranularity::name].
        UnknownValue(timestamp_granularity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod timestamp_granularity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimestampGranularity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Millis => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIMESTAMP_GRANULARITY_UNSPECIFIED"),
                Self::Millis => std::option::Option::Some("MILLIS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimestampGranularity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimestampGranularity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimestampGranularity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Millis,
                _ => Self::UnknownValue(timestamp_granularity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimestampGranularity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIMESTAMP_GRANULARITY_UNSPECIFIED" => Self::Unspecified,
                "MILLIS" => Self::Millis,
                _ => Self::UnknownValue(timestamp_granularity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimestampGranularity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Millis => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimestampGranularity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimestampGranularity>::new(
                ".google.bigtable.admin.v2.Table.TimestampGranularity",
            ))
        }
    }

    /// Defines a view over a table's fields.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum View {
        /// Uses the default view for each method as documented in its request.
        Unspecified,
        /// Only populates `name`.
        NameOnly,
        /// Only populates `name` and fields related to the table's schema.
        SchemaView,
        /// Only populates `name` and fields related to the table's replication
        /// state.
        ReplicationView,
        /// Only populates `name` and fields related to the table's encryption state.
        EncryptionView,
        /// Populates all fields.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [View::value] or
        /// [View::name].
        UnknownValue(view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl View {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NameOnly => std::option::Option::Some(1),
                Self::SchemaView => std::option::Option::Some(2),
                Self::ReplicationView => std::option::Option::Some(3),
                Self::EncryptionView => std::option::Option::Some(5),
                Self::Full => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VIEW_UNSPECIFIED"),
                Self::NameOnly => std::option::Option::Some("NAME_ONLY"),
                Self::SchemaView => std::option::Option::Some("SCHEMA_VIEW"),
                Self::ReplicationView => std::option::Option::Some("REPLICATION_VIEW"),
                Self::EncryptionView => std::option::Option::Some("ENCRYPTION_VIEW"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for View {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for View {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for View {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NameOnly,
                2 => Self::SchemaView,
                3 => Self::ReplicationView,
                4 => Self::Full,
                5 => Self::EncryptionView,
                _ => Self::UnknownValue(view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for View {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VIEW_UNSPECIFIED" => Self::Unspecified,
                "NAME_ONLY" => Self::NameOnly,
                "SCHEMA_VIEW" => Self::SchemaView,
                "REPLICATION_VIEW" => Self::ReplicationView,
                "ENCRYPTION_VIEW" => Self::EncryptionView,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for View {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NameOnly => serializer.serialize_i32(1),
                Self::SchemaView => serializer.serialize_i32(2),
                Self::ReplicationView => serializer.serialize_i32(3),
                Self::EncryptionView => serializer.serialize_i32(5),
                Self::Full => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for View {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<View>::new(
                ".google.bigtable.admin.v2.Table.View",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutomatedBackupConfig {
        /// If specified, automated backups are enabled for this table.
        /// Otherwise, automated backups are disabled.
        AutomatedBackupPolicy(std::boxed::Box<crate::model::table::AutomatedBackupPolicy>),
    }
}

/// AuthorizedViews represent subsets of a particular Cloud Bigtable table. Users
/// can configure access to each Authorized View independently from the table and
/// use the existing Data APIs to access the subset of data.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AuthorizedView {
    /// Identifier. The name of this AuthorizedView.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}/authorizedViews/{authorized_view}`
    pub name: std::string::String,

    /// The etag for this AuthorizedView.
    /// If this is provided on update, it must match the server's etag. The server
    /// returns ABORTED error on a mismatched etag.
    pub etag: std::string::String,

    /// Set to true to make the AuthorizedView protected against deletion.
    /// The parent Table and containing Instance cannot be deleted if an
    /// AuthorizedView has this bit set.
    pub deletion_protection: bool,

    /// The type of this AuthorizedView.
    pub authorized_view: std::option::Option<crate::model::authorized_view::AuthorizedView>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuthorizedView {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AuthorizedView::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AuthorizedView::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [deletion_protection][crate::model::AuthorizedView::deletion_protection].
    pub fn set_deletion_protection<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deletion_protection = v.into();
        self
    }

    /// Sets the value of [authorized_view][crate::model::AuthorizedView::authorized_view].
    ///
    /// Note that all the setters affecting `authorized_view` are mutually
    /// exclusive.
    pub fn set_authorized_view<
        T: std::convert::Into<std::option::Option<crate::model::authorized_view::AuthorizedView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorized_view = v.into();
        self
    }

    /// The value of [authorized_view][crate::model::AuthorizedView::authorized_view]
    /// if it holds a `SubsetView`, `None` if the field is not set or
    /// holds a different branch.
    pub fn subset_view(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::authorized_view::SubsetView>> {
        #[allow(unreachable_patterns)]
        self.authorized_view.as_ref().and_then(|v| match v {
            crate::model::authorized_view::AuthorizedView::SubsetView(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [authorized_view][crate::model::AuthorizedView::authorized_view]
    /// to hold a `SubsetView`.
    ///
    /// Note that all the setters affecting `authorized_view` are
    /// mutually exclusive.
    pub fn set_subset_view<
        T: std::convert::Into<std::boxed::Box<crate::model::authorized_view::SubsetView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorized_view = std::option::Option::Some(
            crate::model::authorized_view::AuthorizedView::SubsetView(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AuthorizedView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.AuthorizedView"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AuthorizedView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __subset_view,
            __etag,
            __deletion_protection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuthorizedView")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "subsetView" => Ok(__FieldTag::__subset_view),
                            "subset_view" => Ok(__FieldTag::__subset_view),
                            "etag" => Ok(__FieldTag::__etag),
                            "deletionProtection" => Ok(__FieldTag::__deletion_protection),
                            "deletion_protection" => Ok(__FieldTag::__deletion_protection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AuthorizedView;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuthorizedView")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subset_view => {
                            if !fields.insert(__FieldTag::__subset_view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subset_view",
                                ));
                            }
                            if result.authorized_view.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `authorized_view`, a oneof with full ID .google.bigtable.admin.v2.AuthorizedView.subset_view, latest field was subsetView",
                                ));
                            }
                            result.authorized_view = std::option::Option::Some(
                                crate::model::authorized_view::AuthorizedView::SubsetView(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::authorized_view::SubsetView>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__deletion_protection => {
                            if !fields.insert(__FieldTag::__deletion_protection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_protection",
                                ));
                            }
                            result.deletion_protection = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AuthorizedView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.subset_view() {
            state.serialize_entry("subsetView", value)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.deletion_protection) {
            state.serialize_entry("deletionProtection", &self.deletion_protection)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AuthorizedView].
pub mod authorized_view {
    #[allow(unused_imports)]
    use super::*;

    /// Subsets of a column family that are included in this AuthorizedView.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FamilySubsets {
        /// Individual exact column qualifiers to be included in the AuthorizedView.
        pub qualifiers: std::vec::Vec<::bytes::Bytes>,

        /// Prefixes for qualifiers to be included in the AuthorizedView. Every
        /// qualifier starting with one of these prefixes is included in the
        /// AuthorizedView. To provide access to all qualifiers, include the empty
        /// string as a prefix
        /// ("").
        pub qualifier_prefixes: std::vec::Vec<::bytes::Bytes>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FamilySubsets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [qualifiers][crate::model::authorized_view::FamilySubsets::qualifiers].
        pub fn set_qualifiers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<::bytes::Bytes>,
        {
            use std::iter::Iterator;
            self.qualifiers = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [qualifier_prefixes][crate::model::authorized_view::FamilySubsets::qualifier_prefixes].
        pub fn set_qualifier_prefixes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<::bytes::Bytes>,
        {
            use std::iter::Iterator;
            self.qualifier_prefixes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for FamilySubsets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AuthorizedView.FamilySubsets"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FamilySubsets {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __qualifiers,
                __qualifier_prefixes,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FamilySubsets")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "qualifiers" => Ok(__FieldTag::__qualifiers),
                                "qualifierPrefixes" => Ok(__FieldTag::__qualifier_prefixes),
                                "qualifier_prefixes" => Ok(__FieldTag::__qualifier_prefixes),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FamilySubsets;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FamilySubsets")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__qualifiers => {
                                if !fields.insert(__FieldTag::__qualifiers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for qualifiers",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<::bytes::Bytes>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<
                                                std::vec::Vec<serde_with::base64::Base64>,
                                            >,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.qualifiers =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__qualifier_prefixes => {
                                if !fields.insert(__FieldTag::__qualifier_prefixes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for qualifier_prefixes",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<::bytes::Bytes>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<
                                                std::vec::Vec<serde_with::base64::Base64>,
                                            >,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.qualifier_prefixes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FamilySubsets {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.qualifiers.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<::bytes::Bytes>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("qualifiers", &__With(&self.qualifiers))?;
            }
            if !self.qualifier_prefixes.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<::bytes::Bytes>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("qualifierPrefixes", &__With(&self.qualifier_prefixes))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines a simple AuthorizedView that is a subset of the underlying Table.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SubsetView {
        /// Row prefixes to be included in the AuthorizedView.
        /// To provide access to all rows, include the empty string as a prefix ("").
        pub row_prefixes: std::vec::Vec<::bytes::Bytes>,

        /// Map from column family name to the columns in this family to be included
        /// in the AuthorizedView.
        pub family_subsets: std::collections::HashMap<
            std::string::String,
            crate::model::authorized_view::FamilySubsets,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SubsetView {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [row_prefixes][crate::model::authorized_view::SubsetView::row_prefixes].
        pub fn set_row_prefixes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<::bytes::Bytes>,
        {
            use std::iter::Iterator;
            self.row_prefixes = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [family_subsets][crate::model::authorized_view::SubsetView::family_subsets].
        pub fn set_family_subsets<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::authorized_view::FamilySubsets>,
        {
            use std::iter::Iterator;
            self.family_subsets = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for SubsetView {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AuthorizedView.SubsetView"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SubsetView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __row_prefixes,
                __family_subsets,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SubsetView")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "rowPrefixes" => Ok(__FieldTag::__row_prefixes),
                                "row_prefixes" => Ok(__FieldTag::__row_prefixes),
                                "familySubsets" => Ok(__FieldTag::__family_subsets),
                                "family_subsets" => Ok(__FieldTag::__family_subsets),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SubsetView;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SubsetView")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__row_prefixes => {
                                if !fields.insert(__FieldTag::__row_prefixes) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for row_prefixes",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<::bytes::Bytes>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<
                                                std::vec::Vec<serde_with::base64::Base64>,
                                            >,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.row_prefixes =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__family_subsets => {
                                if !fields.insert(__FieldTag::__family_subsets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for family_subsets",
                                    ));
                                }
                                result.family_subsets = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            crate::model::authorized_view::FamilySubsets,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SubsetView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.row_prefixes.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<::bytes::Bytes>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("rowPrefixes", &__With(&self.row_prefixes))?;
            }
            if !self.family_subsets.is_empty() {
                state.serialize_entry("familySubsets", &self.family_subsets)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines a subset of an AuthorizedView's fields.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ResponseView {
        /// Uses the default view for each method as documented in the request.
        Unspecified,
        /// Only populates `name`.
        NameOnly,
        /// Only populates the AuthorizedView's basic metadata. This includes:
        /// name, deletion_protection, etag.
        Basic,
        /// Populates every fields.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ResponseView::value] or
        /// [ResponseView::name].
        UnknownValue(response_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod response_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ResponseView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NameOnly => std::option::Option::Some(1),
                Self::Basic => std::option::Option::Some(2),
                Self::Full => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESPONSE_VIEW_UNSPECIFIED"),
                Self::NameOnly => std::option::Option::Some("NAME_ONLY"),
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ResponseView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ResponseView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ResponseView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NameOnly,
                2 => Self::Basic,
                3 => Self::Full,
                _ => Self::UnknownValue(response_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ResponseView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESPONSE_VIEW_UNSPECIFIED" => Self::Unspecified,
                "NAME_ONLY" => Self::NameOnly,
                "BASIC" => Self::Basic,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(response_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ResponseView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NameOnly => serializer.serialize_i32(1),
                Self::Basic => serializer.serialize_i32(2),
                Self::Full => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ResponseView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResponseView>::new(
                ".google.bigtable.admin.v2.AuthorizedView.ResponseView",
            ))
        }
    }

    /// The type of this AuthorizedView.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AuthorizedView {
        /// An AuthorizedView permitting access to an explicit subset of a Table.
        SubsetView(std::boxed::Box<crate::model::authorized_view::SubsetView>),
    }
}

/// A set of columns within a table which share a common configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ColumnFamily {
    /// Garbage collection rule specified as a protobuf.
    /// Must serialize to at most 500 bytes.
    ///
    /// NOTE: Garbage collection executes opportunistically in the background, and
    /// so it's possible for reads to return a cell even if it matches the active
    /// GC expression for its family.
    pub gc_rule: std::option::Option<crate::model::GcRule>,

    /// The type of data stored in each of this family's cell values, including its
    /// full encoding. If omitted, the family only serves raw untyped bytes.
    ///
    /// For now, only the `Aggregate` type is supported.
    ///
    /// `Aggregate` can only be set at family creation and is immutable afterwards.
    ///
    /// If `value_type` is `Aggregate`, written data must be compatible with:
    ///
    /// * `value_type.input_type` for `AddInput` mutations
    pub value_type: std::option::Option<crate::model::Type>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ColumnFamily {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gc_rule][crate::model::ColumnFamily::gc_rule].
    pub fn set_gc_rule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GcRule>,
    {
        self.gc_rule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gc_rule][crate::model::ColumnFamily::gc_rule].
    pub fn set_or_clear_gc_rule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GcRule>,
    {
        self.gc_rule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value_type][crate::model::ColumnFamily::value_type].
    pub fn set_value_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Type>,
    {
        self.value_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value_type][crate::model::ColumnFamily::value_type].
    pub fn set_or_clear_value_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Type>,
    {
        self.value_type = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ColumnFamily {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ColumnFamily"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ColumnFamily {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gc_rule,
            __value_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ColumnFamily")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcRule" => Ok(__FieldTag::__gc_rule),
                            "gc_rule" => Ok(__FieldTag::__gc_rule),
                            "valueType" => Ok(__FieldTag::__value_type),
                            "value_type" => Ok(__FieldTag::__value_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ColumnFamily;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ColumnFamily")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gc_rule => {
                            if !fields.insert(__FieldTag::__gc_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gc_rule",
                                ));
                            }
                            result.gc_rule =
                                map.next_value::<std::option::Option<crate::model::GcRule>>()?;
                        }
                        __FieldTag::__value_type => {
                            if !fields.insert(__FieldTag::__value_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value_type",
                                ));
                            }
                            result.value_type =
                                map.next_value::<std::option::Option<crate::model::Type>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ColumnFamily {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.gc_rule.is_some() {
            state.serialize_entry("gcRule", &self.gc_rule)?;
        }
        if self.value_type.is_some() {
            state.serialize_entry("valueType", &self.value_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Rule for determining which cells to delete during garbage collection.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GcRule {
    /// Garbage collection rules.
    pub rule: std::option::Option<crate::model::gc_rule::Rule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GcRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rule][crate::model::GcRule::rule].
    ///
    /// Note that all the setters affecting `rule` are mutually
    /// exclusive.
    pub fn set_rule<T: std::convert::Into<std::option::Option<crate::model::gc_rule::Rule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule = v.into();
        self
    }

    /// The value of [rule][crate::model::GcRule::rule]
    /// if it holds a `MaxNumVersions`, `None` if the field is not set or
    /// holds a different branch.
    pub fn max_num_versions(&self) -> std::option::Option<&i32> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::gc_rule::Rule::MaxNumVersions(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::GcRule::rule]
    /// to hold a `MaxNumVersions`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_max_num_versions<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.rule =
            std::option::Option::Some(crate::model::gc_rule::Rule::MaxNumVersions(v.into()));
        self
    }

    /// The value of [rule][crate::model::GcRule::rule]
    /// if it holds a `MaxAge`, `None` if the field is not set or
    /// holds a different branch.
    pub fn max_age(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::gc_rule::Rule::MaxAge(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::GcRule::rule]
    /// to hold a `MaxAge`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_max_age<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(crate::model::gc_rule::Rule::MaxAge(v.into()));
        self
    }

    /// The value of [rule][crate::model::GcRule::rule]
    /// if it holds a `Intersection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn intersection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::gc_rule::Intersection>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::gc_rule::Rule::Intersection(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::GcRule::rule]
    /// to hold a `Intersection`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_intersection<
        T: std::convert::Into<std::boxed::Box<crate::model::gc_rule::Intersection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(crate::model::gc_rule::Rule::Intersection(v.into()));
        self
    }

    /// The value of [rule][crate::model::GcRule::rule]
    /// if it holds a `Union`, `None` if the field is not set or
    /// holds a different branch.
    pub fn union(&self) -> std::option::Option<&std::boxed::Box<crate::model::gc_rule::Union>> {
        #[allow(unreachable_patterns)]
        self.rule.as_ref().and_then(|v| match v {
            crate::model::gc_rule::Rule::Union(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [rule][crate::model::GcRule::rule]
    /// to hold a `Union`.
    ///
    /// Note that all the setters affecting `rule` are
    /// mutually exclusive.
    pub fn set_union<T: std::convert::Into<std::boxed::Box<crate::model::gc_rule::Union>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule = std::option::Option::Some(crate::model::gc_rule::Rule::Union(v.into()));
        self
    }
}

impl wkt::message::Message for GcRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GcRule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GcRule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __max_num_versions,
            __max_age,
            __intersection,
            __union,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GcRule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "maxNumVersions" => Ok(__FieldTag::__max_num_versions),
                            "max_num_versions" => Ok(__FieldTag::__max_num_versions),
                            "maxAge" => Ok(__FieldTag::__max_age),
                            "max_age" => Ok(__FieldTag::__max_age),
                            "intersection" => Ok(__FieldTag::__intersection),
                            "union" => Ok(__FieldTag::__union),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GcRule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GcRule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__max_num_versions => {
                            if !fields.insert(__FieldTag::__max_num_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_num_versions",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.rule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule`, a oneof with full ID .google.bigtable.admin.v2.GcRule.max_num_versions, latest field was maxNumVersions",
                                ));
                            }
                            result.rule = std::option::Option::Some(
                                crate::model::gc_rule::Rule::MaxNumVersions(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__max_age => {
                            if !fields.insert(__FieldTag::__max_age) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_age",
                                ));
                            }
                            if result.rule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule`, a oneof with full ID .google.bigtable.admin.v2.GcRule.max_age, latest field was maxAge",
                                ));
                            }
                            result.rule = std::option::Option::Some(
                                crate::model::gc_rule::Rule::MaxAge(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__intersection => {
                            if !fields.insert(__FieldTag::__intersection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intersection",
                                ));
                            }
                            if result.rule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule`, a oneof with full ID .google.bigtable.admin.v2.GcRule.intersection, latest field was intersection",
                                ));
                            }
                            result.rule = std::option::Option::Some(
                                crate::model::gc_rule::Rule::Intersection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::gc_rule::Intersection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__union => {
                            if !fields.insert(__FieldTag::__union) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for union",
                                ));
                            }
                            if result.rule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `rule`, a oneof with full ID .google.bigtable.admin.v2.GcRule.union, latest field was union",
                                ));
                            }
                            result.rule =
                                std::option::Option::Some(crate::model::gc_rule::Rule::Union(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::gc_rule::Union>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GcRule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.max_num_versions() {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxNumVersions", &__With(value))?;
        }
        if let Some(value) = self.max_age() {
            state.serialize_entry("maxAge", value)?;
        }
        if let Some(value) = self.intersection() {
            state.serialize_entry("intersection", value)?;
        }
        if let Some(value) = self.union() {
            state.serialize_entry("union", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GcRule].
pub mod gc_rule {
    #[allow(unused_imports)]
    use super::*;

    /// A GcRule which deletes cells matching all of the given rules.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Intersection {
        /// Only delete cells which would be deleted by every element of `rules`.
        pub rules: std::vec::Vec<crate::model::GcRule>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Intersection {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rules][crate::model::gc_rule::Intersection::rules].
        pub fn set_rules<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::GcRule>,
        {
            use std::iter::Iterator;
            self.rules = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Intersection {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.GcRule.Intersection"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Intersection {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __rules,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Intersection")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "rules" => Ok(__FieldTag::__rules),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Intersection;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Intersection")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__rules => {
                                if !fields.insert(__FieldTag::__rules) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rules",
                                    ));
                                }
                                result.rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GcRule>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Intersection {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.rules.is_empty() {
                state.serialize_entry("rules", &self.rules)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A GcRule which deletes cells matching any of the given rules.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Union {
        /// Delete cells which would be deleted by any element of `rules`.
        pub rules: std::vec::Vec<crate::model::GcRule>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Union {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rules][crate::model::gc_rule::Union::rules].
        pub fn set_rules<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::GcRule>,
        {
            use std::iter::Iterator;
            self.rules = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Union {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.GcRule.Union"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Union {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __rules,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Union")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "rules" => Ok(__FieldTag::__rules),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Union;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Union")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__rules => {
                                if !fields.insert(__FieldTag::__rules) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rules",
                                    ));
                                }
                                result.rules = map.next_value::<std::option::Option<std::vec::Vec<crate::model::GcRule>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Union {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.rules.is_empty() {
                state.serialize_entry("rules", &self.rules)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Garbage collection rules.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Rule {
        /// Delete all cells in a column except the most recent N.
        MaxNumVersions(i32),
        /// Delete cells in a column older than the given age.
        /// Values must be at least one millisecond, and will be truncated to
        /// microsecond granularity.
        MaxAge(std::boxed::Box<wkt::Duration>),
        /// Delete cells that would be deleted by every nested rule.
        Intersection(std::boxed::Box<crate::model::gc_rule::Intersection>),
        /// Delete cells that would be deleted by any nested rule.
        Union(std::boxed::Box<crate::model::gc_rule::Union>),
    }
}

/// Encryption information for a given resource.
/// If this resource is protected with customer managed encryption, the in-use
/// Cloud Key Management Service (Cloud KMS) key version is specified along with
/// its status.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionInfo {
    /// Output only. The type of encryption used to protect this resource.
    pub encryption_type: crate::model::encryption_info::EncryptionType,

    /// Output only. The status of encrypt/decrypt calls on underlying data for
    /// this resource. Regardless of status, the existing data is always encrypted
    /// at rest.
    pub encryption_status: std::option::Option<rpc::model::Status>,

    /// Output only. The version of the Cloud KMS key specified in the parent
    /// cluster that is in use for the data underlying this table.
    pub kms_key_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_type][crate::model::EncryptionInfo::encryption_type].
    pub fn set_encryption_type<
        T: std::convert::Into<crate::model::encryption_info::EncryptionType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_type = v.into();
        self
    }

    /// Sets the value of [encryption_status][crate::model::EncryptionInfo::encryption_status].
    pub fn set_encryption_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.encryption_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_status][crate::model::EncryptionInfo::encryption_status].
    pub fn set_or_clear_encryption_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.encryption_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key_version][crate::model::EncryptionInfo::kms_key_version].
    pub fn set_kms_key_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_version = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.EncryptionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_type,
            __encryption_status,
            __kms_key_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionType" => Ok(__FieldTag::__encryption_type),
                            "encryption_type" => Ok(__FieldTag::__encryption_type),
                            "encryptionStatus" => Ok(__FieldTag::__encryption_status),
                            "encryption_status" => Ok(__FieldTag::__encryption_status),
                            "kmsKeyVersion" => Ok(__FieldTag::__kms_key_version),
                            "kms_key_version" => Ok(__FieldTag::__kms_key_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_type => {
                            if !fields.insert(__FieldTag::__encryption_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_type",
                                ));
                            }
                            result.encryption_type =
                                map.next_value::<std::option::Option<
                                    crate::model::encryption_info::EncryptionType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_status => {
                            if !fields.insert(__FieldTag::__encryption_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_status",
                                ));
                            }
                            result.encryption_status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__kms_key_version => {
                            if !fields.insert(__FieldTag::__kms_key_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version",
                                ));
                            }
                            result.kms_key_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.encryption_type) {
            state.serialize_entry("encryptionType", &self.encryption_type)?;
        }
        if self.encryption_status.is_some() {
            state.serialize_entry("encryptionStatus", &self.encryption_status)?;
        }
        if !self.kms_key_version.is_empty() {
            state.serialize_entry("kmsKeyVersion", &self.kms_key_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EncryptionInfo].
pub mod encryption_info {
    #[allow(unused_imports)]
    use super::*;

    /// Possible encryption types for a resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EncryptionType {
        /// Encryption type was not specified, though data at rest remains encrypted.
        Unspecified,
        /// The data backing this resource is encrypted at rest with a key that is
        /// fully managed by Google. No key version or status will be populated.
        /// This is the default state.
        GoogleDefaultEncryption,
        /// The data backing this resource is encrypted at rest with a key that is
        /// managed by the customer.
        /// The in-use version of the key and its status are populated for
        /// CMEK-protected tables.
        /// CMEK-protected backups are pinned to the key version that was in use at
        /// the time the backup was taken. This key version is populated but its
        /// status is not tracked and is reported as `UNKNOWN`.
        CustomerManagedEncryption,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EncryptionType::value] or
        /// [EncryptionType::name].
        UnknownValue(encryption_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod encryption_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EncryptionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleDefaultEncryption => std::option::Option::Some(1),
                Self::CustomerManagedEncryption => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ENCRYPTION_TYPE_UNSPECIFIED"),
                Self::GoogleDefaultEncryption => {
                    std::option::Option::Some("GOOGLE_DEFAULT_ENCRYPTION")
                }
                Self::CustomerManagedEncryption => {
                    std::option::Option::Some("CUSTOMER_MANAGED_ENCRYPTION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EncryptionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EncryptionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EncryptionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleDefaultEncryption,
                2 => Self::CustomerManagedEncryption,
                _ => Self::UnknownValue(encryption_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EncryptionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENCRYPTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_DEFAULT_ENCRYPTION" => Self::GoogleDefaultEncryption,
                "CUSTOMER_MANAGED_ENCRYPTION" => Self::CustomerManagedEncryption,
                _ => Self::UnknownValue(encryption_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EncryptionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleDefaultEncryption => serializer.serialize_i32(1),
                Self::CustomerManagedEncryption => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EncryptionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EncryptionType>::new(
                ".google.bigtable.admin.v2.EncryptionInfo.EncryptionType",
            ))
        }
    }
}

/// A snapshot of a table at a particular time. A snapshot can be used as a
/// checkpoint for data restoration or a data source for a new table.
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Snapshot {
    /// The unique name of the snapshot.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/{snapshot}`.
    pub name: std::string::String,

    /// Output only. The source table at the time the snapshot was taken.
    pub source_table: std::option::Option<crate::model::Table>,

    /// Output only. The size of the data in the source table at the time the
    /// snapshot was taken. In some cases, this value may be computed
    /// asynchronously via a background process and a placeholder of 0 will be used
    /// in the meantime.
    pub data_size_bytes: i64,

    /// Output only. The time when the snapshot is created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the snapshot will be deleted. The maximum amount of time a
    /// snapshot can stay active is 365 days. If 'ttl' is not specified,
    /// the default maximum of 365 days will be used.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the snapshot.
    pub state: crate::model::snapshot::State,

    /// Description of the snapshot.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Snapshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Snapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_table][crate::model::Snapshot::source_table].
    pub fn set_source_table<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Table>,
    {
        self.source_table = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_table][crate::model::Snapshot::source_table].
    pub fn set_or_clear_source_table<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Table>,
    {
        self.source_table = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_size_bytes][crate::model::Snapshot::data_size_bytes].
    pub fn set_data_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.data_size_bytes = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Snapshot::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Snapshot::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Snapshot::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Snapshot::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Snapshot::state].
    pub fn set_state<T: std::convert::Into<crate::model::snapshot::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Snapshot::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for Snapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Snapshot"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Snapshot {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __source_table,
            __data_size_bytes,
            __create_time,
            __delete_time,
            __state,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Snapshot")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sourceTable" => Ok(__FieldTag::__source_table),
                            "source_table" => Ok(__FieldTag::__source_table),
                            "dataSizeBytes" => Ok(__FieldTag::__data_size_bytes),
                            "data_size_bytes" => Ok(__FieldTag::__data_size_bytes),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "state" => Ok(__FieldTag::__state),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Snapshot;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Snapshot")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_table => {
                            if !fields.insert(__FieldTag::__source_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_table",
                                ));
                            }
                            result.source_table =
                                map.next_value::<std::option::Option<crate::model::Table>>()?;
                        }
                        __FieldTag::__data_size_bytes => {
                            if !fields.insert(__FieldTag::__data_size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.data_size_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::snapshot::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Snapshot {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.source_table.is_some() {
            state.serialize_entry("sourceTable", &self.source_table)?;
        }
        if !wkt::internal::is_default(&self.data_size_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("dataSizeBytes", &__With(&self.data_size_bytes))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Snapshot].
pub mod snapshot {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a snapshot.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state of the snapshot could not be determined.
        NotKnown,
        /// The snapshot has been successfully created and can serve all requests.
        Ready,
        /// The snapshot is currently being created, and may be destroyed if the
        /// creation process encounters an error. A snapshot may not be restored to a
        /// table while it is being created.
        Creating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::NotKnown => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::NotKnown => std::option::Option::Some("STATE_NOT_KNOWN"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::NotKnown,
                1 => Self::Ready,
                2 => Self::Creating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_NOT_KNOWN" => Self::NotKnown,
                "READY" => Self::Ready,
                "CREATING" => Self::Creating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::NotKnown => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Creating => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.bigtable.admin.v2.Snapshot.State",
            ))
        }
    }
}

/// A backup of a Cloud Bigtable table.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Backup {
    /// A globally unique identifier for the backup which cannot be
    /// changed. Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/
    /// backups/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`
    /// The final segment of the name must be between 1 and 50 characters
    /// in length.
    ///
    /// The backup is stored in the cluster identified by the prefix of the backup
    /// name of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    pub name: std::string::String,

    /// Required. Immutable. Name of the table from which this backup was created.
    /// This needs to be in the same instance as the backup. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{source_table}`.
    pub source_table: std::string::String,

    /// Output only. Name of the backup from which this backup was copied. If a
    /// backup is not created by copying a backup, this field will be empty. Values
    /// are of the form:
    /// projects/\<project\>/instances/\<instance\>/clusters/\<cluster\>/backups/\<backup\>
    pub source_backup: std::string::String,

    /// Required. The expiration time of the backup.
    /// When creating a backup or updating its `expire_time`, the value must be
    /// greater than the backup creation time by:
    ///
    /// - At least 6 hours
    /// - At most 90 days
    ///
    /// Once the `expire_time` has passed, Cloud Bigtable will delete the backup.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. `start_time` is the time that the backup was started
    /// (i.e. approximately the time the
    /// [CreateBackup][google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup]
    /// request is received).  The row data in this backup will be no older than
    /// this timestamp.
    ///
    /// [google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup]: crate::client::BigtableTableAdmin::create_backup
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. `end_time` is the time that the backup was finished. The row
    /// data in the backup will be no newer than this timestamp.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Size of the backup in bytes.
    pub size_bytes: i64,

    /// Output only. The current state of the backup.
    pub state: crate::model::backup::State,

    /// Output only. The encryption information for the backup.
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// Indicates the backup type of the backup.
    pub backup_type: crate::model::backup::BackupType,

    /// The time at which the hot backup will be converted to a standard backup.
    /// Once the `hot_to_standard_time` has passed, Cloud Bigtable will convert the
    /// hot backup to a standard backup. This value must be greater than the backup
    /// creation time by:
    ///
    /// - At least 24 hours
    ///
    /// This field only applies for hot backups. When creating or updating a
    /// standard backup, attempting to set this field will fail the request.
    pub hot_to_standard_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_table][crate::model::Backup::source_table].
    pub fn set_source_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_table = v.into();
        self
    }

    /// Sets the value of [source_backup][crate::model::Backup::source_backup].
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_backup = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Backup::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Backup::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Backup::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Backup::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [size_bytes][crate::model::Backup::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [encryption_info][crate::model::Backup::encryption_info].
    pub fn set_encryption_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_info][crate::model::Backup::encryption_info].
    pub fn set_or_clear_encryption_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_type][crate::model::Backup::backup_type].
    pub fn set_backup_type<T: std::convert::Into<crate::model::backup::BackupType>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_type = v.into();
        self
    }

    /// Sets the value of [hot_to_standard_time][crate::model::Backup::hot_to_standard_time].
    pub fn set_hot_to_standard_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.hot_to_standard_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hot_to_standard_time][crate::model::Backup::hot_to_standard_time].
    pub fn set_or_clear_hot_to_standard_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.hot_to_standard_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Backup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Backup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __source_table,
            __source_backup,
            __expire_time,
            __start_time,
            __end_time,
            __size_bytes,
            __state,
            __encryption_info,
            __backup_type,
            __hot_to_standard_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Backup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "sourceTable" => Ok(__FieldTag::__source_table),
                            "source_table" => Ok(__FieldTag::__source_table),
                            "sourceBackup" => Ok(__FieldTag::__source_backup),
                            "source_backup" => Ok(__FieldTag::__source_backup),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "sizeBytes" => Ok(__FieldTag::__size_bytes),
                            "size_bytes" => Ok(__FieldTag::__size_bytes),
                            "state" => Ok(__FieldTag::__state),
                            "encryptionInfo" => Ok(__FieldTag::__encryption_info),
                            "encryption_info" => Ok(__FieldTag::__encryption_info),
                            "backupType" => Ok(__FieldTag::__backup_type),
                            "backup_type" => Ok(__FieldTag::__backup_type),
                            "hotToStandardTime" => Ok(__FieldTag::__hot_to_standard_time),
                            "hot_to_standard_time" => Ok(__FieldTag::__hot_to_standard_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Backup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Backup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_table => {
                            if !fields.insert(__FieldTag::__source_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_table",
                                ));
                            }
                            result.source_table = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_backup => {
                            if !fields.insert(__FieldTag::__source_backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_backup",
                                ));
                            }
                            result.source_backup = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__size_bytes => {
                            if !fields.insert(__FieldTag::__size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::backup::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_info => {
                            if !fields.insert(__FieldTag::__encryption_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_info",
                                ));
                            }
                            result.encryption_info = map
                                .next_value::<std::option::Option<crate::model::EncryptionInfo>>(
                                )?;
                        }
                        __FieldTag::__backup_type => {
                            if !fields.insert(__FieldTag::__backup_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_type",
                                ));
                            }
                            result.backup_type = map.next_value::<std::option::Option<crate::model::backup::BackupType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hot_to_standard_time => {
                            if !fields.insert(__FieldTag::__hot_to_standard_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hot_to_standard_time",
                                ));
                            }
                            result.hot_to_standard_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Backup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.source_table.is_empty() {
            state.serialize_entry("sourceTable", &self.source_table)?;
        }
        if !self.source_backup.is_empty() {
            state.serialize_entry("sourceBackup", &self.source_backup)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !wkt::internal::is_default(&self.size_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeBytes", &__With(&self.size_bytes))?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.encryption_info.is_some() {
            state.serialize_entry("encryptionInfo", &self.encryption_info)?;
        }
        if !wkt::internal::is_default(&self.backup_type) {
            state.serialize_entry("backupType", &self.backup_type)?;
        }
        if self.hot_to_standard_time.is_some() {
            state.serialize_entry("hotToStandardTime", &self.hot_to_standard_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the current state of the backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not specified.
        Unspecified,
        /// The pending backup is still being created. Operations on the
        /// backup may fail with `FAILED_PRECONDITION` in this state.
        Creating,
        /// The backup is complete and ready for use.
        Ready,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.bigtable.admin.v2.Backup.State",
            ))
        }
    }

    /// The type of the backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupType {
        /// Not specified.
        Unspecified,
        /// The default type for Cloud Bigtable managed backups. Supported for
        /// backups created in both HDD and SSD instances. Requires optimization when
        /// restored to a table in an SSD instance.
        Standard,
        /// A backup type with faster restore to SSD performance. Only supported for
        /// backups created in SSD instances. A new SSD table restored from a hot
        /// backup reaches production performance more quickly than a standard
        /// backup.
        Hot,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackupType::value] or
        /// [BackupType::name].
        UnknownValue(backup_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backup_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackupType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Standard => std::option::Option::Some(1),
                Self::Hot => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BACKUP_TYPE_UNSPECIFIED"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::Hot => std::option::Option::Some("HOT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackupType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Standard,
                2 => Self::Hot,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackupType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKUP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                "HOT" => Self::Hot,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Standard => serializer.serialize_i32(1),
                Self::Hot => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupType>::new(
                ".google.bigtable.admin.v2.Backup.BackupType",
            ))
        }
    }
}

/// Information about a backup.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupInfo {
    /// Output only. Name of the backup.
    pub backup: std::string::String,

    /// Output only. The time that the backup was started. Row data in the backup
    /// will be no older than this timestamp.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. This time that the backup was finished. Row data in the
    /// backup will be no newer than this timestamp.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Name of the table the backup was created from.
    pub source_table: std::string::String,

    /// Output only. Name of the backup from which this backup was copied. If a
    /// backup is not created by copying a backup, this field will be empty. Values
    /// are of the form:
    /// projects/\<project\>/instances/\<instance\>/clusters/\<cluster\>/backups/\<backup\>
    pub source_backup: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup][crate::model::BackupInfo::backup].
    pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BackupInfo::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::BackupInfo::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::BackupInfo::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::BackupInfo::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_table][crate::model::BackupInfo::source_table].
    pub fn set_source_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_table = v.into();
        self
    }

    /// Sets the value of [source_backup][crate::model::BackupInfo::source_backup].
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_backup = v.into();
        self
    }
}

impl wkt::message::Message for BackupInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.BackupInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup,
            __start_time,
            __end_time,
            __source_table,
            __source_backup,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backup" => Ok(__FieldTag::__backup),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "sourceTable" => Ok(__FieldTag::__source_table),
                            "source_table" => Ok(__FieldTag::__source_table),
                            "sourceBackup" => Ok(__FieldTag::__source_backup),
                            "source_backup" => Ok(__FieldTag::__source_backup),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup => {
                            if !fields.insert(__FieldTag::__backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup",
                                ));
                            }
                            result.backup = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__source_table => {
                            if !fields.insert(__FieldTag::__source_table) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_table",
                                ));
                            }
                            result.source_table = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_backup => {
                            if !fields.insert(__FieldTag::__source_backup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_backup",
                                ));
                            }
                            result.source_backup = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup.is_empty() {
            state.serialize_entry("backup", &self.backup)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.source_table.is_empty() {
            state.serialize_entry("sourceTable", &self.source_table)?;
        }
        if !self.source_backup.is_empty() {
            state.serialize_entry("sourceBackup", &self.source_backup)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `Type` represents the type of data that is written to, read from, or stored
/// in Bigtable. It is heavily based on the GoogleSQL standard to help maintain
/// familiarity and consistency across products and features.
///
/// For compatibility with Bigtable's existing untyped APIs, each `Type` includes
/// an `Encoding` which describes how to convert to or from the underlying data.
///
/// Each encoding can operate in one of two modes:
///
/// - Sorted: In this mode, Bigtable guarantees that `Encode(X) <= Encode(Y)`
///   if and only if `X <= Y`. This is useful anywhere sort order is important,
///   for example when encoding keys.
/// - Distinct: In this mode, Bigtable guarantees that if `X != Y` then
///   `Encode(X) != Encode(Y)`. However, the converse is not guaranteed. For
///   example, both "{'foo': '1', 'bar': '2'}" and "{'bar': '2', 'foo': '1'}"
///   are valid encodings of the same JSON value.
///
/// The API clearly documents which mode is used wherever an encoding can be
/// configured. Each encoding also documents which values are supported in which
/// modes. For example, when encoding INT64 as a numeric STRING, negative numbers
/// cannot be encoded in sorted mode. This is because `INT64(1) > INT64(-1)`, but
/// `STRING("-00001") > STRING("00001")`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Type {
    /// The kind of type that this represents.
    pub kind: std::option::Option<crate::model::r#type::Kind>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Type {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Type::kind].
    ///
    /// Note that all the setters affecting `kind` are mutually
    /// exclusive.
    pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::r#type::Kind>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `BytesType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bytes_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::r#type::Bytes>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::BytesType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `BytesType`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_bytes_type<T: std::convert::Into<std::boxed::Box<crate::model::r#type::Bytes>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::BytesType(v.into()));
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `StringType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::r#type::String>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::StringType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `StringType`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_string_type<T: std::convert::Into<std::boxed::Box<crate::model::r#type::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::StringType(v.into()));
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `Int64Type`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int64_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::r#type::Int64>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::Int64Type(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `Int64Type`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_int64_type<T: std::convert::Into<std::boxed::Box<crate::model::r#type::Int64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::Int64Type(v.into()));
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `Float32Type`, `None` if the field is not set or
    /// holds a different branch.
    pub fn float32_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::r#type::Float32>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::Float32Type(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `Float32Type`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_float32_type<
        T: std::convert::Into<std::boxed::Box<crate::model::r#type::Float32>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::Float32Type(v.into()));
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `Float64Type`, `None` if the field is not set or
    /// holds a different branch.
    pub fn float64_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::r#type::Float64>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::Float64Type(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `Float64Type`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_float64_type<
        T: std::convert::Into<std::boxed::Box<crate::model::r#type::Float64>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::Float64Type(v.into()));
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `BoolType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::r#type::Bool>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::BoolType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `BoolType`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_bool_type<T: std::convert::Into<std::boxed::Box<crate::model::r#type::Bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::BoolType(v.into()));
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `TimestampType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn timestamp_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::r#type::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::TimestampType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `TimestampType`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_timestamp_type<
        T: std::convert::Into<std::boxed::Box<crate::model::r#type::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::TimestampType(v.into()));
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `DateType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn date_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::r#type::Date>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::DateType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `DateType`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_date_type<T: std::convert::Into<std::boxed::Box<crate::model::r#type::Date>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::DateType(v.into()));
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `AggregateType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aggregate_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::r#type::Aggregate>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::AggregateType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `AggregateType`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_aggregate_type<
        T: std::convert::Into<std::boxed::Box<crate::model::r#type::Aggregate>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::AggregateType(v.into()));
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `StructType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn struct_type(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::r#type::Struct>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::StructType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `StructType`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_struct_type<T: std::convert::Into<std::boxed::Box<crate::model::r#type::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::StructType(v.into()));
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `ArrayType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn array_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::r#type::Array>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::ArrayType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `ArrayType`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_array_type<T: std::convert::Into<std::boxed::Box<crate::model::r#type::Array>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::ArrayType(v.into()));
        self
    }

    /// The value of [kind][crate::model::Type::kind]
    /// if it holds a `MapType`, `None` if the field is not set or
    /// holds a different branch.
    pub fn map_type(&self) -> std::option::Option<&std::boxed::Box<crate::model::r#type::Map>> {
        #[allow(unreachable_patterns)]
        self.kind.as_ref().and_then(|v| match v {
            crate::model::r#type::Kind::MapType(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [kind][crate::model::Type::kind]
    /// to hold a `MapType`.
    ///
    /// Note that all the setters affecting `kind` are
    /// mutually exclusive.
    pub fn set_map_type<T: std::convert::Into<std::boxed::Box<crate::model::r#type::Map>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = std::option::Option::Some(crate::model::r#type::Kind::MapType(v.into()));
        self
    }
}

impl wkt::message::Message for Type {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Type"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Type {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bytes_type,
            __string_type,
            __int64_type,
            __float32_type,
            __float64_type,
            __bool_type,
            __timestamp_type,
            __date_type,
            __aggregate_type,
            __struct_type,
            __array_type,
            __map_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Type")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bytesType" => Ok(__FieldTag::__bytes_type),
                            "bytes_type" => Ok(__FieldTag::__bytes_type),
                            "stringType" => Ok(__FieldTag::__string_type),
                            "string_type" => Ok(__FieldTag::__string_type),
                            "int64Type" => Ok(__FieldTag::__int64_type),
                            "int64_type" => Ok(__FieldTag::__int64_type),
                            "float32Type" => Ok(__FieldTag::__float32_type),
                            "float32_type" => Ok(__FieldTag::__float32_type),
                            "float64Type" => Ok(__FieldTag::__float64_type),
                            "float64_type" => Ok(__FieldTag::__float64_type),
                            "boolType" => Ok(__FieldTag::__bool_type),
                            "bool_type" => Ok(__FieldTag::__bool_type),
                            "timestampType" => Ok(__FieldTag::__timestamp_type),
                            "timestamp_type" => Ok(__FieldTag::__timestamp_type),
                            "dateType" => Ok(__FieldTag::__date_type),
                            "date_type" => Ok(__FieldTag::__date_type),
                            "aggregateType" => Ok(__FieldTag::__aggregate_type),
                            "aggregate_type" => Ok(__FieldTag::__aggregate_type),
                            "structType" => Ok(__FieldTag::__struct_type),
                            "struct_type" => Ok(__FieldTag::__struct_type),
                            "arrayType" => Ok(__FieldTag::__array_type),
                            "array_type" => Ok(__FieldTag::__array_type),
                            "mapType" => Ok(__FieldTag::__map_type),
                            "map_type" => Ok(__FieldTag::__map_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Type;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Type")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bytes_type => {
                            if !fields.insert(__FieldTag::__bytes_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bytes_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.bytes_type, latest field was bytesType",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::r#type::Kind::BytesType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::Bytes>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__string_type => {
                            if !fields.insert(__FieldTag::__string_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.string_type, latest field was stringType",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::r#type::Kind::StringType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::String>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__int64_type => {
                            if !fields.insert(__FieldTag::__int64_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int64_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.int64_type, latest field was int64Type",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::r#type::Kind::Int64Type(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::Int64>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__float32_type => {
                            if !fields.insert(__FieldTag::__float32_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for float32_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.float32_type, latest field was float32Type",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::r#type::Kind::Float32Type(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::Float32>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__float64_type => {
                            if !fields.insert(__FieldTag::__float64_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for float64_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.float64_type, latest field was float64Type",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::r#type::Kind::Float64Type(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::Float64>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__bool_type => {
                            if !fields.insert(__FieldTag::__bool_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.bool_type, latest field was boolType",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::r#type::Kind::BoolType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::Bool>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__timestamp_type => {
                            if !fields.insert(__FieldTag::__timestamp_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.timestamp_type, latest field was timestampType",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::r#type::Kind::TimestampType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::Timestamp>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__date_type => {
                            if !fields.insert(__FieldTag::__date_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for date_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.date_type, latest field was dateType",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::r#type::Kind::DateType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::Date>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__aggregate_type => {
                            if !fields.insert(__FieldTag::__aggregate_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aggregate_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.aggregate_type, latest field was aggregateType",
                                ));
                            }
                            result.kind = std::option::Option::Some(
                                crate::model::r#type::Kind::AggregateType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::Aggregate>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__struct_type => {
                            if !fields.insert(__FieldTag::__struct_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for struct_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.struct_type, latest field was structType",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::r#type::Kind::StructType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::Struct>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__array_type => {
                            if !fields.insert(__FieldTag::__array_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for array_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.array_type, latest field was arrayType",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::r#type::Kind::ArrayType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::Array>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__map_type => {
                            if !fields.insert(__FieldTag::__map_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for map_type",
                                ));
                            }
                            if result.kind.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `kind`, a oneof with full ID .google.bigtable.admin.v2.Type.map_type, latest field was mapType",
                                ));
                            }
                            result.kind =
                                std::option::Option::Some(crate::model::r#type::Kind::MapType(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::r#type::Map>,
                                    >>()?
                                    .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Type {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.bytes_type() {
            state.serialize_entry("bytesType", value)?;
        }
        if let Some(value) = self.string_type() {
            state.serialize_entry("stringType", value)?;
        }
        if let Some(value) = self.int64_type() {
            state.serialize_entry("int64Type", value)?;
        }
        if let Some(value) = self.float32_type() {
            state.serialize_entry("float32Type", value)?;
        }
        if let Some(value) = self.float64_type() {
            state.serialize_entry("float64Type", value)?;
        }
        if let Some(value) = self.bool_type() {
            state.serialize_entry("boolType", value)?;
        }
        if let Some(value) = self.timestamp_type() {
            state.serialize_entry("timestampType", value)?;
        }
        if let Some(value) = self.date_type() {
            state.serialize_entry("dateType", value)?;
        }
        if let Some(value) = self.aggregate_type() {
            state.serialize_entry("aggregateType", value)?;
        }
        if let Some(value) = self.struct_type() {
            state.serialize_entry("structType", value)?;
        }
        if let Some(value) = self.array_type() {
            state.serialize_entry("arrayType", value)?;
        }
        if let Some(value) = self.map_type() {
            state.serialize_entry("mapType", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Type].
pub mod r#type {
    #[allow(unused_imports)]
    use super::*;

    /// Bytes
    /// Values of type `Bytes` are stored in `Value.bytes_value`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Bytes {
        /// The encoding to use when converting to or from lower level types.
        pub encoding: std::option::Option<crate::model::r#type::bytes::Encoding>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Bytes {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encoding][crate::model::r#type::Bytes::encoding].
        pub fn set_encoding<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::r#type::bytes::Encoding>,
        {
            self.encoding = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [encoding][crate::model::r#type::Bytes::encoding].
        pub fn set_or_clear_encoding<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::r#type::bytes::Encoding>,
        {
            self.encoding = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Bytes {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Bytes"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Bytes {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __encoding,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Bytes")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "encoding" => Ok(__FieldTag::__encoding),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Bytes;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Bytes")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__encoding => {
                                if !fields.insert(__FieldTag::__encoding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encoding",
                                    ));
                                }
                                result.encoding = map.next_value::<std::option::Option<crate::model::r#type::bytes::Encoding>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Bytes {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.encoding.is_some() {
                state.serialize_entry("encoding", &self.encoding)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Bytes].
    pub mod bytes {
        #[allow(unused_imports)]
        use super::*;

        /// Rules used to convert to or from lower level types.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Encoding {
            /// Which encoding to use.
            pub encoding: std::option::Option<crate::model::r#type::bytes::encoding::Encoding>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Encoding {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [encoding][crate::model::r#type::bytes::Encoding::encoding].
            ///
            /// Note that all the setters affecting `encoding` are mutually
            /// exclusive.
            pub fn set_encoding<
                T: std::convert::Into<
                        std::option::Option<crate::model::r#type::bytes::encoding::Encoding>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// The value of [encoding][crate::model::r#type::bytes::Encoding::encoding]
            /// if it holds a `Raw`, `None` if the field is not set or
            /// holds a different branch.
            pub fn raw(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::r#type::bytes::encoding::Raw>>
            {
                #[allow(unreachable_patterns)]
                self.encoding.as_ref().and_then(|v| match v {
                    crate::model::r#type::bytes::encoding::Encoding::Raw(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [encoding][crate::model::r#type::bytes::Encoding::encoding]
            /// to hold a `Raw`.
            ///
            /// Note that all the setters affecting `encoding` are
            /// mutually exclusive.
            pub fn set_raw<
                T: std::convert::Into<std::boxed::Box<crate::model::r#type::bytes::encoding::Raw>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = std::option::Option::Some(
                    crate::model::r#type::bytes::encoding::Encoding::Raw(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for Encoding {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Bytes.Encoding"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Encoding {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __raw,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Encoding")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "raw" => Ok(__FieldTag::__raw),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Encoding;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Encoding")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__raw => {
                                    if !fields.insert(__FieldTag::__raw) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for raw"),
                                        );
                                    }
                                    if result.encoding.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `encoding`, a oneof with full ID .google.bigtable.admin.v2.Type.Bytes.Encoding.raw, latest field was raw",
                                            ),
                                        );
                                    }
                                    result.encoding = std::option::Option::Some(
                                        crate::model::r#type::bytes::encoding::Encoding::Raw(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::r#type::bytes::encoding::Raw,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Encoding {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.raw() {
                    state.serialize_entry("raw", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Encoding].
        pub mod encoding {
            #[allow(unused_imports)]
            use super::*;

            /// Leaves the value as-is.
            ///
            /// Sorted mode: all values are supported.
            ///
            /// Distinct mode: all values are supported.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Raw {
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Raw {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for Raw {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.Bytes.Encoding.Raw"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Raw {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Raw")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    Ok(__FieldTag::Unknown(value.to_string()))
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Raw;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Raw")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Raw {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Which encoding to use.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Encoding {
                /// Use `Raw` encoding.
                Raw(std::boxed::Box<crate::model::r#type::bytes::encoding::Raw>),
            }
        }
    }

    /// String
    /// Values of type `String` are stored in `Value.string_value`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct String {
        /// The encoding to use when converting to or from lower level types.
        pub encoding: std::option::Option<crate::model::r#type::string::Encoding>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl String {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encoding][crate::model::r#type::String::encoding].
        pub fn set_encoding<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::r#type::string::Encoding>,
        {
            self.encoding = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [encoding][crate::model::r#type::String::encoding].
        pub fn set_or_clear_encoding<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::r#type::string::Encoding>,
        {
            self.encoding = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for String {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.String"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for String {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __encoding,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for String")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "encoding" => Ok(__FieldTag::__encoding),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = String;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct String")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__encoding => {
                                if !fields.insert(__FieldTag::__encoding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encoding",
                                    ));
                                }
                                result.encoding = map.next_value::<std::option::Option<crate::model::r#type::string::Encoding>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for String {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.encoding.is_some() {
                state.serialize_entry("encoding", &self.encoding)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [String].
    pub mod string {
        #[allow(unused_imports)]
        use super::*;

        /// Rules used to convert to or from lower level types.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Encoding {
            /// Which encoding to use.
            pub encoding: std::option::Option<crate::model::r#type::string::encoding::Encoding>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Encoding {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [encoding][crate::model::r#type::string::Encoding::encoding].
            ///
            /// Note that all the setters affecting `encoding` are mutually
            /// exclusive.
            pub fn set_encoding<
                T: std::convert::Into<
                        std::option::Option<crate::model::r#type::string::encoding::Encoding>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// The value of [encoding][crate::model::r#type::string::Encoding::encoding]
            /// if it holds a `Utf8Raw`, `None` if the field is not set or
            /// holds a different branch.
            #[deprecated]
            pub fn utf8_raw(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::r#type::string::encoding::Utf8Raw>,
            > {
                #[allow(unreachable_patterns)]
                self.encoding.as_ref().and_then(|v| match v {
                    crate::model::r#type::string::encoding::Encoding::Utf8Raw(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [encoding][crate::model::r#type::string::Encoding::encoding]
            /// to hold a `Utf8Raw`.
            ///
            /// Note that all the setters affecting `encoding` are
            /// mutually exclusive.
            #[deprecated]
            pub fn set_utf8_raw<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::r#type::string::encoding::Utf8Raw>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = std::option::Option::Some(
                    crate::model::r#type::string::encoding::Encoding::Utf8Raw(v.into()),
                );
                self
            }

            /// The value of [encoding][crate::model::r#type::string::Encoding::encoding]
            /// if it holds a `Utf8Bytes`, `None` if the field is not set or
            /// holds a different branch.
            pub fn utf8_bytes(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::r#type::string::encoding::Utf8Bytes>,
            > {
                #[allow(unreachable_patterns)]
                self.encoding.as_ref().and_then(|v| match v {
                    crate::model::r#type::string::encoding::Encoding::Utf8Bytes(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [encoding][crate::model::r#type::string::Encoding::encoding]
            /// to hold a `Utf8Bytes`.
            ///
            /// Note that all the setters affecting `encoding` are
            /// mutually exclusive.
            pub fn set_utf8_bytes<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::r#type::string::encoding::Utf8Bytes>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = std::option::Option::Some(
                    crate::model::r#type::string::encoding::Encoding::Utf8Bytes(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for Encoding {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.String.Encoding"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Encoding {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __utf8_raw,
                    __utf8_bytes,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Encoding")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "utf8Raw" => Ok(__FieldTag::__utf8_raw),
                                    "utf8_raw" => Ok(__FieldTag::__utf8_raw),
                                    "utf8Bytes" => Ok(__FieldTag::__utf8_bytes),
                                    "utf8_bytes" => Ok(__FieldTag::__utf8_bytes),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Encoding;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Encoding")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__utf8_raw => {
                                    if !fields.insert(__FieldTag::__utf8_raw) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for utf8_raw",
                                            ),
                                        );
                                    }
                                    if result.encoding.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `encoding`, a oneof with full ID .google.bigtable.admin.v2.Type.String.Encoding.utf8_raw, latest field was utf8Raw",
                                            ),
                                        );
                                    }
                                    result.encoding = std::option::Option::Some(
                                        crate::model::r#type::string::encoding::Encoding::Utf8Raw(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::r#type::string::encoding::Utf8Raw,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__utf8_bytes => {
                                    if !fields.insert(__FieldTag::__utf8_bytes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for utf8_bytes",
                                            ),
                                        );
                                    }
                                    if result.encoding.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `encoding`, a oneof with full ID .google.bigtable.admin.v2.Type.String.Encoding.utf8_bytes, latest field was utf8Bytes",
                                            ),
                                        );
                                    }
                                    result.encoding = std::option::Option::Some(
                                        crate::model::r#type::string::encoding::Encoding::Utf8Bytes(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::r#type::string::encoding::Utf8Bytes>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Encoding {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.utf8_raw() {
                    state.serialize_entry("utf8Raw", value)?;
                }
                if let Some(value) = self.utf8_bytes() {
                    state.serialize_entry("utf8Bytes", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Encoding].
        pub mod encoding {
            #[allow(unused_imports)]
            use super::*;

            /// Deprecated: prefer the equivalent `Utf8Bytes`.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            #[deprecated]
            pub struct Utf8Raw {
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Utf8Raw {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for Utf8Raw {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.String.Encoding.Utf8Raw"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Utf8Raw {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Utf8Raw")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    Ok(__FieldTag::Unknown(value.to_string()))
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Utf8Raw;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Utf8Raw")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Utf8Raw {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// UTF-8 encoding.
            ///
            /// Sorted mode:
            ///
            /// - All values are supported.
            /// - Code point order is preserved.
            ///
            /// Distinct mode: all values are supported.
            ///
            /// Compatible with:
            ///
            /// - BigQuery `TEXT` encoding
            /// - HBase `Bytes.toBytes`
            /// - Java `String#getBytes(StandardCharsets.UTF_8)`
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Utf8Bytes {
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Utf8Bytes {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for Utf8Bytes {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.String.Encoding.Utf8Bytes"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Utf8Bytes {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Utf8Bytes")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    Ok(__FieldTag::Unknown(value.to_string()))
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Utf8Bytes;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Utf8Bytes")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Utf8Bytes {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Which encoding to use.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Encoding {
                /// Deprecated: if set, converts to an empty `utf8_bytes`.
                #[deprecated]
                Utf8Raw(std::boxed::Box<crate::model::r#type::string::encoding::Utf8Raw>),
                /// Use `Utf8Bytes` encoding.
                Utf8Bytes(std::boxed::Box<crate::model::r#type::string::encoding::Utf8Bytes>),
            }
        }
    }

    /// Int64
    /// Values of type `Int64` are stored in `Value.int_value`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Int64 {
        /// The encoding to use when converting to or from lower level types.
        pub encoding: std::option::Option<crate::model::r#type::int_64::Encoding>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Int64 {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encoding][crate::model::r#type::Int64::encoding].
        pub fn set_encoding<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::r#type::int_64::Encoding>,
        {
            self.encoding = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [encoding][crate::model::r#type::Int64::encoding].
        pub fn set_or_clear_encoding<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::r#type::int_64::Encoding>,
        {
            self.encoding = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Int64 {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Int64"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Int64 {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __encoding,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Int64")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "encoding" => Ok(__FieldTag::__encoding),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Int64;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Int64")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__encoding => {
                                if !fields.insert(__FieldTag::__encoding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encoding",
                                    ));
                                }
                                result.encoding = map.next_value::<std::option::Option<crate::model::r#type::int_64::Encoding>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Int64 {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.encoding.is_some() {
                state.serialize_entry("encoding", &self.encoding)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Int64].
    pub mod int_64 {
        #[allow(unused_imports)]
        use super::*;

        /// Rules used to convert to or from lower level types.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Encoding {
            /// Which encoding to use.
            pub encoding: std::option::Option<crate::model::r#type::int_64::encoding::Encoding>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Encoding {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [encoding][crate::model::r#type::int_64::Encoding::encoding].
            ///
            /// Note that all the setters affecting `encoding` are mutually
            /// exclusive.
            pub fn set_encoding<
                T: std::convert::Into<
                        std::option::Option<crate::model::r#type::int_64::encoding::Encoding>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// The value of [encoding][crate::model::r#type::int_64::Encoding::encoding]
            /// if it holds a `BigEndianBytes`, `None` if the field is not set or
            /// holds a different branch.
            pub fn big_endian_bytes(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::r#type::int_64::encoding::BigEndianBytes>,
            > {
                #[allow(unreachable_patterns)]
                self.encoding.as_ref().and_then(|v| match v {
                    crate::model::r#type::int_64::encoding::Encoding::BigEndianBytes(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [encoding][crate::model::r#type::int_64::Encoding::encoding]
            /// to hold a `BigEndianBytes`.
            ///
            /// Note that all the setters affecting `encoding` are
            /// mutually exclusive.
            pub fn set_big_endian_bytes<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::r#type::int_64::encoding::BigEndianBytes>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = std::option::Option::Some(
                    crate::model::r#type::int_64::encoding::Encoding::BigEndianBytes(v.into()),
                );
                self
            }

            /// The value of [encoding][crate::model::r#type::int_64::Encoding::encoding]
            /// if it holds a `OrderedCodeBytes`, `None` if the field is not set or
            /// holds a different branch.
            pub fn ordered_code_bytes(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::r#type::int_64::encoding::OrderedCodeBytes>,
            > {
                #[allow(unreachable_patterns)]
                self.encoding.as_ref().and_then(|v| match v {
                    crate::model::r#type::int_64::encoding::Encoding::OrderedCodeBytes(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [encoding][crate::model::r#type::int_64::Encoding::encoding]
            /// to hold a `OrderedCodeBytes`.
            ///
            /// Note that all the setters affecting `encoding` are
            /// mutually exclusive.
            pub fn set_ordered_code_bytes<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::r#type::int_64::encoding::OrderedCodeBytes>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = std::option::Option::Some(
                    crate::model::r#type::int_64::encoding::Encoding::OrderedCodeBytes(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for Encoding {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Int64.Encoding"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Encoding {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __big_endian_bytes,
                    __ordered_code_bytes,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Encoding")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "bigEndianBytes" => Ok(__FieldTag::__big_endian_bytes),
                                    "big_endian_bytes" => Ok(__FieldTag::__big_endian_bytes),
                                    "orderedCodeBytes" => Ok(__FieldTag::__ordered_code_bytes),
                                    "ordered_code_bytes" => Ok(__FieldTag::__ordered_code_bytes),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Encoding;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Encoding")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__big_endian_bytes => {
                                    if !fields.insert(__FieldTag::__big_endian_bytes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for big_endian_bytes",
                                            ),
                                        );
                                    }
                                    if result.encoding.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `encoding`, a oneof with full ID .google.bigtable.admin.v2.Type.Int64.Encoding.big_endian_bytes, latest field was bigEndianBytes",
                                            ),
                                        );
                                    }
                                    result.encoding = std::option::Option::Some(
                                        crate::model::r#type::int_64::encoding::Encoding::BigEndianBytes(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::r#type::int_64::encoding::BigEndianBytes>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__ordered_code_bytes => {
                                    if !fields.insert(__FieldTag::__ordered_code_bytes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for ordered_code_bytes",
                                            ),
                                        );
                                    }
                                    if result.encoding.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `encoding`, a oneof with full ID .google.bigtable.admin.v2.Type.Int64.Encoding.ordered_code_bytes, latest field was orderedCodeBytes",
                                            ),
                                        );
                                    }
                                    result.encoding = std::option::Option::Some(
                                        crate::model::r#type::int_64::encoding::Encoding::OrderedCodeBytes(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::r#type::int_64::encoding::OrderedCodeBytes>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Encoding {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.big_endian_bytes() {
                    state.serialize_entry("bigEndianBytes", value)?;
                }
                if let Some(value) = self.ordered_code_bytes() {
                    state.serialize_entry("orderedCodeBytes", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Encoding].
        pub mod encoding {
            #[allow(unused_imports)]
            use super::*;

            /// Encodes the value as an 8-byte big-endian two's complement value.
            ///
            /// Sorted mode: non-negative values are supported.
            ///
            /// Distinct mode: all values are supported.
            ///
            /// Compatible with:
            ///
            /// - BigQuery `BINARY` encoding
            /// - HBase `Bytes.toBytes`
            /// - Java `ByteBuffer.putLong()` with `ByteOrder.BIG_ENDIAN`
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct BigEndianBytes {
                /// Deprecated: ignored if set.
                #[deprecated]
                pub bytes_type: std::option::Option<crate::model::r#type::Bytes>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl BigEndianBytes {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [bytes_type][crate::model::r#type::int_64::encoding::BigEndianBytes::bytes_type].
                #[deprecated]
                pub fn set_bytes_type<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::r#type::Bytes>,
                {
                    self.bytes_type = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [bytes_type][crate::model::r#type::int_64::encoding::BigEndianBytes::bytes_type].
                #[deprecated]
                pub fn set_or_clear_bytes_type<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::r#type::Bytes>,
                {
                    self.bytes_type = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for BigEndianBytes {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.Int64.Encoding.BigEndianBytes"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for BigEndianBytes {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __bytes_type,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for BigEndianBytes")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "bytesType" => Ok(__FieldTag::__bytes_type),
                                        "bytes_type" => Ok(__FieldTag::__bytes_type),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = BigEndianBytes;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct BigEndianBytes")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__bytes_type => {
                                        if !fields.insert(__FieldTag::__bytes_type) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for bytes_type",
                                                ),
                                            );
                                        }
                                        result.bytes_type = map.next_value::<std::option::Option<crate::model::r#type::Bytes>>()?
                                            ;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for BigEndianBytes {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.bytes_type.is_some() {
                        state.serialize_entry("bytesType", &self.bytes_type)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Encodes the value in a variable length binary format of up to 10 bytes.
            /// Values that are closer to zero use fewer bytes.
            ///
            /// Sorted mode: all values are supported.
            ///
            /// Distinct mode: all values are supported.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct OrderedCodeBytes {
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl OrderedCodeBytes {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for OrderedCodeBytes {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.Int64.Encoding.OrderedCodeBytes"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for OrderedCodeBytes {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for OrderedCodeBytes")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    Ok(__FieldTag::Unknown(value.to_string()))
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = OrderedCodeBytes;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct OrderedCodeBytes")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for OrderedCodeBytes {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Which encoding to use.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Encoding {
                /// Use `BigEndianBytes` encoding.
                BigEndianBytes(
                    std::boxed::Box<crate::model::r#type::int_64::encoding::BigEndianBytes>,
                ),
                /// Use `OrderedCodeBytes` encoding.
                OrderedCodeBytes(
                    std::boxed::Box<crate::model::r#type::int_64::encoding::OrderedCodeBytes>,
                ),
            }
        }
    }

    /// bool
    /// Values of type `Bool` are stored in `Value.bool_value`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Bool {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Bool {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Bool {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Bool"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Bool {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Bool")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Bool;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Bool")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Bool {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Float32
    /// Values of type `Float32` are stored in `Value.float_value`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Float32 {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Float32 {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Float32 {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Float32"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Float32 {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Float32")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Float32;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Float32")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Float32 {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Float64
    /// Values of type `Float64` are stored in `Value.float_value`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Float64 {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Float64 {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Float64 {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Float64"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Float64 {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Float64")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Float64;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Float64")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Float64 {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Timestamp
    /// Values of type `Timestamp` are stored in `Value.timestamp_value`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Timestamp {
        /// The encoding to use when converting to or from lower level types.
        pub encoding: std::option::Option<crate::model::r#type::timestamp::Encoding>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Timestamp {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [encoding][crate::model::r#type::Timestamp::encoding].
        pub fn set_encoding<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::r#type::timestamp::Encoding>,
        {
            self.encoding = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [encoding][crate::model::r#type::Timestamp::encoding].
        pub fn set_or_clear_encoding<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::r#type::timestamp::Encoding>,
        {
            self.encoding = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Timestamp {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Timestamp"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Timestamp {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __encoding,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Timestamp")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "encoding" => Ok(__FieldTag::__encoding),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Timestamp;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Timestamp")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__encoding => {
                                if !fields.insert(__FieldTag::__encoding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encoding",
                                    ));
                                }
                                result.encoding = map.next_value::<std::option::Option<
                                    crate::model::r#type::timestamp::Encoding,
                                >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Timestamp {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.encoding.is_some() {
                state.serialize_entry("encoding", &self.encoding)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Timestamp].
    pub mod timestamp {
        #[allow(unused_imports)]
        use super::*;

        /// Rules used to convert to or from lower level types.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Encoding {
            /// Which encoding to use.
            pub encoding: std::option::Option<crate::model::r#type::timestamp::encoding::Encoding>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Encoding {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [encoding][crate::model::r#type::timestamp::Encoding::encoding].
            ///
            /// Note that all the setters affecting `encoding` are mutually
            /// exclusive.
            pub fn set_encoding<
                T: std::convert::Into<
                        std::option::Option<crate::model::r#type::timestamp::encoding::Encoding>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// The value of [encoding][crate::model::r#type::timestamp::Encoding::encoding]
            /// if it holds a `UnixMicrosInt64`, `None` if the field is not set or
            /// holds a different branch.
            pub fn unix_micros_int64(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::r#type::int_64::Encoding>>
            {
                #[allow(unreachable_patterns)]
                self.encoding.as_ref().and_then(|v| match v {
                    crate::model::r#type::timestamp::encoding::Encoding::UnixMicrosInt64(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [encoding][crate::model::r#type::timestamp::Encoding::encoding]
            /// to hold a `UnixMicrosInt64`.
            ///
            /// Note that all the setters affecting `encoding` are
            /// mutually exclusive.
            pub fn set_unix_micros_int64<
                T: std::convert::Into<std::boxed::Box<crate::model::r#type::int_64::Encoding>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = std::option::Option::Some(
                    crate::model::r#type::timestamp::encoding::Encoding::UnixMicrosInt64(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for Encoding {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Timestamp.Encoding"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Encoding {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __unix_micros_int64,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Encoding")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "unixMicrosInt64" => Ok(__FieldTag::__unix_micros_int64),
                                    "unix_micros_int64" => Ok(__FieldTag::__unix_micros_int64),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Encoding;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Encoding")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__unix_micros_int64 => {
                                    if !fields.insert(__FieldTag::__unix_micros_int64) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for unix_micros_int64",
                                            ),
                                        );
                                    }
                                    if result.encoding.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `encoding`, a oneof with full ID .google.bigtable.admin.v2.Type.Timestamp.Encoding.unix_micros_int64, latest field was unixMicrosInt64",
                                            ),
                                        );
                                    }
                                    result.encoding = std::option::Option::Some(
                                        crate::model::r#type::timestamp::encoding::Encoding::UnixMicrosInt64(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::r#type::int_64::Encoding>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Encoding {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.unix_micros_int64() {
                    state.serialize_entry("unixMicrosInt64", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Encoding].
        pub mod encoding {
            #[allow(unused_imports)]
            use super::*;

            /// Which encoding to use.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Encoding {
                /// Encodes the number of microseconds since the Unix epoch using the
                /// given `Int64` encoding. Values must be microsecond-aligned.
                ///
                /// Compatible with:
                ///
                /// - Java `Instant.truncatedTo()` with `ChronoUnit.MICROS`
                UnixMicrosInt64(std::boxed::Box<crate::model::r#type::int_64::Encoding>),
            }
        }
    }

    /// Date
    /// Values of type `Date` are stored in `Value.date_value`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Date {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Date {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for Date {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Date"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Date {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Date")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Date;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Date")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Date {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A structured data value, consisting of fields which map to dynamically
    /// typed values.
    /// Values of type `Struct` are stored in `Value.array_value` where entries are
    /// in the same order and number as `field_types`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Struct {
        /// The names and types of the fields in this struct.
        pub fields: std::vec::Vec<crate::model::r#type::r#struct::Field>,

        /// The encoding to use when converting to or from lower level types.
        pub encoding: std::option::Option<crate::model::r#type::r#struct::Encoding>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Struct {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [fields][crate::model::r#type::Struct::fields].
        pub fn set_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::r#type::r#struct::Field>,
        {
            use std::iter::Iterator;
            self.fields = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [encoding][crate::model::r#type::Struct::encoding].
        pub fn set_encoding<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::r#type::r#struct::Encoding>,
        {
            self.encoding = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [encoding][crate::model::r#type::Struct::encoding].
        pub fn set_or_clear_encoding<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::r#type::r#struct::Encoding>,
        {
            self.encoding = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Struct {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Struct"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Struct {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __fields,
                __encoding,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Struct")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "fields" => Ok(__FieldTag::__fields),
                                "encoding" => Ok(__FieldTag::__encoding),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Struct;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Struct")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__fields => {
                                if !fields.insert(__FieldTag::__fields) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for fields",
                                    ));
                                }
                                result.fields = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::r#type::r#struct::Field>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__encoding => {
                                if !fields.insert(__FieldTag::__encoding) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for encoding",
                                    ));
                                }
                                result.encoding =
                                    map.next_value::<std::option::Option<
                                        crate::model::r#type::r#struct::Encoding,
                                    >>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Struct {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.fields.is_empty() {
                state.serialize_entry("fields", &self.fields)?;
            }
            if self.encoding.is_some() {
                state.serialize_entry("encoding", &self.encoding)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Struct].
    pub mod r#struct {
        #[allow(unused_imports)]
        use super::*;

        /// A struct field and its type.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Field {
            /// The field name (optional). Fields without a `field_name` are considered
            /// anonymous and cannot be referenced by name.
            pub field_name: std::string::String,

            /// The type of values in this field.
            pub r#type: std::option::Option<std::boxed::Box<crate::model::Type>>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Field {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [field_name][crate::model::r#type::r#struct::Field::field_name].
            pub fn set_field_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.field_name = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::r#type::r#struct::Field::type].
            pub fn set_type<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::Type>,
            {
                self.r#type = std::option::Option::Some(std::boxed::Box::new(v.into()));
                self
            }

            /// Sets or clears the value of [r#type][crate::model::r#type::r#struct::Field::type].
            pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::Type>,
            {
                self.r#type = v.map(|x| std::boxed::Box::new(x.into()));
                self
            }
        }

        impl wkt::message::Message for Field {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Struct.Field"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Field {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __field_name,
                    __type,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Field")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "fieldName" => Ok(__FieldTag::__field_name),
                                    "field_name" => Ok(__FieldTag::__field_name),
                                    "type" => Ok(__FieldTag::__type),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Field;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Field")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__field_name => {
                                    if !fields.insert(__FieldTag::__field_name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for field_name",
                                            ),
                                        );
                                    }
                                    result.field_name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__type => {
                                    if !fields.insert(__FieldTag::__type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for type"),
                                        );
                                    }
                                    result.r#type =
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Type>,
                                        >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Field {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.field_name.is_empty() {
                    state.serialize_entry("fieldName", &self.field_name)?;
                }
                if self.r#type.is_some() {
                    state.serialize_entry("type", &self.r#type)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Rules used to convert to or from lower level types.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Encoding {
            /// Which encoding to use.
            pub encoding: std::option::Option<crate::model::r#type::r#struct::encoding::Encoding>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Encoding {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [encoding][crate::model::r#type::r#struct::Encoding::encoding].
            ///
            /// Note that all the setters affecting `encoding` are mutually
            /// exclusive.
            pub fn set_encoding<
                T: std::convert::Into<
                        std::option::Option<crate::model::r#type::r#struct::encoding::Encoding>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }

            /// The value of [encoding][crate::model::r#type::r#struct::Encoding::encoding]
            /// if it holds a `Singleton`, `None` if the field is not set or
            /// holds a different branch.
            pub fn singleton(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::r#type::r#struct::encoding::Singleton>,
            > {
                #[allow(unreachable_patterns)]
                self.encoding.as_ref().and_then(|v| match v {
                    crate::model::r#type::r#struct::encoding::Encoding::Singleton(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [encoding][crate::model::r#type::r#struct::Encoding::encoding]
            /// to hold a `Singleton`.
            ///
            /// Note that all the setters affecting `encoding` are
            /// mutually exclusive.
            pub fn set_singleton<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::r#type::r#struct::encoding::Singleton>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = std::option::Option::Some(
                    crate::model::r#type::r#struct::encoding::Encoding::Singleton(v.into()),
                );
                self
            }

            /// The value of [encoding][crate::model::r#type::r#struct::Encoding::encoding]
            /// if it holds a `DelimitedBytes`, `None` if the field is not set or
            /// holds a different branch.
            pub fn delimited_bytes(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::r#type::r#struct::encoding::DelimitedBytes>,
            > {
                #[allow(unreachable_patterns)]
                self.encoding.as_ref().and_then(|v| match v {
                    crate::model::r#type::r#struct::encoding::Encoding::DelimitedBytes(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [encoding][crate::model::r#type::r#struct::Encoding::encoding]
            /// to hold a `DelimitedBytes`.
            ///
            /// Note that all the setters affecting `encoding` are
            /// mutually exclusive.
            pub fn set_delimited_bytes<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::r#type::r#struct::encoding::DelimitedBytes>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = std::option::Option::Some(
                    crate::model::r#type::r#struct::encoding::Encoding::DelimitedBytes(v.into()),
                );
                self
            }

            /// The value of [encoding][crate::model::r#type::r#struct::Encoding::encoding]
            /// if it holds a `OrderedCodeBytes`, `None` if the field is not set or
            /// holds a different branch.
            pub fn ordered_code_bytes(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::r#type::r#struct::encoding::OrderedCodeBytes>,
            > {
                #[allow(unreachable_patterns)]
                self.encoding.as_ref().and_then(|v| match v {
                    crate::model::r#type::r#struct::encoding::Encoding::OrderedCodeBytes(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [encoding][crate::model::r#type::r#struct::Encoding::encoding]
            /// to hold a `OrderedCodeBytes`.
            ///
            /// Note that all the setters affecting `encoding` are
            /// mutually exclusive.
            pub fn set_ordered_code_bytes<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::r#type::r#struct::encoding::OrderedCodeBytes>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = std::option::Option::Some(
                    crate::model::r#type::r#struct::encoding::Encoding::OrderedCodeBytes(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for Encoding {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Struct.Encoding"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Encoding {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __singleton,
                    __delimited_bytes,
                    __ordered_code_bytes,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Encoding")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "singleton" => Ok(__FieldTag::__singleton),
                                    "delimitedBytes" => Ok(__FieldTag::__delimited_bytes),
                                    "delimited_bytes" => Ok(__FieldTag::__delimited_bytes),
                                    "orderedCodeBytes" => Ok(__FieldTag::__ordered_code_bytes),
                                    "ordered_code_bytes" => Ok(__FieldTag::__ordered_code_bytes),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Encoding;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Encoding")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__singleton => {
                                    if !fields.insert(__FieldTag::__singleton) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for singleton",
                                            ),
                                        );
                                    }
                                    if result.encoding.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `encoding`, a oneof with full ID .google.bigtable.admin.v2.Type.Struct.Encoding.singleton, latest field was singleton",
                                            ),
                                        );
                                    }
                                    result.encoding = std::option::Option::Some(
                                        crate::model::r#type::r#struct::encoding::Encoding::Singleton(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::r#type::r#struct::encoding::Singleton>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__delimited_bytes => {
                                    if !fields.insert(__FieldTag::__delimited_bytes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for delimited_bytes",
                                            ),
                                        );
                                    }
                                    if result.encoding.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `encoding`, a oneof with full ID .google.bigtable.admin.v2.Type.Struct.Encoding.delimited_bytes, latest field was delimitedBytes",
                                            ),
                                        );
                                    }
                                    result.encoding = std::option::Option::Some(
                                        crate::model::r#type::r#struct::encoding::Encoding::DelimitedBytes(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::r#type::r#struct::encoding::DelimitedBytes>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__ordered_code_bytes => {
                                    if !fields.insert(__FieldTag::__ordered_code_bytes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for ordered_code_bytes",
                                            ),
                                        );
                                    }
                                    if result.encoding.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `encoding`, a oneof with full ID .google.bigtable.admin.v2.Type.Struct.Encoding.ordered_code_bytes, latest field was orderedCodeBytes",
                                            ),
                                        );
                                    }
                                    result.encoding = std::option::Option::Some(
                                        crate::model::r#type::r#struct::encoding::Encoding::OrderedCodeBytes(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::r#type::r#struct::encoding::OrderedCodeBytes>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Encoding {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.singleton() {
                    state.serialize_entry("singleton", value)?;
                }
                if let Some(value) = self.delimited_bytes() {
                    state.serialize_entry("delimitedBytes", value)?;
                }
                if let Some(value) = self.ordered_code_bytes() {
                    state.serialize_entry("orderedCodeBytes", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [Encoding].
        pub mod encoding {
            #[allow(unused_imports)]
            use super::*;

            /// Uses the encoding of `fields[0].type` as-is.
            /// Only valid if `fields.size == 1`.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Singleton {
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Singleton {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for Singleton {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.Struct.Encoding.Singleton"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Singleton {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Singleton")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    Ok(__FieldTag::Unknown(value.to_string()))
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Singleton;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Singleton")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Singleton {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Fields are encoded independently and concatenated with a configurable
            /// `delimiter` in between.
            ///
            /// A struct with no fields defined is encoded as a single `delimiter`.
            ///
            /// Sorted mode:
            ///
            /// - Fields are encoded in sorted mode.
            /// - Encoded field values must not contain any bytes <= `delimiter[0]`
            /// - Element-wise order is preserved: `A < B` if `A[0] < B[0]`, or if
            ///   `A[0] == B[0] && A[1] < B[1]`, etc. Strict prefixes sort first.
            ///
            /// Distinct mode:
            ///
            /// - Fields are encoded in distinct mode.
            /// - Encoded field values must not contain `delimiter[0]`.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct DelimitedBytes {
                /// Byte sequence used to delimit concatenated fields. The delimiter must
                /// contain at least 1 character and at most 50 characters.
                pub delimiter: ::bytes::Bytes,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl DelimitedBytes {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [delimiter][crate::model::r#type::r#struct::encoding::DelimitedBytes::delimiter].
                pub fn set_delimiter<T: std::convert::Into<::bytes::Bytes>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.delimiter = v.into();
                    self
                }
            }

            impl wkt::message::Message for DelimitedBytes {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.Struct.Encoding.DelimitedBytes"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for DelimitedBytes {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __delimiter,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for DelimitedBytes")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "delimiter" => Ok(__FieldTag::__delimiter),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = DelimitedBytes;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct DelimitedBytes")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__delimiter => {
                                        if !fields.insert(__FieldTag::__delimiter) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for delimiter",
                                                ),
                                            );
                                        }
                                        struct __With(std::option::Option<::bytes::Bytes>);
                                        impl<'de> serde::de::Deserialize<'de> for __With {
                                            fn deserialize<D>(
                                                deserializer: D,
                                            ) -> std::result::Result<Self, D::Error>
                                            where
                                                D: serde::de::Deserializer<'de>,
                                            {
                                                serde_with::As::<
                                                    std::option::Option<serde_with::base64::Base64>,
                                                >::deserialize(
                                                    deserializer
                                                )
                                                .map(__With)
                                            }
                                        }
                                        result.delimiter =
                                            map.next_value::<__With>()?.0.unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for DelimitedBytes {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.delimiter.is_empty() {
                        struct __With<'a>(&'a ::bytes::Bytes);
                        impl<'a> serde::ser::Serialize for __With<'a> {
                            fn serialize<S>(
                                &self,
                                serializer: S,
                            ) -> std::result::Result<S::Ok, S::Error>
                            where
                                S: serde::ser::Serializer,
                            {
                                serde_with::As::<serde_with::base64::Base64>::serialize(
                                    self.0, serializer,
                                )
                            }
                        }
                        state.serialize_entry("delimiter", &__With(&self.delimiter))?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Fields are encoded independently and concatenated with the fixed byte
            /// pair {0x00, 0x01} in between.
            ///
            /// Any null (0x00) byte in an encoded field is replaced by the fixed byte
            /// pair {0x00, 0xFF}.
            ///
            /// Fields that encode to the empty string "" have special handling:
            ///
            /// - If *every* field encodes to "", or if the STRUCT has no fields
            ///   defined, then the STRUCT is encoded as the fixed byte pair
            ///   {0x00, 0x00}.
            /// - Otherwise, the STRUCT only encodes until the last non-empty field,
            ///   omitting any trailing empty fields. Any empty fields that aren't
            ///   omitted are replaced with the fixed byte pair {0x00, 0x00}.
            ///
            /// Examples:
            ///
            /// - STRUCT()             -> "\00\00"
            /// - STRUCT("")           -> "\00\00"
            /// - STRUCT("", "")       -> "\00\00"
            /// - STRUCT("", "B")      -> "\00\00" + "\00\01" + "B"
            /// - STRUCT("A", "")      -> "A"
            /// - STRUCT("", "B", "")  -> "\00\00" + "\00\01" + "B"
            /// - STRUCT("A", "", "C") -> "A" + "\00\01" + "\00\00" + "\00\01" + "C"
            ///
            /// Since null bytes are always escaped, this encoding can cause size
            /// blowup for encodings like `Int64.BigEndianBytes` that are likely to
            /// produce many such bytes.
            ///
            /// Sorted mode:
            ///
            /// - Fields are encoded in sorted mode.
            /// - All values supported by the field encodings are allowed
            /// - Element-wise order is preserved: `A < B` if `A[0] < B[0]`, or if
            ///   `A[0] == B[0] && A[1] < B[1]`, etc. Strict prefixes sort first.
            ///
            /// Distinct mode:
            ///
            /// - Fields are encoded in distinct mode.
            /// - All values supported by the field encodings are allowed.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct OrderedCodeBytes {
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl OrderedCodeBytes {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for OrderedCodeBytes {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.Struct.Encoding.OrderedCodeBytes"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for OrderedCodeBytes {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for OrderedCodeBytes")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    Ok(__FieldTag::Unknown(value.to_string()))
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = OrderedCodeBytes;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct OrderedCodeBytes")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for OrderedCodeBytes {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// Which encoding to use.
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Encoding {
                /// Use `Singleton` encoding.
                Singleton(std::boxed::Box<crate::model::r#type::r#struct::encoding::Singleton>),
                /// Use `DelimitedBytes` encoding.
                DelimitedBytes(
                    std::boxed::Box<crate::model::r#type::r#struct::encoding::DelimitedBytes>,
                ),
                /// User `OrderedCodeBytes` encoding.
                OrderedCodeBytes(
                    std::boxed::Box<crate::model::r#type::r#struct::encoding::OrderedCodeBytes>,
                ),
            }
        }
    }

    /// An ordered list of elements of a given type.
    /// Values of type `Array` are stored in `Value.array_value`.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Array {
        /// The type of the elements in the array. This must not be `Array`.
        pub element_type: std::option::Option<std::boxed::Box<crate::model::Type>>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Array {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [element_type][crate::model::r#type::Array::element_type].
        pub fn set_element_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Type>,
        {
            self.element_type = std::option::Option::Some(std::boxed::Box::new(v.into()));
            self
        }

        /// Sets or clears the value of [element_type][crate::model::r#type::Array::element_type].
        pub fn set_or_clear_element_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Type>,
        {
            self.element_type = v.map(|x| std::boxed::Box::new(x.into()));
            self
        }
    }

    impl wkt::message::Message for Array {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Array"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Array {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __element_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Array")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "elementType" => Ok(__FieldTag::__element_type),
                                "element_type" => Ok(__FieldTag::__element_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Array;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Array")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__element_type => {
                                if !fields.insert(__FieldTag::__element_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for element_type",
                                    ));
                                }
                                result.element_type = map.next_value::<std::option::Option<std::boxed::Box<crate::model::Type>>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Array {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.element_type.is_some() {
                state.serialize_entry("elementType", &self.element_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A mapping of keys to values of a given type.
    /// Values of type `Map` are stored in a `Value.array_value` where each entry
    /// is another `Value.array_value` with two elements (the key and the value,
    /// in that order).
    /// Normally encoded Map values won't have repeated keys, however, clients are
    /// expected to handle the case in which they do. If the same key appears
    /// multiple times, the _last_ value takes precedence.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Map {
        /// The type of a map key.
        /// Only `Bytes`, `String`, and `Int64` are allowed as key types.
        pub key_type: std::option::Option<std::boxed::Box<crate::model::Type>>,

        /// The type of the values in a map.
        pub value_type: std::option::Option<std::boxed::Box<crate::model::Type>>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Map {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key_type][crate::model::r#type::Map::key_type].
        pub fn set_key_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Type>,
        {
            self.key_type = std::option::Option::Some(std::boxed::Box::new(v.into()));
            self
        }

        /// Sets or clears the value of [key_type][crate::model::r#type::Map::key_type].
        pub fn set_or_clear_key_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Type>,
        {
            self.key_type = v.map(|x| std::boxed::Box::new(x.into()));
            self
        }

        /// Sets the value of [value_type][crate::model::r#type::Map::value_type].
        pub fn set_value_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Type>,
        {
            self.value_type = std::option::Option::Some(std::boxed::Box::new(v.into()));
            self
        }

        /// Sets or clears the value of [value_type][crate::model::r#type::Map::value_type].
        pub fn set_or_clear_value_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Type>,
        {
            self.value_type = v.map(|x| std::boxed::Box::new(x.into()));
            self
        }
    }

    impl wkt::message::Message for Map {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Map"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Map {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key_type,
                __value_type,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Map")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "keyType" => Ok(__FieldTag::__key_type),
                                "key_type" => Ok(__FieldTag::__key_type),
                                "valueType" => Ok(__FieldTag::__value_type),
                                "value_type" => Ok(__FieldTag::__value_type),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Map;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Map")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key_type => {
                                if !fields.insert(__FieldTag::__key_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key_type",
                                    ));
                                }
                                result.key_type = map.next_value::<std::option::Option<std::boxed::Box<crate::model::Type>>>()?
                                    ;
                            }
                            __FieldTag::__value_type => {
                                if !fields.insert(__FieldTag::__value_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value_type",
                                    ));
                                }
                                result.value_type = map.next_value::<std::option::Option<std::boxed::Box<crate::model::Type>>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Map {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.key_type.is_some() {
                state.serialize_entry("keyType", &self.key_type)?;
            }
            if self.value_type.is_some() {
                state.serialize_entry("valueType", &self.value_type)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A value that combines incremental updates into a summarized value.
    ///
    /// Data is never directly written or read using type `Aggregate`. Writes will
    /// provide either the `input_type` or `state_type`, and reads will always
    /// return the `state_type` .
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Aggregate {
        /// Type of the inputs that are accumulated by this `Aggregate`, which must
        /// specify a full encoding.
        /// Use `AddInput` mutations to accumulate new inputs.
        pub input_type: std::option::Option<std::boxed::Box<crate::model::Type>>,

        /// Output only. Type that holds the internal accumulator state for the
        /// `Aggregate`. This is a function of the `input_type` and `aggregator`
        /// chosen, and will always specify a full encoding.
        pub state_type: std::option::Option<std::boxed::Box<crate::model::Type>>,

        /// Which aggregator function to use. The configured types must match.
        pub aggregator: std::option::Option<crate::model::r#type::aggregate::Aggregator>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Aggregate {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [input_type][crate::model::r#type::Aggregate::input_type].
        pub fn set_input_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Type>,
        {
            self.input_type = std::option::Option::Some(std::boxed::Box::new(v.into()));
            self
        }

        /// Sets or clears the value of [input_type][crate::model::r#type::Aggregate::input_type].
        pub fn set_or_clear_input_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Type>,
        {
            self.input_type = v.map(|x| std::boxed::Box::new(x.into()));
            self
        }

        /// Sets the value of [state_type][crate::model::r#type::Aggregate::state_type].
        pub fn set_state_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Type>,
        {
            self.state_type = std::option::Option::Some(std::boxed::Box::new(v.into()));
            self
        }

        /// Sets or clears the value of [state_type][crate::model::r#type::Aggregate::state_type].
        pub fn set_or_clear_state_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Type>,
        {
            self.state_type = v.map(|x| std::boxed::Box::new(x.into()));
            self
        }

        /// Sets the value of [aggregator][crate::model::r#type::Aggregate::aggregator].
        ///
        /// Note that all the setters affecting `aggregator` are mutually
        /// exclusive.
        pub fn set_aggregator<
            T: std::convert::Into<std::option::Option<crate::model::r#type::aggregate::Aggregator>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aggregator = v.into();
            self
        }

        /// The value of [aggregator][crate::model::r#type::Aggregate::aggregator]
        /// if it holds a `Sum`, `None` if the field is not set or
        /// holds a different branch.
        pub fn sum(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::r#type::aggregate::Sum>> {
            #[allow(unreachable_patterns)]
            self.aggregator.as_ref().and_then(|v| match v {
                crate::model::r#type::aggregate::Aggregator::Sum(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [aggregator][crate::model::r#type::Aggregate::aggregator]
        /// to hold a `Sum`.
        ///
        /// Note that all the setters affecting `aggregator` are
        /// mutually exclusive.
        pub fn set_sum<
            T: std::convert::Into<std::boxed::Box<crate::model::r#type::aggregate::Sum>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aggregator = std::option::Option::Some(
                crate::model::r#type::aggregate::Aggregator::Sum(v.into()),
            );
            self
        }

        /// The value of [aggregator][crate::model::r#type::Aggregate::aggregator]
        /// if it holds a `HllppUniqueCount`, `None` if the field is not set or
        /// holds a different branch.
        pub fn hllpp_unique_count(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::r#type::aggregate::HyperLogLogPlusPlusUniqueCount>,
        > {
            #[allow(unreachable_patterns)]
            self.aggregator.as_ref().and_then(|v| match v {
                crate::model::r#type::aggregate::Aggregator::HllppUniqueCount(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [aggregator][crate::model::r#type::Aggregate::aggregator]
        /// to hold a `HllppUniqueCount`.
        ///
        /// Note that all the setters affecting `aggregator` are
        /// mutually exclusive.
        pub fn set_hllpp_unique_count<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::r#type::aggregate::HyperLogLogPlusPlusUniqueCount,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aggregator = std::option::Option::Some(
                crate::model::r#type::aggregate::Aggregator::HllppUniqueCount(v.into()),
            );
            self
        }

        /// The value of [aggregator][crate::model::r#type::Aggregate::aggregator]
        /// if it holds a `Max`, `None` if the field is not set or
        /// holds a different branch.
        pub fn max(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::r#type::aggregate::Max>> {
            #[allow(unreachable_patterns)]
            self.aggregator.as_ref().and_then(|v| match v {
                crate::model::r#type::aggregate::Aggregator::Max(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [aggregator][crate::model::r#type::Aggregate::aggregator]
        /// to hold a `Max`.
        ///
        /// Note that all the setters affecting `aggregator` are
        /// mutually exclusive.
        pub fn set_max<
            T: std::convert::Into<std::boxed::Box<crate::model::r#type::aggregate::Max>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aggregator = std::option::Option::Some(
                crate::model::r#type::aggregate::Aggregator::Max(v.into()),
            );
            self
        }

        /// The value of [aggregator][crate::model::r#type::Aggregate::aggregator]
        /// if it holds a `Min`, `None` if the field is not set or
        /// holds a different branch.
        pub fn min(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::r#type::aggregate::Min>> {
            #[allow(unreachable_patterns)]
            self.aggregator.as_ref().and_then(|v| match v {
                crate::model::r#type::aggregate::Aggregator::Min(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [aggregator][crate::model::r#type::Aggregate::aggregator]
        /// to hold a `Min`.
        ///
        /// Note that all the setters affecting `aggregator` are
        /// mutually exclusive.
        pub fn set_min<
            T: std::convert::Into<std::boxed::Box<crate::model::r#type::aggregate::Min>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aggregator = std::option::Option::Some(
                crate::model::r#type::aggregate::Aggregator::Min(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Aggregate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Aggregate"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Aggregate {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __input_type,
                __state_type,
                __sum,
                __hllpp_unique_count,
                __max,
                __min,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Aggregate")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "inputType" => Ok(__FieldTag::__input_type),
                                "input_type" => Ok(__FieldTag::__input_type),
                                "stateType" => Ok(__FieldTag::__state_type),
                                "state_type" => Ok(__FieldTag::__state_type),
                                "sum" => Ok(__FieldTag::__sum),
                                "hllppUniqueCount" => Ok(__FieldTag::__hllpp_unique_count),
                                "hllpp_unique_count" => Ok(__FieldTag::__hllpp_unique_count),
                                "max" => Ok(__FieldTag::__max),
                                "min" => Ok(__FieldTag::__min),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Aggregate;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Aggregate")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__input_type => {
                                if !fields.insert(__FieldTag::__input_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for input_type",
                                    ));
                                }
                                result.input_type = map.next_value::<std::option::Option<std::boxed::Box<crate::model::Type>>>()?
                                    ;
                            }
                            __FieldTag::__state_type => {
                                if !fields.insert(__FieldTag::__state_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state_type",
                                    ));
                                }
                                result.state_type = map.next_value::<std::option::Option<std::boxed::Box<crate::model::Type>>>()?
                                    ;
                            }
                            __FieldTag::__sum => {
                                if !fields.insert(__FieldTag::__sum) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sum",
                                    ));
                                }
                                if result.aggregator.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `aggregator`, a oneof with full ID .google.bigtable.admin.v2.Type.Aggregate.sum, latest field was sum",
                                    ));
                                }
                                result.aggregator = std::option::Option::Some(
                                    crate::model::r#type::aggregate::Aggregator::Sum(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::r#type::aggregate::Sum>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__hllpp_unique_count => {
                                if !fields.insert(__FieldTag::__hllpp_unique_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for hllpp_unique_count",
                                    ));
                                }
                                if result.aggregator.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `aggregator`, a oneof with full ID .google.bigtable.admin.v2.Type.Aggregate.hllpp_unique_count, latest field was hllppUniqueCount",
                                    ));
                                }
                                result.aggregator = std::option::Option::Some(
                                    crate::model::r#type::aggregate::Aggregator::HllppUniqueCount(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::r#type::aggregate::HyperLogLogPlusPlusUniqueCount>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__max => {
                                if !fields.insert(__FieldTag::__max) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for max",
                                    ));
                                }
                                if result.aggregator.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `aggregator`, a oneof with full ID .google.bigtable.admin.v2.Type.Aggregate.max, latest field was max",
                                    ));
                                }
                                result.aggregator = std::option::Option::Some(
                                    crate::model::r#type::aggregate::Aggregator::Max(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::r#type::aggregate::Max>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__min => {
                                if !fields.insert(__FieldTag::__min) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for min",
                                    ));
                                }
                                if result.aggregator.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `aggregator`, a oneof with full ID .google.bigtable.admin.v2.Type.Aggregate.min, latest field was min",
                                    ));
                                }
                                result.aggregator = std::option::Option::Some(
                                    crate::model::r#type::aggregate::Aggregator::Min(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::r#type::aggregate::Min>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Aggregate {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.input_type.is_some() {
                state.serialize_entry("inputType", &self.input_type)?;
            }
            if self.state_type.is_some() {
                state.serialize_entry("stateType", &self.state_type)?;
            }
            if let Some(value) = self.sum() {
                state.serialize_entry("sum", value)?;
            }
            if let Some(value) = self.hllpp_unique_count() {
                state.serialize_entry("hllppUniqueCount", value)?;
            }
            if let Some(value) = self.max() {
                state.serialize_entry("max", value)?;
            }
            if let Some(value) = self.min() {
                state.serialize_entry("min", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Aggregate].
    pub mod aggregate {
        #[allow(unused_imports)]
        use super::*;

        /// Computes the sum of the input values.
        /// Allowed input: `Int64`
        /// State: same as input
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Sum {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Sum {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for Sum {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Aggregate.Sum"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Sum {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Sum")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Sum;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Sum")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Sum {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Computes the max of the input values.
        /// Allowed input: `Int64`
        /// State: same as input
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Max {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Max {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for Max {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Aggregate.Max"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Max {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Max")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Max;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Max")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Max {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Computes the min of the input values.
        /// Allowed input: `Int64`
        /// State: same as input
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Min {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Min {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for Min {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Aggregate.Min"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Min {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Min")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Min;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Min")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Min {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Computes an approximate unique count over the input values. When using
        /// raw data as input, be careful to use a consistent encoding. Otherwise
        /// the same value encoded differently could count more than once, or two
        /// distinct values could count as identical.
        /// Input: Any, or omit for Raw
        /// State: TBD
        /// Special state conversions: `Int64` (the unique count estimate)
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct HyperLogLogPlusPlusUniqueCount {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl HyperLogLogPlusPlusUniqueCount {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for HyperLogLogPlusPlusUniqueCount {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Aggregate.HyperLogLogPlusPlusUniqueCount"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for HyperLogLogPlusPlusUniqueCount {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter
                                    .write_str("a field name for HyperLogLogPlusPlusUniqueCount")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = HyperLogLogPlusPlusUniqueCount;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct HyperLogLogPlusPlusUniqueCount")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for HyperLogLogPlusPlusUniqueCount {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Which aggregator function to use. The configured types must match.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Aggregator {
            /// Sum aggregator.
            Sum(std::boxed::Box<crate::model::r#type::aggregate::Sum>),
            /// HyperLogLogPlusPlusUniqueCount aggregator.
            HllppUniqueCount(
                std::boxed::Box<crate::model::r#type::aggregate::HyperLogLogPlusPlusUniqueCount>,
            ),
            /// Max aggregator.
            Max(std::boxed::Box<crate::model::r#type::aggregate::Max>),
            /// Min aggregator.
            Min(std::boxed::Box<crate::model::r#type::aggregate::Min>),
        }
    }

    /// The kind of type that this represents.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// Bytes
        BytesType(std::boxed::Box<crate::model::r#type::Bytes>),
        /// String
        StringType(std::boxed::Box<crate::model::r#type::String>),
        /// Int64
        Int64Type(std::boxed::Box<crate::model::r#type::Int64>),
        /// Float32
        Float32Type(std::boxed::Box<crate::model::r#type::Float32>),
        /// Float64
        Float64Type(std::boxed::Box<crate::model::r#type::Float64>),
        /// Bool
        BoolType(std::boxed::Box<crate::model::r#type::Bool>),
        /// Timestamp
        TimestampType(std::boxed::Box<crate::model::r#type::Timestamp>),
        /// Date
        DateType(std::boxed::Box<crate::model::r#type::Date>),
        /// Aggregate
        AggregateType(std::boxed::Box<crate::model::r#type::Aggregate>),
        /// Struct
        StructType(std::boxed::Box<crate::model::r#type::Struct>),
        /// Array
        ArrayType(std::boxed::Box<crate::model::r#type::Array>),
        /// Map
        MapType(std::boxed::Box<crate::model::r#type::Map>),
    }
}

/// Storage media types for persisting Bigtable data.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum StorageType {
    /// The user did not specify a storage type.
    Unspecified,
    /// Flash (SSD) storage should be used.
    Ssd,
    /// Magnetic drive (HDD) storage should be used.
    Hdd,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [StorageType::value] or
    /// [StorageType::name].
    UnknownValue(storage_type::UnknownValue),
}

#[doc(hidden)]
pub mod storage_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl StorageType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Ssd => std::option::Option::Some(1),
            Self::Hdd => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STORAGE_TYPE_UNSPECIFIED"),
            Self::Ssd => std::option::Option::Some("SSD"),
            Self::Hdd => std::option::Option::Some("HDD"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for StorageType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for StorageType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for StorageType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Ssd,
            2 => Self::Hdd,
            _ => Self::UnknownValue(storage_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for StorageType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STORAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "SSD" => Self::Ssd,
            "HDD" => Self::Hdd,
            _ => Self::UnknownValue(storage_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for StorageType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Ssd => serializer.serialize_i32(1),
            Self::Hdd => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for StorageType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageType>::new(
            ".google.bigtable.admin.v2.StorageType",
        ))
    }
}

/// Indicates the type of the restore source.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum RestoreSourceType {
    /// No restore associated.
    Unspecified,
    /// A backup was used as the source of the restore.
    Backup,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [RestoreSourceType::value] or
    /// [RestoreSourceType::name].
    UnknownValue(restore_source_type::UnknownValue),
}

#[doc(hidden)]
pub mod restore_source_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl RestoreSourceType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Backup => std::option::Option::Some(1),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RESTORE_SOURCE_TYPE_UNSPECIFIED"),
            Self::Backup => std::option::Option::Some("BACKUP"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for RestoreSourceType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for RestoreSourceType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for RestoreSourceType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Backup,
            _ => Self::UnknownValue(restore_source_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for RestoreSourceType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RESTORE_SOURCE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "BACKUP" => Self::Backup,
            _ => Self::UnknownValue(restore_source_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for RestoreSourceType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Backup => serializer.serialize_i32(1),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for RestoreSourceType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<RestoreSourceType>::new(
            ".google.bigtable.admin.v2.RestoreSourceType",
        ))
    }
}
