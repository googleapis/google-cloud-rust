// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::invalid_html_tags)]
#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for BigtableInstanceAdmin.CreateInstance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The unique name of the project in which to create the new
    /// instance. Values are of the form `projects/{project}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to be used when referring to the new instance within its
    /// project, e.g., just `myinstance` rather than
    /// `projects/myproject/instances/myinstance`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. The instance to create.
    /// Fields marked `OutputOnly` must be left blank.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Required. The clusters to be created within the instance, mapped by desired
    /// cluster ID, e.g., just `mycluster` rather than
    /// `projects/myproject/instances/myinstance/clusters/mycluster`.
    /// Fields marked `OutputOnly` must be left blank.
    /// Currently, at most four clusters can be specified.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub clusters: std::collections::HashMap<std::string::String, crate::model::Cluster>,
}

impl CreateInstanceRequest {
    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [clusters][crate::model::CreateInstanceRequest::clusters].
    pub fn set_clusters<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateInstanceRequest"
    }
}

/// Request message for BigtableInstanceAdmin.GetInstance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The unique name of the requested instance. Values are of the form
    /// `projects/{project}/instances/{instance}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetInstanceRequest {
    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetInstanceRequest"
    }
}

/// Request message for BigtableInstanceAdmin.ListInstances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The unique name of the project for which a list of instances is
    /// requested. Values are of the form `projects/{project}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// DEPRECATED: This field is unused and ignored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListInstancesRequest {
    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListInstancesRequest"
    }
}

/// Response message for BigtableInstanceAdmin.ListInstances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// The list of requested instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// Locations from which Instance information could not be retrieved,
    /// due to an outage or some other transient condition.
    /// Instances whose Clusters are all in one of the failed locations
    /// may be missing from `instances`, and Instances with at least one
    /// Cluster in a failed location may only have partial information returned.
    /// Values are of the form `projects/<project>/locations/<zone_id>`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub failed_locations: std::vec::Vec<std::string::String>,

    /// DEPRECATED: This field is unused and ignored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListInstancesResponse {
    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [failed_locations][crate::model::ListInstancesResponse::failed_locations].
    pub fn set_failed_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.failed_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListInstancesResponse"
    }
}

/// Request message for BigtableInstanceAdmin.PartialUpdateInstance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PartialUpdateInstanceRequest {
    /// Required. The Instance which will (partially) replace the current value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Required. The subset of Instance fields which should be replaced.
    /// Must be explicitly set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl PartialUpdateInstanceRequest {
    /// Sets the value of [instance][crate::model::PartialUpdateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::PartialUpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for PartialUpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.PartialUpdateInstanceRequest"
    }
}

/// Request message for BigtableInstanceAdmin.DeleteInstance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The unique name of the instance to be deleted.
    /// Values are of the form `projects/{project}/instances/{instance}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteInstanceRequest {
    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteInstanceRequest"
    }
}

/// Request message for BigtableInstanceAdmin.CreateCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The unique name of the instance in which to create the new
    /// cluster. Values are of the form `projects/{project}/instances/{instance}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to be used when referring to the new cluster within its
    /// instance, e.g., just `mycluster` rather than
    /// `projects/myproject/instances/myinstance/clusters/mycluster`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_id: std::string::String,

    /// Required. The cluster to be created.
    /// Fields marked `OutputOnly` must be left blank.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,
}

impl CreateClusterRequest {
    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateClusterRequest"
    }
}

/// Request message for BigtableInstanceAdmin.GetCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. The unique name of the requested cluster. Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetClusterRequest {
    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetClusterRequest"
    }
}

/// Request message for BigtableInstanceAdmin.ListClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The unique name of the instance for which a list of clusters is
    /// requested. Values are of the form
    /// `projects/{project}/instances/{instance}`. Use `{instance} = '-'` to list
    /// Clusters for all Instances in a project, e.g.,
    /// `projects/myproject/instances/-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// DEPRECATED: This field is unused and ignored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListClustersRequest {
    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListClustersRequest"
    }
}

/// Response message for BigtableInstanceAdmin.ListClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// The list of requested clusters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// Locations from which Cluster information could not be retrieved,
    /// due to an outage or some other transient condition.
    /// Clusters from these locations may be missing from `clusters`,
    /// or may only have partial information returned.
    /// Values are of the form `projects/<project>/locations/<zone_id>`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub failed_locations: std::vec::Vec<std::string::String>,

    /// DEPRECATED: This field is unused and ignored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListClustersResponse {
    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [failed_locations][crate::model::ListClustersResponse::failed_locations].
    pub fn set_failed_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.failed_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListClustersResponse"
    }
}

/// Request message for BigtableInstanceAdmin.DeleteCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. The unique name of the cluster to be deleted. Values are of the
    /// form `projects/{project}/instances/{instance}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteClusterRequest {
    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteClusterRequest"
    }
}

/// The metadata for the Operation returned by CreateInstance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceMetadata {
    /// The request that prompted the initiation of this CreateInstance operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_request: std::option::Option<crate::model::CreateInstanceRequest>,

    /// The time at which the original request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,
}

impl CreateInstanceMetadata {
    /// Sets the value of [original_request][crate::model::CreateInstanceMetadata::original_request].
    pub fn set_original_request<
        T: std::convert::Into<std::option::Option<crate::model::CreateInstanceRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_request = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::CreateInstanceMetadata::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::CreateInstanceMetadata::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateInstanceMetadata"
    }
}

/// The metadata for the Operation returned by UpdateInstance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceMetadata {
    /// The request that prompted the initiation of this UpdateInstance operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_request: std::option::Option<crate::model::PartialUpdateInstanceRequest>,

    /// The time at which the original request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,
}

impl UpdateInstanceMetadata {
    /// Sets the value of [original_request][crate::model::UpdateInstanceMetadata::original_request].
    pub fn set_original_request<
        T: std::convert::Into<std::option::Option<crate::model::PartialUpdateInstanceRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_request = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::UpdateInstanceMetadata::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::UpdateInstanceMetadata::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateInstanceMetadata"
    }
}

/// The metadata for the Operation returned by CreateCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateClusterMetadata {
    /// The request that prompted the initiation of this CreateCluster operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_request: std::option::Option<crate::model::CreateClusterRequest>,

    /// The time at which the original request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,

    /// Keys: the full `name` of each table that existed in the instance when
    /// CreateCluster was first called, i.e.
    /// `projects/<project>/instances/<instance>/tables/<table>`. Any table added
    /// to the instance by a later API call will be created in the new cluster by
    /// that API call, not this one.
    ///
    /// Values: information on how much of a table's data has been copied to the
    /// newly-created cluster so far.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tables: std::collections::HashMap<
        std::string::String,
        crate::model::create_cluster_metadata::TableProgress,
    >,
}

impl CreateClusterMetadata {
    /// Sets the value of [original_request][crate::model::CreateClusterMetadata::original_request].
    pub fn set_original_request<
        T: std::convert::Into<std::option::Option<crate::model::CreateClusterRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_request = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::CreateClusterMetadata::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::CreateClusterMetadata::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }

    /// Sets the value of [tables][crate::model::CreateClusterMetadata::tables].
    pub fn set_tables<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::create_cluster_metadata::TableProgress>,
    {
        use std::iter::Iterator;
        self.tables = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CreateClusterMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateClusterMetadata"
    }
}

/// Defines additional types related to CreateClusterMetadata
pub mod create_cluster_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Progress info for copying a table's data to the new cluster.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TableProgress {
        /// Estimate of the size of the table to be copied.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub estimated_size_bytes: i64,

        /// Estimate of the number of bytes copied so far for this table.
        /// This will eventually reach 'estimated_size_bytes' unless the table copy
        /// is CANCELLED.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub estimated_copied_bytes: i64,

        pub state: crate::model::create_cluster_metadata::table_progress::State,
    }

    impl TableProgress {
        /// Sets the value of [estimated_size_bytes][crate::model::create_cluster_metadata::TableProgress::estimated_size_bytes].
        pub fn set_estimated_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.estimated_size_bytes = v.into();
            self
        }

        /// Sets the value of [estimated_copied_bytes][crate::model::create_cluster_metadata::TableProgress::estimated_copied_bytes].
        pub fn set_estimated_copied_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.estimated_copied_bytes = v.into();
            self
        }

        /// Sets the value of [state][crate::model::create_cluster_metadata::TableProgress::state].
        pub fn set_state<
            T: std::convert::Into<crate::model::create_cluster_metadata::table_progress::State>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }
    }

    impl wkt::message::Message for TableProgress {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.CreateClusterMetadata.TableProgress"
        }
    }

    /// Defines additional types related to TableProgress
    pub mod table_progress {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct State(std::string::String);

        impl State {
            /// Sets the enum value.
            pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.0 = v.into();
                self
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [State](State)
        pub mod state {

            pub const STATE_UNSPECIFIED: &str = "STATE_UNSPECIFIED";

            /// The table has not yet begun copying to the new cluster.
            pub const PENDING: &str = "PENDING";

            /// The table is actively being copied to the new cluster.
            pub const COPYING: &str = "COPYING";

            /// The table has been fully copied to the new cluster.
            pub const COMPLETED: &str = "COMPLETED";

            /// The table was deleted before it finished copying to the new cluster.
            /// Note that tables deleted after completion will stay marked as
            /// COMPLETED, not CANCELLED.
            pub const CANCELLED: &str = "CANCELLED";
        }
    }
}

/// The metadata for the Operation returned by UpdateCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateClusterMetadata {
    /// The request that prompted the initiation of this UpdateCluster operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_request: std::option::Option<crate::model::Cluster>,

    /// The time at which the original request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,
}

impl UpdateClusterMetadata {
    /// Sets the value of [original_request][crate::model::UpdateClusterMetadata::original_request].
    pub fn set_original_request<
        T: std::convert::Into<std::option::Option<crate::model::Cluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_request = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::UpdateClusterMetadata::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::UpdateClusterMetadata::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateClusterMetadata"
    }
}

/// The metadata for the Operation returned by PartialUpdateCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PartialUpdateClusterMetadata {
    /// The time at which the original request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,

    /// The original request for PartialUpdateCluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_request: std::option::Option<crate::model::PartialUpdateClusterRequest>,
}

impl PartialUpdateClusterMetadata {
    /// Sets the value of [request_time][crate::model::PartialUpdateClusterMetadata::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::PartialUpdateClusterMetadata::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }

    /// Sets the value of [original_request][crate::model::PartialUpdateClusterMetadata::original_request].
    pub fn set_original_request<
        T: std::convert::Into<std::option::Option<crate::model::PartialUpdateClusterRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_request = v.into();
        self
    }
}

impl wkt::message::Message for PartialUpdateClusterMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.PartialUpdateClusterMetadata"
    }
}

/// Request message for BigtableInstanceAdmin.PartialUpdateCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PartialUpdateClusterRequest {
    /// Required. The Cluster which contains the partial updates to be applied,
    /// subject to the update_mask.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Required. The subset of Cluster fields which should be replaced.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl PartialUpdateClusterRequest {
    /// Sets the value of [cluster][crate::model::PartialUpdateClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::PartialUpdateClusterRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for PartialUpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.PartialUpdateClusterRequest"
    }
}

/// Request message for BigtableInstanceAdmin.CreateAppProfile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAppProfileRequest {
    /// Required. The unique name of the instance in which to create the new app
    /// profile. Values are of the form `projects/{project}/instances/{instance}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to be used when referring to the new app profile within
    /// its instance, e.g., just `myprofile` rather than
    /// `projects/myproject/instances/myinstance/appProfiles/myprofile`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub app_profile_id: std::string::String,

    /// Required. The app profile to be created.
    /// Fields marked `OutputOnly` will be ignored.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub app_profile: std::option::Option<crate::model::AppProfile>,

    /// If true, ignore safety checks when creating the app profile.
    pub ignore_warnings: bool,
}

impl CreateAppProfileRequest {
    /// Sets the value of [parent][crate::model::CreateAppProfileRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [app_profile_id][crate::model::CreateAppProfileRequest::app_profile_id].
    pub fn set_app_profile_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.app_profile_id = v.into();
        self
    }

    /// Sets the value of [app_profile][crate::model::CreateAppProfileRequest::app_profile].
    pub fn set_app_profile<T: std::convert::Into<std::option::Option<crate::model::AppProfile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.app_profile = v.into();
        self
    }

    /// Sets the value of [ignore_warnings][crate::model::CreateAppProfileRequest::ignore_warnings].
    pub fn set_ignore_warnings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_warnings = v.into();
        self
    }
}

impl wkt::message::Message for CreateAppProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateAppProfileRequest"
    }
}

/// Request message for BigtableInstanceAdmin.GetAppProfile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAppProfileRequest {
    /// Required. The unique name of the requested app profile. Values are of the
    /// form `projects/{project}/instances/{instance}/appProfiles/{app_profile}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetAppProfileRequest {
    /// Sets the value of [name][crate::model::GetAppProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetAppProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetAppProfileRequest"
    }
}

/// Request message for BigtableInstanceAdmin.ListAppProfiles.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAppProfilesRequest {
    /// Required. The unique name of the instance for which a list of app profiles
    /// is requested. Values are of the form
    /// `projects/{project}/instances/{instance}`.
    /// Use `{instance} = '-'` to list AppProfiles for all Instances in a project,
    /// e.g., `projects/myproject/instances/-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Maximum number of results per page.
    ///
    /// A page_size of zero lets the server choose the number of items to return.
    /// A page_size which is strictly positive will return at most that many items.
    /// A negative page_size will cause an error.
    ///
    /// Following the first request, subsequent paginated calls are not required
    /// to pass a page_size. If a page_size is set in subsequent calls, it must
    /// match the page_size given in the first request.
    pub page_size: i32,

    /// The value of `next_page_token` returned by a previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListAppProfilesRequest {
    /// Sets the value of [parent][crate::model::ListAppProfilesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAppProfilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAppProfilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListAppProfilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListAppProfilesRequest"
    }
}

/// Response message for BigtableInstanceAdmin.ListAppProfiles.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAppProfilesResponse {
    /// The list of requested app profiles.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub app_profiles: std::vec::Vec<crate::model::AppProfile>,

    /// Set if not all app profiles could be returned in a single response.
    /// Pass this value to `page_token` in another request to get the next
    /// page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations from which AppProfile information could not be retrieved,
    /// due to an outage or some other transient condition.
    /// AppProfiles from these locations may be missing from `app_profiles`.
    /// Values are of the form `projects/<project>/locations/<zone_id>`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub failed_locations: std::vec::Vec<std::string::String>,
}

impl ListAppProfilesResponse {
    /// Sets the value of [next_page_token][crate::model::ListAppProfilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [app_profiles][crate::model::ListAppProfilesResponse::app_profiles].
    pub fn set_app_profiles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AppProfile>,
    {
        use std::iter::Iterator;
        self.app_profiles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [failed_locations][crate::model::ListAppProfilesResponse::failed_locations].
    pub fn set_failed_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.failed_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAppProfilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListAppProfilesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListAppProfilesResponse {
    type PageItem = crate::model::AppProfile;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.app_profiles
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for BigtableInstanceAdmin.UpdateAppProfile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAppProfileRequest {
    /// Required. The app profile which will (partially) replace the current value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub app_profile: std::option::Option<crate::model::AppProfile>,

    /// Required. The subset of app profile fields which should be replaced.
    /// If unset, all fields will be replaced.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// If true, ignore safety checks when updating the app profile.
    pub ignore_warnings: bool,
}

impl UpdateAppProfileRequest {
    /// Sets the value of [app_profile][crate::model::UpdateAppProfileRequest::app_profile].
    pub fn set_app_profile<T: std::convert::Into<std::option::Option<crate::model::AppProfile>>>(
        mut self,
        v: T,
    ) -> Self {
        self.app_profile = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAppProfileRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [ignore_warnings][crate::model::UpdateAppProfileRequest::ignore_warnings].
    pub fn set_ignore_warnings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_warnings = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAppProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateAppProfileRequest"
    }
}

/// Request message for BigtableInstanceAdmin.DeleteAppProfile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAppProfileRequest {
    /// Required. The unique name of the app profile to be deleted. Values are of
    /// the form
    /// `projects/{project}/instances/{instance}/appProfiles/{app_profile}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. If true, ignore safety checks when deleting the app profile.
    pub ignore_warnings: bool,
}

impl DeleteAppProfileRequest {
    /// Sets the value of [name][crate::model::DeleteAppProfileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ignore_warnings][crate::model::DeleteAppProfileRequest::ignore_warnings].
    pub fn set_ignore_warnings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_warnings = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAppProfileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteAppProfileRequest"
    }
}

/// The metadata for the Operation returned by UpdateAppProfile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAppProfileMetadata {}

impl UpdateAppProfileMetadata {}

impl wkt::message::Message for UpdateAppProfileMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateAppProfileMetadata"
    }
}

/// Request message for BigtableInstanceAdmin.ListHotTablets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHotTabletsRequest {
    /// Required. The cluster name to list hot tablets.
    /// Value is in the following form:
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The start time to list hot tablets. The hot tablets in the response will
    /// have start times between the requested start time and end time. Start time
    /// defaults to Now if it is unset, and end time defaults to Now - 24 hours if
    /// it is unset. The start time should be less than the end time, and the
    /// maximum allowed time range between start time and end time is 48 hours.
    /// Start time and end time should have values between Now and Now - 14 days.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end time to list hot tablets.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Maximum number of results per page.
    ///
    /// A page_size that is empty or zero lets the server choose the number of
    /// items to return. A page_size which is strictly positive will return at most
    /// that many items. A negative page_size will cause an error.
    ///
    /// Following the first request, subsequent paginated calls do not need a
    /// page_size field. If a page_size is set in subsequent calls, it must match
    /// the page_size given in the first request.
    pub page_size: i32,

    /// The value of `next_page_token` returned by a previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListHotTabletsRequest {
    /// Sets the value of [parent][crate::model::ListHotTabletsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ListHotTabletsRequest::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ListHotTabletsRequest::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListHotTabletsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListHotTabletsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListHotTabletsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListHotTabletsRequest"
    }
}

/// Response message for BigtableInstanceAdmin.ListHotTablets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListHotTabletsResponse {
    /// List of hot tablets in the tables of the requested cluster that fall
    /// within the requested time range. Hot tablets are ordered by node cpu usage
    /// percent. If there are multiple hot tablets that correspond to the same
    /// tablet within a 15-minute interval, only the hot tablet with the highest
    /// node cpu usage will be included in the response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub hot_tablets: std::vec::Vec<crate::model::HotTablet>,

    /// Set if not all hot tablets could be returned in a single response.
    /// Pass this value to `page_token` in another request to get the next
    /// page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListHotTabletsResponse {
    /// Sets the value of [next_page_token][crate::model::ListHotTabletsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [hot_tablets][crate::model::ListHotTabletsResponse::hot_tablets].
    pub fn set_hot_tablets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HotTablet>,
    {
        use std::iter::Iterator;
        self.hot_tablets = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListHotTabletsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListHotTabletsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListHotTabletsResponse {
    type PageItem = crate::model::HotTablet;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.hot_tablets
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for
/// [RestoreTable][google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable]: crate::client::BigtableTableAdmin::restore_table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreTableRequest {
    /// Required. The name of the instance in which to create the restored
    /// table. Values are of the form `projects/<project>/instances/<instance>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The id of the table to create and restore to. This
    /// table must not already exist. The `table_id` appended to
    /// `parent` forms the full table name of the form
    /// `projects/<project>/instances/<instance>/tables/<table_id>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Required. The source from which to restore.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::restore_table_request::Source>,
}

impl RestoreTableRequest {
    /// Sets the value of [parent][crate::model::RestoreTableRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::RestoreTableRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of `source`.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::restore_table_request::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }
}

impl wkt::message::Message for RestoreTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.RestoreTableRequest"
    }
}

/// Defines additional types related to RestoreTableRequest
pub mod restore_table_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. The source from which to restore.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Source {
        /// Name of the backup from which to restore.  Values are of the form
        /// `projects/<project>/instances/<instance>/clusters/<cluster>/backups/<backup>`.
        Backup(std::string::String),
    }
}

/// Metadata type for the long-running operation returned by
/// [RestoreTable][google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable]: crate::client::BigtableTableAdmin::restore_table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreTableMetadata {
    /// Name of the table being created and restored to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The type of the restore source.
    pub source_type: crate::model::RestoreSourceType,

    /// If exists, the name of the long-running operation that will be used to
    /// track the post-restore optimization process to optimize the performance of
    /// the restored table. The metadata type of the long-running operation is
    /// [OptimizeRestoreTableMetadata][]. The response type is
    /// [Empty][google.protobuf.Empty]. This long-running operation may be
    /// automatically created by the system if applicable after the
    /// RestoreTable long-running operation completes successfully. This operation
    /// may not be created if the table is already optimized or the restore was
    /// not successful.
    ///
    /// [google.protobuf.Empty]: wkt::Empty
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub optimize_table_operation_name: std::string::String,

    /// The progress of the
    /// [RestoreTable][google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable]
    /// operation.
    ///
    /// [google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable]: crate::client::BigtableTableAdmin::restore_table
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress: std::option::Option<crate::model::OperationProgress>,

    /// Information about the source used to restore the table, as specified by
    /// `source` in
    /// [RestoreTableRequest][google.bigtable.admin.v2.RestoreTableRequest].
    ///
    /// [google.bigtable.admin.v2.RestoreTableRequest]: crate::model::RestoreTableRequest
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_info: std::option::Option<crate::model::restore_table_metadata::SourceInfo>,
}

impl RestoreTableMetadata {
    /// Sets the value of [name][crate::model::RestoreTableMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_type][crate::model::RestoreTableMetadata::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::RestoreSourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of [optimize_table_operation_name][crate::model::RestoreTableMetadata::optimize_table_operation_name].
    pub fn set_optimize_table_operation_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.optimize_table_operation_name = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::RestoreTableMetadata::progress].
    pub fn set_progress<
        T: std::convert::Into<std::option::Option<crate::model::OperationProgress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress = v.into();
        self
    }

    /// Sets the value of `source_info`.
    pub fn set_source_info<
        T: std::convert::Into<std::option::Option<crate::model::restore_table_metadata::SourceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_info = v.into();
        self
    }
}

impl wkt::message::Message for RestoreTableMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.RestoreTableMetadata"
    }
}

/// Defines additional types related to RestoreTableMetadata
pub mod restore_table_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Information about the source used to restore the table, as specified by
    /// `source` in
    /// [RestoreTableRequest][google.bigtable.admin.v2.RestoreTableRequest].
    ///
    /// [google.bigtable.admin.v2.RestoreTableRequest]: crate::model::RestoreTableRequest
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceInfo {
        BackupInfo(crate::model::BackupInfo),
    }
}

/// Metadata type for the long-running operation used to track the progress
/// of optimizations performed on a newly restored table. This long-running
/// operation is automatically created by the system after the successful
/// completion of a table restore, and cannot be cancelled.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OptimizeRestoredTableMetadata {
    /// Name of the restored table being optimized.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The progress of the post-restore optimizations.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress: std::option::Option<crate::model::OperationProgress>,
}

impl OptimizeRestoredTableMetadata {
    /// Sets the value of [name][crate::model::OptimizeRestoredTableMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::OptimizeRestoredTableMetadata::progress].
    pub fn set_progress<
        T: std::convert::Into<std::option::Option<crate::model::OperationProgress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress = v.into();
        self
    }
}

impl wkt::message::Message for OptimizeRestoredTableMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.OptimizeRestoredTableMetadata"
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateTable][google.bigtable.admin.v2.BigtableTableAdmin.CreateTable]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateTable]: crate::client::BigtableTableAdmin::create_table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTableRequest {
    /// Required. The unique name of the instance in which to create the table.
    /// Values are of the form `projects/{project}/instances/{instance}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The name by which the new table should be referred to within the
    /// parent instance, e.g., `foobar` rather than `{parent}/tables/foobar`.
    /// Maximum 50 characters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Required. The Table to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table: std::option::Option<crate::model::Table>,

    /// The optional list of row keys that will be used to initially split the
    /// table into several tablets (tablets are similar to HBase regions).
    /// Given two split keys, `s1` and `s2`, three tablets will be created,
    /// spanning the key ranges: `[, s1), [s1, s2), [s2, )`.
    ///
    /// Example:
    ///
    /// * Row keys := `["a", "apple", "custom", "customer_1", "customer_2",`
    ///   `"other", "zz"]`
    /// * initial_split_keys := `["apple", "customer_1", "customer_2", "other"]`
    /// * Key assignment:
    ///   - Tablet 1 `[, apple)                => {"a"}.`
    ///   - Tablet 2 `[apple, customer_1)      => {"apple", "custom"}.`
    ///   - Tablet 3 `[customer_1, customer_2) => {"customer_1"}.`
    ///   - Tablet 4 `[customer_2, other)      => {"customer_2"}.`
    ///   - Tablet 5 `[other, )                => {"other", "zz"}.`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub initial_splits: std::vec::Vec<crate::model::create_table_request::Split>,
}

impl CreateTableRequest {
    /// Sets the value of [parent][crate::model::CreateTableRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::CreateTableRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [table][crate::model::CreateTableRequest::table].
    pub fn set_table<T: std::convert::Into<std::option::Option<crate::model::Table>>>(
        mut self,
        v: T,
    ) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [initial_splits][crate::model::CreateTableRequest::initial_splits].
    pub fn set_initial_splits<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::create_table_request::Split>,
    {
        use std::iter::Iterator;
        self.initial_splits = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateTableRequest"
    }
}

/// Defines additional types related to CreateTableRequest
pub mod create_table_request {
    #[allow(unused_imports)]
    use super::*;

    /// An initial split point for a newly created table.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Split {
        /// Row key to use as an initial tablet boundary.
        #[serde(skip_serializing_if = "bytes::Bytes::is_empty")]
        #[serde_as(as = "serde_with::base64::Base64")]
        pub key: bytes::Bytes,
    }

    impl Split {
        /// Sets the value of [key][crate::model::create_table_request::Split::key].
        pub fn set_key<T: std::convert::Into<bytes::Bytes>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }
    }

    impl wkt::message::Message for Split {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.CreateTableRequest.Split"
        }
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateTableFromSnapshot][google.bigtable.admin.v2.BigtableTableAdmin.CreateTableFromSnapshot]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateTableFromSnapshot]: crate::client::BigtableTableAdmin::create_table_from_snapshot
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTableFromSnapshotRequest {
    /// Required. The unique name of the instance in which to create the table.
    /// Values are of the form `projects/{project}/instances/{instance}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The name by which the new table should be referred to within the
    /// parent instance, e.g., `foobar` rather than `{parent}/tables/foobar`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_id: std::string::String,

    /// Required. The unique name of the snapshot from which to restore the table.
    /// The snapshot and the table must be in the same instance. Values are of the
    /// form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/{snapshot}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_snapshot: std::string::String,
}

impl CreateTableFromSnapshotRequest {
    /// Sets the value of [parent][crate::model::CreateTableFromSnapshotRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [table_id][crate::model::CreateTableFromSnapshotRequest::table_id].
    pub fn set_table_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_id = v.into();
        self
    }

    /// Sets the value of [source_snapshot][crate::model::CreateTableFromSnapshotRequest::source_snapshot].
    pub fn set_source_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_snapshot = v.into();
        self
    }
}

impl wkt::message::Message for CreateTableFromSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateTableFromSnapshotRequest"
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.DropRowRange][google.bigtable.admin.v2.BigtableTableAdmin.DropRowRange]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.DropRowRange]: crate::client::BigtableTableAdmin::drop_row_range
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DropRowRangeRequest {
    /// Required. The unique name of the table on which to drop a range of rows.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Delete all rows or by prefix.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target: std::option::Option<crate::model::drop_row_range_request::Target>,
}

impl DropRowRangeRequest {
    /// Sets the value of [name][crate::model::DropRowRangeRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of `target`.
    pub fn set_target<
        T: std::convert::Into<std::option::Option<crate::model::drop_row_range_request::Target>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target = v.into();
        self
    }
}

impl wkt::message::Message for DropRowRangeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DropRowRangeRequest"
    }
}

/// Defines additional types related to DropRowRangeRequest
pub mod drop_row_range_request {
    #[allow(unused_imports)]
    use super::*;

    /// Delete all rows or by prefix.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Target {
        /// Delete all rows that start with this row key prefix. Prefix cannot be
        /// zero length.
        RowKeyPrefix(bytes::Bytes),
        /// Delete all rows in the table. Setting this to false is a no-op.
        DeleteAllDataFromTable(bool),
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListTables][google.bigtable.admin.v2.BigtableTableAdmin.ListTables]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListTables]: crate::client::BigtableTableAdmin::list_tables
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTablesRequest {
    /// Required. The unique name of the instance for which tables should be
    /// listed. Values are of the form `projects/{project}/instances/{instance}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The view to be applied to the returned tables' fields.
    /// NAME_ONLY view (default) and REPLICATION_VIEW are supported.
    pub view: crate::model::table::View,

    /// Maximum number of results per page.
    ///
    /// A page_size of zero lets the server choose the number of items to return.
    /// A page_size which is strictly positive will return at most that many items.
    /// A negative page_size will cause an error.
    ///
    /// Following the first request, subsequent paginated calls are not required
    /// to pass a page_size. If a page_size is set in subsequent calls, it must
    /// match the page_size given in the first request.
    pub page_size: i32,

    /// The value of `next_page_token` returned by a previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListTablesRequest {
    /// Sets the value of [parent][crate::model::ListTablesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListTablesRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::table::View>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTablesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTablesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTablesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListTablesRequest"
    }
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListTables][google.bigtable.admin.v2.BigtableTableAdmin.ListTables]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListTables]: crate::client::BigtableTableAdmin::list_tables
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTablesResponse {
    /// The tables present in the requested instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tables: std::vec::Vec<crate::model::Table>,

    /// Set if not all tables could be returned in a single response.
    /// Pass this value to `page_token` in another request to get the next
    /// page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListTablesResponse {
    /// Sets the value of [next_page_token][crate::model::ListTablesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tables][crate::model::ListTablesResponse::tables].
    pub fn set_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Table>,
    {
        use std::iter::Iterator;
        self.tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTablesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListTablesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListTablesResponse {
    type PageItem = crate::model::Table;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tables
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetTable][google.bigtable.admin.v2.BigtableTableAdmin.GetTable]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetTable]: crate::client::BigtableTableAdmin::get_table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTableRequest {
    /// Required. The unique name of the requested table.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The view to be applied to the returned table's fields.
    /// Defaults to `SCHEMA_VIEW` if unspecified.
    pub view: crate::model::table::View,
}

impl GetTableRequest {
    /// Sets the value of [name][crate::model::GetTableRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetTableRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::table::View>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetTableRequest"
    }
}

/// The request for
/// [UpdateTable][google.bigtable.admin.v2.BigtableTableAdmin.UpdateTable].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UpdateTable]: crate::client::BigtableTableAdmin::update_table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTableRequest {
    /// Required. The table to update.
    /// The table's `name` field is used to identify the table to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub table: std::option::Option<crate::model::Table>,

    /// Required. The list of fields to update.
    /// A mask specifying which fields (e.g. `change_stream_config`) in the `table`
    /// field should be updated. This mask is relative to the `table` field, not to
    /// the request message. The wildcard (*) path is currently not supported.
    /// Currently UpdateTable is only supported for the following fields:
    ///
    /// * `change_stream_config`
    /// * `change_stream_config.retention_period`
    /// * `deletion_protection`
    ///
    /// If `column_families` is set in `update_mask`, it will return an
    /// UNIMPLEMENTED error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateTableRequest {
    /// Sets the value of [table][crate::model::UpdateTableRequest::table].
    pub fn set_table<T: std::convert::Into<std::option::Option<crate::model::Table>>>(
        mut self,
        v: T,
    ) -> Self {
        self.table = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateTableRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateTableRequest"
    }
}

/// Metadata type for the operation returned by
/// [UpdateTable][google.bigtable.admin.v2.BigtableTableAdmin.UpdateTable].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UpdateTable]: crate::client::BigtableTableAdmin::update_table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTableMetadata {
    /// The name of the table being updated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The time at which this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation finished or was canceled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl UpdateTableMetadata {
    /// Sets the value of [name][crate::model::UpdateTableMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::UpdateTableMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::UpdateTableMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTableMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateTableMetadata"
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteTable][google.bigtable.admin.v2.BigtableTableAdmin.DeleteTable]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteTable]: crate::client::BigtableTableAdmin::delete_table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTableRequest {
    /// Required. The unique name of the table to be deleted.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteTableRequest {
    /// Sets the value of [name][crate::model::DeleteTableRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteTableRequest"
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable][google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable]: crate::client::BigtableTableAdmin::undelete_table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeleteTableRequest {
    /// Required. The unique name of the table to be restored.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl UndeleteTableRequest {
    /// Sets the value of [name][crate::model::UndeleteTableRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UndeleteTableRequest"
    }
}

/// Metadata type for the operation returned by
/// [google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable][google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UndeleteTable]: crate::client::BigtableTableAdmin::undelete_table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeleteTableMetadata {
    /// The name of the table being restored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The time at which this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation finished or was cancelled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl UndeleteTableMetadata {
    /// Sets the value of [name][crate::model::UndeleteTableMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::UndeleteTableMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::UndeleteTableMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteTableMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UndeleteTableMetadata"
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ModifyColumnFamilies][google.bigtable.admin.v2.BigtableTableAdmin.ModifyColumnFamilies]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ModifyColumnFamilies]: crate::client::BigtableTableAdmin::modify_column_families
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ModifyColumnFamiliesRequest {
    /// Required. The unique name of the table whose families should be modified.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Modifications to be atomically applied to the specified table's
    /// families. Entries are applied in order, meaning that earlier modifications
    /// can be masked by later ones (in the case of repeated updates to the same
    /// family, for example).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub modifications: std::vec::Vec<crate::model::modify_column_families_request::Modification>,

    /// Optional. If true, ignore safety checks when modifying the column families.
    pub ignore_warnings: bool,
}

impl ModifyColumnFamiliesRequest {
    /// Sets the value of [name][crate::model::ModifyColumnFamiliesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ignore_warnings][crate::model::ModifyColumnFamiliesRequest::ignore_warnings].
    pub fn set_ignore_warnings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_warnings = v.into();
        self
    }

    /// Sets the value of [modifications][crate::model::ModifyColumnFamiliesRequest::modifications].
    pub fn set_modifications<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::modify_column_families_request::Modification>,
    {
        use std::iter::Iterator;
        self.modifications = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ModifyColumnFamiliesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ModifyColumnFamiliesRequest"
    }
}

/// Defines additional types related to ModifyColumnFamiliesRequest
pub mod modify_column_families_request {
    #[allow(unused_imports)]
    use super::*;

    /// A create, update, or delete of a particular column family.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Modification {
        /// The ID of the column family to be modified.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub id: std::string::String,

        /// Optional. A mask specifying which fields (e.g. `gc_rule`) in the `update`
        /// mod should be updated, ignored for other modification types. If unset or
        /// empty, we treat it as updating `gc_rule` to be backward compatible.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_mask: std::option::Option<wkt::FieldMask>,

        /// Column family modifications.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub r#mod:
            std::option::Option<crate::model::modify_column_families_request::modification::Mod>,
    }

    impl Modification {
        /// Sets the value of [id][crate::model::modify_column_families_request::Modification::id].
        pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [update_mask][crate::model::modify_column_families_request::Modification::update_mask].
        pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_mask = v.into();
            self
        }

        /// Sets the value of `r#mod`.
        pub fn set_mod<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::modify_column_families_request::modification::Mod,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#mod = v.into();
            self
        }
    }

    impl wkt::message::Message for Modification {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.ModifyColumnFamiliesRequest.Modification"
        }
    }

    /// Defines additional types related to Modification
    pub mod modification {
        #[allow(unused_imports)]
        use super::*;

        /// Column family modifications.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Mod {
            /// Create a new column family with the specified schema, or fail if
            /// one already exists with the given ID.
            Create(crate::model::ColumnFamily),
            /// Update an existing column family to the specified schema, or fail
            /// if no column family exists with the given ID.
            Update(crate::model::ColumnFamily),
            /// Drop (delete) the column family with the given ID, or fail if no such
            /// family exists.
            Drop(bool),
        }
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken][google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken]: crate::client::BigtableTableAdmin::generate_consistency_token
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateConsistencyTokenRequest {
    /// Required. The unique name of the Table for which to create a consistency
    /// token. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GenerateConsistencyTokenRequest {
    /// Sets the value of [name][crate::model::GenerateConsistencyTokenRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GenerateConsistencyTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GenerateConsistencyTokenRequest"
    }
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken][google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken]: crate::client::BigtableTableAdmin::generate_consistency_token
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateConsistencyTokenResponse {
    /// The generated consistency token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub consistency_token: std::string::String,
}

impl GenerateConsistencyTokenResponse {
    /// Sets the value of [consistency_token][crate::model::GenerateConsistencyTokenResponse::consistency_token].
    pub fn set_consistency_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.consistency_token = v.into();
        self
    }
}

impl wkt::message::Message for GenerateConsistencyTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GenerateConsistencyTokenResponse"
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency][google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency]: crate::client::BigtableTableAdmin::check_consistency
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckConsistencyRequest {
    /// Required. The unique name of the Table for which to check replication
    /// consistency. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The token created using GenerateConsistencyToken for the Table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub consistency_token: std::string::String,

    /// Which type of read needs to consistently observe which type of write?
    /// Default: `standard_read_remote_writes`
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub mode: std::option::Option<crate::model::check_consistency_request::Mode>,
}

impl CheckConsistencyRequest {
    /// Sets the value of [name][crate::model::CheckConsistencyRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [consistency_token][crate::model::CheckConsistencyRequest::consistency_token].
    pub fn set_consistency_token<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.consistency_token = v.into();
        self
    }

    /// Sets the value of `mode`.
    pub fn set_mode<
        T: std::convert::Into<std::option::Option<crate::model::check_consistency_request::Mode>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }
}

impl wkt::message::Message for CheckConsistencyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CheckConsistencyRequest"
    }
}

/// Defines additional types related to CheckConsistencyRequest
pub mod check_consistency_request {
    #[allow(unused_imports)]
    use super::*;

    /// Which type of read needs to consistently observe which type of write?
    /// Default: `standard_read_remote_writes`
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Mode {
        /// Checks that reads using an app profile with `StandardIsolation` can
        /// see all writes committed before the token was created, even if the
        /// read and write target different clusters.
        StandardReadRemoteWrites(crate::model::StandardReadRemoteWrites),
        /// Checks that reads using an app profile with `DataBoostIsolationReadOnly`
        /// can see all writes committed before the token was created, but only if
        /// the read and write target the same cluster.
        DataBoostReadLocalWrites(crate::model::DataBoostReadLocalWrites),
    }
}

/// Checks that all writes before the consistency token was generated are
/// replicated in every cluster and readable.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StandardReadRemoteWrites {}

impl StandardReadRemoteWrites {}

impl wkt::message::Message for StandardReadRemoteWrites {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.StandardReadRemoteWrites"
    }
}

/// Checks that all writes before the consistency token was generated in the same
/// cluster are readable by Databoost.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataBoostReadLocalWrites {}

impl DataBoostReadLocalWrites {}

impl wkt::message::Message for DataBoostReadLocalWrites {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DataBoostReadLocalWrites"
    }
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency][google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency]: crate::client::BigtableTableAdmin::check_consistency
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckConsistencyResponse {
    /// True only if the token is consistent. A token is consistent if replication
    /// has caught up with the restrictions specified in the request.
    pub consistent: bool,
}

impl CheckConsistencyResponse {
    /// Sets the value of [consistent][crate::model::CheckConsistencyResponse::consistent].
    pub fn set_consistent<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.consistent = v.into();
        self
    }
}

impl wkt::message::Message for CheckConsistencyResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CheckConsistencyResponse"
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.SnapshotTable][google.bigtable.admin.v2.BigtableTableAdmin.SnapshotTable]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.SnapshotTable]: crate::client::BigtableTableAdmin::snapshot_table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SnapshotTableRequest {
    /// Required. The unique name of the table to have the snapshot taken.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The name of the cluster where the snapshot will be created in.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster: std::string::String,

    /// Required. The ID by which the new snapshot should be referred to within the
    /// parent cluster, e.g., `mysnapshot` of the form:
    /// `[_a-zA-Z0-9][-_.a-zA-Z0-9]*` rather than
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/mysnapshot`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot_id: std::string::String,

    /// The amount of time that the new snapshot can stay active after it is
    /// created. Once 'ttl' expires, the snapshot will get deleted. The maximum
    /// amount of time a snapshot can stay active is 7 days. If 'ttl' is not
    /// specified, the default value of 24 hours will be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ttl: std::option::Option<wkt::Duration>,

    /// Description of the snapshot.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,
}

impl SnapshotTableRequest {
    /// Sets the value of [name][crate::model::SnapshotTableRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::SnapshotTableRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [snapshot_id][crate::model::SnapshotTableRequest::snapshot_id].
    pub fn set_snapshot_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot_id = v.into();
        self
    }

    /// Sets the value of [ttl][crate::model::SnapshotTableRequest::ttl].
    pub fn set_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ttl = v.into();
        self
    }

    /// Sets the value of [description][crate::model::SnapshotTableRequest::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for SnapshotTableRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.SnapshotTableRequest"
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetSnapshot][google.bigtable.admin.v2.BigtableTableAdmin.GetSnapshot]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetSnapshot]: crate::client::BigtableTableAdmin::get_snapshot
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSnapshotRequest {
    /// Required. The unique name of the requested snapshot.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/{snapshot}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetSnapshotRequest {
    /// Sets the value of [name][crate::model::GetSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetSnapshotRequest"
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots][google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots]: crate::client::BigtableTableAdmin::list_snapshots
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnapshotsRequest {
    /// Required. The unique name of the cluster for which snapshots should be
    /// listed. Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    /// Use `{cluster} = '-'` to list snapshots for all clusters in an instance,
    /// e.g., `projects/{project}/instances/{instance}/clusters/-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of snapshots to return per page.
    /// CURRENTLY UNIMPLEMENTED AND IGNORED.
    pub page_size: i32,

    /// The value of `next_page_token` returned by a previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListSnapshotsRequest {
    /// Sets the value of [parent][crate::model::ListSnapshotsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSnapshotsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSnapshotsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSnapshotsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListSnapshotsRequest"
    }
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots][google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots]: crate::client::BigtableTableAdmin::list_snapshots
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSnapshotsResponse {
    /// The snapshots present in the requested cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub snapshots: std::vec::Vec<crate::model::Snapshot>,

    /// Set if not all snapshots could be returned in a single response.
    /// Pass this value to `page_token` in another request to get the next
    /// page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListSnapshotsResponse {
    /// Sets the value of [next_page_token][crate::model::ListSnapshotsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [snapshots][crate::model::ListSnapshotsResponse::snapshots].
    pub fn set_snapshots<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Snapshot>,
    {
        use std::iter::Iterator;
        self.snapshots = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSnapshotsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListSnapshotsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListSnapshotsResponse {
    type PageItem = crate::model::Snapshot;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.snapshots
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteSnapshot][google.bigtable.admin.v2.BigtableTableAdmin.DeleteSnapshot]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteSnapshot]: crate::client::BigtableTableAdmin::delete_snapshot
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSnapshotRequest {
    /// Required. The unique name of the snapshot to be deleted.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/{snapshot}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteSnapshotRequest {
    /// Sets the value of [name][crate::model::DeleteSnapshotRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSnapshotRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteSnapshotRequest"
    }
}

/// The metadata for the Operation returned by SnapshotTable.
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SnapshotTableMetadata {
    /// The request that prompted the initiation of this SnapshotTable operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_request: std::option::Option<crate::model::SnapshotTableRequest>,

    /// The time at which the original request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,
}

impl SnapshotTableMetadata {
    /// Sets the value of [original_request][crate::model::SnapshotTableMetadata::original_request].
    pub fn set_original_request<
        T: std::convert::Into<std::option::Option<crate::model::SnapshotTableRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_request = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::SnapshotTableMetadata::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::SnapshotTableMetadata::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }
}

impl wkt::message::Message for SnapshotTableMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.SnapshotTableMetadata"
    }
}

/// The metadata for the Operation returned by CreateTableFromSnapshot.
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTableFromSnapshotMetadata {
    /// The request that prompted the initiation of this CreateTableFromSnapshot
    /// operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_request: std::option::Option<crate::model::CreateTableFromSnapshotRequest>,

    /// The time at which the original request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,
}

impl CreateTableFromSnapshotMetadata {
    /// Sets the value of [original_request][crate::model::CreateTableFromSnapshotMetadata::original_request].
    pub fn set_original_request<
        T: std::convert::Into<std::option::Option<crate::model::CreateTableFromSnapshotRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_request = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::CreateTableFromSnapshotMetadata::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::CreateTableFromSnapshotMetadata::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }
}

impl wkt::message::Message for CreateTableFromSnapshotMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateTableFromSnapshotMetadata"
    }
}

/// The request for
/// [CreateBackup][google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup]: crate::client::BigtableTableAdmin::create_backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupRequest {
    /// Required. This must be one of the clusters in the instance in which this
    /// table is located. The backup will be stored in this cluster. Values are
    /// of the form `projects/{project}/instances/{instance}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The id of the backup to be created. The `backup_id` along with
    /// the parent `parent` are combined as {parent}/backups/{backup_id} to create
    /// the full backup name, of the form:
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup_id}`.
    /// This string must be between 1 and 50 characters in length and match the
    /// regex [_a-zA-Z0-9][-_.a-zA-Z0-9]*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_id: std::string::String,

    /// Required. The backup to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,
}

impl CreateBackupRequest {
    /// Sets the value of [parent][crate::model::CreateBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CreateBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [backup][crate::model::CreateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateBackupRequest"
    }
}

/// Metadata type for the operation returned by
/// [CreateBackup][google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup]: crate::client::BigtableTableAdmin::create_backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBackupMetadata {
    /// The name of the backup being created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The name of the table the backup is created from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_table: std::string::String,

    /// The time at which this operation started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation finished or was cancelled.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl CreateBackupMetadata {
    /// Sets the value of [name][crate::model::CreateBackupMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_table][crate::model::CreateBackupMetadata::source_table].
    pub fn set_source_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_table = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::CreateBackupMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::CreateBackupMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for CreateBackupMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateBackupMetadata"
    }
}

/// The request for
/// [UpdateBackup][google.bigtable.admin.v2.BigtableTableAdmin.UpdateBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UpdateBackup]: crate::client::BigtableTableAdmin::update_backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBackupRequest {
    /// Required. The backup to update. `backup.name`, and the fields to be updated
    /// as specified by `update_mask` are required. Other fields are ignored.
    /// Update is only supported for the following fields:
    ///
    /// * `backup.expire_time`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup: std::option::Option<crate::model::Backup>,

    /// Required. A mask specifying which fields (e.g. `expire_time`) in the
    /// Backup resource should be updated. This mask is relative to the Backup
    /// resource, not to the request message. The field mask must always be
    /// specified; this prevents any future fields from being erased accidentally
    /// by clients that do not know about them.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateBackupRequest {
    /// Sets the value of [backup][crate::model::UpdateBackupRequest::backup].
    pub fn set_backup<T: std::convert::Into<std::option::Option<crate::model::Backup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBackupRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateBackupRequest"
    }
}

/// The request for
/// [GetBackup][google.bigtable.admin.v2.BigtableTableAdmin.GetBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetBackup]: crate::client::BigtableTableAdmin::get_backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Name of the backup.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetBackupRequest {
    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetBackupRequest"
    }
}

/// The request for
/// [DeleteBackup][google.bigtable.admin.v2.BigtableTableAdmin.DeleteBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteBackup]: crate::client::BigtableTableAdmin::delete_backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Name of the backup to delete.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteBackupRequest {
    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteBackupRequest"
    }
}

/// The request for
/// [ListBackups][google.bigtable.admin.v2.BigtableTableAdmin.ListBackups].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListBackups]: crate::client::BigtableTableAdmin::list_backups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The cluster to list backups from.  Values are of the
    /// form `projects/{project}/instances/{instance}/clusters/{cluster}`.
    /// Use `{cluster} = '-'` to list backups for all clusters in an instance,
    /// e.g., `projects/{project}/instances/{instance}/clusters/-`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// A filter expression that filters backups listed in the response.
    /// The expression must specify the field name, a comparison operator,
    /// and the value that you want to use for filtering. The value must be a
    /// string, a number, or a boolean. The comparison operator must be
    /// <, >, <=, >=, !=, =, or :. Colon ':' represents a HAS operator which is
    /// roughly synonymous with equality. Filter rules are case insensitive.
    ///
    /// The fields eligible for filtering are:
    ///
    /// * `name`
    /// * `source_table`
    /// * `state`
    /// * `start_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)
    /// * `end_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)
    /// * `expire_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)
    /// * `size_bytes`
    ///
    /// To filter on multiple expressions, provide each separate expression within
    /// parentheses. By default, each expression is an AND expression. However,
    /// you can include AND, OR, and NOT expressions explicitly.
    ///
    /// Some examples of using filters are:
    ///
    /// * `name:"exact"` --> The backup's name is the string "exact".
    /// * `name:howl` --> The backup's name contains the string "howl".
    /// * `source_table:prod`
    ///   --> The source_table's name contains the string "prod".
    /// * `state:CREATING` --> The backup is pending creation.
    /// * `state:READY` --> The backup is fully created and ready for use.
    /// * `(name:howl) AND (start_time < \"2018-03-28T14:50:00Z\")`
    ///   --> The backup name contains the string "howl" and start_time
    ///   of the backup is before 2018-03-28T14:50:00Z.
    /// * `size_bytes > 10000000000` --> The backup's size is greater than 10GB
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// An expression for specifying the sort order of the results of the request.
    /// The string value should specify one or more fields in
    /// [Backup][google.bigtable.admin.v2.Backup]. The full syntax is described at
    /// <https://aip.dev/132#ordering>.
    ///
    /// Fields supported are:
    ///
    /// * name
    /// * source_table
    /// * expire_time
    /// * start_time
    /// * end_time
    /// * size_bytes
    /// * state
    ///
    /// For example, "start_time". The default sorting order is ascending.
    /// To specify descending order for the field, a suffix " desc" should
    /// be appended to the field name. For example, "start_time desc".
    /// Redundant space characters in the syntax are insigificant.
    ///
    /// If order_by is empty, results will be sorted by `start_time` in descending
    /// order starting from the most recently created backup.
    ///
    /// [google.bigtable.admin.v2.Backup]: crate::model::Backup
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Number of backups to be returned in the response. If 0 or
    /// less, defaults to the server's maximum allowed page size.
    pub page_size: i32,

    /// If non-empty, `page_token` should contain a
    /// [next_page_token][google.bigtable.admin.v2.ListBackupsResponse.next_page_token]
    /// from a previous
    /// [ListBackupsResponse][google.bigtable.admin.v2.ListBackupsResponse] to the
    /// same `parent` and with the same `filter`.
    ///
    /// [google.bigtable.admin.v2.ListBackupsResponse]: crate::model::ListBackupsResponse
    /// [google.bigtable.admin.v2.ListBackupsResponse.next_page_token]: crate::model::ListBackupsResponse::next_page_token
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListBackupsRequest {
    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBackupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBackupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListBackupsRequest"
    }
}

/// The response for
/// [ListBackups][google.bigtable.admin.v2.BigtableTableAdmin.ListBackups].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListBackups]: crate::client::BigtableTableAdmin::list_backups
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// The list of matching backups.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// `next_page_token` can be sent in a subsequent
    /// [ListBackups][google.bigtable.admin.v2.BigtableTableAdmin.ListBackups] call
    /// to fetch more of the matching backups.
    ///
    /// [google.bigtable.admin.v2.BigtableTableAdmin.ListBackups]: crate::client::BigtableTableAdmin::list_backups
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListBackupsResponse {
    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListBackupsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// The request for
/// [CopyBackup][google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup]: crate::client::BigtableTableAdmin::copy_backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyBackupRequest {
    /// Required. The name of the destination cluster that will contain the backup
    /// copy. The cluster must already exist. Values are of the form:
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The id of the new backup. The `backup_id` along with `parent`
    /// are combined as {parent}/backups/{backup_id} to create the full backup
    /// name, of the form:
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup_id}`.
    /// This string must be between 1 and 50 characters in length and match the
    /// regex [_a-zA-Z0-9][-_.a-zA-Z0-9]*.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup_id: std::string::String,

    /// Required. The source backup to be copied from.
    /// The source backup needs to be in READY state for it to be copied.
    /// Copying a copied backup is not allowed.
    /// Once CopyBackup is in progress, the source backup cannot be deleted or
    /// cleaned up on expiration until CopyBackup is finished.
    /// Values are of the form:
    /// `projects/<project>/instances/<instance>/clusters/<cluster>/backups/<backup>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_backup: std::string::String,

    /// Required. Required. The expiration time of the copied backup with
    /// microsecond granularity that must be at least 6 hours and at most 30 days
    /// from the time the request is received. Once the `expire_time` has
    /// passed, Cloud Bigtable will delete the backup and free the resources used
    /// by the backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,
}

impl CopyBackupRequest {
    /// Sets the value of [parent][crate::model::CopyBackupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::CopyBackupRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup_id = v.into();
        self
    }

    /// Sets the value of [source_backup][crate::model::CopyBackupRequest::source_backup].
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_backup = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::CopyBackupRequest::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }
}

impl wkt::message::Message for CopyBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CopyBackupRequest"
    }
}

/// Metadata type for the google.longrunning.Operation returned by
/// [CopyBackup][google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup]: crate::client::BigtableTableAdmin::copy_backup
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CopyBackupMetadata {
    /// The name of the backup being created through the copy operation.
    /// Values are of the form
    /// `projects/<project>/instances/<instance>/clusters/<cluster>/backups/<backup>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Information about the source backup that is being copied from.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_backup_info: std::option::Option<crate::model::BackupInfo>,

    /// The progress of the
    /// [CopyBackup][google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup]
    /// operation.
    ///
    /// [google.bigtable.admin.v2.BigtableTableAdmin.CopyBackup]: crate::client::BigtableTableAdmin::copy_backup
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub progress: std::option::Option<crate::model::OperationProgress>,
}

impl CopyBackupMetadata {
    /// Sets the value of [name][crate::model::CopyBackupMetadata::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_backup_info][crate::model::CopyBackupMetadata::source_backup_info].
    pub fn set_source_backup_info<
        T: std::convert::Into<std::option::Option<crate::model::BackupInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_backup_info = v.into();
        self
    }

    /// Sets the value of [progress][crate::model::CopyBackupMetadata::progress].
    pub fn set_progress<
        T: std::convert::Into<std::option::Option<crate::model::OperationProgress>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.progress = v.into();
        self
    }
}

impl wkt::message::Message for CopyBackupMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CopyBackupMetadata"
    }
}

/// The request for
/// [CreateAuthorizedView][google.bigtable.admin.v2.BigtableTableAdmin.CreateAuthorizedView]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateAuthorizedView]: crate::client::BigtableTableAdmin::create_authorized_view
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAuthorizedViewRequest {
    /// Required. This is the name of the table the AuthorizedView belongs to.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The id of the AuthorizedView to create. This AuthorizedView must
    /// not already exist. The `authorized_view_id` appended to `parent` forms the
    /// full AuthorizedView name of the form
    /// `projects/{project}/instances/{instance}/tables/{table}/authorizedView/{authorized_view}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub authorized_view_id: std::string::String,

    /// Required. The AuthorizedView to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorized_view: std::option::Option<crate::model::AuthorizedView>,
}

impl CreateAuthorizedViewRequest {
    /// Sets the value of [parent][crate::model::CreateAuthorizedViewRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [authorized_view_id][crate::model::CreateAuthorizedViewRequest::authorized_view_id].
    pub fn set_authorized_view_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorized_view_id = v.into();
        self
    }

    /// Sets the value of [authorized_view][crate::model::CreateAuthorizedViewRequest::authorized_view].
    pub fn set_authorized_view<
        T: std::convert::Into<std::option::Option<crate::model::AuthorizedView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorized_view = v.into();
        self
    }
}

impl wkt::message::Message for CreateAuthorizedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateAuthorizedViewRequest"
    }
}

/// The metadata for the Operation returned by CreateAuthorizedView.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateAuthorizedViewMetadata {
    /// The request that prompted the initiation of this CreateInstance operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_request: std::option::Option<crate::model::CreateAuthorizedViewRequest>,

    /// The time at which the original request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,
}

impl CreateAuthorizedViewMetadata {
    /// Sets the value of [original_request][crate::model::CreateAuthorizedViewMetadata::original_request].
    pub fn set_original_request<
        T: std::convert::Into<std::option::Option<crate::model::CreateAuthorizedViewRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_request = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::CreateAuthorizedViewMetadata::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::CreateAuthorizedViewMetadata::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }
}

impl wkt::message::Message for CreateAuthorizedViewMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.CreateAuthorizedViewMetadata"
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews][google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews]: crate::client::BigtableTableAdmin::list_authorized_views
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAuthorizedViewsRequest {
    /// Required. The unique name of the table for which AuthorizedViews should be
    /// listed. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of results per page.
    ///
    /// A page_size of zero lets the server choose the number of items to return.
    /// A page_size which is strictly positive will return at most that many items.
    /// A negative page_size will cause an error.
    ///
    /// Following the first request, subsequent paginated calls are not required
    /// to pass a page_size. If a page_size is set in subsequent calls, it must
    /// match the page_size given in the first request.
    pub page_size: i32,

    /// Optional. The value of `next_page_token` returned by a previous call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The resource_view to be applied to the returned views' fields.
    /// Default to NAME_ONLY.
    pub view: crate::model::authorized_view::ResponseView,
}

impl ListAuthorizedViewsRequest {
    /// Sets the value of [parent][crate::model::ListAuthorizedViewsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListAuthorizedViewsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListAuthorizedViewsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListAuthorizedViewsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::authorized_view::ResponseView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListAuthorizedViewsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListAuthorizedViewsRequest"
    }
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews][google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListAuthorizedViews]: crate::client::BigtableTableAdmin::list_authorized_views
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListAuthorizedViewsResponse {
    /// The AuthorizedViews present in the requested table.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub authorized_views: std::vec::Vec<crate::model::AuthorizedView>,

    /// Set if not all tables could be returned in a single response.
    /// Pass this value to `page_token` in another request to get the next
    /// page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl ListAuthorizedViewsResponse {
    /// Sets the value of [next_page_token][crate::model::ListAuthorizedViewsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [authorized_views][crate::model::ListAuthorizedViewsResponse::authorized_views].
    pub fn set_authorized_views<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuthorizedView>,
    {
        use std::iter::Iterator;
        self.authorized_views = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListAuthorizedViewsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ListAuthorizedViewsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListAuthorizedViewsResponse {
    type PageItem = crate::model::AuthorizedView;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.authorized_views
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetAuthorizedView][google.bigtable.admin.v2.BigtableTableAdmin.GetAuthorizedView]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetAuthorizedView]: crate::client::BigtableTableAdmin::get_authorized_view
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetAuthorizedViewRequest {
    /// Required. The unique name of the requested AuthorizedView.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}/authorizedViews/{authorized_view}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The resource_view to be applied to the returned AuthorizedView's
    /// fields. Default to BASIC.
    pub view: crate::model::authorized_view::ResponseView,
}

impl GetAuthorizedViewRequest {
    /// Sets the value of [name][crate::model::GetAuthorizedViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetAuthorizedViewRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::authorized_view::ResponseView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetAuthorizedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GetAuthorizedViewRequest"
    }
}

/// The request for
/// [UpdateAuthorizedView][google.bigtable.admin.v2.BigtableTableAdmin.UpdateAuthorizedView].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UpdateAuthorizedView]: crate::client::BigtableTableAdmin::update_authorized_view
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAuthorizedViewRequest {
    /// Required. The AuthorizedView to update. The `name` in `authorized_view` is
    /// used to identify the AuthorizedView. AuthorizedView name must in this
    /// format
    /// projects/\<project\>/instances/\<instance\>/tables/\<table\>/authorizedViews/<authorized_view>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorized_view: std::option::Option<crate::model::AuthorizedView>,

    /// Optional. The list of fields to update.
    /// A mask specifying which fields in the AuthorizedView resource should be
    /// updated. This mask is relative to the AuthorizedView resource, not to the
    /// request message. A field will be overwritten if it is in the mask. If
    /// empty, all fields set in the request will be overwritten. A special value
    /// `*` means to overwrite all fields (including fields not set in the
    /// request).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If true, ignore the safety checks when updating the
    /// AuthorizedView.
    pub ignore_warnings: bool,
}

impl UpdateAuthorizedViewRequest {
    /// Sets the value of [authorized_view][crate::model::UpdateAuthorizedViewRequest::authorized_view].
    pub fn set_authorized_view<
        T: std::convert::Into<std::option::Option<crate::model::AuthorizedView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorized_view = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateAuthorizedViewRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [ignore_warnings][crate::model::UpdateAuthorizedViewRequest::ignore_warnings].
    pub fn set_ignore_warnings<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ignore_warnings = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAuthorizedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateAuthorizedViewRequest"
    }
}

/// Metadata for the google.longrunning.Operation returned by
/// [UpdateAuthorizedView][google.bigtable.admin.v2.BigtableTableAdmin.UpdateAuthorizedView].
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.UpdateAuthorizedView]: crate::client::BigtableTableAdmin::update_authorized_view
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateAuthorizedViewMetadata {
    /// The request that prompted the initiation of this UpdateAuthorizedView
    /// operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub original_request: std::option::Option<crate::model::UpdateAuthorizedViewRequest>,

    /// The time at which the original request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_time: std::option::Option<wkt::Timestamp>,

    /// The time at which the operation failed or was completed successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub finish_time: std::option::Option<wkt::Timestamp>,
}

impl UpdateAuthorizedViewMetadata {
    /// Sets the value of [original_request][crate::model::UpdateAuthorizedViewMetadata::original_request].
    pub fn set_original_request<
        T: std::convert::Into<std::option::Option<crate::model::UpdateAuthorizedViewRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.original_request = v.into();
        self
    }

    /// Sets the value of [request_time][crate::model::UpdateAuthorizedViewMetadata::request_time].
    pub fn set_request_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_time = v.into();
        self
    }

    /// Sets the value of [finish_time][crate::model::UpdateAuthorizedViewMetadata::finish_time].
    pub fn set_finish_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.finish_time = v.into();
        self
    }
}

impl wkt::message::Message for UpdateAuthorizedViewMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.UpdateAuthorizedViewMetadata"
    }
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteAuthorizedView][google.bigtable.admin.v2.BigtableTableAdmin.DeleteAuthorizedView]
///
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteAuthorizedView]: crate::client::BigtableTableAdmin::delete_authorized_view
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteAuthorizedViewRequest {
    /// Required. The unique name of the AuthorizedView to be deleted.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}/authorizedViews/{authorized_view}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The current etag of the AuthorizedView.
    /// If an etag is provided and does not match the current etag of the
    /// AuthorizedView, deletion will be blocked and an ABORTED error will be
    /// returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl DeleteAuthorizedViewRequest {
    /// Sets the value of [name][crate::model::DeleteAuthorizedViewRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteAuthorizedViewRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteAuthorizedViewRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.DeleteAuthorizedViewRequest"
    }
}

/// Encapsulates progress related information for a Cloud Bigtable long
/// running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationProgress {
    /// Percent completion of the operation.
    /// Values are between 0 and 100 inclusive.
    pub progress_percent: i32,

    /// Time the request was received.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// If set, the time at which this operation failed or was completed
    /// successfully.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl OperationProgress {
    /// Sets the value of [progress_percent][crate::model::OperationProgress::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::OperationProgress::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationProgress::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for OperationProgress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.OperationProgress"
    }
}

/// A collection of Bigtable [Tables][google.bigtable.admin.v2.Table] and
/// the resources that serve them.
/// All tables in an instance are served from all
/// [Clusters][google.bigtable.admin.v2.Cluster] in the instance.
///
/// [google.bigtable.admin.v2.Cluster]: crate::model::Cluster
/// [google.bigtable.admin.v2.Table]: crate::model::Table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// The unique name of the instance. Values are of the form
    /// `projects/{project}/instances/[a-z][a-z0-9\\-]+[a-z0-9]`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The descriptive name for this instance as it appears in UIs.
    /// Can be changed at any time, but should be kept globally unique
    /// to avoid confusion.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// (`OutputOnly`)
    /// The current state of the instance.
    pub state: crate::model::instance::State,

    /// The type of the instance. Defaults to `PRODUCTION`.
    #[serde(rename = "type")]
    pub r#type: crate::model::instance::Type,

    /// Labels are a flexible and lightweight mechanism for organizing cloud
    /// resources into groups that reflect a customer's organizational needs and
    /// deployment strategies. They can be used to filter resources and aggregate
    /// metrics.
    ///
    /// * Label keys must be between 1 and 63 characters long and must conform to
    ///   the regular expression: `[\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}`.
    /// * Label values must be between 0 and 63 characters long and must conform to
    ///   the regular expression: `[\p{Ll}\p{Lo}\p{N}_-]{0,63}`.
    /// * No more than 64 labels can be associated with a given resource.
    /// * Keys and values must both be under 128 bytes.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. A server-assigned timestamp representing when this Instance
    /// was created. For instances created before this field was added (August
    /// 2021), this value is `seconds: 0, nanos: 1`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Reserved for future use.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub satisfies_pzs: std::option::Option<bool>,
}

impl Instance {
    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Instance::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Instance::type].
    pub fn set_type<T: std::convert::Into<crate::model::instance::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_satisfies_pzs<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.satisfies_pzs = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Instance"
    }
}

/// Defines additional types related to Instance
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of an instance.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::string::String);

    impl State {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {

        /// The state of the instance could not be determined.
        pub const STATE_NOT_KNOWN: &str = "STATE_NOT_KNOWN";

        /// The instance has been successfully created and can serve requests
        /// to its tables.
        pub const READY: &str = "READY";

        /// The instance is currently being created, and may be destroyed
        /// if the creation process encounters an error.
        pub const CREATING: &str = "CREATING";
    }

    /// The type of the instance.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(std::string::String);

    impl Type {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Type](Type)
    pub mod r#type {

        /// The type of the instance is unspecified. If set when creating an
        /// instance, a `PRODUCTION` instance will be created. If set when updating
        /// an instance, the type will be left unchanged.
        pub const TYPE_UNSPECIFIED: &str = "TYPE_UNSPECIFIED";

        /// An instance meant for production use. `serve_nodes` must be set
        /// on the cluster.
        pub const PRODUCTION: &str = "PRODUCTION";

        /// DEPRECATED: Prefer PRODUCTION for all use cases, as it no longer enforces
        /// a higher minimum node count than DEVELOPMENT.
        pub const DEVELOPMENT: &str = "DEVELOPMENT";
    }
}

/// The Autoscaling targets for a Cluster. These determine the recommended nodes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutoscalingTargets {
    /// The cpu utilization that the Autoscaler should be trying to achieve.
    /// This number is on a scale from 0 (no utilization) to
    /// 100 (total utilization), and is limited between 10 and 80, otherwise it
    /// will return INVALID_ARGUMENT error.
    pub cpu_utilization_percent: i32,

    /// The storage utilization that the Autoscaler should be trying to achieve.
    /// This number is limited between 2560 (2.5TiB) and 5120 (5TiB) for a SSD
    /// cluster and between 8192 (8TiB) and 16384 (16TiB) for an HDD cluster,
    /// otherwise it will return INVALID_ARGUMENT error. If this value is set to 0,
    /// it will be treated as if it were set to the default value: 2560 for SSD,
    /// 8192 for HDD.
    pub storage_utilization_gib_per_node: i32,
}

impl AutoscalingTargets {
    /// Sets the value of [cpu_utilization_percent][crate::model::AutoscalingTargets::cpu_utilization_percent].
    pub fn set_cpu_utilization_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_utilization_percent = v.into();
        self
    }

    /// Sets the value of [storage_utilization_gib_per_node][crate::model::AutoscalingTargets::storage_utilization_gib_per_node].
    pub fn set_storage_utilization_gib_per_node<T: std::convert::Into<i32>>(
        mut self,
        v: T,
    ) -> Self {
        self.storage_utilization_gib_per_node = v.into();
        self
    }
}

impl wkt::message::Message for AutoscalingTargets {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.AutoscalingTargets"
    }
}

/// Limits for the number of nodes a Cluster can autoscale up/down to.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutoscalingLimits {
    /// Required. Minimum number of nodes to scale down to.
    pub min_serve_nodes: i32,

    /// Required. Maximum number of nodes to scale up to.
    pub max_serve_nodes: i32,
}

impl AutoscalingLimits {
    /// Sets the value of [min_serve_nodes][crate::model::AutoscalingLimits::min_serve_nodes].
    pub fn set_min_serve_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_serve_nodes = v.into();
        self
    }

    /// Sets the value of [max_serve_nodes][crate::model::AutoscalingLimits::max_serve_nodes].
    pub fn set_max_serve_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_serve_nodes = v.into();
        self
    }
}

impl wkt::message::Message for AutoscalingLimits {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.AutoscalingLimits"
    }
}

/// A resizable group of nodes in a particular cloud location, capable
/// of serving all [Tables][google.bigtable.admin.v2.Table] in the parent
/// [Instance][google.bigtable.admin.v2.Instance].
///
/// [google.bigtable.admin.v2.Instance]: crate::model::Instance
/// [google.bigtable.admin.v2.Table]: crate::model::Table
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Cluster {
    /// The unique name of the cluster. Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/[a-z][-a-z0-9]*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Immutable. The location where this cluster's nodes and storage reside. For
    /// best performance, clients should be located as close as possible to this
    /// cluster. Currently only zones are supported, so values should be of the
    /// form `projects/{project}/locations/{zone}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// Output only. The current state of the cluster.
    pub state: crate::model::cluster::State,

    /// The number of nodes allocated to this cluster. More nodes enable higher
    /// throughput and more consistent performance.
    pub serve_nodes: i32,

    /// Immutable. The node scaling factor of this cluster.
    pub node_scaling_factor: crate::model::cluster::NodeScalingFactor,

    /// Immutable. The type of storage used by this cluster to serve its
    /// parent instance's tables, unless explicitly overridden.
    pub default_storage_type: crate::model::StorageType,

    /// Immutable. The encryption configuration for CMEK-protected clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_config: std::option::Option<crate::model::cluster::EncryptionConfig>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub config: std::option::Option<crate::model::cluster::Config>,
}

impl Cluster {
    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Cluster::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Cluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [serve_nodes][crate::model::Cluster::serve_nodes].
    pub fn set_serve_nodes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.serve_nodes = v.into();
        self
    }

    /// Sets the value of [node_scaling_factor][crate::model::Cluster::node_scaling_factor].
    pub fn set_node_scaling_factor<
        T: std::convert::Into<crate::model::cluster::NodeScalingFactor>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_scaling_factor = v.into();
        self
    }

    /// Sets the value of [default_storage_type][crate::model::Cluster::default_storage_type].
    pub fn set_default_storage_type<T: std::convert::Into<crate::model::StorageType>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_storage_type = v.into();
        self
    }

    /// Sets the value of [encryption_config][crate::model::Cluster::encryption_config].
    pub fn set_encryption_config<
        T: std::convert::Into<std::option::Option<crate::model::cluster::EncryptionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_config = v.into();
        self
    }

    /// Sets the value of `config`.
    pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::cluster::Config>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config = v.into();
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Cluster"
    }
}

/// Defines additional types related to Cluster
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Autoscaling config for a cluster.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ClusterAutoscalingConfig {
        /// Required. Autoscaling limits for this cluster.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub autoscaling_limits: std::option::Option<crate::model::AutoscalingLimits>,

        /// Required. Autoscaling targets for this cluster.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub autoscaling_targets: std::option::Option<crate::model::AutoscalingTargets>,
    }

    impl ClusterAutoscalingConfig {
        /// Sets the value of [autoscaling_limits][crate::model::cluster::ClusterAutoscalingConfig::autoscaling_limits].
        pub fn set_autoscaling_limits<
            T: std::convert::Into<std::option::Option<crate::model::AutoscalingLimits>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.autoscaling_limits = v.into();
            self
        }

        /// Sets the value of [autoscaling_targets][crate::model::cluster::ClusterAutoscalingConfig::autoscaling_targets].
        pub fn set_autoscaling_targets<
            T: std::convert::Into<std::option::Option<crate::model::AutoscalingTargets>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.autoscaling_targets = v.into();
            self
        }
    }

    impl wkt::message::Message for ClusterAutoscalingConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Cluster.ClusterAutoscalingConfig"
        }
    }

    /// Configuration for a cluster.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ClusterConfig {
        /// Autoscaling configuration for this cluster.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub cluster_autoscaling_config:
            std::option::Option<crate::model::cluster::ClusterAutoscalingConfig>,
    }

    impl ClusterConfig {
        /// Sets the value of [cluster_autoscaling_config][crate::model::cluster::ClusterConfig::cluster_autoscaling_config].
        pub fn set_cluster_autoscaling_config<
            T: std::convert::Into<
                std::option::Option<crate::model::cluster::ClusterAutoscalingConfig>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_autoscaling_config = v.into();
            self
        }
    }

    impl wkt::message::Message for ClusterConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Cluster.ClusterConfig"
        }
    }

    /// Cloud Key Management Service (Cloud KMS) settings for a CMEK-protected
    /// cluster.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct EncryptionConfig {
        /// Describes the Cloud KMS encryption key that will be used to protect the
        /// destination Bigtable cluster. The requirements for this key are:
        ///
        /// ) The Cloud Bigtable service account associated with the project that
        ///   contains this cluster must be granted the
        ///   `cloudkms.cryptoKeyEncrypterDecrypter` role on the CMEK key.
        /// ) Only regional keys can be used and the region of the CMEK key must
        ///   match the region of the cluster.
        /// ) All clusters within an instance must use the same CMEK key.
        ///   Values are of the form
        ///   `projects/{project}/locations/{location}/keyRings/{keyring}/cryptoKeys/{key}`
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key_name: std::string::String,
    }

    impl EncryptionConfig {
        /// Sets the value of [kms_key_name][crate::model::cluster::EncryptionConfig::kms_key_name].
        pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_name = v.into();
            self
        }
    }

    impl wkt::message::Message for EncryptionConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Cluster.EncryptionConfig"
        }
    }

    /// Possible states of a cluster.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::string::String);

    impl State {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {

        /// The state of the cluster could not be determined.
        pub const STATE_NOT_KNOWN: &str = "STATE_NOT_KNOWN";

        /// The cluster has been successfully created and is ready to serve requests.
        pub const READY: &str = "READY";

        /// The cluster is currently being created, and may be destroyed
        /// if the creation process encounters an error.
        /// A cluster may not be able to serve requests while being created.
        pub const CREATING: &str = "CREATING";

        /// The cluster is currently being resized, and may revert to its previous
        /// node count if the process encounters an error.
        /// A cluster is still capable of serving requests while being resized,
        /// but may exhibit performance as if its number of allocated nodes is
        /// between the starting and requested states.
        pub const RESIZING: &str = "RESIZING";

        /// The cluster has no backing nodes. The data (tables) still
        /// exist, but no operations can be performed on the cluster.
        pub const DISABLED: &str = "DISABLED";
    }

    /// Possible node scaling factors of the clusters. Node scaling delivers better
    /// latency and more throughput by removing node boundaries.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct NodeScalingFactor(std::string::String);

    impl NodeScalingFactor {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [NodeScalingFactor](NodeScalingFactor)
    pub mod node_scaling_factor {

        /// No node scaling specified. Defaults to NODE_SCALING_FACTOR_1X.
        pub const NODE_SCALING_FACTOR_UNSPECIFIED: &str = "NODE_SCALING_FACTOR_UNSPECIFIED";

        /// The cluster is running with a scaling factor of 1.
        pub const NODE_SCALING_FACTOR_1X: &str = "NODE_SCALING_FACTOR_1X";

        /// The cluster is running with a scaling factor of 2.
        /// All node count values must be in increments of 2 with this scaling factor
        /// enabled, otherwise an INVALID_ARGUMENT error will be returned.
        pub const NODE_SCALING_FACTOR_2X: &str = "NODE_SCALING_FACTOR_2X";
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Config {
        /// Configuration for this cluster.
        ClusterConfig(crate::model::cluster::ClusterConfig),
    }
}

/// A configuration object describing how Cloud Bigtable should treat traffic
/// from a particular end user application.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AppProfile {
    /// The unique name of the app profile. Values are of the form
    /// `projects/{project}/instances/{instance}/appProfiles/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Strongly validated etag for optimistic concurrency control. Preserve the
    /// value returned from `GetAppProfile` when calling `UpdateAppProfile` to
    /// fail the request if there has been a modification in the mean time. The
    /// `update_mask` of the request need not include `etag` for this protection
    /// to apply.
    /// See [Wikipedia](https://en.wikipedia.org/wiki/HTTP_ETag) and
    /// [RFC 7232](https://tools.ietf.org/html/rfc7232#section-2.3) for more
    /// details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Long form description of the use case for this AppProfile.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The routing policy for all read/write requests that use this app profile.
    /// A value must be explicitly set.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub routing_policy: std::option::Option<crate::model::app_profile::RoutingPolicy>,

    /// Options for isolating this app profile's traffic from other use cases.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub isolation: std::option::Option<crate::model::app_profile::Isolation>,
}

impl AppProfile {
    /// Sets the value of [name][crate::model::AppProfile::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AppProfile::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [description][crate::model::AppProfile::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of `routing_policy`.
    pub fn set_routing_policy<
        T: std::convert::Into<std::option::Option<crate::model::app_profile::RoutingPolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.routing_policy = v.into();
        self
    }

    /// Sets the value of `isolation`.
    pub fn set_isolation<
        T: std::convert::Into<std::option::Option<crate::model::app_profile::Isolation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.isolation = v.into();
        self
    }
}

impl wkt::message::Message for AppProfile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.AppProfile"
    }
}

/// Defines additional types related to AppProfile
pub mod app_profile {
    #[allow(unused_imports)]
    use super::*;

    /// Read/write requests are routed to the nearest cluster in the instance, and
    /// will fail over to the nearest cluster that is available in the event of
    /// transient errors or delays. Clusters in a region are considered
    /// equidistant. Choosing this option sacrifices read-your-writes consistency
    /// to improve availability.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MultiClusterRoutingUseAny {
        /// The set of clusters to route to. The order is ignored; clusters will be
        /// tried in order of distance. If left empty, all clusters are eligible.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub cluster_ids: std::vec::Vec<std::string::String>,

        /// Possible algorithms for routing affinity. If enabled, Bigtable will
        /// route between equidistant clusters in a deterministic order rather than
        /// choosing randomly.
        ///
        /// This mechanism gives read-your-writes consistency for *most* requests
        /// under *most* circumstances, without sacrificing availability. Consistency
        /// is *not* guaranteed, as requests might still fail over between clusters
        /// in the event of errors or latency.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub affinity:
            std::option::Option<crate::model::app_profile::multi_cluster_routing_use_any::Affinity>,
    }

    impl MultiClusterRoutingUseAny {
        /// Sets the value of [cluster_ids][crate::model::app_profile::MultiClusterRoutingUseAny::cluster_ids].
        pub fn set_cluster_ids<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.cluster_ids = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of `affinity`.
        pub fn set_affinity<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::app_profile::multi_cluster_routing_use_any::Affinity,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.affinity = v.into();
            self
        }
    }

    impl wkt::message::Message for MultiClusterRoutingUseAny {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AppProfile.MultiClusterRoutingUseAny"
        }
    }

    /// Defines additional types related to MultiClusterRoutingUseAny
    pub mod multi_cluster_routing_use_any {
        #[allow(unused_imports)]
        use super::*;

        /// If enabled, Bigtable will route the request based on the row key of the
        /// request, rather than randomly. Instead, each row key will be assigned
        /// to a cluster, and will stick to that cluster. If clusters are added or
        /// removed, then this may affect which row keys stick to which clusters.
        /// To avoid this, users can use a cluster group to specify which clusters
        /// are to be used. In this case, new clusters that are not a part of the
        /// cluster group will not be routed to, and routing will be unaffected by
        /// the new cluster. Moreover, clusters specified in the cluster group cannot
        /// be deleted unless removed from the cluster group.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct RowAffinity {}

        impl RowAffinity {}

        impl wkt::message::Message for RowAffinity {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.AppProfile.MultiClusterRoutingUseAny.RowAffinity"
            }
        }

        /// Possible algorithms for routing affinity. If enabled, Bigtable will
        /// route between equidistant clusters in a deterministic order rather than
        /// choosing randomly.
        ///
        /// This mechanism gives read-your-writes consistency for *most* requests
        /// under *most* circumstances, without sacrificing availability. Consistency
        /// is *not* guaranteed, as requests might still fail over between clusters
        /// in the event of errors or latency.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Affinity {
            /// Row affinity sticky routing based on the row key of the request.
            /// Requests that span multiple rows are routed non-deterministically.
            RowAffinity(crate::model::app_profile::multi_cluster_routing_use_any::RowAffinity),
        }
    }

    /// Unconditionally routes all read/write requests to a specific cluster.
    /// This option preserves read-your-writes consistency but does not improve
    /// availability.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SingleClusterRouting {
        /// The cluster to which read/write requests should be routed.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cluster_id: std::string::String,

        /// Whether or not `CheckAndMutateRow` and `ReadModifyWriteRow` requests are
        /// allowed by this app profile. It is unsafe to send these requests to
        /// the same table/row/column in multiple clusters.
        pub allow_transactional_writes: bool,
    }

    impl SingleClusterRouting {
        /// Sets the value of [cluster_id][crate::model::app_profile::SingleClusterRouting::cluster_id].
        pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cluster_id = v.into();
            self
        }

        /// Sets the value of [allow_transactional_writes][crate::model::app_profile::SingleClusterRouting::allow_transactional_writes].
        pub fn set_allow_transactional_writes<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.allow_transactional_writes = v.into();
            self
        }
    }

    impl wkt::message::Message for SingleClusterRouting {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AppProfile.SingleClusterRouting"
        }
    }

    /// Standard options for isolating this app profile's traffic from other use
    /// cases.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StandardIsolation {
        /// The priority of requests sent using this app profile.
        pub priority: crate::model::app_profile::Priority,
    }

    impl StandardIsolation {
        /// Sets the value of [priority][crate::model::app_profile::StandardIsolation::priority].
        pub fn set_priority<T: std::convert::Into<crate::model::app_profile::Priority>>(
            mut self,
            v: T,
        ) -> Self {
            self.priority = v.into();
            self
        }
    }

    impl wkt::message::Message for StandardIsolation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AppProfile.StandardIsolation"
        }
    }

    /// Data Boost is a serverless compute capability that lets you run
    /// high-throughput read jobs on your Bigtable data, without impacting the
    /// performance of the clusters that handle your application traffic.
    /// Currently, Data Boost exclusively supports read-only use-cases with
    /// single-cluster routing.
    ///
    /// Data Boost reads are only guaranteed to see the results of writes that
    /// were written at least 30 minutes ago. This means newly written values may
    /// not become visible for up to 30m, and also means that old values may
    /// remain visible for up to 30m after being deleted or overwritten. To
    /// mitigate the staleness of the data, users may either wait 30m, or use
    /// CheckConsistency.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DataBoostIsolationReadOnly {
        /// The Compute Billing Owner for this Data Boost App Profile.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub compute_billing_owner: std::option::Option<
            crate::model::app_profile::data_boost_isolation_read_only::ComputeBillingOwner,
        >,
    }

    impl DataBoostIsolationReadOnly {
        /// Sets the value of [compute_billing_owner][crate::model::app_profile::DataBoostIsolationReadOnly::compute_billing_owner].
        pub fn set_compute_billing_owner<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::app_profile::data_boost_isolation_read_only::ComputeBillingOwner,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.compute_billing_owner = v.into();
            self
        }
    }

    impl wkt::message::Message for DataBoostIsolationReadOnly {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AppProfile.DataBoostIsolationReadOnly"
        }
    }

    /// Defines additional types related to DataBoostIsolationReadOnly
    pub mod data_boost_isolation_read_only {
        #[allow(unused_imports)]
        use super::*;

        /// Compute Billing Owner specifies how usage should be accounted when using
        /// Data Boost. Compute Billing Owner also configures which Cloud Project is
        /// charged for relevant quota.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ComputeBillingOwner(std::string::String);

        impl ComputeBillingOwner {
            /// Sets the enum value.
            pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.0 = v.into();
                self
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [ComputeBillingOwner](ComputeBillingOwner)
        pub mod compute_billing_owner {

            /// Unspecified value.
            pub const COMPUTE_BILLING_OWNER_UNSPECIFIED: &str = "COMPUTE_BILLING_OWNER_UNSPECIFIED";

            /// The host Cloud Project containing the targeted Bigtable Instance /
            /// Table pays for compute.
            pub const HOST_PAYS: &str = "HOST_PAYS";
        }
    }

    /// Possible priorities for an app profile. Note that higher priority writes
    /// can sometimes queue behind lower priority writes to the same tablet, as
    /// writes must be strictly sequenced in the durability log.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Priority(std::string::String);

    impl Priority {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [Priority](Priority)
    pub mod priority {

        /// Default value. Mapped to PRIORITY_HIGH (the legacy behavior) on creation.
        pub const PRIORITY_UNSPECIFIED: &str = "PRIORITY_UNSPECIFIED";

        pub const PRIORITY_LOW: &str = "PRIORITY_LOW";

        pub const PRIORITY_MEDIUM: &str = "PRIORITY_MEDIUM";

        pub const PRIORITY_HIGH: &str = "PRIORITY_HIGH";
    }

    /// The routing policy for all read/write requests that use this app profile.
    /// A value must be explicitly set.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum RoutingPolicy {
        /// Use a multi-cluster routing policy.
        MultiClusterRoutingUseAny(crate::model::app_profile::MultiClusterRoutingUseAny),
        /// Use a single-cluster routing policy.
        SingleClusterRouting(crate::model::app_profile::SingleClusterRouting),
    }

    /// Options for isolating this app profile's traffic from other use cases.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Isolation {
        /// This field has been deprecated in favor of `standard_isolation.priority`.
        /// If you set this field, `standard_isolation.priority` will be set instead.
        ///
        /// The priority of requests sent using this app profile.
        Priority(crate::model::app_profile::Priority),
        /// The standard options used for isolating this app profile's traffic from
        /// other use cases.
        StandardIsolation(crate::model::app_profile::StandardIsolation),
        /// Specifies that this app profile is intended for read-only usage via the
        /// Data Boost feature.
        DataBoostIsolationReadOnly(crate::model::app_profile::DataBoostIsolationReadOnly),
    }
}

/// A tablet is a defined by a start and end key and is explained in
/// <https://cloud.google.com/bigtable/docs/overview#architecture> and
/// <https://cloud.google.com/bigtable/docs/performance#optimization>.
/// A Hot tablet is a tablet that exhibits high average cpu usage during the time
/// interval from start time to end time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HotTablet {
    /// The unique name of the hot tablet. Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/hotTablets/[a-zA-Z0-9_-]*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Name of the table that contains the tablet. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_name: std::string::String,

    /// Output only. The start time of the hot tablet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The end time of the hot tablet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Tablet Start Key (inclusive).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub start_key: std::string::String,

    /// Tablet End Key (inclusive).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub end_key: std::string::String,

    /// Output only. The average CPU usage spent by a node on this tablet over the
    /// start_time to end_time time range. The percentage is the amount of CPU used
    /// by the node to serve the tablet, from 0% (tablet was not interacted with)
    /// to 100% (the node spent all cycles serving the hot tablet).
    pub node_cpu_usage_percent: f32,
}

impl HotTablet {
    /// Sets the value of [name][crate::model::HotTablet::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [table_name][crate::model::HotTablet::table_name].
    pub fn set_table_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_name = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::HotTablet::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::HotTablet::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [start_key][crate::model::HotTablet::start_key].
    pub fn set_start_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.start_key = v.into();
        self
    }

    /// Sets the value of [end_key][crate::model::HotTablet::end_key].
    pub fn set_end_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.end_key = v.into();
        self
    }

    /// Sets the value of [node_cpu_usage_percent][crate::model::HotTablet::node_cpu_usage_percent].
    pub fn set_node_cpu_usage_percent<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.node_cpu_usage_percent = v.into();
        self
    }
}

impl wkt::message::Message for HotTablet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.HotTablet"
    }
}

/// Information about a table restore.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestoreInfo {
    /// The type of the restore source.
    pub source_type: crate::model::RestoreSourceType,

    /// Information about the source used to restore the table.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_info: std::option::Option<crate::model::restore_info::SourceInfo>,
}

impl RestoreInfo {
    /// Sets the value of [source_type][crate::model::RestoreInfo::source_type].
    pub fn set_source_type<T: std::convert::Into<crate::model::RestoreSourceType>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_type = v.into();
        self
    }

    /// Sets the value of `source_info`.
    pub fn set_source_info<
        T: std::convert::Into<std::option::Option<crate::model::restore_info::SourceInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_info = v.into();
        self
    }
}

impl wkt::message::Message for RestoreInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.RestoreInfo"
    }
}

/// Defines additional types related to RestoreInfo
pub mod restore_info {
    #[allow(unused_imports)]
    use super::*;

    /// Information about the source used to restore the table.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceInfo {
        /// Information about the backup used to restore the table. The backup
        /// may no longer exist.
        BackupInfo(crate::model::BackupInfo),
    }
}

/// Change stream configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ChangeStreamConfig {
    /// How long the change stream should be retained. Change stream data older
    /// than the retention period will not be returned when reading the change
    /// stream from the table.
    /// Values must be at least 1 day and at most 7 days, and will be truncated to
    /// microsecond granularity.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retention_period: std::option::Option<wkt::Duration>,
}

impl ChangeStreamConfig {
    /// Sets the value of [retention_period][crate::model::ChangeStreamConfig::retention_period].
    pub fn set_retention_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.retention_period = v.into();
        self
    }
}

impl wkt::message::Message for ChangeStreamConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ChangeStreamConfig"
    }
}

/// A collection of user data indexed by row, column, and timestamp.
/// Each table is served using the resources of its parent cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Table {
    /// The unique name of the table. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
    /// Views: `NAME_ONLY`, `SCHEMA_VIEW`, `REPLICATION_VIEW`, `FULL`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Map from cluster ID to per-cluster table state.
    /// If it could not be determined whether or not the table has data in a
    /// particular cluster (for example, if its zone is unavailable), then
    /// there will be an entry for the cluster with UNKNOWN `replication_status`.
    /// Views: `REPLICATION_VIEW`, `ENCRYPTION_VIEW`, `FULL`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub cluster_states:
        std::collections::HashMap<std::string::String, crate::model::table::ClusterState>,

    /// The column families configured for this table, mapped by column family ID.
    /// Views: `SCHEMA_VIEW`, `STATS_VIEW`, `FULL`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub column_families: std::collections::HashMap<std::string::String, crate::model::ColumnFamily>,

    /// Immutable. The granularity (i.e. `MILLIS`) at which timestamps are stored
    /// in this table. Timestamps not matching the granularity will be rejected. If
    /// unspecified at creation time, the value will be set to `MILLIS`. Views:
    /// `SCHEMA_VIEW`, `FULL`.
    pub granularity: crate::model::table::TimestampGranularity,

    /// Output only. If this table was restored from another data source (e.g. a
    /// backup), this field will be populated with information about the restore.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub restore_info: std::option::Option<crate::model::RestoreInfo>,

    /// If specified, enable the change stream on this table.
    /// Otherwise, the change stream is disabled and the change stream is not
    /// retained.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub change_stream_config: std::option::Option<crate::model::ChangeStreamConfig>,

    /// Set to true to make the table protected against data loss. i.e. deleting
    /// the following resources through Admin APIs are prohibited:
    ///
    /// * The table.
    /// * The column families in the table.
    /// * The instance containing the table.
    ///
    /// Note one can still delete the data stored in the table through Data APIs.
    pub deletion_protection: bool,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub automated_backup_config: std::option::Option<crate::model::table::AutomatedBackupConfig>,
}

impl Table {
    /// Sets the value of [name][crate::model::Table::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [granularity][crate::model::Table::granularity].
    pub fn set_granularity<T: std::convert::Into<crate::model::table::TimestampGranularity>>(
        mut self,
        v: T,
    ) -> Self {
        self.granularity = v.into();
        self
    }

    /// Sets the value of [restore_info][crate::model::Table::restore_info].
    pub fn set_restore_info<
        T: std::convert::Into<std::option::Option<crate::model::RestoreInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restore_info = v.into();
        self
    }

    /// Sets the value of [change_stream_config][crate::model::Table::change_stream_config].
    pub fn set_change_stream_config<
        T: std::convert::Into<std::option::Option<crate::model::ChangeStreamConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.change_stream_config = v.into();
        self
    }

    /// Sets the value of [deletion_protection][crate::model::Table::deletion_protection].
    pub fn set_deletion_protection<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deletion_protection = v.into();
        self
    }

    /// Sets the value of [cluster_states][crate::model::Table::cluster_states].
    pub fn set_cluster_states<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::table::ClusterState>,
    {
        use std::iter::Iterator;
        self.cluster_states = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [column_families][crate::model::Table::column_families].
    pub fn set_column_families<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ColumnFamily>,
    {
        use std::iter::Iterator;
        self.column_families = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `automated_backup_config`.
    pub fn set_automated_backup_config<
        T: std::convert::Into<std::option::Option<crate::model::table::AutomatedBackupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_backup_config = v.into();
        self
    }
}

impl wkt::message::Message for Table {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Table"
    }
}

/// Defines additional types related to Table
pub mod table {
    #[allow(unused_imports)]
    use super::*;

    /// The state of a table's data in a particular cluster.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ClusterState {
        /// Output only. The state of replication for the table in this cluster.
        pub replication_state: crate::model::table::cluster_state::ReplicationState,

        /// Output only. The encryption information for the table in this cluster.
        /// If the encryption key protecting this resource is customer managed, then
        /// its version can be rotated in Cloud Key Management Service (Cloud KMS).
        /// The primary version of the key and its status will be reflected here when
        /// changes propagate from Cloud KMS.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub encryption_info: std::vec::Vec<crate::model::EncryptionInfo>,
    }

    impl ClusterState {
        /// Sets the value of [replication_state][crate::model::table::ClusterState::replication_state].
        pub fn set_replication_state<
            T: std::convert::Into<crate::model::table::cluster_state::ReplicationState>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.replication_state = v.into();
            self
        }

        /// Sets the value of [encryption_info][crate::model::table::ClusterState::encryption_info].
        pub fn set_encryption_info<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::EncryptionInfo>,
        {
            use std::iter::Iterator;
            self.encryption_info = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ClusterState {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Table.ClusterState"
        }
    }

    /// Defines additional types related to ClusterState
    pub mod cluster_state {
        #[allow(unused_imports)]
        use super::*;

        /// Table replication states.
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ReplicationState(std::string::String);

        impl ReplicationState {
            /// Sets the enum value.
            pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.0 = v.into();
                self
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                &self.0
            }
        }

        /// Useful constants to work with [ReplicationState](ReplicationState)
        pub mod replication_state {

            /// The replication state of the table is unknown in this cluster.
            pub const STATE_NOT_KNOWN: &str = "STATE_NOT_KNOWN";

            /// The cluster was recently created, and the table must finish copying
            /// over pre-existing data from other clusters before it can begin
            /// receiving live replication updates and serving Data API requests.
            pub const INITIALIZING: &str = "INITIALIZING";

            /// The table is temporarily unable to serve Data API requests from this
            /// cluster due to planned internal maintenance.
            pub const PLANNED_MAINTENANCE: &str = "PLANNED_MAINTENANCE";

            /// The table is temporarily unable to serve Data API requests from this
            /// cluster due to unplanned or emergency maintenance.
            pub const UNPLANNED_MAINTENANCE: &str = "UNPLANNED_MAINTENANCE";

            /// The table can serve Data API requests from this cluster. Depending on
            /// replication delay, reads may not immediately reflect the state of the
            /// table in other clusters.
            pub const READY: &str = "READY";

            /// The table is fully created and ready for use after a restore, and is
            /// being optimized for performance. When optimizations are complete, the
            /// table will transition to `READY` state.
            pub const READY_OPTIMIZING: &str = "READY_OPTIMIZING";
        }
    }

    /// Defines an automated backup policy for a table
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AutomatedBackupPolicy {
        /// Required. How long the automated backups should be retained. The only
        /// supported value at this time is 3 days.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub retention_period: std::option::Option<wkt::Duration>,

        /// Required. How frequently automated backups should occur. The only
        /// supported value at this time is 24 hours.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub frequency: std::option::Option<wkt::Duration>,
    }

    impl AutomatedBackupPolicy {
        /// Sets the value of [retention_period][crate::model::table::AutomatedBackupPolicy::retention_period].
        pub fn set_retention_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.retention_period = v.into();
            self
        }

        /// Sets the value of [frequency][crate::model::table::AutomatedBackupPolicy::frequency].
        pub fn set_frequency<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.frequency = v.into();
            self
        }
    }

    impl wkt::message::Message for AutomatedBackupPolicy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Table.AutomatedBackupPolicy"
        }
    }

    /// Possible timestamp granularities to use when keeping multiple versions
    /// of data in a table.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TimestampGranularity(std::string::String);

    impl TimestampGranularity {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [TimestampGranularity](TimestampGranularity)
    pub mod timestamp_granularity {

        /// The user did not specify a granularity. Should not be returned.
        /// When specified during table creation, MILLIS will be used.
        pub const TIMESTAMP_GRANULARITY_UNSPECIFIED: &str = "TIMESTAMP_GRANULARITY_UNSPECIFIED";

        /// The table keeps data versioned at a granularity of 1ms.
        pub const MILLIS: &str = "MILLIS";
    }

    /// Defines a view over a table's fields.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct View(std::string::String);

    impl View {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [View](View)
    pub mod view {

        /// Uses the default view for each method as documented in its request.
        pub const VIEW_UNSPECIFIED: &str = "VIEW_UNSPECIFIED";

        /// Only populates `name`.
        pub const NAME_ONLY: &str = "NAME_ONLY";

        /// Only populates `name` and fields related to the table's schema.
        pub const SCHEMA_VIEW: &str = "SCHEMA_VIEW";

        /// Only populates `name` and fields related to the table's replication
        /// state.
        pub const REPLICATION_VIEW: &str = "REPLICATION_VIEW";

        /// Only populates `name` and fields related to the table's encryption state.
        pub const ENCRYPTION_VIEW: &str = "ENCRYPTION_VIEW";

        /// Populates all fields.
        pub const FULL: &str = "FULL";
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AutomatedBackupConfig {
        /// If specified, automated backups are enabled for this table.
        /// Otherwise, automated backups are disabled.
        AutomatedBackupPolicy(crate::model::table::AutomatedBackupPolicy),
    }
}

/// AuthorizedViews represent subsets of a particular Cloud Bigtable table. Users
/// can configure access to each Authorized View independently from the table and
/// use the existing Data APIs to access the subset of data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuthorizedView {
    /// Identifier. The name of this AuthorizedView.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{table}/authorizedViews/{authorized_view}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The etag for this AuthorizedView.
    /// If this is provided on update, it must match the server's etag. The server
    /// returns ABORTED error on a mismatched etag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Set to true to make the AuthorizedView protected against deletion.
    /// The parent Table and containing Instance cannot be deleted if an
    /// AuthorizedView has this bit set.
    pub deletion_protection: bool,

    /// The type of this AuthorizedView.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub authorized_view: std::option::Option<crate::model::authorized_view::AuthorizedView>,
}

impl AuthorizedView {
    /// Sets the value of [name][crate::model::AuthorizedView::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::AuthorizedView::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [deletion_protection][crate::model::AuthorizedView::deletion_protection].
    pub fn set_deletion_protection<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.deletion_protection = v.into();
        self
    }

    /// Sets the value of `authorized_view`.
    pub fn set_authorized_view<
        T: std::convert::Into<std::option::Option<crate::model::authorized_view::AuthorizedView>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorized_view = v.into();
        self
    }
}

impl wkt::message::Message for AuthorizedView {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.AuthorizedView"
    }
}

/// Defines additional types related to AuthorizedView
pub mod authorized_view {
    #[allow(unused_imports)]
    use super::*;

    /// Subsets of a column family that are included in this AuthorizedView.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FamilySubsets {
        /// Individual exact column qualifiers to be included in the AuthorizedView.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
        pub qualifiers: std::vec::Vec<bytes::Bytes>,

        /// Prefixes for qualifiers to be included in the AuthorizedView. Every
        /// qualifier starting with one of these prefixes is included in the
        /// AuthorizedView. To provide access to all qualifiers, include the empty
        /// string as a prefix
        /// ("").
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
        pub qualifier_prefixes: std::vec::Vec<bytes::Bytes>,
    }

    impl FamilySubsets {
        /// Sets the value of [qualifiers][crate::model::authorized_view::FamilySubsets::qualifiers].
        pub fn set_qualifiers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<bytes::Bytes>,
        {
            use std::iter::Iterator;
            self.qualifiers = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [qualifier_prefixes][crate::model::authorized_view::FamilySubsets::qualifier_prefixes].
        pub fn set_qualifier_prefixes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<bytes::Bytes>,
        {
            use std::iter::Iterator;
            self.qualifier_prefixes = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for FamilySubsets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AuthorizedView.FamilySubsets"
        }
    }

    /// Defines a simple AuthorizedView that is a subset of the underlying Table.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SubsetView {
        /// Row prefixes to be included in the AuthorizedView.
        /// To provide access to all rows, include the empty string as a prefix ("").
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
        pub row_prefixes: std::vec::Vec<bytes::Bytes>,

        /// Map from column family name to the columns in this family to be included
        /// in the AuthorizedView.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub family_subsets: std::collections::HashMap<
            std::string::String,
            crate::model::authorized_view::FamilySubsets,
        >,
    }

    impl SubsetView {
        /// Sets the value of [row_prefixes][crate::model::authorized_view::SubsetView::row_prefixes].
        pub fn set_row_prefixes<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<bytes::Bytes>,
        {
            use std::iter::Iterator;
            self.row_prefixes = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [family_subsets][crate::model::authorized_view::SubsetView::family_subsets].
        pub fn set_family_subsets<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<crate::model::authorized_view::FamilySubsets>,
        {
            use std::iter::Iterator;
            self.family_subsets = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for SubsetView {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.AuthorizedView.SubsetView"
        }
    }

    /// Defines a subset of an AuthorizedView's fields.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ResponseView(std::string::String);

    impl ResponseView {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [ResponseView](ResponseView)
    pub mod response_view {

        /// Uses the default view for each method as documented in the request.
        pub const RESPONSE_VIEW_UNSPECIFIED: &str = "RESPONSE_VIEW_UNSPECIFIED";

        /// Only populates `name`.
        pub const NAME_ONLY: &str = "NAME_ONLY";

        /// Only populates the AuthorizedView's basic metadata. This includes:
        /// name, deletion_protection, etag.
        pub const BASIC: &str = "BASIC";

        /// Populates every fields.
        pub const FULL: &str = "FULL";
    }

    /// The type of this AuthorizedView.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AuthorizedView {
        /// An AuthorizedView permitting access to an explicit subset of a Table.
        SubsetView(crate::model::authorized_view::SubsetView),
    }
}

/// A set of columns within a table which share a common configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ColumnFamily {
    /// Garbage collection rule specified as a protobuf.
    /// Must serialize to at most 500 bytes.
    ///
    /// NOTE: Garbage collection executes opportunistically in the background, and
    /// so it's possible for reads to return a cell even if it matches the active
    /// GC expression for its family.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gc_rule: std::option::Option<crate::model::GcRule>,

    /// The type of data stored in each of this family's cell values, including its
    /// full encoding. If omitted, the family only serves raw untyped bytes.
    ///
    /// For now, only the `Aggregate` type is supported.
    ///
    /// `Aggregate` can only be set at family creation and is immutable afterwards.
    ///
    /// If `value_type` is `Aggregate`, written data must be compatible with:
    ///
    /// * `value_type.input_type` for `AddInput` mutations
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub value_type: std::option::Option<crate::model::Type>,
}

impl ColumnFamily {
    /// Sets the value of [gc_rule][crate::model::ColumnFamily::gc_rule].
    pub fn set_gc_rule<T: std::convert::Into<std::option::Option<crate::model::GcRule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.gc_rule = v.into();
        self
    }

    /// Sets the value of [value_type][crate::model::ColumnFamily::value_type].
    pub fn set_value_type<T: std::convert::Into<std::option::Option<crate::model::Type>>>(
        mut self,
        v: T,
    ) -> Self {
        self.value_type = v.into();
        self
    }
}

impl wkt::message::Message for ColumnFamily {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.ColumnFamily"
    }
}

/// Rule for determining which cells to delete during garbage collection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GcRule {
    /// Garbage collection rules.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub rule: std::option::Option<crate::model::gc_rule::Rule>,
}

impl GcRule {
    /// Sets the value of `rule`.
    pub fn set_rule<T: std::convert::Into<std::option::Option<crate::model::gc_rule::Rule>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rule = v.into();
        self
    }
}

impl wkt::message::Message for GcRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.GcRule"
    }
}

/// Defines additional types related to GcRule
pub mod gc_rule {
    #[allow(unused_imports)]
    use super::*;

    /// A GcRule which deletes cells matching all of the given rules.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Intersection {
        /// Only delete cells which would be deleted by every element of `rules`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub rules: std::vec::Vec<crate::model::GcRule>,
    }

    impl Intersection {
        /// Sets the value of [rules][crate::model::gc_rule::Intersection::rules].
        pub fn set_rules<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::GcRule>,
        {
            use std::iter::Iterator;
            self.rules = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Intersection {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.GcRule.Intersection"
        }
    }

    /// A GcRule which deletes cells matching any of the given rules.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Union {
        /// Delete cells which would be deleted by any element of `rules`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub rules: std::vec::Vec<crate::model::GcRule>,
    }

    impl Union {
        /// Sets the value of [rules][crate::model::gc_rule::Union::rules].
        pub fn set_rules<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::GcRule>,
        {
            use std::iter::Iterator;
            self.rules = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Union {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.GcRule.Union"
        }
    }

    /// Garbage collection rules.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Rule {
        /// Delete all cells in a column except the most recent N.
        MaxNumVersions(i32),
        /// Delete cells in a column older than the given age.
        /// Values must be at least one millisecond, and will be truncated to
        /// microsecond granularity.
        MaxAge(wkt::Duration),
        /// Delete cells that would be deleted by every nested rule.
        Intersection(crate::model::gc_rule::Intersection),
        /// Delete cells that would be deleted by any nested rule.
        Union(crate::model::gc_rule::Union),
    }
}

/// Encryption information for a given resource.
/// If this resource is protected with customer managed encryption, the in-use
/// Cloud Key Management Service (Cloud KMS) key version is specified along with
/// its status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptionInfo {
    /// Output only. The type of encryption used to protect this resource.
    pub encryption_type: crate::model::encryption_info::EncryptionType,

    /// Output only. The status of encrypt/decrypt calls on underlying data for
    /// this resource. Regardless of status, the existing data is always encrypted
    /// at rest.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_status: std::option::Option<rpc::model::Status>,

    /// Output only. The version of the Cloud KMS key specified in the parent
    /// cluster that is in use for the data underlying this table.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_version: std::string::String,
}

impl EncryptionInfo {
    /// Sets the value of [encryption_type][crate::model::EncryptionInfo::encryption_type].
    pub fn set_encryption_type<
        T: std::convert::Into<crate::model::encryption_info::EncryptionType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_type = v.into();
        self
    }

    /// Sets the value of [encryption_status][crate::model::EncryptionInfo::encryption_status].
    pub fn set_encryption_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_status = v.into();
        self
    }

    /// Sets the value of [kms_key_version][crate::model::EncryptionInfo::kms_key_version].
    pub fn set_kms_key_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_version = v.into();
        self
    }
}

impl wkt::message::Message for EncryptionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.EncryptionInfo"
    }
}

/// Defines additional types related to EncryptionInfo
pub mod encryption_info {
    #[allow(unused_imports)]
    use super::*;

    /// Possible encryption types for a resource.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct EncryptionType(std::string::String);

    impl EncryptionType {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [EncryptionType](EncryptionType)
    pub mod encryption_type {

        /// Encryption type was not specified, though data at rest remains encrypted.
        pub const ENCRYPTION_TYPE_UNSPECIFIED: &str = "ENCRYPTION_TYPE_UNSPECIFIED";

        /// The data backing this resource is encrypted at rest with a key that is
        /// fully managed by Google. No key version or status will be populated.
        /// This is the default state.
        pub const GOOGLE_DEFAULT_ENCRYPTION: &str = "GOOGLE_DEFAULT_ENCRYPTION";

        /// The data backing this resource is encrypted at rest with a key that is
        /// managed by the customer.
        /// The in-use version of the key and its status are populated for
        /// CMEK-protected tables.
        /// CMEK-protected backups are pinned to the key version that was in use at
        /// the time the backup was taken. This key version is populated but its
        /// status is not tracked and is reported as `UNKNOWN`.
        pub const CUSTOMER_MANAGED_ENCRYPTION: &str = "CUSTOMER_MANAGED_ENCRYPTION";
    }
}

/// A snapshot of a table at a particular time. A snapshot can be used as a
/// checkpoint for data restoration or a data source for a new table.
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Snapshot {
    /// The unique name of the snapshot.
    /// Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/{snapshot}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The source table at the time the snapshot was taken.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_table: std::option::Option<crate::model::Table>,

    /// Output only. The size of the data in the source table at the time the
    /// snapshot was taken. In some cases, this value may be computed
    /// asynchronously via a background process and a placeholder of 0 will be used
    /// in the meantime.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub data_size_bytes: i64,

    /// Output only. The time when the snapshot is created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time when the snapshot will be deleted. The maximum amount of time a
    /// snapshot can stay active is 365 days. If 'ttl' is not specified,
    /// the default maximum of 365 days will be used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the snapshot.
    pub state: crate::model::snapshot::State,

    /// Description of the snapshot.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,
}

impl Snapshot {
    /// Sets the value of [name][crate::model::Snapshot::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_table][crate::model::Snapshot::source_table].
    pub fn set_source_table<T: std::convert::Into<std::option::Option<crate::model::Table>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_table = v.into();
        self
    }

    /// Sets the value of [data_size_bytes][crate::model::Snapshot::data_size_bytes].
    pub fn set_data_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.data_size_bytes = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Snapshot::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Snapshot::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Snapshot::state].
    pub fn set_state<T: std::convert::Into<crate::model::snapshot::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Snapshot::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for Snapshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Snapshot"
    }
}

/// Defines additional types related to Snapshot
pub mod snapshot {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a snapshot.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::string::String);

    impl State {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {

        /// The state of the snapshot could not be determined.
        pub const STATE_NOT_KNOWN: &str = "STATE_NOT_KNOWN";

        /// The snapshot has been successfully created and can serve all requests.
        pub const READY: &str = "READY";

        /// The snapshot is currently being created, and may be destroyed if the
        /// creation process encounters an error. A snapshot may not be restored to a
        /// table while it is being created.
        pub const CREATING: &str = "CREATING";
    }
}

/// A backup of a Cloud Bigtable table.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Backup {
    /// A globally unique identifier for the backup which cannot be
    /// changed. Values are of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}/
    /// backups/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`
    /// The final segment of the name must be between 1 and 50 characters
    /// in length.
    ///
    /// The backup is stored in the cluster identified by the prefix of the backup
    /// name of the form
    /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Immutable. Name of the table from which this backup was created.
    /// This needs to be in the same instance as the backup. Values are of the form
    /// `projects/{project}/instances/{instance}/tables/{source_table}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_table: std::string::String,

    /// Output only. Name of the backup from which this backup was copied. If a
    /// backup is not created by copying a backup, this field will be empty. Values
    /// are of the form:
    /// projects/\<project\>/instances/\<instance\>/clusters/\<cluster\>/backups/\<backup\>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_backup: std::string::String,

    /// Required. The expiration time of the backup.
    /// When creating a backup or updating its `expire_time`, the value must be
    /// greater than the backup creation time by:
    ///
    /// - At least 6 hours
    /// - At most 90 days
    ///
    /// Once the `expire_time` has passed, Cloud Bigtable will delete the backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. `start_time` is the time that the backup was started
    /// (i.e. approximately the time the
    /// [CreateBackup][google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup]
    /// request is received).  The row data in this backup will be no older than
    /// this timestamp.
    ///
    /// [google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup]: crate::client::BigtableTableAdmin::create_backup
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. `end_time` is the time that the backup was finished. The row
    /// data in the backup will be no newer than this timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Size of the backup in bytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub size_bytes: i64,

    /// Output only. The current state of the backup.
    pub state: crate::model::backup::State,

    /// Output only. The encryption information for the backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// Indicates the backup type of the backup.
    pub backup_type: crate::model::backup::BackupType,

    /// The time at which the hot backup will be converted to a standard backup.
    /// Once the `hot_to_standard_time` has passed, Cloud Bigtable will convert the
    /// hot backup to a standard backup. This value must be greater than the backup
    /// creation time by:
    ///
    /// - At least 24 hours
    ///
    /// This field only applies for hot backups. When creating or updating a
    /// standard backup, attempting to set this field will fail the request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hot_to_standard_time: std::option::Option<wkt::Timestamp>,
}

impl Backup {
    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_table][crate::model::Backup::source_table].
    pub fn set_source_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_table = v.into();
        self
    }

    /// Sets the value of [source_backup][crate::model::Backup::source_backup].
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_backup = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Backup::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Backup::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::Backup::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [encryption_info][crate::model::Backup::encryption_info].
    pub fn set_encryption_info<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_info = v.into();
        self
    }

    /// Sets the value of [backup_type][crate::model::Backup::backup_type].
    pub fn set_backup_type<T: std::convert::Into<crate::model::backup::BackupType>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_type = v.into();
        self
    }

    /// Sets the value of [hot_to_standard_time][crate::model::Backup::hot_to_standard_time].
    pub fn set_hot_to_standard_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.hot_to_standard_time = v.into();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Backup"
    }
}

/// Defines additional types related to Backup
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the current state of the backup.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::string::String);

    impl State {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {

        /// Not specified.
        pub const STATE_UNSPECIFIED: &str = "STATE_UNSPECIFIED";

        /// The pending backup is still being created. Operations on the
        /// backup may fail with `FAILED_PRECONDITION` in this state.
        pub const CREATING: &str = "CREATING";

        /// The backup is complete and ready for use.
        pub const READY: &str = "READY";
    }

    /// The type of the backup.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct BackupType(std::string::String);

    impl BackupType {
        /// Sets the enum value.
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.0 = v.into();
            self
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [BackupType](BackupType)
    pub mod backup_type {

        /// Not specified.
        pub const BACKUP_TYPE_UNSPECIFIED: &str = "BACKUP_TYPE_UNSPECIFIED";

        /// The default type for Cloud Bigtable managed backups. Supported for
        /// backups created in both HDD and SSD instances. Requires optimization when
        /// restored to a table in an SSD instance.
        pub const STANDARD: &str = "STANDARD";

        /// A backup type with faster restore to SSD performance. Only supported for
        /// backups created in SSD instances. A new SSD table restored from a hot
        /// backup reaches production performance more quickly than a standard
        /// backup.
        pub const HOT: &str = "HOT";
    }
}

/// Information about a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupInfo {
    /// Output only. Name of the backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backup: std::string::String,

    /// Output only. The time that the backup was started. Row data in the backup
    /// will be no older than this timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. This time that the backup was finished. Row data in the
    /// backup will be no newer than this timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Name of the table the backup was created from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_table: std::string::String,

    /// Output only. Name of the backup from which this backup was copied. If a
    /// backup is not created by copying a backup, this field will be empty. Values
    /// are of the form:
    /// projects/\<project\>/instances/\<instance\>/clusters/\<cluster\>/backups/\<backup\>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_backup: std::string::String,
}

impl BackupInfo {
    /// Sets the value of [backup][crate::model::BackupInfo::backup].
    pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backup = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::BackupInfo::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BackupInfo::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [source_table][crate::model::BackupInfo::source_table].
    pub fn set_source_table<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_table = v.into();
        self
    }

    /// Sets the value of [source_backup][crate::model::BackupInfo::source_backup].
    pub fn set_source_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_backup = v.into();
        self
    }
}

impl wkt::message::Message for BackupInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.BackupInfo"
    }
}

/// `Type` represents the type of data that is written to, read from, or stored
/// in Bigtable. It is heavily based on the GoogleSQL standard to help maintain
/// familiarity and consistency across products and features.
///
/// For compatibility with Bigtable's existing untyped APIs, each `Type` includes
/// an `Encoding` which describes how to convert to/from the underlying data.
///
/// Each encoding also defines the following properties:
///
/// * Order-preserving: Does the encoded value sort consistently with the
///   original typed value? Note that Bigtable will always sort data based on
///   the raw encoded value, *not* the decoded type.
///   - Example: BYTES values sort in the same order as their raw encodings.
///   - Counterexample: Encoding INT64 as a fixed-width decimal string does
///     *not* preserve sort order when dealing with negative numbers.
///     `INT64(1) > INT64(-1)`, but `STRING("-00001") > STRING("00001)`.
/// * Self-delimiting: If we concatenate two encoded values, can we always tell
///   where the first one ends and the second one begins?
///   - Example: If we encode INT64s to fixed-width STRINGs, the first value
///     will always contain exactly N digits, possibly preceded by a sign.
///   - Counterexample: If we concatenate two UTF-8 encoded STRINGs, we have
///     no way to tell where the first one ends.
/// * Compatibility: Which other systems have matching encoding schemes? For
///   example, does this encoding have a GoogleSQL equivalent? HBase? Java?
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Type {
    /// The kind of type that this represents.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub kind: std::option::Option<crate::model::r#type::Kind>,
}

impl Type {
    /// Sets the value of `kind`.
    pub fn set_kind<T: std::convert::Into<std::option::Option<crate::model::r#type::Kind>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kind = v.into();
        self
    }
}

impl wkt::message::Message for Type {
    fn typename() -> &'static str {
        "type.googleapis.com/google.bigtable.admin.v2.Type"
    }
}

/// Defines additional types related to Type
pub mod r#type {
    #[allow(unused_imports)]
    use super::*;

    /// Bytes
    /// Values of type `Bytes` are stored in `Value.bytes_value`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Bytes {
        /// The encoding to use when converting to/from lower level types.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub encoding: std::option::Option<crate::model::r#type::bytes::Encoding>,
    }

    impl Bytes {
        /// Sets the value of [encoding][crate::model::r#type::Bytes::encoding].
        pub fn set_encoding<
            T: std::convert::Into<std::option::Option<crate::model::r#type::bytes::Encoding>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encoding = v.into();
            self
        }
    }

    impl wkt::message::Message for Bytes {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Bytes"
        }
    }

    /// Defines additional types related to Bytes
    pub mod bytes {
        #[allow(unused_imports)]
        use super::*;

        /// Rules used to convert to/from lower level types.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Encoding {
            /// Which encoding to use.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub encoding: std::option::Option<crate::model::r#type::bytes::encoding::Encoding>,
        }

        impl Encoding {
            /// Sets the value of `encoding`.
            pub fn set_encoding<
                T: std::convert::Into<
                    std::option::Option<crate::model::r#type::bytes::encoding::Encoding>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }
        }

        impl wkt::message::Message for Encoding {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Bytes.Encoding"
            }
        }

        /// Defines additional types related to Encoding
        pub mod encoding {
            #[allow(unused_imports)]
            use super::*;

            /// Leaves the value "as-is"
            ///
            /// * Order-preserving? Yes
            /// * Self-delimiting? No
            /// * Compatibility? N/A
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Raw {}

            impl Raw {}

            impl wkt::message::Message for Raw {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.Bytes.Encoding.Raw"
                }
            }

            /// Which encoding to use.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Encoding {
                /// Use `Raw` encoding.
                Raw(crate::model::r#type::bytes::encoding::Raw),
            }
        }
    }

    /// String
    /// Values of type `String` are stored in `Value.string_value`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct String {
        /// The encoding to use when converting to/from lower level types.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub encoding: std::option::Option<crate::model::r#type::string::Encoding>,
    }

    impl String {
        /// Sets the value of [encoding][crate::model::r#type::String::encoding].
        pub fn set_encoding<
            T: std::convert::Into<std::option::Option<crate::model::r#type::string::Encoding>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encoding = v.into();
            self
        }
    }

    impl wkt::message::Message for String {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.String"
        }
    }

    /// Defines additional types related to String
    pub mod string {
        #[allow(unused_imports)]
        use super::*;

        /// Rules used to convert to/from lower level types.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Encoding {
            /// Which encoding to use.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub encoding: std::option::Option<crate::model::r#type::string::encoding::Encoding>,
        }

        impl Encoding {
            /// Sets the value of `encoding`.
            pub fn set_encoding<
                T: std::convert::Into<
                    std::option::Option<crate::model::r#type::string::encoding::Encoding>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }
        }

        impl wkt::message::Message for Encoding {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.String.Encoding"
            }
        }

        /// Defines additional types related to Encoding
        pub mod encoding {
            #[allow(unused_imports)]
            use super::*;

            /// Deprecated: prefer the equivalent `Utf8Bytes`.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Utf8Raw {}

            impl Utf8Raw {}

            impl wkt::message::Message for Utf8Raw {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.String.Encoding.Utf8Raw"
                }
            }

            /// UTF-8 encoding
            ///
            /// * Order-preserving? Yes (code point order)
            /// * Self-delimiting? No
            /// * Compatibility?
            ///   - BigQuery Federation `TEXT` encoding
            ///   - HBase `Bytes.toBytes`
            ///   - Java `String#getBytes(StandardCharsets.UTF_8)`
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Utf8Bytes {}

            impl Utf8Bytes {}

            impl wkt::message::Message for Utf8Bytes {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.String.Encoding.Utf8Bytes"
                }
            }

            /// Which encoding to use.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Encoding {
                /// Deprecated: if set, converts to an empty `utf8_bytes`.
                Utf8Raw(crate::model::r#type::string::encoding::Utf8Raw),
                /// Use `Utf8Bytes` encoding.
                Utf8Bytes(crate::model::r#type::string::encoding::Utf8Bytes),
            }
        }
    }

    /// Int64
    /// Values of type `Int64` are stored in `Value.int_value`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Int64 {
        /// The encoding to use when converting to/from lower level types.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub encoding: std::option::Option<crate::model::r#type::int_64::Encoding>,
    }

    impl Int64 {
        /// Sets the value of [encoding][crate::model::r#type::Int64::encoding].
        pub fn set_encoding<
            T: std::convert::Into<std::option::Option<crate::model::r#type::int_64::Encoding>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.encoding = v.into();
            self
        }
    }

    impl wkt::message::Message for Int64 {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Int64"
        }
    }

    /// Defines additional types related to Int64
    pub mod int_64 {
        #[allow(unused_imports)]
        use super::*;

        /// Rules used to convert to/from lower level types.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Encoding {
            /// Which encoding to use.
            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub encoding: std::option::Option<crate::model::r#type::int_64::encoding::Encoding>,
        }

        impl Encoding {
            /// Sets the value of `encoding`.
            pub fn set_encoding<
                T: std::convert::Into<
                    std::option::Option<crate::model::r#type::int_64::encoding::Encoding>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.encoding = v.into();
                self
            }
        }

        impl wkt::message::Message for Encoding {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Int64.Encoding"
            }
        }

        /// Defines additional types related to Encoding
        pub mod encoding {
            #[allow(unused_imports)]
            use super::*;

            /// Encodes the value as an 8-byte big endian twos complement `Bytes`
            /// value.
            ///
            /// * Order-preserving? No (positive values only)
            /// * Self-delimiting? Yes
            /// * Compatibility?
            ///   - BigQuery Federation `BINARY` encoding
            ///   - HBase `Bytes.toBytes`
            ///   - Java `ByteBuffer.putLong()` with `ByteOrder.BIG_ENDIAN`
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct BigEndianBytes {
                /// Deprecated: ignored if set.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub bytes_type: std::option::Option<crate::model::r#type::Bytes>,
            }

            impl BigEndianBytes {
                /// Sets the value of [bytes_type][crate::model::r#type::int_64::encoding::BigEndianBytes::bytes_type].
                pub fn set_bytes_type<
                    T: std::convert::Into<std::option::Option<crate::model::r#type::Bytes>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.bytes_type = v.into();
                    self
                }
            }

            impl wkt::message::Message for BigEndianBytes {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.bigtable.admin.v2.Type.Int64.Encoding.BigEndianBytes"
                }
            }

            /// Which encoding to use.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Encoding {
                /// Use `BigEndianBytes` encoding.
                BigEndianBytes(crate::model::r#type::int_64::encoding::BigEndianBytes),
            }
        }
    }

    /// bool
    /// Values of type `Bool` are stored in `Value.bool_value`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Bool {}

    impl Bool {}

    impl wkt::message::Message for Bool {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Bool"
        }
    }

    /// Float32
    /// Values of type `Float32` are stored in `Value.float_value`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Float32 {}

    impl Float32 {}

    impl wkt::message::Message for Float32 {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Float32"
        }
    }

    /// Float64
    /// Values of type `Float64` are stored in `Value.float_value`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Float64 {}

    impl Float64 {}

    impl wkt::message::Message for Float64 {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Float64"
        }
    }

    /// Timestamp
    /// Values of type `Timestamp` are stored in `Value.timestamp_value`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Timestamp {}

    impl Timestamp {}

    impl wkt::message::Message for Timestamp {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Timestamp"
        }
    }

    /// Date
    /// Values of type `Date` are stored in `Value.date_value`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Date {}

    impl Date {}

    impl wkt::message::Message for Date {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Date"
        }
    }

    /// A structured data value, consisting of fields which map to dynamically
    /// typed values.
    /// Values of type `Struct` are stored in `Value.array_value` where entries are
    /// in the same order and number as `field_types`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Struct {
        /// The names and types of the fields in this struct.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub fields: std::vec::Vec<crate::model::r#type::r#struct::Field>,
    }

    impl Struct {
        /// Sets the value of [fields][crate::model::r#type::Struct::fields].
        pub fn set_fields<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::r#type::r#struct::Field>,
        {
            use std::iter::Iterator;
            self.fields = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Struct {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Struct"
        }
    }

    /// Defines additional types related to Struct
    pub mod r#struct {
        #[allow(unused_imports)]
        use super::*;

        /// A struct field and its type.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Field {
            /// The field name (optional). Fields without a `field_name` are considered
            /// anonymous and cannot be referenced by name.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub field_name: std::string::String,

            /// The type of values in this field.
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub r#type: std::option::Option<std::boxed::Box<crate::model::Type>>,
        }

        impl Field {
            /// Sets the value of [field_name][crate::model::r#type::r#struct::Field::field_name].
            pub fn set_field_name<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.field_name = v.into();
                self
            }

            /// Sets the value of [r#type][crate::model::r#type::r#struct::Field::type].
            pub fn set_type<
                T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::Type>>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.r#type = v.into();
                self
            }
        }

        impl wkt::message::Message for Field {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Struct.Field"
            }
        }
    }

    /// An ordered list of elements of a given type.
    /// Values of type `Array` are stored in `Value.array_value`.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Array {
        /// The type of the elements in the array. This must not be `Array`.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub element_type: std::option::Option<std::boxed::Box<crate::model::Type>>,
    }

    impl Array {
        /// Sets the value of [element_type][crate::model::r#type::Array::element_type].
        pub fn set_element_type<
            T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::Type>>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.element_type = v.into();
            self
        }
    }

    impl wkt::message::Message for Array {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Array"
        }
    }

    /// A mapping of keys to values of a given type.
    /// Values of type `Map` are stored in a `Value.array_value` where each entry
    /// is another `Value.array_value` with two elements (the key and the value,
    /// in that order).
    /// Normally encoded Map values won't have repeated keys, however, clients are
    /// expected to handle the case in which they do. If the same key appears
    /// multiple times, the _last_ value takes precedence.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Map {
        /// The type of a map key.
        /// Only `Bytes`, `String`, and `Int64` are allowed as key types.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub key_type: std::option::Option<std::boxed::Box<crate::model::Type>>,

        /// The type of the values in a map.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub value_type: std::option::Option<std::boxed::Box<crate::model::Type>>,
    }

    impl Map {
        /// Sets the value of [key_type][crate::model::r#type::Map::key_type].
        pub fn set_key_type<
            T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::Type>>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.key_type = v.into();
            self
        }

        /// Sets the value of [value_type][crate::model::r#type::Map::value_type].
        pub fn set_value_type<
            T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::Type>>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.value_type = v.into();
            self
        }
    }

    impl wkt::message::Message for Map {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Map"
        }
    }

    /// A value that combines incremental updates into a summarized value.
    ///
    /// Data is never directly written or read using type `Aggregate`. Writes will
    /// provide either the `input_type` or `state_type`, and reads will always
    /// return the `state_type` .
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Aggregate {
        /// Type of the inputs that are accumulated by this `Aggregate`, which must
        /// specify a full encoding.
        /// Use `AddInput` mutations to accumulate new inputs.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub input_type: std::option::Option<std::boxed::Box<crate::model::Type>>,

        /// Output only. Type that holds the internal accumulator state for the
        /// `Aggregate`. This is a function of the `input_type` and `aggregator`
        /// chosen, and will always specify a full encoding.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub state_type: std::option::Option<std::boxed::Box<crate::model::Type>>,

        /// Which aggregator function to use. The configured types must match.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub aggregator: std::option::Option<crate::model::r#type::aggregate::Aggregator>,
    }

    impl Aggregate {
        /// Sets the value of [input_type][crate::model::r#type::Aggregate::input_type].
        pub fn set_input_type<
            T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::Type>>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.input_type = v.into();
            self
        }

        /// Sets the value of [state_type][crate::model::r#type::Aggregate::state_type].
        pub fn set_state_type<
            T: std::convert::Into<std::option::Option<std::boxed::Box<crate::model::Type>>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state_type = v.into();
            self
        }

        /// Sets the value of `aggregator`.
        pub fn set_aggregator<
            T: std::convert::Into<std::option::Option<crate::model::r#type::aggregate::Aggregator>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.aggregator = v.into();
            self
        }
    }

    impl wkt::message::Message for Aggregate {
        fn typename() -> &'static str {
            "type.googleapis.com/google.bigtable.admin.v2.Type.Aggregate"
        }
    }

    /// Defines additional types related to Aggregate
    pub mod aggregate {
        #[allow(unused_imports)]
        use super::*;

        /// Computes the sum of the input values.
        /// Allowed input: `Int64`
        /// State: same as input
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Sum {}

        impl Sum {}

        impl wkt::message::Message for Sum {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Aggregate.Sum"
            }
        }

        /// Computes the max of the input values.
        /// Allowed input: `Int64`
        /// State: same as input
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Max {}

        impl Max {}

        impl wkt::message::Message for Max {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Aggregate.Max"
            }
        }

        /// Computes the min of the input values.
        /// Allowed input: `Int64`
        /// State: same as input
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Min {}

        impl Min {}

        impl wkt::message::Message for Min {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Aggregate.Min"
            }
        }

        /// Computes an approximate unique count over the input values. When using
        /// raw data as input, be careful to use a consistent encoding. Otherwise
        /// the same value encoded differently could count more than once, or two
        /// distinct values could count as identical.
        /// Input: Any, or omit for Raw
        /// State: TBD
        /// Special state conversions: `Int64` (the unique count estimate)
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct HyperLogLogPlusPlusUniqueCount {}

        impl HyperLogLogPlusPlusUniqueCount {}

        impl wkt::message::Message for HyperLogLogPlusPlusUniqueCount {
            fn typename() -> &'static str {
                "type.googleapis.com/google.bigtable.admin.v2.Type.Aggregate.HyperLogLogPlusPlusUniqueCount"
            }
        }

        /// Which aggregator function to use. The configured types must match.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Aggregator {
            /// Sum aggregator.
            Sum(crate::model::r#type::aggregate::Sum),
            /// HyperLogLogPlusPlusUniqueCount aggregator.
            HllppUniqueCount(crate::model::r#type::aggregate::HyperLogLogPlusPlusUniqueCount),
            /// Max aggregator.
            Max(crate::model::r#type::aggregate::Max),
            /// Min aggregator.
            Min(crate::model::r#type::aggregate::Min),
        }
    }

    /// The kind of type that this represents.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Kind {
        /// Bytes
        BytesType(crate::model::r#type::Bytes),
        /// String
        StringType(crate::model::r#type::String),
        /// Int64
        Int64Type(crate::model::r#type::Int64),
        /// Float32
        Float32Type(crate::model::r#type::Float32),
        /// Float64
        Float64Type(crate::model::r#type::Float64),
        /// Bool
        BoolType(crate::model::r#type::Bool),
        /// Timestamp
        TimestampType(crate::model::r#type::Timestamp),
        /// Date
        DateType(crate::model::r#type::Date),
        /// Aggregate
        AggregateType(crate::model::r#type::Aggregate),
        /// Struct
        StructType(crate::model::r#type::Struct),
        /// Array
        ArrayType(crate::model::r#type::Array),
        /// Map
        MapType(crate::model::r#type::Map),
    }
}

/// Storage media types for persisting Bigtable data.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct StorageType(std::string::String);

impl StorageType {
    /// Sets the enum value.
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.0 = v.into();
        self
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [StorageType](StorageType)
pub mod storage_type {

    /// The user did not specify a storage type.
    pub const STORAGE_TYPE_UNSPECIFIED: &str = "STORAGE_TYPE_UNSPECIFIED";

    /// Flash (SSD) storage should be used.
    pub const SSD: &str = "SSD";

    /// Magnetic drive (HDD) storage should be used.
    pub const HDD: &str = "HDD";
}

/// Indicates the type of the restore source.
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct RestoreSourceType(std::string::String);

impl RestoreSourceType {
    /// Sets the enum value.
    pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.0 = v.into();
        self
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        &self.0
    }
}

/// Useful constants to work with [RestoreSourceType](RestoreSourceType)
pub mod restore_source_type {

    /// No restore associated.
    pub const RESTORE_SOURCE_TYPE_UNSPECIFIED: &str = "RESTORE_SOURCE_TYPE_UNSPECIFIED";

    /// A backup was used as the source of the restore.
    pub const BACKUP: &str = "BACKUP";
}
