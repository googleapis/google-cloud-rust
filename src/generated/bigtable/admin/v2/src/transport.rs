// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [BigtableInstanceAdmin](super::stub::BigtableInstanceAdmin) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct BigtableInstanceAdmin {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for BigtableInstanceAdmin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("BigtableInstanceAdmin")
            .field("inner", &self.inner)
            .finish()
    }
}

impl BigtableInstanceAdmin {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::BigtableInstanceAdmin for BigtableInstanceAdmin {
    async fn create_instance(
        &self,
        req: crate::model::CreateInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}/instances", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_instance(
        &self,
        req: crate::model::GetInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Instance>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_instances(
        &self,
        req: crate::model::ListInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListInstancesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/instances", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_instance(
        &self,
        req: crate::model::Instance,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Instance>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PUT, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn partial_update_instance(
        &self,
        req: crate::model::PartialUpdateInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}", {
            let arg = &req
                .instance
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("instance"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("instance.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.instance), options)
            .await
    }

    async fn delete_instance(
        &self,
        req: crate::model::DeleteInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn create_cluster(
        &self,
        req: crate::model::CreateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}/clusters", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("clusterId", &req.cluster_id)]);
        self.inner
            .execute(builder, Some(req.cluster), options)
            .await
    }

    async fn get_cluster(
        &self,
        req: crate::model::GetClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Cluster>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_clusters(
        &self,
        req: crate::model::ListClustersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListClustersResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/clusters", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_cluster(
        &self,
        req: crate::model::Cluster,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PUT, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn partial_update_cluster(
        &self,
        req: crate::model::PartialUpdateClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}", {
            let arg = &req
                .cluster
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("cluster"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("cluster.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.cluster), options)
            .await
    }

    async fn delete_cluster(
        &self,
        req: crate::model::DeleteClusterRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn create_app_profile(
        &self,
        req: crate::model::CreateAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AppProfile>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}/appProfiles", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("appProfileId", &req.app_profile_id)]);
        let builder = builder.query(&[("ignoreWarnings", &req.ignore_warnings)]);
        self.inner
            .execute(builder, Some(req.app_profile), options)
            .await
    }

    async fn get_app_profile(
        &self,
        req: crate::model::GetAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AppProfile>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_app_profiles(
        &self,
        req: crate::model::ListAppProfilesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAppProfilesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/appProfiles", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_app_profile(
        &self,
        req: crate::model::UpdateAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}", {
            let arg = &req
                .app_profile
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("app_profile"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("app_profile.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("ignoreWarnings", &req.ignore_warnings)]);
        self.inner
            .execute(builder, Some(req.app_profile), options)
            .await
    }

    async fn delete_app_profile(
        &self,
        req: crate::model::DeleteAppProfileRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("ignoreWarnings", &req.ignore_warnings)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:getIamPolicy", {
            let arg = &req.resource;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("resource"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:setIamPolicy", {
            let arg = &req.resource;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("resource"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:testIamPermissions", {
            let arg = &req.resource;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("resource"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_hot_tablets(
        &self,
        req: crate::model::ListHotTabletsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListHotTabletsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/hotTablets", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .start_time
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "startTime")
            });
        let builder = req
            .end_time
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "endTime")
            });
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_logical_view(
        &self,
        req: crate::model::CreateLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}/logicalViews", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("logicalViewId", &req.logical_view_id)]);
        self.inner
            .execute(builder, Some(req.logical_view), options)
            .await
    }

    async fn get_logical_view(
        &self,
        req: crate::model::GetLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LogicalView>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_logical_views(
        &self,
        req: crate::model::ListLogicalViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListLogicalViewsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/logicalViews", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_logical_view(
        &self,
        req: crate::model::UpdateLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}", {
            let arg = &req
                .logical_view
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("logical_view"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("logical_view.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.logical_view), options)
            .await
    }

    async fn delete_logical_view(
        &self,
        req: crate::model::DeleteLogicalViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn create_materialized_view(
        &self,
        req: crate::model::CreateMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}/materializedViews", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("materializedViewId", &req.materialized_view_id)]);
        self.inner
            .execute(builder, Some(req.materialized_view), options)
            .await
    }

    async fn get_materialized_view(
        &self,
        req: crate::model::GetMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MaterializedView>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_materialized_views(
        &self,
        req: crate::model::ListMaterializedViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListMaterializedViewsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/materializedViews", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_materialized_view(
        &self,
        req: crate::model::UpdateMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}", {
            let arg = &req
                .materialized_view
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("materialized_view"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("materialized_view.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner
            .execute(builder, Some(req.materialized_view), options)
            .await
    }

    async fn delete_materialized_view(
        &self,
        req: crate::model::DeleteMaterializedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/operations", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:cancel", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [BigtableTableAdmin](super::stub::BigtableTableAdmin) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct BigtableTableAdmin {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for BigtableTableAdmin {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("BigtableTableAdmin")
            .field("inner", &self.inner)
            .finish()
    }
}

impl BigtableTableAdmin {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::BigtableTableAdmin for BigtableTableAdmin {
    async fn create_table(
        &self,
        req: crate::model::CreateTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}/tables", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn create_table_from_snapshot(
        &self,
        req: crate::model::CreateTableFromSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}/tables:createFromSnapshot", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_tables(
        &self,
        req: crate::model::ListTablesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTablesResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/tables", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_table(
        &self,
        req: crate::model::GetTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_table(
        &self,
        req: crate::model::UpdateTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}", {
            let arg = &req
                .table
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("table"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("table.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("ignoreWarnings", &req.ignore_warnings)]);
        self.inner.execute(builder, Some(req.table), options).await
    }

    async fn delete_table(
        &self,
        req: crate::model::DeleteTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn undelete_table(
        &self,
        req: crate::model::UndeleteTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:undelete", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn create_authorized_view(
        &self,
        req: crate::model::CreateAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}/authorizedViews", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("authorizedViewId", &req.authorized_view_id)]);
        self.inner
            .execute(builder, Some(req.authorized_view), options)
            .await
    }

    async fn list_authorized_views(
        &self,
        req: crate::model::ListAuthorizedViewsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListAuthorizedViewsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/authorizedViews", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        let builder = builder.query(&[("view", &req.view)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_authorized_view(
        &self,
        req: crate::model::GetAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AuthorizedView>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("view", &req.view)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_authorized_view(
        &self,
        req: crate::model::UpdateAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}", {
            let arg = &req
                .authorized_view
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("authorized_view"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("authorized_view.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        let builder = builder.query(&[("ignoreWarnings", &req.ignore_warnings)]);
        self.inner
            .execute(builder, Some(req.authorized_view), options)
            .await
    }

    async fn delete_authorized_view(
        &self,
        req: crate::model::DeleteAuthorizedViewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("etag", &req.etag)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn modify_column_families(
        &self,
        req: crate::model::ModifyColumnFamiliesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Table>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:modifyColumnFamilies", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn drop_row_range(
        &self,
        req: crate::model::DropRowRangeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:dropRowRange", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn generate_consistency_token(
        &self,
        req: crate::model::GenerateConsistencyTokenRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GenerateConsistencyTokenResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:generateConsistencyToken", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn check_consistency(
        &self,
        req: crate::model::CheckConsistencyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CheckConsistencyResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:checkConsistency", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn snapshot_table(
        &self,
        req: crate::model::SnapshotTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:snapshot", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_snapshot(
        &self,
        req: crate::model::GetSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snapshot>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_snapshots(
        &self,
        req: crate::model::ListSnapshotsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSnapshotsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/snapshots", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_snapshot(
        &self,
        req: crate::model::DeleteSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn create_backup(
        &self,
        req: crate::model::CreateBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}/backups", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("backupId", &req.backup_id)]);
        self.inner.execute(builder, Some(req.backup), options).await
    }

    async fn get_backup(
        &self,
        req: crate::model::GetBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Backup>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_backup(
        &self,
        req: crate::model::UpdateBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Backup>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}", {
            let arg = &req
                .backup
                .as_ref()
                .ok_or_else(|| gaxi::path_parameter::missing("backup"))?
                .name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("backup.name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::PATCH, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::ser))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "updateMask")
            });
        self.inner.execute(builder, Some(req.backup), options).await
    }

    async fn delete_backup(
        &self,
        req: crate::model::DeleteBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_backups(
        &self,
        req: crate::model::ListBackupsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListBackupsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/backups", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("orderBy", &req.order_by)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn restore_table(
        &self,
        req: crate::model::RestoreTableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}/tables:restore", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn copy_backup(
        &self,
        req: crate::model::CopyBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}/backups:copy", {
            let arg = &req.parent;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("parent"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:getIamPolicy", {
            let arg = &req.resource;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("resource"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:setIamPolicy", {
            let arg = &req.resource;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("resource"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:testIamPermissions", {
            let arg = &req.resource;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("resource"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}/operations", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let path = format!("/v2/{}", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let path = format!("/v2/{}:cancel", {
            let arg = &req.name;
            if arg.is_empty() {
                return Err(gaxi::path_parameter::missing("name"));
            }
            arg
        },);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, path)
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(gaxi::http::NoBody), options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}
