// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A service that is available for use by the consumer.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Service {
    /// The resource name of the consumer and service.
    ///
    /// A valid name would be:
    ///
    /// - projects/123/services/serviceusage.googleapis.com
    pub name: std::string::String,

    /// The resource name of the consumer.
    ///
    /// A valid name would be:
    ///
    /// - projects/123
    pub parent: std::string::String,

    /// The service configuration of the available service.
    /// Some fields may be filtered out of the configuration in responses to
    /// the `ListServices` method. These fields are present only in responses to
    /// the `GetService` method.
    pub config: std::option::Option<crate::model::ServiceConfig>,

    /// Whether or not the service has been enabled for use by the consumer.
    pub state: crate::model::State,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Service {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Service::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::Service::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [config][crate::model::Service::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceConfig>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::Service::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceConfig>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Service::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }
}

impl wkt::message::Message for Service {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.Service"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Service {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __parent,
            __config,
            __state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Service")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "parent" => Ok(__FieldTag::__parent),
                            "config" => Ok(__FieldTag::__config),
                            "state" => Ok(__FieldTag::__state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Service;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Service")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config = map
                                .next_value::<std::option::Option<crate::model::ServiceConfig>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Service {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The configuration of the service.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceConfig {
    /// The DNS address at which this service is available.
    ///
    /// An example DNS address would be:
    /// `calendar.googleapis.com`.
    pub name: std::string::String,

    /// The product title for this service.
    pub title: std::string::String,

    /// A list of API interfaces exported by this service. Contains only the names,
    /// versions, and method names of the interfaces.
    pub apis: std::vec::Vec<wkt::Api>,

    /// Additional API documentation. Contains only the summary and the
    /// documentation URL.
    pub documentation: std::option::Option<api::model::Documentation>,

    /// Quota configuration.
    pub quota: std::option::Option<api::model::Quota>,

    /// Auth configuration. Contains only the OAuth rules.
    pub authentication: std::option::Option<api::model::Authentication>,

    /// Configuration controlling usage of this service.
    pub usage: std::option::Option<api::model::Usage>,

    /// Configuration for network endpoints. Contains only the names and aliases
    /// of the endpoints.
    pub endpoints: std::vec::Vec<api::model::Endpoint>,

    /// Defines the monitored resources used by this service. This is required
    /// by the [Service.monitoring][google.api.Service.monitoring] and
    /// [Service.logging][google.api.Service.logging] configurations.
    pub monitored_resources: std::vec::Vec<api::model::MonitoredResourceDescriptor>,

    /// Monitoring configuration.
    /// This should not include the 'producer_destinations' field.
    pub monitoring: std::option::Option<api::model::Monitoring>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ServiceConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [title][crate::model::ServiceConfig::title].
    pub fn set_title<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [apis][crate::model::ServiceConfig::apis].
    pub fn set_apis<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Api>,
    {
        use std::iter::Iterator;
        self.apis = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [documentation][crate::model::ServiceConfig::documentation].
    pub fn set_documentation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::Documentation>,
    {
        self.documentation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [documentation][crate::model::ServiceConfig::documentation].
    pub fn set_or_clear_documentation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::Documentation>,
    {
        self.documentation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [quota][crate::model::ServiceConfig::quota].
    pub fn set_quota<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::Quota>,
    {
        self.quota = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quota][crate::model::ServiceConfig::quota].
    pub fn set_or_clear_quota<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::Quota>,
    {
        self.quota = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authentication][crate::model::ServiceConfig::authentication].
    pub fn set_authentication<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::Authentication>,
    {
        self.authentication = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authentication][crate::model::ServiceConfig::authentication].
    pub fn set_or_clear_authentication<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::Authentication>,
    {
        self.authentication = v.map(|x| x.into());
        self
    }

    /// Sets the value of [usage][crate::model::ServiceConfig::usage].
    pub fn set_usage<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::Usage>,
    {
        self.usage = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [usage][crate::model::ServiceConfig::usage].
    pub fn set_or_clear_usage<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::Usage>,
    {
        self.usage = v.map(|x| x.into());
        self
    }

    /// Sets the value of [endpoints][crate::model::ServiceConfig::endpoints].
    pub fn set_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::Endpoint>,
    {
        use std::iter::Iterator;
        self.endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [monitored_resources][crate::model::ServiceConfig::monitored_resources].
    pub fn set_monitored_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::MonitoredResourceDescriptor>,
    {
        use std::iter::Iterator;
        self.monitored_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [monitoring][crate::model::ServiceConfig::monitoring].
    pub fn set_monitoring<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::Monitoring>,
    {
        self.monitoring = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [monitoring][crate::model::ServiceConfig::monitoring].
    pub fn set_or_clear_monitoring<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::Monitoring>,
    {
        self.monitoring = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ServiceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.ServiceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __title,
            __apis,
            __documentation,
            __quota,
            __authentication,
            __usage,
            __endpoints,
            __monitored_resources,
            __monitoring,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "title" => Ok(__FieldTag::__title),
                            "apis" => Ok(__FieldTag::__apis),
                            "documentation" => Ok(__FieldTag::__documentation),
                            "quota" => Ok(__FieldTag::__quota),
                            "authentication" => Ok(__FieldTag::__authentication),
                            "usage" => Ok(__FieldTag::__usage),
                            "endpoints" => Ok(__FieldTag::__endpoints),
                            "monitoredResources" => Ok(__FieldTag::__monitored_resources),
                            "monitored_resources" => Ok(__FieldTag::__monitored_resources),
                            "monitoring" => Ok(__FieldTag::__monitoring),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__title => {
                            if !fields.insert(__FieldTag::__title) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for title",
                                ));
                            }
                            result.title = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__apis => {
                            if !fields.insert(__FieldTag::__apis) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for apis",
                                ));
                            }
                            result.apis = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Api>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__documentation => {
                            if !fields.insert(__FieldTag::__documentation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for documentation",
                                ));
                            }
                            result.documentation =
                                map.next_value::<std::option::Option<api::model::Documentation>>()?;
                        }
                        __FieldTag::__quota => {
                            if !fields.insert(__FieldTag::__quota) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota",
                                ));
                            }
                            result.quota =
                                map.next_value::<std::option::Option<api::model::Quota>>()?;
                        }
                        __FieldTag::__authentication => {
                            if !fields.insert(__FieldTag::__authentication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authentication",
                                ));
                            }
                            result.authentication = map
                                .next_value::<std::option::Option<api::model::Authentication>>()?;
                        }
                        __FieldTag::__usage => {
                            if !fields.insert(__FieldTag::__usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for usage",
                                ));
                            }
                            result.usage =
                                map.next_value::<std::option::Option<api::model::Usage>>()?;
                        }
                        __FieldTag::__endpoints => {
                            if !fields.insert(__FieldTag::__endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoints",
                                ));
                            }
                            result.endpoints = map.next_value::<std::option::Option<std::vec::Vec<api::model::Endpoint>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__monitored_resources => {
                            if !fields.insert(__FieldTag::__monitored_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitored_resources",
                                ));
                            }
                            result.monitored_resources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<api::model::MonitoredResourceDescriptor>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__monitoring => {
                            if !fields.insert(__FieldTag::__monitoring) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for monitoring",
                                ));
                            }
                            result.monitoring =
                                map.next_value::<std::option::Option<api::model::Monitoring>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.title.is_empty() {
            state.serialize_entry("title", &self.title)?;
        }
        if !self.apis.is_empty() {
            state.serialize_entry("apis", &self.apis)?;
        }
        if self.documentation.is_some() {
            state.serialize_entry("documentation", &self.documentation)?;
        }
        if self.quota.is_some() {
            state.serialize_entry("quota", &self.quota)?;
        }
        if self.authentication.is_some() {
            state.serialize_entry("authentication", &self.authentication)?;
        }
        if self.usage.is_some() {
            state.serialize_entry("usage", &self.usage)?;
        }
        if !self.endpoints.is_empty() {
            state.serialize_entry("endpoints", &self.endpoints)?;
        }
        if !self.monitored_resources.is_empty() {
            state.serialize_entry("monitoredResources", &self.monitored_resources)?;
        }
        if self.monitoring.is_some() {
            state.serialize_entry("monitoring", &self.monitoring)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The operation metadata returned for the batchend services operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The full name of the resources that this operation is directly
    /// associated with.
    pub resource_names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_names][crate::model::OperationMetadata::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceNames" => Ok(__FieldTag::__resource_names),
                            "resource_names" => Ok(__FieldTag::__resource_names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_names => {
                            if !fields.insert(__FieldTag::__resource_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_names",
                                ));
                            }
                            result.resource_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_names.is_empty() {
            state.serialize_entry("resourceNames", &self.resource_names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the `EnableService` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableServiceRequest {
    /// Name of the consumer and service to enable the service on.
    ///
    /// The `EnableService` and `DisableService` methods currently only support
    /// projects.
    ///
    /// Enabling a service requires that the service is public or is shared with
    /// the user enabling the service.
    ///
    /// An example name would be:
    /// `projects/123/services/serviceusage.googleapis.com` where `123` is the
    /// project number.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EnableServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for EnableServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.EnableServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnableServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnableServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnableServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnableServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the `EnableService` method.
/// This response message is assigned to the `response` field of the returned
/// Operation when that operation is done.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableServiceResponse {
    /// The new state of the service after enabling.
    pub service: std::option::Option<crate::model::Service>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableServiceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::EnableServiceResponse::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::EnableServiceResponse::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EnableServiceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.EnableServiceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnableServiceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnableServiceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnableServiceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableServiceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service =
                                map.next_value::<std::option::Option<crate::model::Service>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnableServiceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the `DisableService` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableServiceRequest {
    /// Name of the consumer and service to disable the service on.
    ///
    /// The enable and disable methods currently only support projects.
    ///
    /// An example name would be:
    /// `projects/123/services/serviceusage.googleapis.com` where `123` is the
    /// project number.
    pub name: std::string::String,

    /// Indicates if services that are enabled and which depend on this service
    /// should also be disabled. If not set, an error will be generated if any
    /// enabled services depend on the service to be disabled. When set, the
    /// service, and any enabled services that depend on it, will be disabled
    /// together.
    pub disable_dependent_services: bool,

    /// Defines the behavior for checking service usage when disabling a service.
    pub check_if_service_has_usage: crate::model::disable_service_request::CheckIfServiceHasUsage,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DisableServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [disable_dependent_services][crate::model::DisableServiceRequest::disable_dependent_services].
    pub fn set_disable_dependent_services<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_dependent_services = v.into();
        self
    }

    /// Sets the value of [check_if_service_has_usage][crate::model::DisableServiceRequest::check_if_service_has_usage].
    pub fn set_check_if_service_has_usage<
        T: std::convert::Into<crate::model::disable_service_request::CheckIfServiceHasUsage>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.check_if_service_has_usage = v.into();
        self
    }
}

impl wkt::message::Message for DisableServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.DisableServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisableServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __disable_dependent_services,
            __check_if_service_has_usage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisableServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "disableDependentServices" => {
                                Ok(__FieldTag::__disable_dependent_services)
                            }
                            "disable_dependent_services" => {
                                Ok(__FieldTag::__disable_dependent_services)
                            }
                            "checkIfServiceHasUsage" => {
                                Ok(__FieldTag::__check_if_service_has_usage)
                            }
                            "check_if_service_has_usage" => {
                                Ok(__FieldTag::__check_if_service_has_usage)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisableServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisableServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disable_dependent_services => {
                            if !fields.insert(__FieldTag::__disable_dependent_services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_dependent_services",
                                ));
                            }
                            result.disable_dependent_services = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__check_if_service_has_usage => {
                            if !fields.insert(__FieldTag::__check_if_service_has_usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for check_if_service_has_usage",
                                ));
                            }
                            result.check_if_service_has_usage = map
                                .next_value::<std::option::Option<
                                    crate::model::disable_service_request::CheckIfServiceHasUsage,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisableServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.disable_dependent_services) {
            state.serialize_entry("disableDependentServices", &self.disable_dependent_services)?;
        }
        if !wkt::internal::is_default(&self.check_if_service_has_usage) {
            state.serialize_entry("checkIfServiceHasUsage", &self.check_if_service_has_usage)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DisableServiceRequest].
pub mod disable_service_request {
    #[allow(unused_imports)]
    use super::*;

    /// Enum to determine if service usage should be checked when disabling a
    /// service.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CheckIfServiceHasUsage {
        /// When unset, the default behavior is used, which is SKIP.
        Unspecified,
        /// If set, skip checking service usage when disabling a service.
        Skip,
        /// If set, service usage is checked when disabling the service. If a
        /// service, or its dependents, has usage in the last 30 days, the request
        /// returns a FAILED_PRECONDITION error.
        Check,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CheckIfServiceHasUsage::value] or
        /// [CheckIfServiceHasUsage::name].
        UnknownValue(check_if_service_has_usage::UnknownValue),
    }

    #[doc(hidden)]
    pub mod check_if_service_has_usage {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CheckIfServiceHasUsage {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skip => std::option::Option::Some(1),
                Self::Check => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CHECK_IF_SERVICE_HAS_USAGE_UNSPECIFIED")
                }
                Self::Skip => std::option::Option::Some("SKIP"),
                Self::Check => std::option::Option::Some("CHECK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CheckIfServiceHasUsage {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CheckIfServiceHasUsage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CheckIfServiceHasUsage {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skip,
                2 => Self::Check,
                _ => Self::UnknownValue(check_if_service_has_usage::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CheckIfServiceHasUsage {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CHECK_IF_SERVICE_HAS_USAGE_UNSPECIFIED" => Self::Unspecified,
                "SKIP" => Self::Skip,
                "CHECK" => Self::Check,
                _ => Self::UnknownValue(check_if_service_has_usage::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CheckIfServiceHasUsage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skip => serializer.serialize_i32(1),
                Self::Check => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CheckIfServiceHasUsage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CheckIfServiceHasUsage>::new(
                ".google.api.serviceusage.v1.DisableServiceRequest.CheckIfServiceHasUsage",
            ))
        }
    }
}

/// Response message for the `DisableService` method.
/// This response message is assigned to the `response` field of the returned
/// Operation when that operation is done.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DisableServiceResponse {
    /// The new state of the service after disabling.
    pub service: std::option::Option<crate::model::Service>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableServiceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::DisableServiceResponse::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::DisableServiceResponse::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Service>,
    {
        self.service = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DisableServiceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.DisableServiceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisableServiceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisableServiceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisableServiceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisableServiceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service =
                                map.next_value::<std::option::Option<crate::model::Service>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisableServiceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the `GetService` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServiceRequest {
    /// Name of the consumer and service to get the `ConsumerState` for.
    ///
    /// An example name would be:
    /// `projects/123/services/serviceusage.googleapis.com` where `123` is the
    /// project number.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServiceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.GetServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the `ListServices` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Parent to search for services on.
    ///
    /// An example name would be:
    /// `projects/123` where `123` is the project number.
    pub parent: std::string::String,

    /// Requested size of the next page of data.
    /// Requested page size cannot exceed 200.
    /// If not set, the default page size is 50.
    pub page_size: i32,

    /// Token identifying which result to start with, which is returned by a
    /// previous list call.
    pub page_token: std::string::String,

    /// Only list services that conform to the given filter.
    /// The allowed filter strings are `state:ENABLED` and `state:DISABLED`.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListServicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListServicesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.ListServicesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the `ListServices` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// The available services for the requested project.
    pub services: std::vec::Vec<crate::model::Service>,

    /// Token that can be passed to `ListServices` to resume a paginated
    /// query.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.ListServicesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __services,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "services" => Ok(__FieldTag::__services),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__services => {
                            if !fields.insert(__FieldTag::__services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services",
                                ));
                            }
                            result.services = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Service>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.services.is_empty() {
            state.serialize_entry("services", &self.services)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for the `BatchEnableServices` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchEnableServicesRequest {
    /// Parent to enable services on.
    ///
    /// An example name would be:
    /// `projects/123` where `123` is the project number.
    ///
    /// The `BatchEnableServices` method currently only supports projects.
    pub parent: std::string::String,

    /// The identifiers of the services to enable on the project.
    ///
    /// A valid identifier would be:
    /// serviceusage.googleapis.com
    ///
    /// Enabling services requires that each service is public or is shared with
    /// the user enabling the service.
    ///
    /// A single request can enable a maximum of 20 services at a time. If more
    /// than 20 services are specified, the request will fail, and no state changes
    /// will occur.
    pub service_ids: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchEnableServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchEnableServicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [service_ids][crate::model::BatchEnableServicesRequest::service_ids].
    pub fn set_service_ids<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.service_ids = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchEnableServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.BatchEnableServicesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchEnableServicesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __service_ids,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchEnableServicesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "serviceIds" => Ok(__FieldTag::__service_ids),
                            "service_ids" => Ok(__FieldTag::__service_ids),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchEnableServicesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchEnableServicesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_ids => {
                            if !fields.insert(__FieldTag::__service_ids) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_ids",
                                ));
                            }
                            result.service_ids = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchEnableServicesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.service_ids.is_empty() {
            state.serialize_entry("serviceIds", &self.service_ids)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the `BatchEnableServices` method.
/// This response message is assigned to the `response` field of the returned
/// Operation when that operation is done.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchEnableServicesResponse {
    /// The new state of the services after enabling.
    pub services: std::vec::Vec<crate::model::Service>,

    /// If allow_partial_success is true, and one or more services could not be
    /// enabled, this field contains the details about each failure.
    pub failures: std::vec::Vec<crate::model::batch_enable_services_response::EnableFailure>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchEnableServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::BatchEnableServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [failures][crate::model::BatchEnableServicesResponse::failures].
    pub fn set_failures<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::batch_enable_services_response::EnableFailure>,
    {
        use std::iter::Iterator;
        self.failures = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchEnableServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.BatchEnableServicesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchEnableServicesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __services,
            __failures,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchEnableServicesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "services" => Ok(__FieldTag::__services),
                            "failures" => Ok(__FieldTag::__failures),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchEnableServicesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchEnableServicesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__services => {
                            if !fields.insert(__FieldTag::__services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services",
                                ));
                            }
                            result.services = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Service>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__failures => {
                            if !fields.insert(__FieldTag::__failures) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failures",
                                ));
                            }
                            result.failures = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::batch_enable_services_response::EnableFailure,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchEnableServicesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.services.is_empty() {
            state.serialize_entry("services", &self.services)?;
        }
        if !self.failures.is_empty() {
            state.serialize_entry("failures", &self.failures)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BatchEnableServicesResponse].
pub mod batch_enable_services_response {
    #[allow(unused_imports)]
    use super::*;

    /// Provides error messages for the failing services.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct EnableFailure {
        /// The service id of a service that could not be enabled.
        pub service_id: std::string::String,

        /// An error message describing why the service could not be enabled.
        pub error_message: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl EnableFailure {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [service_id][crate::model::batch_enable_services_response::EnableFailure::service_id].
        pub fn set_service_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service_id = v.into();
            self
        }

        /// Sets the value of [error_message][crate::model::batch_enable_services_response::EnableFailure::error_message].
        pub fn set_error_message<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.error_message = v.into();
            self
        }
    }

    impl wkt::message::Message for EnableFailure {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.serviceusage.v1.BatchEnableServicesResponse.EnableFailure"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for EnableFailure {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __service_id,
                __error_message,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for EnableFailure")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "serviceId" => Ok(__FieldTag::__service_id),
                                "service_id" => Ok(__FieldTag::__service_id),
                                "errorMessage" => Ok(__FieldTag::__error_message),
                                "error_message" => Ok(__FieldTag::__error_message),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = EnableFailure;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct EnableFailure")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__service_id => {
                                if !fields.insert(__FieldTag::__service_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_id",
                                    ));
                                }
                                result.service_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__error_message => {
                                if !fields.insert(__FieldTag::__error_message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_message",
                                    ));
                                }
                                result.error_message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for EnableFailure {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.service_id.is_empty() {
                state.serialize_entry("serviceId", &self.service_id)?;
            }
            if !self.error_message.is_empty() {
                state.serialize_entry("errorMessage", &self.error_message)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Request message for the `BatchGetServices` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchGetServicesRequest {
    /// Parent to retrieve services from.
    /// If this is set, the parent of all of the services specified in `names` must
    /// match this field. An example name would be: `projects/123` where `123` is
    /// the project number. The `BatchGetServices` method currently only supports
    /// projects.
    pub parent: std::string::String,

    /// Names of the services to retrieve.
    ///
    /// An example name would be:
    /// `projects/123/services/serviceusage.googleapis.com` where `123` is the
    /// project number.
    /// A single request can get a maximum of 30 services at a time.
    pub names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchGetServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::BatchGetServicesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [names][crate::model::BatchGetServicesRequest::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchGetServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.BatchGetServicesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchGetServicesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchGetServicesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "names" => Ok(__FieldTag::__names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchGetServicesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchGetServicesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchGetServicesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the `BatchGetServices` method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BatchGetServicesResponse {
    /// The requested Service states.
    pub services: std::vec::Vec<crate::model::Service>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BatchGetServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::BatchGetServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Service>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for BatchGetServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.serviceusage.v1.BatchGetServicesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BatchGetServicesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __services,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BatchGetServicesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "services" => Ok(__FieldTag::__services),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BatchGetServicesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BatchGetServicesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__services => {
                            if !fields.insert(__FieldTag::__services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services",
                                ));
                            }
                            result.services = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Service>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BatchGetServicesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.services.is_empty() {
            state.serialize_entry("services", &self.services)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Whether or not a service has been enabled for use by a consumer.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum State {
    /// The default value, which indicates that the enabled state of the service
    /// is unspecified or not meaningful. Currently, all consumers other than
    /// projects (such as folders and organizations) are always in this state.
    Unspecified,
    /// The service cannot be used by this consumer. It has either been explicitly
    /// disabled, or has never been enabled.
    Disabled,
    /// The service has been explicitly enabled for use by this consumer.
    Enabled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [State::value] or
    /// [State::name].
    UnknownValue(state::UnknownValue),
}

#[doc(hidden)]
pub mod state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl State {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Disabled => std::option::Option::Some(1),
            Self::Enabled => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
            Self::Disabled => std::option::Option::Some("DISABLED"),
            Self::Enabled => std::option::Option::Some("ENABLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for State {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for State {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Disabled,
            2 => Self::Enabled,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for State {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STATE_UNSPECIFIED" => Self::Unspecified,
            "DISABLED" => Self::Disabled,
            "ENABLED" => Self::Enabled,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for State {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Disabled => serializer.serialize_i32(1),
            Self::Enabled => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for State {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
            ".google.api.serviceusage.v1.State",
        ))
    }
}
