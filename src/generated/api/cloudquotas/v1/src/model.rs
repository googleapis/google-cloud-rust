// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Message for requesting list of QuotaInfos
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQuotaInfosRequest {
    /// Required. Parent value of QuotaInfo resources.
    /// Listing across different resource containers (such as 'projects/-') is not
    /// allowed.
    ///
    /// Example names:
    /// `projects/123/locations/global/services/compute.googleapis.com`
    /// `folders/234/locations/global/services/compute.googleapis.com`
    /// `organizations/345/locations/global/services/compute.googleapis.com`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaInfosRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQuotaInfosRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQuotaInfosRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQuotaInfosRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQuotaInfosRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.ListQuotaInfosRequest"
    }
}

/// Message for response to listing QuotaInfos
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQuotaInfosResponse {
    /// The list of QuotaInfo
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub quota_infos: std::vec::Vec<crate::model::QuotaInfo>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaInfosResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quota_infos][crate::model::ListQuotaInfosResponse::quota_infos].
    pub fn set_quota_infos<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaInfo>,
    {
        use std::iter::Iterator;
        self.quota_infos = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQuotaInfosResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQuotaInfosResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.ListQuotaInfosResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQuotaInfosResponse {
    type PageItem = crate::model::QuotaInfo;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.quota_infos
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a QuotaInfo
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetQuotaInfoRequest {
    /// Required. The resource name of the quota info.
    ///
    /// An example name:
    /// `projects/123/locations/global/services/compute.googleapis.com/quotaInfos/CpusPerProjectPerRegion`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQuotaInfoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQuotaInfoRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQuotaInfoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.GetQuotaInfoRequest"
    }
}

/// Message for requesting list of QuotaPreferences
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQuotaPreferencesRequest {
    /// Required. Parent value of QuotaPreference resources.
    /// Listing across different resource containers (such as 'projects/-') is not
    /// allowed.
    ///
    /// When the value starts with 'folders' or 'organizations', it lists the
    /// QuotaPreferences for org quotas in the container. It does not list the
    /// QuotaPreferences in the descendant projects of the container.
    ///
    /// Example parents:
    /// `projects/123/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I32>")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub page_token: std::string::String,

    /// Optional. Filter result QuotaPreferences by their state, type,
    /// create/update time range.
    ///
    /// Example filters:
    /// `reconciling=true AND request_type=CLOUD_CONSOLE`,
    /// `reconciling=true OR creation_time>2022-12-03T10:30:00`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub filter: std::string::String,

    /// Optional. How to order of the results. By default, the results are ordered
    /// by create time.
    ///
    /// Example orders:
    /// `quota_id`,
    /// `service, create_time`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaPreferencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQuotaPreferencesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQuotaPreferencesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQuotaPreferencesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListQuotaPreferencesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListQuotaPreferencesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListQuotaPreferencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.ListQuotaPreferencesRequest"
    }
}

/// Message for response to listing QuotaPreferences
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListQuotaPreferencesResponse {
    /// The list of QuotaPreference
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub quota_preferences: std::vec::Vec<crate::model::QuotaPreference>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaPreferencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quota_preferences][crate::model::ListQuotaPreferencesResponse::quota_preferences].
    pub fn set_quota_preferences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaPreference>,
    {
        use std::iter::Iterator;
        self.quota_preferences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQuotaPreferencesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListQuotaPreferencesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListQuotaPreferencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.ListQuotaPreferencesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQuotaPreferencesResponse {
    type PageItem = crate::model::QuotaPreference;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.quota_preferences
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a QuotaPreference
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetQuotaPreferenceRequest {
    /// Required. Name of the resource
    ///
    /// Example name:
    /// `projects/123/locations/global/quota_preferences/my-config-for-us-east1`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQuotaPreferenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQuotaPreferenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQuotaPreferenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.GetQuotaPreferenceRequest"
    }
}

/// Message for creating a QuotaPreference
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateQuotaPreferenceRequest {
    /// Required. Value for parent.
    ///
    /// Example:
    /// `projects/123/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub parent: std::string::String,

    /// Optional. Id of the requesting object, must be unique under its parent.
    /// If client does not set this field, the service will generate one.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub quota_preference_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quota_preference: std::option::Option<crate::model::QuotaPreference>,

    /// The list of quota safety checks to be ignored.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub ignore_safety_checks: std::vec::Vec<crate::model::QuotaSafetyCheck>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateQuotaPreferenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQuotaPreferenceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [quota_preference_id][crate::model::CreateQuotaPreferenceRequest::quota_preference_id].
    pub fn set_quota_preference_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.quota_preference_id = v.into();
        self
    }

    /// Sets the value of [quota_preference][crate::model::CreateQuotaPreferenceRequest::quota_preference].
    pub fn set_quota_preference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaPreference>,
    {
        self.quota_preference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quota_preference][crate::model::CreateQuotaPreferenceRequest::quota_preference].
    pub fn set_or_clear_quota_preference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaPreference>,
    {
        self.quota_preference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ignore_safety_checks][crate::model::CreateQuotaPreferenceRequest::ignore_safety_checks].
    pub fn set_ignore_safety_checks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaSafetyCheck>,
    {
        use std::iter::Iterator;
        self.ignore_safety_checks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateQuotaPreferenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.CreateQuotaPreferenceRequest"
    }
}

/// Message for updating a QuotaPreference
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateQuotaPreferenceRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// QuotaPreference resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quota_preference: std::option::Option<crate::model::QuotaPreference>,

    /// Optional. If set to true, and the quota preference is not found, a new one
    /// will be created. In this situation, `update_mask` is ignored.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub allow_missing: bool,

    /// Optional. If set to true, validate the request, but do not actually update.
    /// Note that a request being valid does not mean that the request is
    /// guaranteed to be fulfilled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub validate_only: bool,

    /// The list of quota safety checks to be ignored.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub ignore_safety_checks: std::vec::Vec<crate::model::QuotaSafetyCheck>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateQuotaPreferenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateQuotaPreferenceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateQuotaPreferenceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [quota_preference][crate::model::UpdateQuotaPreferenceRequest::quota_preference].
    pub fn set_quota_preference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaPreference>,
    {
        self.quota_preference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quota_preference][crate::model::UpdateQuotaPreferenceRequest::quota_preference].
    pub fn set_or_clear_quota_preference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaPreference>,
    {
        self.quota_preference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateQuotaPreferenceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateQuotaPreferenceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [ignore_safety_checks][crate::model::UpdateQuotaPreferenceRequest::ignore_safety_checks].
    pub fn set_ignore_safety_checks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaSafetyCheck>,
    {
        use std::iter::Iterator;
        self.ignore_safety_checks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpdateQuotaPreferenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.UpdateQuotaPreferenceRequest"
    }
}

/// QuotaInfo represents information about a particular quota for a given
/// project, folder or organization.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuotaInfo {
    /// Resource name of this QuotaInfo.
    /// The ID component following "locations/" must be "global".
    /// Example:
    /// `projects/123/locations/global/services/compute.googleapis.com/quotaInfos/CpusPerProjectPerRegion`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// The id of the quota, which is unquie within the service.
    /// Example: `CpusPerProjectPerRegion`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub quota_id: std::string::String,

    /// The metric of the quota. It specifies the resources consumption the quota
    /// is defined for.
    /// Example: `compute.googleapis.com/cpus`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub metric: std::string::String,

    /// The name of the service in which the quota is defined.
    /// Example: `compute.googleapis.com`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service: std::string::String,

    /// Whether this is a precise quota. A precise quota is tracked with absolute
    /// precision. In contrast, an imprecise quota is not tracked with precision.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_precise: bool,

    /// The reset time interval for the quota. Refresh interval applies to rate
    /// quota only.
    /// Example: "minute" for per minute, "day" for per day, or "10 seconds" for
    /// every 10 seconds.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub refresh_interval: std::string::String,

    /// The container type of the QuotaInfo.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub container_type: crate::model::quota_info::ContainerType,

    /// The dimensions the quota is defined on.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub dimensions: std::vec::Vec<std::string::String>,

    /// The display name of the quota metric
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub metric_display_name: std::string::String,

    /// The display name of the quota.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub quota_display_name: std::string::String,

    /// The unit in which the metric value is reported, e.g., "MByte".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub metric_unit: std::string::String,

    /// Whether it is eligible to request a higher quota value for this quota.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quota_increase_eligibility: std::option::Option<crate::model::QuotaIncreaseEligibility>,

    /// Whether the quota value is fixed or adjustable
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_fixed: bool,

    /// The collection of dimensions info ordered by their dimensions from more
    /// specific ones to less specific ones.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub dimensions_infos: std::vec::Vec<crate::model::DimensionsInfo>,

    /// Whether the quota is a concurrent quota. Concurrent quotas are enforced
    /// on the total number of concurrent operations in flight at any given time.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_concurrent: bool,

    /// URI to the page where users can request more quota for the cloud
    /// service—for example,
    /// <https://console.cloud.google.com/iam-admin/quotas>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service_request_quota_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QuotaInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [quota_id][crate::model::QuotaInfo::quota_id].
    pub fn set_quota_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.quota_id = v.into();
        self
    }

    /// Sets the value of [metric][crate::model::QuotaInfo::metric].
    pub fn set_metric<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric = v.into();
        self
    }

    /// Sets the value of [service][crate::model::QuotaInfo::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [is_precise][crate::model::QuotaInfo::is_precise].
    pub fn set_is_precise<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_precise = v.into();
        self
    }

    /// Sets the value of [refresh_interval][crate::model::QuotaInfo::refresh_interval].
    pub fn set_refresh_interval<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_interval = v.into();
        self
    }

    /// Sets the value of [container_type][crate::model::QuotaInfo::container_type].
    pub fn set_container_type<T: std::convert::Into<crate::model::quota_info::ContainerType>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_type = v.into();
        self
    }

    /// Sets the value of [dimensions][crate::model::QuotaInfo::dimensions].
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metric_display_name][crate::model::QuotaInfo::metric_display_name].
    pub fn set_metric_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_display_name = v.into();
        self
    }

    /// Sets the value of [quota_display_name][crate::model::QuotaInfo::quota_display_name].
    pub fn set_quota_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.quota_display_name = v.into();
        self
    }

    /// Sets the value of [metric_unit][crate::model::QuotaInfo::metric_unit].
    pub fn set_metric_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_unit = v.into();
        self
    }

    /// Sets the value of [quota_increase_eligibility][crate::model::QuotaInfo::quota_increase_eligibility].
    pub fn set_quota_increase_eligibility<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaIncreaseEligibility>,
    {
        self.quota_increase_eligibility = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quota_increase_eligibility][crate::model::QuotaInfo::quota_increase_eligibility].
    pub fn set_or_clear_quota_increase_eligibility<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaIncreaseEligibility>,
    {
        self.quota_increase_eligibility = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_fixed][crate::model::QuotaInfo::is_fixed].
    pub fn set_is_fixed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_fixed = v.into();
        self
    }

    /// Sets the value of [dimensions_infos][crate::model::QuotaInfo::dimensions_infos].
    pub fn set_dimensions_infos<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DimensionsInfo>,
    {
        use std::iter::Iterator;
        self.dimensions_infos = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [is_concurrent][crate::model::QuotaInfo::is_concurrent].
    pub fn set_is_concurrent<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_concurrent = v.into();
        self
    }

    /// Sets the value of [service_request_quota_uri][crate::model::QuotaInfo::service_request_quota_uri].
    pub fn set_service_request_quota_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_request_quota_uri = v.into();
        self
    }
}

impl wkt::message::Message for QuotaInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.QuotaInfo"
    }
}

/// Defines additional types related to [QuotaInfo].
pub mod quota_info {
    #[allow(unused_imports)]
    use super::*;

    /// The enumeration of the types of a cloud resource container.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ContainerType {
        /// Unspecified container type.
        Unspecified,
        /// consumer project
        Project,
        /// folder
        Folder,
        /// organization
        Organization,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ContainerType::value] or
        /// [ContainerType::name].
        UnknownValue(container_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod container_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ContainerType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Project => std::option::Option::Some(1),
                Self::Folder => std::option::Option::Some(2),
                Self::Organization => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONTAINER_TYPE_UNSPECIFIED"),
                Self::Project => std::option::Option::Some("PROJECT"),
                Self::Folder => std::option::Option::Some("FOLDER"),
                Self::Organization => std::option::Option::Some("ORGANIZATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ContainerType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ContainerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ContainerType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Project,
                2 => Self::Folder,
                3 => Self::Organization,
                _ => Self::UnknownValue(container_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ContainerType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONTAINER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PROJECT" => Self::Project,
                "FOLDER" => Self::Folder,
                "ORGANIZATION" => Self::Organization,
                _ => Self::UnknownValue(container_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ContainerType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Project => serializer.serialize_i32(1),
                Self::Folder => serializer.serialize_i32(2),
                Self::Organization => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ContainerType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContainerType>::new(
                ".google.api.cloudquotas.v1.QuotaInfo.ContainerType",
            ))
        }
    }
}

/// Eligibility information regarding requesting increase adjustment of a quota.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuotaIncreaseEligibility {
    /// Whether a higher quota value can be requested for the quota.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub is_eligible: bool,

    /// The reason of why it is ineligible to request increased value of the quota.
    /// If the is_eligible field is true, it defaults to
    /// INELIGIBILITY_REASON_UNSPECIFIED.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ineligibility_reason: crate::model::quota_increase_eligibility::IneligibilityReason,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaIncreaseEligibility {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [is_eligible][crate::model::QuotaIncreaseEligibility::is_eligible].
    pub fn set_is_eligible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_eligible = v.into();
        self
    }

    /// Sets the value of [ineligibility_reason][crate::model::QuotaIncreaseEligibility::ineligibility_reason].
    pub fn set_ineligibility_reason<
        T: std::convert::Into<crate::model::quota_increase_eligibility::IneligibilityReason>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ineligibility_reason = v.into();
        self
    }
}

impl wkt::message::Message for QuotaIncreaseEligibility {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.QuotaIncreaseEligibility"
    }
}

/// Defines additional types related to [QuotaIncreaseEligibility].
pub mod quota_increase_eligibility {
    #[allow(unused_imports)]
    use super::*;

    /// The enumeration of reasons when it is ineligible to request increase
    /// adjustment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IneligibilityReason {
        /// Default value when is_eligible is true.
        Unspecified,
        /// The container is not linked with a valid billing account.
        NoValidBillingAccount,
        /// Quota increase is not supported for the quota.
        NotSupported,
        /// There is not enough usage history to determine the eligibility.
        NotEnoughUsageHistory,
        /// Other reasons.
        Other,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IneligibilityReason::value] or
        /// [IneligibilityReason::name].
        UnknownValue(ineligibility_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ineligibility_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IneligibilityReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoValidBillingAccount => std::option::Option::Some(1),
                Self::NotSupported => std::option::Option::Some(3),
                Self::NotEnoughUsageHistory => std::option::Option::Some(4),
                Self::Other => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INELIGIBILITY_REASON_UNSPECIFIED"),
                Self::NoValidBillingAccount => {
                    std::option::Option::Some("NO_VALID_BILLING_ACCOUNT")
                }
                Self::NotSupported => std::option::Option::Some("NOT_SUPPORTED"),
                Self::NotEnoughUsageHistory => {
                    std::option::Option::Some("NOT_ENOUGH_USAGE_HISTORY")
                }
                Self::Other => std::option::Option::Some("OTHER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IneligibilityReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IneligibilityReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IneligibilityReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoValidBillingAccount,
                2 => Self::Other,
                3 => Self::NotSupported,
                4 => Self::NotEnoughUsageHistory,
                _ => Self::UnknownValue(ineligibility_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IneligibilityReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INELIGIBILITY_REASON_UNSPECIFIED" => Self::Unspecified,
                "NO_VALID_BILLING_ACCOUNT" => Self::NoValidBillingAccount,
                "NOT_SUPPORTED" => Self::NotSupported,
                "NOT_ENOUGH_USAGE_HISTORY" => Self::NotEnoughUsageHistory,
                "OTHER" => Self::Other,
                _ => Self::UnknownValue(ineligibility_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IneligibilityReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoValidBillingAccount => serializer.serialize_i32(1),
                Self::NotSupported => serializer.serialize_i32(3),
                Self::NotEnoughUsageHistory => serializer.serialize_i32(4),
                Self::Other => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IneligibilityReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IneligibilityReason>::new(
                ".google.api.cloudquotas.v1.QuotaIncreaseEligibility.IneligibilityReason",
            ))
        }
    }
}

/// QuotaPreference represents the preferred quota configuration specified for
/// a project, folder or organization. There is only one QuotaPreference
/// resource for a quota value targeting a unique set of dimensions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuotaPreference {
    /// Required except in the CREATE requests.
    /// The resource name of the quota preference.
    /// The ID component following "locations/" must be "global".
    /// Example:
    /// `projects/123/locations/global/quotaPreferences/my-config-for-us-east1`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub name: std::string::String,

    /// Immutable. The dimensions that this quota preference applies to. The key of
    /// the map entry is the name of a dimension, such as "region", "zone",
    /// "network_id", and the value of the map entry is the dimension value.
    ///
    /// If a dimension is missing from the map of dimensions, the quota preference
    /// applies to all the dimension values except for those that have other quota
    /// preferences configured for the specific value.
    ///
    /// NOTE: QuotaPreferences can only be applied across all values of "user" and
    /// "resource" dimension. Do not set values for "user" or "resource" in the
    /// dimension map.
    ///
    /// Example: {"provider", "Foo Inc"} where "provider" is a service specific
    /// dimension.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub dimensions: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Preferred quota configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub quota_config: std::option::Option<crate::model::QuotaConfig>,

    /// Optional. The current etag of the quota preference. If an etag is provided
    /// on update and does not match the current server's etag of the quota
    /// preference, the request will be blocked and an ABORTED error will be
    /// returned. See <https://google.aip.dev/134#etags> for more details on etags.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub etag: std::string::String,

    /// Output only. Create time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The name of the service to which the quota preference is applied.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub service: std::string::String,

    /// Required. The id of the quota to which the quota preference is applied. A
    /// quota name is unique in the service. Example: `CpusPerProjectPerRegion`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub quota_id: std::string::String,

    /// Output only. Is the quota preference pending Google Cloud approval and
    /// fulfillment.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub reconciling: bool,

    /// The reason / justification for this quota preference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub justification: std::string::String,

    /// Input only. An email address that can be used to contact the the user, in
    /// case Google Cloud needs more information to make a decision before
    /// additional quota can be granted.
    ///
    /// When requesting a quota increase, the email address is required.
    /// When requesting a quota decrease, the email address is optional.
    /// For example, the email address is optional when the
    /// `QuotaConfig.preferred_value` is smaller than the
    /// `QuotaDetails.reset_value`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub contact_email: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaPreference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QuotaPreference::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [dimensions][crate::model::QuotaPreference::dimensions].
    pub fn set_dimensions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [quota_config][crate::model::QuotaPreference::quota_config].
    pub fn set_quota_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaConfig>,
    {
        self.quota_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quota_config][crate::model::QuotaPreference::quota_config].
    pub fn set_or_clear_quota_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaConfig>,
    {
        self.quota_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::QuotaPreference::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::QuotaPreference::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::QuotaPreference::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::QuotaPreference::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::QuotaPreference::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service][crate::model::QuotaPreference::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [quota_id][crate::model::QuotaPreference::quota_id].
    pub fn set_quota_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.quota_id = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::QuotaPreference::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [justification][crate::model::QuotaPreference::justification].
    pub fn set_justification<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.justification = v.into();
        self
    }

    /// Sets the value of [contact_email][crate::model::QuotaPreference::contact_email].
    pub fn set_contact_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.contact_email = v.into();
        self
    }
}

impl wkt::message::Message for QuotaPreference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.QuotaPreference"
    }
}

/// The preferred quota configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuotaConfig {
    /// Required. The preferred value. Must be greater than or equal to -1. If set
    /// to -1, it means the value is "unlimited".
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub preferred_value: i64,

    /// Output only. Optional details about the state of this quota preference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub state_detail: std::string::String,

    /// Output only. Granted quota value.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<wkt::internal::I64>")]
    pub granted_value: std::option::Option<wkt::Int64Value>,

    /// Output only. The trace id that the Google Cloud uses to provision the
    /// requested quota. This trace id may be used by the client to contact Cloud
    /// support to track the state of a quota preference request. The trace id is
    /// only produced for increase requests and is unique for each request. The
    /// quota decrease requests do not have a trace id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub trace_id: std::string::String,

    /// Optional. The annotations map for clients to store small amounts of
    /// arbitrary data. Do not put PII or other sensitive information here. See
    /// <https://google.aip.dev/128#annotations>
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The origin of the quota preference request.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub request_origin: crate::model::quota_config::Origin,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [preferred_value][crate::model::QuotaConfig::preferred_value].
    pub fn set_preferred_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.preferred_value = v.into();
        self
    }

    /// Sets the value of [state_detail][crate::model::QuotaConfig::state_detail].
    pub fn set_state_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_detail = v.into();
        self
    }

    /// Sets the value of [granted_value][crate::model::QuotaConfig::granted_value].
    pub fn set_granted_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.granted_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [granted_value][crate::model::QuotaConfig::granted_value].
    pub fn set_or_clear_granted_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.granted_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trace_id][crate::model::QuotaConfig::trace_id].
    pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_id = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::QuotaConfig::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [request_origin][crate::model::QuotaConfig::request_origin].
    pub fn set_request_origin<T: std::convert::Into<crate::model::quota_config::Origin>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_origin = v.into();
        self
    }
}

impl wkt::message::Message for QuotaConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.QuotaConfig"
    }
}

/// Defines additional types related to [QuotaConfig].
pub mod quota_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumeration of the origins of quota preference requests.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Origin {
        /// The unspecified value.
        Unspecified,
        /// Created through Cloud Console.
        CloudConsole,
        /// Generated by automatic quota adjustment.
        AutoAdjuster,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Origin::value] or
        /// [Origin::name].
        UnknownValue(origin::UnknownValue),
    }

    #[doc(hidden)]
    pub mod origin {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Origin {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudConsole => std::option::Option::Some(1),
                Self::AutoAdjuster => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ORIGIN_UNSPECIFIED"),
                Self::CloudConsole => std::option::Option::Some("CLOUD_CONSOLE"),
                Self::AutoAdjuster => std::option::Option::Some("AUTO_ADJUSTER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Origin {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Origin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Origin {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudConsole,
                2 => Self::AutoAdjuster,
                _ => Self::UnknownValue(origin::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Origin {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ORIGIN_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_CONSOLE" => Self::CloudConsole,
                "AUTO_ADJUSTER" => Self::AutoAdjuster,
                _ => Self::UnknownValue(origin::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Origin {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudConsole => serializer.serialize_i32(1),
                Self::AutoAdjuster => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Origin {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Origin>::new(
                ".google.api.cloudquotas.v1.QuotaConfig.Origin",
            ))
        }
    }
}

/// The detailed quota information such as effective quota value for a
/// combination of dimensions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DimensionsInfo {
    /// The map of dimensions for this dimensions info. The key of a map entry
    /// is "region", "zone" or the name of a service specific dimension, and the
    /// value of a map entry is the value of the dimension.  If a dimension does
    /// not appear in the map of dimensions, the dimensions info applies to all
    /// the dimension values except for those that have another DimenisonInfo
    /// instance configured for the specific value.
    /// Example: {"provider" : "Foo Inc"} where "provider" is a service specific
    /// dimension of a quota.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::collections::HashMap<_, _>>")]
    pub dimensions: std::collections::HashMap<std::string::String, std::string::String>,

    /// Quota details for the specified dimensions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::QuotaDetails>,

    /// The applicable regions or zones of this dimensions info. The field will be
    /// set to ['global'] for quotas that are not per region or per zone.
    /// Otherwise, it will be set to the list of locations this dimension info is
    /// applicable to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "serde_with::DefaultOnNull<std::vec::Vec<_>>")]
    pub applicable_locations: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DimensionsInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimensions][crate::model::DimensionsInfo::dimensions].
    pub fn set_dimensions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [details][crate::model::DimensionsInfo::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaDetails>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::DimensionsInfo::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaDetails>,
    {
        self.details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [applicable_locations][crate::model::DimensionsInfo::applicable_locations].
    pub fn set_applicable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.applicable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DimensionsInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.DimensionsInfo"
    }
}

/// The quota details for a map of dimensions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuotaDetails {
    /// The value currently in effect and being enforced.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<wkt::internal::I64>")]
    pub value: i64,

    /// Rollout information of this quota.
    /// This field is present only if the effective limit will change due to the
    /// ongoing rollout of the service config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollout_info: std::option::Option<crate::model::RolloutInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::QuotaDetails::value].
    pub fn set_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [rollout_info][crate::model::QuotaDetails::rollout_info].
    pub fn set_rollout_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RolloutInfo>,
    {
        self.rollout_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout_info][crate::model::QuotaDetails::rollout_info].
    pub fn set_or_clear_rollout_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RolloutInfo>,
    {
        self.rollout_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for QuotaDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.QuotaDetails"
    }
}

/// [Output only] Rollout information of a quota.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RolloutInfo {
    /// Whether there is an ongoing rollout for a quota or not.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "serde_with::DefaultOnNull<_>")]
    pub ongoing_rollout: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RolloutInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ongoing_rollout][crate::model::RolloutInfo::ongoing_rollout].
    pub fn set_ongoing_rollout<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ongoing_rollout = v.into();
        self
    }
}

impl wkt::message::Message for RolloutInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.RolloutInfo"
    }
}

/// Enumerations of quota safety checks.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum QuotaSafetyCheck {
    /// Unspecified quota safety check.
    Unspecified,
    /// Validates that a quota mutation would not cause the consumer's effective
    /// limit to be lower than the consumer's quota usage.
    QuotaDecreaseBelowUsage,
    /// Validates that a quota mutation would not cause the consumer's effective
    /// limit to decrease by more than 10 percent.
    QuotaDecreasePercentageTooHigh,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [QuotaSafetyCheck::value] or
    /// [QuotaSafetyCheck::name].
    UnknownValue(quota_safety_check::UnknownValue),
}

#[doc(hidden)]
pub mod quota_safety_check {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl QuotaSafetyCheck {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::QuotaDecreaseBelowUsage => std::option::Option::Some(1),
            Self::QuotaDecreasePercentageTooHigh => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("QUOTA_SAFETY_CHECK_UNSPECIFIED"),
            Self::QuotaDecreaseBelowUsage => {
                std::option::Option::Some("QUOTA_DECREASE_BELOW_USAGE")
            }
            Self::QuotaDecreasePercentageTooHigh => {
                std::option::Option::Some("QUOTA_DECREASE_PERCENTAGE_TOO_HIGH")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for QuotaSafetyCheck {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for QuotaSafetyCheck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for QuotaSafetyCheck {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::QuotaDecreaseBelowUsage,
            2 => Self::QuotaDecreasePercentageTooHigh,
            _ => Self::UnknownValue(quota_safety_check::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for QuotaSafetyCheck {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "QUOTA_SAFETY_CHECK_UNSPECIFIED" => Self::Unspecified,
            "QUOTA_DECREASE_BELOW_USAGE" => Self::QuotaDecreaseBelowUsage,
            "QUOTA_DECREASE_PERCENTAGE_TOO_HIGH" => Self::QuotaDecreasePercentageTooHigh,
            _ => Self::UnknownValue(quota_safety_check::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for QuotaSafetyCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::QuotaDecreaseBelowUsage => serializer.serialize_i32(1),
            Self::QuotaDecreasePercentageTooHigh => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for QuotaSafetyCheck {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<QuotaSafetyCheck>::new(
            ".google.api.cloudquotas.v1.QuotaSafetyCheck",
        ))
    }
}
