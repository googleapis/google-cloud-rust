// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Message for requesting list of QuotaInfos
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQuotaInfosRequest {
    /// Required. Parent value of QuotaInfo resources.
    /// Listing across different resource containers (such as 'projects/-') is not
    /// allowed.
    ///
    /// Example names:
    /// `projects/123/locations/global/services/compute.googleapis.com`
    /// `folders/234/locations/global/services/compute.googleapis.com`
    /// `organizations/345/locations/global/services/compute.googleapis.com`
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaInfosRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQuotaInfosRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQuotaInfosRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQuotaInfosRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQuotaInfosRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.ListQuotaInfosRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQuotaInfosRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQuotaInfosRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQuotaInfosRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQuotaInfosRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQuotaInfosRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing QuotaInfos
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQuotaInfosResponse {
    /// The list of QuotaInfo
    pub quota_infos: std::vec::Vec<crate::model::QuotaInfo>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaInfosResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quota_infos][crate::model::ListQuotaInfosResponse::quota_infos].
    pub fn set_quota_infos<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaInfo>,
    {
        use std::iter::Iterator;
        self.quota_infos = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQuotaInfosResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListQuotaInfosResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.ListQuotaInfosResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQuotaInfosResponse {
    type PageItem = crate::model::QuotaInfo;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.quota_infos
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQuotaInfosResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __quota_infos,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQuotaInfosResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "quotaInfos" => Ok(__FieldTag::__quota_infos),
                            "quota_infos" => Ok(__FieldTag::__quota_infos),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQuotaInfosResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQuotaInfosResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__quota_infos => {
                            if !fields.insert(__FieldTag::__quota_infos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_infos",
                                ));
                            }
                            result.quota_infos = map.next_value::<std::option::Option<std::vec::Vec<crate::model::QuotaInfo>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQuotaInfosResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.quota_infos.is_empty() {
            state.serialize_entry("quotaInfos", &self.quota_infos)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a QuotaInfo
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetQuotaInfoRequest {
    /// Required. The resource name of the quota info.
    ///
    /// An example name:
    /// `projects/123/locations/global/services/compute.googleapis.com/quotaInfos/CpusPerProjectPerRegion`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQuotaInfoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQuotaInfoRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQuotaInfoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.GetQuotaInfoRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetQuotaInfoRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetQuotaInfoRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetQuotaInfoRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetQuotaInfoRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetQuotaInfoRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for requesting list of QuotaPreferences
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQuotaPreferencesRequest {
    /// Required. Parent value of QuotaPreference resources.
    /// Listing across different resource containers (such as 'projects/-') is not
    /// allowed.
    ///
    /// When the value starts with 'folders' or 'organizations', it lists the
    /// QuotaPreferences for org quotas in the container. It does not list the
    /// QuotaPreferences in the descendant projects of the container.
    ///
    /// Example parents:
    /// `projects/123/locations/global`
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filter result QuotaPreferences by their state, type,
    /// create/update time range.
    ///
    /// Example filters:
    /// `reconciling=true AND request_type=CLOUD_CONSOLE`,
    /// `reconciling=true OR creation_time>2022-12-03T10:30:00`
    pub filter: std::string::String,

    /// Optional. How to order of the results. By default, the results are ordered
    /// by create time.
    ///
    /// Example orders:
    /// `quota_id`,
    /// `service, create_time`
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaPreferencesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListQuotaPreferencesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListQuotaPreferencesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListQuotaPreferencesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListQuotaPreferencesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListQuotaPreferencesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListQuotaPreferencesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.ListQuotaPreferencesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQuotaPreferencesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQuotaPreferencesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQuotaPreferencesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQuotaPreferencesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQuotaPreferencesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for response to listing QuotaPreferences
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListQuotaPreferencesResponse {
    /// The list of QuotaPreference
    pub quota_preferences: std::vec::Vec<crate::model::QuotaPreference>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListQuotaPreferencesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quota_preferences][crate::model::ListQuotaPreferencesResponse::quota_preferences].
    pub fn set_quota_preferences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaPreference>,
    {
        use std::iter::Iterator;
        self.quota_preferences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListQuotaPreferencesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListQuotaPreferencesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListQuotaPreferencesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.ListQuotaPreferencesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListQuotaPreferencesResponse {
    type PageItem = crate::model::QuotaPreference;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.quota_preferences
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListQuotaPreferencesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __quota_preferences,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListQuotaPreferencesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "quotaPreferences" => Ok(__FieldTag::__quota_preferences),
                            "quota_preferences" => Ok(__FieldTag::__quota_preferences),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListQuotaPreferencesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListQuotaPreferencesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__quota_preferences => {
                            if !fields.insert(__FieldTag::__quota_preferences) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_preferences",
                                ));
                            }
                            result.quota_preferences =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QuotaPreference>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListQuotaPreferencesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.quota_preferences.is_empty() {
            state.serialize_entry("quotaPreferences", &self.quota_preferences)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for getting a QuotaPreference
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetQuotaPreferenceRequest {
    /// Required. Name of the resource
    ///
    /// Example name:
    /// `projects/123/locations/global/quota_preferences/my-config-for-us-east1`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetQuotaPreferenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetQuotaPreferenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetQuotaPreferenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.GetQuotaPreferenceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetQuotaPreferenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetQuotaPreferenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetQuotaPreferenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetQuotaPreferenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetQuotaPreferenceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a QuotaPreference
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateQuotaPreferenceRequest {
    /// Required. Value for parent.
    ///
    /// Example:
    /// `projects/123/locations/global`
    pub parent: std::string::String,

    /// Optional. Id of the requesting object, must be unique under its parent.
    /// If client does not set this field, the service will generate one.
    pub quota_preference_id: std::string::String,

    /// Required. The resource being created
    pub quota_preference: std::option::Option<crate::model::QuotaPreference>,

    /// The list of quota safety checks to be ignored.
    pub ignore_safety_checks: std::vec::Vec<crate::model::QuotaSafetyCheck>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateQuotaPreferenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateQuotaPreferenceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [quota_preference_id][crate::model::CreateQuotaPreferenceRequest::quota_preference_id].
    pub fn set_quota_preference_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.quota_preference_id = v.into();
        self
    }

    /// Sets the value of [quota_preference][crate::model::CreateQuotaPreferenceRequest::quota_preference].
    pub fn set_quota_preference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaPreference>,
    {
        self.quota_preference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quota_preference][crate::model::CreateQuotaPreferenceRequest::quota_preference].
    pub fn set_or_clear_quota_preference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaPreference>,
    {
        self.quota_preference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ignore_safety_checks][crate::model::CreateQuotaPreferenceRequest::ignore_safety_checks].
    pub fn set_ignore_safety_checks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaSafetyCheck>,
    {
        use std::iter::Iterator;
        self.ignore_safety_checks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CreateQuotaPreferenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.CreateQuotaPreferenceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateQuotaPreferenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __quota_preference_id,
            __quota_preference,
            __ignore_safety_checks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateQuotaPreferenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "quotaPreferenceId" => Ok(__FieldTag::__quota_preference_id),
                            "quota_preference_id" => Ok(__FieldTag::__quota_preference_id),
                            "quotaPreference" => Ok(__FieldTag::__quota_preference),
                            "quota_preference" => Ok(__FieldTag::__quota_preference),
                            "ignoreSafetyChecks" => Ok(__FieldTag::__ignore_safety_checks),
                            "ignore_safety_checks" => Ok(__FieldTag::__ignore_safety_checks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateQuotaPreferenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateQuotaPreferenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quota_preference_id => {
                            if !fields.insert(__FieldTag::__quota_preference_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_preference_id",
                                ));
                            }
                            result.quota_preference_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quota_preference => {
                            if !fields.insert(__FieldTag::__quota_preference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_preference",
                                ));
                            }
                            result.quota_preference = map
                                .next_value::<std::option::Option<crate::model::QuotaPreference>>(
                                )?;
                        }
                        __FieldTag::__ignore_safety_checks => {
                            if !fields.insert(__FieldTag::__ignore_safety_checks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_safety_checks",
                                ));
                            }
                            result.ignore_safety_checks =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QuotaSafetyCheck>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateQuotaPreferenceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.quota_preference_id.is_empty() {
            state.serialize_entry("quotaPreferenceId", &self.quota_preference_id)?;
        }
        if self.quota_preference.is_some() {
            state.serialize_entry("quotaPreference", &self.quota_preference)?;
        }
        if !self.ignore_safety_checks.is_empty() {
            state.serialize_entry("ignoreSafetyChecks", &self.ignore_safety_checks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for updating a QuotaPreference
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateQuotaPreferenceRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// QuotaPreference resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    pub quota_preference: std::option::Option<crate::model::QuotaPreference>,

    /// Optional. If set to true, and the quota preference is not found, a new one
    /// will be created. In this situation, `update_mask` is ignored.
    pub allow_missing: bool,

    /// Optional. If set to true, validate the request, but do not actually update.
    /// Note that a request being valid does not mean that the request is
    /// guaranteed to be fulfilled.
    pub validate_only: bool,

    /// The list of quota safety checks to be ignored.
    pub ignore_safety_checks: std::vec::Vec<crate::model::QuotaSafetyCheck>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateQuotaPreferenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateQuotaPreferenceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateQuotaPreferenceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [quota_preference][crate::model::UpdateQuotaPreferenceRequest::quota_preference].
    pub fn set_quota_preference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaPreference>,
    {
        self.quota_preference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quota_preference][crate::model::UpdateQuotaPreferenceRequest::quota_preference].
    pub fn set_or_clear_quota_preference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaPreference>,
    {
        self.quota_preference = v.map(|x| x.into());
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateQuotaPreferenceRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateQuotaPreferenceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [ignore_safety_checks][crate::model::UpdateQuotaPreferenceRequest::ignore_safety_checks].
    pub fn set_ignore_safety_checks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaSafetyCheck>,
    {
        use std::iter::Iterator;
        self.ignore_safety_checks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UpdateQuotaPreferenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.UpdateQuotaPreferenceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateQuotaPreferenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __quota_preference,
            __allow_missing,
            __validate_only,
            __ignore_safety_checks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateQuotaPreferenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "quotaPreference" => Ok(__FieldTag::__quota_preference),
                            "quota_preference" => Ok(__FieldTag::__quota_preference),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "ignoreSafetyChecks" => Ok(__FieldTag::__ignore_safety_checks),
                            "ignore_safety_checks" => Ok(__FieldTag::__ignore_safety_checks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateQuotaPreferenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateQuotaPreferenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__quota_preference => {
                            if !fields.insert(__FieldTag::__quota_preference) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_preference",
                                ));
                            }
                            result.quota_preference = map
                                .next_value::<std::option::Option<crate::model::QuotaPreference>>(
                                )?;
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ignore_safety_checks => {
                            if !fields.insert(__FieldTag::__ignore_safety_checks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ignore_safety_checks",
                                ));
                            }
                            result.ignore_safety_checks =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::QuotaSafetyCheck>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateQuotaPreferenceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.quota_preference.is_some() {
            state.serialize_entry("quotaPreference", &self.quota_preference)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.ignore_safety_checks.is_empty() {
            state.serialize_entry("ignoreSafetyChecks", &self.ignore_safety_checks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// QuotaInfo represents information about a particular quota for a given
/// project, folder or organization.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QuotaInfo {
    /// Resource name of this QuotaInfo.
    /// The ID component following "locations/" must be "global".
    /// Example:
    /// `projects/123/locations/global/services/compute.googleapis.com/quotaInfos/CpusPerProjectPerRegion`
    pub name: std::string::String,

    /// The id of the quota, which is unquie within the service.
    /// Example: `CpusPerProjectPerRegion`
    pub quota_id: std::string::String,

    /// The metric of the quota. It specifies the resources consumption the quota
    /// is defined for.
    /// Example: `compute.googleapis.com/cpus`
    pub metric: std::string::String,

    /// The name of the service in which the quota is defined.
    /// Example: `compute.googleapis.com`
    pub service: std::string::String,

    /// Whether this is a precise quota. A precise quota is tracked with absolute
    /// precision. In contrast, an imprecise quota is not tracked with precision.
    pub is_precise: bool,

    /// The reset time interval for the quota. Refresh interval applies to rate
    /// quota only.
    /// Example: "minute" for per minute, "day" for per day, or "10 seconds" for
    /// every 10 seconds.
    pub refresh_interval: std::string::String,

    /// The container type of the QuotaInfo.
    pub container_type: crate::model::quota_info::ContainerType,

    /// The dimensions the quota is defined on.
    pub dimensions: std::vec::Vec<std::string::String>,

    /// The display name of the quota metric
    pub metric_display_name: std::string::String,

    /// The display name of the quota.
    pub quota_display_name: std::string::String,

    /// The unit in which the metric value is reported, e.g., "MByte".
    pub metric_unit: std::string::String,

    /// Whether it is eligible to request a higher quota value for this quota.
    pub quota_increase_eligibility: std::option::Option<crate::model::QuotaIncreaseEligibility>,

    /// Whether the quota value is fixed or adjustable
    pub is_fixed: bool,

    /// The collection of dimensions info ordered by their dimensions from more
    /// specific ones to less specific ones.
    pub dimensions_infos: std::vec::Vec<crate::model::DimensionsInfo>,

    /// Whether the quota is a concurrent quota. Concurrent quotas are enforced
    /// on the total number of concurrent operations in flight at any given time.
    pub is_concurrent: bool,

    /// URI to the page where users can request more quota for the cloud
    /// service—for example,
    /// <https://console.cloud.google.com/iam-admin/quotas>.
    pub service_request_quota_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QuotaInfo::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [quota_id][crate::model::QuotaInfo::quota_id].
    pub fn set_quota_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.quota_id = v.into();
        self
    }

    /// Sets the value of [metric][crate::model::QuotaInfo::metric].
    pub fn set_metric<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric = v.into();
        self
    }

    /// Sets the value of [service][crate::model::QuotaInfo::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [is_precise][crate::model::QuotaInfo::is_precise].
    pub fn set_is_precise<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_precise = v.into();
        self
    }

    /// Sets the value of [refresh_interval][crate::model::QuotaInfo::refresh_interval].
    pub fn set_refresh_interval<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.refresh_interval = v.into();
        self
    }

    /// Sets the value of [container_type][crate::model::QuotaInfo::container_type].
    pub fn set_container_type<T: std::convert::Into<crate::model::quota_info::ContainerType>>(
        mut self,
        v: T,
    ) -> Self {
        self.container_type = v.into();
        self
    }

    /// Sets the value of [dimensions][crate::model::QuotaInfo::dimensions].
    pub fn set_dimensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metric_display_name][crate::model::QuotaInfo::metric_display_name].
    pub fn set_metric_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.metric_display_name = v.into();
        self
    }

    /// Sets the value of [quota_display_name][crate::model::QuotaInfo::quota_display_name].
    pub fn set_quota_display_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.quota_display_name = v.into();
        self
    }

    /// Sets the value of [metric_unit][crate::model::QuotaInfo::metric_unit].
    pub fn set_metric_unit<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_unit = v.into();
        self
    }

    /// Sets the value of [quota_increase_eligibility][crate::model::QuotaInfo::quota_increase_eligibility].
    pub fn set_quota_increase_eligibility<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaIncreaseEligibility>,
    {
        self.quota_increase_eligibility = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quota_increase_eligibility][crate::model::QuotaInfo::quota_increase_eligibility].
    pub fn set_or_clear_quota_increase_eligibility<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaIncreaseEligibility>,
    {
        self.quota_increase_eligibility = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_fixed][crate::model::QuotaInfo::is_fixed].
    pub fn set_is_fixed<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_fixed = v.into();
        self
    }

    /// Sets the value of [dimensions_infos][crate::model::QuotaInfo::dimensions_infos].
    pub fn set_dimensions_infos<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DimensionsInfo>,
    {
        use std::iter::Iterator;
        self.dimensions_infos = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [is_concurrent][crate::model::QuotaInfo::is_concurrent].
    pub fn set_is_concurrent<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_concurrent = v.into();
        self
    }

    /// Sets the value of [service_request_quota_uri][crate::model::QuotaInfo::service_request_quota_uri].
    pub fn set_service_request_quota_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_request_quota_uri = v.into();
        self
    }
}

impl wkt::message::Message for QuotaInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.QuotaInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QuotaInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __quota_id,
            __metric,
            __service,
            __is_precise,
            __refresh_interval,
            __container_type,
            __dimensions,
            __metric_display_name,
            __quota_display_name,
            __metric_unit,
            __quota_increase_eligibility,
            __is_fixed,
            __dimensions_infos,
            __is_concurrent,
            __service_request_quota_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QuotaInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "quotaId" => Ok(__FieldTag::__quota_id),
                            "quota_id" => Ok(__FieldTag::__quota_id),
                            "metric" => Ok(__FieldTag::__metric),
                            "service" => Ok(__FieldTag::__service),
                            "isPrecise" => Ok(__FieldTag::__is_precise),
                            "is_precise" => Ok(__FieldTag::__is_precise),
                            "refreshInterval" => Ok(__FieldTag::__refresh_interval),
                            "refresh_interval" => Ok(__FieldTag::__refresh_interval),
                            "containerType" => Ok(__FieldTag::__container_type),
                            "container_type" => Ok(__FieldTag::__container_type),
                            "dimensions" => Ok(__FieldTag::__dimensions),
                            "metricDisplayName" => Ok(__FieldTag::__metric_display_name),
                            "metric_display_name" => Ok(__FieldTag::__metric_display_name),
                            "quotaDisplayName" => Ok(__FieldTag::__quota_display_name),
                            "quota_display_name" => Ok(__FieldTag::__quota_display_name),
                            "metricUnit" => Ok(__FieldTag::__metric_unit),
                            "metric_unit" => Ok(__FieldTag::__metric_unit),
                            "quotaIncreaseEligibility" => {
                                Ok(__FieldTag::__quota_increase_eligibility)
                            }
                            "quota_increase_eligibility" => {
                                Ok(__FieldTag::__quota_increase_eligibility)
                            }
                            "isFixed" => Ok(__FieldTag::__is_fixed),
                            "is_fixed" => Ok(__FieldTag::__is_fixed),
                            "dimensionsInfos" => Ok(__FieldTag::__dimensions_infos),
                            "dimensions_infos" => Ok(__FieldTag::__dimensions_infos),
                            "isConcurrent" => Ok(__FieldTag::__is_concurrent),
                            "is_concurrent" => Ok(__FieldTag::__is_concurrent),
                            "serviceRequestQuotaUri" => Ok(__FieldTag::__service_request_quota_uri),
                            "service_request_quota_uri" => {
                                Ok(__FieldTag::__service_request_quota_uri)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QuotaInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QuotaInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quota_id => {
                            if !fields.insert(__FieldTag::__quota_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_id",
                                ));
                            }
                            result.quota_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metric => {
                            if !fields.insert(__FieldTag::__metric) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric",
                                ));
                            }
                            result.metric = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_precise => {
                            if !fields.insert(__FieldTag::__is_precise) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_precise",
                                ));
                            }
                            result.is_precise = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__refresh_interval => {
                            if !fields.insert(__FieldTag::__refresh_interval) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for refresh_interval",
                                ));
                            }
                            result.refresh_interval = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_type => {
                            if !fields.insert(__FieldTag::__container_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_type",
                                ));
                            }
                            result.container_type = map.next_value::<std::option::Option<crate::model::quota_info::ContainerType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__dimensions => {
                            if !fields.insert(__FieldTag::__dimensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimensions",
                                ));
                            }
                            result.dimensions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metric_display_name => {
                            if !fields.insert(__FieldTag::__metric_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_display_name",
                                ));
                            }
                            result.metric_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quota_display_name => {
                            if !fields.insert(__FieldTag::__quota_display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_display_name",
                                ));
                            }
                            result.quota_display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metric_unit => {
                            if !fields.insert(__FieldTag::__metric_unit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_unit",
                                ));
                            }
                            result.metric_unit = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quota_increase_eligibility => {
                            if !fields.insert(__FieldTag::__quota_increase_eligibility) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_increase_eligibility",
                                ));
                            }
                            result.quota_increase_eligibility = map.next_value::<std::option::Option<crate::model::QuotaIncreaseEligibility>>()?
                                ;
                        }
                        __FieldTag::__is_fixed => {
                            if !fields.insert(__FieldTag::__is_fixed) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_fixed",
                                ));
                            }
                            result.is_fixed = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dimensions_infos => {
                            if !fields.insert(__FieldTag::__dimensions_infos) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimensions_infos",
                                ));
                            }
                            result.dimensions_infos =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DimensionsInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__is_concurrent => {
                            if !fields.insert(__FieldTag::__is_concurrent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_concurrent",
                                ));
                            }
                            result.is_concurrent = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_request_quota_uri => {
                            if !fields.insert(__FieldTag::__service_request_quota_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_request_quota_uri",
                                ));
                            }
                            result.service_request_quota_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QuotaInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.quota_id.is_empty() {
            state.serialize_entry("quotaId", &self.quota_id)?;
        }
        if !self.metric.is_empty() {
            state.serialize_entry("metric", &self.metric)?;
        }
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !wkt::internal::is_default(&self.is_precise) {
            state.serialize_entry("isPrecise", &self.is_precise)?;
        }
        if !self.refresh_interval.is_empty() {
            state.serialize_entry("refreshInterval", &self.refresh_interval)?;
        }
        if !wkt::internal::is_default(&self.container_type) {
            state.serialize_entry("containerType", &self.container_type)?;
        }
        if !self.dimensions.is_empty() {
            state.serialize_entry("dimensions", &self.dimensions)?;
        }
        if !self.metric_display_name.is_empty() {
            state.serialize_entry("metricDisplayName", &self.metric_display_name)?;
        }
        if !self.quota_display_name.is_empty() {
            state.serialize_entry("quotaDisplayName", &self.quota_display_name)?;
        }
        if !self.metric_unit.is_empty() {
            state.serialize_entry("metricUnit", &self.metric_unit)?;
        }
        if self.quota_increase_eligibility.is_some() {
            state.serialize_entry("quotaIncreaseEligibility", &self.quota_increase_eligibility)?;
        }
        if !wkt::internal::is_default(&self.is_fixed) {
            state.serialize_entry("isFixed", &self.is_fixed)?;
        }
        if !self.dimensions_infos.is_empty() {
            state.serialize_entry("dimensionsInfos", &self.dimensions_infos)?;
        }
        if !wkt::internal::is_default(&self.is_concurrent) {
            state.serialize_entry("isConcurrent", &self.is_concurrent)?;
        }
        if !self.service_request_quota_uri.is_empty() {
            state.serialize_entry("serviceRequestQuotaUri", &self.service_request_quota_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [QuotaInfo].
pub mod quota_info {
    #[allow(unused_imports)]
    use super::*;

    /// The enumeration of the types of a cloud resource container.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ContainerType {
        /// Unspecified container type.
        Unspecified,
        /// consumer project
        Project,
        /// folder
        Folder,
        /// organization
        Organization,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ContainerType::value] or
        /// [ContainerType::name].
        UnknownValue(container_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod container_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ContainerType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Project => std::option::Option::Some(1),
                Self::Folder => std::option::Option::Some(2),
                Self::Organization => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CONTAINER_TYPE_UNSPECIFIED"),
                Self::Project => std::option::Option::Some("PROJECT"),
                Self::Folder => std::option::Option::Some("FOLDER"),
                Self::Organization => std::option::Option::Some("ORGANIZATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ContainerType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ContainerType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ContainerType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Project,
                2 => Self::Folder,
                3 => Self::Organization,
                _ => Self::UnknownValue(container_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ContainerType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONTAINER_TYPE_UNSPECIFIED" => Self::Unspecified,
                "PROJECT" => Self::Project,
                "FOLDER" => Self::Folder,
                "ORGANIZATION" => Self::Organization,
                _ => Self::UnknownValue(container_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ContainerType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Project => serializer.serialize_i32(1),
                Self::Folder => serializer.serialize_i32(2),
                Self::Organization => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ContainerType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContainerType>::new(
                ".google.api.cloudquotas.v1.QuotaInfo.ContainerType",
            ))
        }
    }
}

/// Eligibility information regarding requesting increase adjustment of a quota.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QuotaIncreaseEligibility {
    /// Whether a higher quota value can be requested for the quota.
    pub is_eligible: bool,

    /// The reason of why it is ineligible to request increased value of the quota.
    /// If the is_eligible field is true, it defaults to
    /// INELIGIBILITY_REASON_UNSPECIFIED.
    pub ineligibility_reason: crate::model::quota_increase_eligibility::IneligibilityReason,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaIncreaseEligibility {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [is_eligible][crate::model::QuotaIncreaseEligibility::is_eligible].
    pub fn set_is_eligible<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.is_eligible = v.into();
        self
    }

    /// Sets the value of [ineligibility_reason][crate::model::QuotaIncreaseEligibility::ineligibility_reason].
    pub fn set_ineligibility_reason<
        T: std::convert::Into<crate::model::quota_increase_eligibility::IneligibilityReason>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.ineligibility_reason = v.into();
        self
    }
}

impl wkt::message::Message for QuotaIncreaseEligibility {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.QuotaIncreaseEligibility"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QuotaIncreaseEligibility {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __is_eligible,
            __ineligibility_reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QuotaIncreaseEligibility")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "isEligible" => Ok(__FieldTag::__is_eligible),
                            "is_eligible" => Ok(__FieldTag::__is_eligible),
                            "ineligibilityReason" => Ok(__FieldTag::__ineligibility_reason),
                            "ineligibility_reason" => Ok(__FieldTag::__ineligibility_reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QuotaIncreaseEligibility;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QuotaIncreaseEligibility")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__is_eligible => {
                            if !fields.insert(__FieldTag::__is_eligible) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for is_eligible",
                                ));
                            }
                            result.is_eligible = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ineligibility_reason => {
                            if !fields.insert(__FieldTag::__ineligibility_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ineligibility_reason",
                                ));
                            }
                            result.ineligibility_reason = map
                                .next_value::<std::option::Option<
                                    crate::model::quota_increase_eligibility::IneligibilityReason,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QuotaIncreaseEligibility {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.is_eligible) {
            state.serialize_entry("isEligible", &self.is_eligible)?;
        }
        if !wkt::internal::is_default(&self.ineligibility_reason) {
            state.serialize_entry("ineligibilityReason", &self.ineligibility_reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [QuotaIncreaseEligibility].
pub mod quota_increase_eligibility {
    #[allow(unused_imports)]
    use super::*;

    /// The enumeration of reasons when it is ineligible to request increase
    /// adjustment.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum IneligibilityReason {
        /// Default value when is_eligible is true.
        Unspecified,
        /// The container is not linked with a valid billing account.
        NoValidBillingAccount,
        /// Quota increase is not supported for the quota.
        NotSupported,
        /// There is not enough usage history to determine the eligibility.
        NotEnoughUsageHistory,
        /// Other reasons.
        Other,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [IneligibilityReason::value] or
        /// [IneligibilityReason::name].
        UnknownValue(ineligibility_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ineligibility_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl IneligibilityReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NoValidBillingAccount => std::option::Option::Some(1),
                Self::NotSupported => std::option::Option::Some(3),
                Self::NotEnoughUsageHistory => std::option::Option::Some(4),
                Self::Other => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("INELIGIBILITY_REASON_UNSPECIFIED"),
                Self::NoValidBillingAccount => {
                    std::option::Option::Some("NO_VALID_BILLING_ACCOUNT")
                }
                Self::NotSupported => std::option::Option::Some("NOT_SUPPORTED"),
                Self::NotEnoughUsageHistory => {
                    std::option::Option::Some("NOT_ENOUGH_USAGE_HISTORY")
                }
                Self::Other => std::option::Option::Some("OTHER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for IneligibilityReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for IneligibilityReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for IneligibilityReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NoValidBillingAccount,
                2 => Self::Other,
                3 => Self::NotSupported,
                4 => Self::NotEnoughUsageHistory,
                _ => Self::UnknownValue(ineligibility_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for IneligibilityReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INELIGIBILITY_REASON_UNSPECIFIED" => Self::Unspecified,
                "NO_VALID_BILLING_ACCOUNT" => Self::NoValidBillingAccount,
                "NOT_SUPPORTED" => Self::NotSupported,
                "NOT_ENOUGH_USAGE_HISTORY" => Self::NotEnoughUsageHistory,
                "OTHER" => Self::Other,
                _ => Self::UnknownValue(ineligibility_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for IneligibilityReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NoValidBillingAccount => serializer.serialize_i32(1),
                Self::NotSupported => serializer.serialize_i32(3),
                Self::NotEnoughUsageHistory => serializer.serialize_i32(4),
                Self::Other => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for IneligibilityReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<IneligibilityReason>::new(
                ".google.api.cloudquotas.v1.QuotaIncreaseEligibility.IneligibilityReason",
            ))
        }
    }
}

/// QuotaPreference represents the preferred quota configuration specified for
/// a project, folder or organization. There is only one QuotaPreference
/// resource for a quota value targeting a unique set of dimensions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QuotaPreference {
    /// Required except in the CREATE requests.
    /// The resource name of the quota preference.
    /// The ID component following "locations/" must be "global".
    /// Example:
    /// `projects/123/locations/global/quotaPreferences/my-config-for-us-east1`
    pub name: std::string::String,

    /// Immutable. The dimensions that this quota preference applies to. The key of
    /// the map entry is the name of a dimension, such as "region", "zone",
    /// "network_id", and the value of the map entry is the dimension value.
    ///
    /// If a dimension is missing from the map of dimensions, the quota preference
    /// applies to all the dimension values except for those that have other quota
    /// preferences configured for the specific value.
    ///
    /// NOTE: QuotaPreferences can only be applied across all values of "user" and
    /// "resource" dimension. Do not set values for "user" or "resource" in the
    /// dimension map.
    ///
    /// Example: {"provider", "Foo Inc"} where "provider" is a service specific
    /// dimension.
    pub dimensions: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Preferred quota configuration.
    pub quota_config: std::option::Option<crate::model::QuotaConfig>,

    /// Optional. The current etag of the quota preference. If an etag is provided
    /// on update and does not match the current server's etag of the quota
    /// preference, the request will be blocked and an ABORTED error will be
    /// returned. See <https://google.aip.dev/134#etags> for more details on etags.
    pub etag: std::string::String,

    /// Output only. Create time stamp
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Required. The name of the service to which the quota preference is applied.
    pub service: std::string::String,

    /// Required. The id of the quota to which the quota preference is applied. A
    /// quota name is unique in the service. Example: `CpusPerProjectPerRegion`
    pub quota_id: std::string::String,

    /// Output only. Is the quota preference pending Google Cloud approval and
    /// fulfillment.
    pub reconciling: bool,

    /// The reason / justification for this quota preference.
    pub justification: std::string::String,

    /// Input only. An email address that can be used to contact the the user, in
    /// case Google Cloud needs more information to make a decision before
    /// additional quota can be granted.
    ///
    /// When requesting a quota increase, the email address is required.
    /// When requesting a quota decrease, the email address is optional.
    /// For example, the email address is optional when the
    /// `QuotaConfig.preferred_value` is smaller than the
    /// `QuotaDetails.reset_value`.
    pub contact_email: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaPreference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QuotaPreference::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [dimensions][crate::model::QuotaPreference::dimensions].
    pub fn set_dimensions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [quota_config][crate::model::QuotaPreference::quota_config].
    pub fn set_quota_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaConfig>,
    {
        self.quota_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [quota_config][crate::model::QuotaPreference::quota_config].
    pub fn set_or_clear_quota_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaConfig>,
    {
        self.quota_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::QuotaPreference::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::QuotaPreference::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::QuotaPreference::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::QuotaPreference::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::QuotaPreference::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service][crate::model::QuotaPreference::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [quota_id][crate::model::QuotaPreference::quota_id].
    pub fn set_quota_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.quota_id = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::QuotaPreference::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [justification][crate::model::QuotaPreference::justification].
    pub fn set_justification<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.justification = v.into();
        self
    }

    /// Sets the value of [contact_email][crate::model::QuotaPreference::contact_email].
    pub fn set_contact_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.contact_email = v.into();
        self
    }
}

impl wkt::message::Message for QuotaPreference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.QuotaPreference"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QuotaPreference {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __dimensions,
            __quota_config,
            __etag,
            __create_time,
            __update_time,
            __service,
            __quota_id,
            __reconciling,
            __justification,
            __contact_email,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QuotaPreference")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "dimensions" => Ok(__FieldTag::__dimensions),
                            "quotaConfig" => Ok(__FieldTag::__quota_config),
                            "quota_config" => Ok(__FieldTag::__quota_config),
                            "etag" => Ok(__FieldTag::__etag),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "service" => Ok(__FieldTag::__service),
                            "quotaId" => Ok(__FieldTag::__quota_id),
                            "quota_id" => Ok(__FieldTag::__quota_id),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "justification" => Ok(__FieldTag::__justification),
                            "contactEmail" => Ok(__FieldTag::__contact_email),
                            "contact_email" => Ok(__FieldTag::__contact_email),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QuotaPreference;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QuotaPreference")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dimensions => {
                            if !fields.insert(__FieldTag::__dimensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimensions",
                                ));
                            }
                            result.dimensions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quota_config => {
                            if !fields.insert(__FieldTag::__quota_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_config",
                                ));
                            }
                            result.quota_config =
                                map.next_value::<std::option::Option<crate::model::QuotaConfig>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quota_id => {
                            if !fields.insert(__FieldTag::__quota_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_id",
                                ));
                            }
                            result.quota_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__justification => {
                            if !fields.insert(__FieldTag::__justification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for justification",
                                ));
                            }
                            result.justification = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contact_email => {
                            if !fields.insert(__FieldTag::__contact_email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contact_email",
                                ));
                            }
                            result.contact_email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QuotaPreference {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.dimensions.is_empty() {
            state.serialize_entry("dimensions", &self.dimensions)?;
        }
        if self.quota_config.is_some() {
            state.serialize_entry("quotaConfig", &self.quota_config)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.service.is_empty() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self.quota_id.is_empty() {
            state.serialize_entry("quotaId", &self.quota_id)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.justification.is_empty() {
            state.serialize_entry("justification", &self.justification)?;
        }
        if !self.contact_email.is_empty() {
            state.serialize_entry("contactEmail", &self.contact_email)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The preferred quota configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QuotaConfig {
    /// Required. The preferred value. Must be greater than or equal to -1. If set
    /// to -1, it means the value is "unlimited".
    pub preferred_value: i64,

    /// Output only. Optional details about the state of this quota preference.
    pub state_detail: std::string::String,

    /// Output only. Granted quota value.
    pub granted_value: std::option::Option<wkt::Int64Value>,

    /// Output only. The trace id that the Google Cloud uses to provision the
    /// requested quota. This trace id may be used by the client to contact Cloud
    /// support to track the state of a quota preference request. The trace id is
    /// only produced for increase requests and is unique for each request. The
    /// quota decrease requests do not have a trace id.
    pub trace_id: std::string::String,

    /// Optional. The annotations map for clients to store small amounts of
    /// arbitrary data. Do not put PII or other sensitive information here. See
    /// <https://google.aip.dev/128#annotations>
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The origin of the quota preference request.
    pub request_origin: crate::model::quota_config::Origin,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [preferred_value][crate::model::QuotaConfig::preferred_value].
    pub fn set_preferred_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.preferred_value = v.into();
        self
    }

    /// Sets the value of [state_detail][crate::model::QuotaConfig::state_detail].
    pub fn set_state_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_detail = v.into();
        self
    }

    /// Sets the value of [granted_value][crate::model::QuotaConfig::granted_value].
    pub fn set_granted_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.granted_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [granted_value][crate::model::QuotaConfig::granted_value].
    pub fn set_or_clear_granted_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Int64Value>,
    {
        self.granted_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trace_id][crate::model::QuotaConfig::trace_id].
    pub fn set_trace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace_id = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::QuotaConfig::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [request_origin][crate::model::QuotaConfig::request_origin].
    pub fn set_request_origin<T: std::convert::Into<crate::model::quota_config::Origin>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_origin = v.into();
        self
    }
}

impl wkt::message::Message for QuotaConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.QuotaConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QuotaConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __preferred_value,
            __state_detail,
            __granted_value,
            __trace_id,
            __annotations,
            __request_origin,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QuotaConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "preferredValue" => Ok(__FieldTag::__preferred_value),
                            "preferred_value" => Ok(__FieldTag::__preferred_value),
                            "stateDetail" => Ok(__FieldTag::__state_detail),
                            "state_detail" => Ok(__FieldTag::__state_detail),
                            "grantedValue" => Ok(__FieldTag::__granted_value),
                            "granted_value" => Ok(__FieldTag::__granted_value),
                            "traceId" => Ok(__FieldTag::__trace_id),
                            "trace_id" => Ok(__FieldTag::__trace_id),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "requestOrigin" => Ok(__FieldTag::__request_origin),
                            "request_origin" => Ok(__FieldTag::__request_origin),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QuotaConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QuotaConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__preferred_value => {
                            if !fields.insert(__FieldTag::__preferred_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preferred_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.preferred_value =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__state_detail => {
                            if !fields.insert(__FieldTag::__state_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_detail",
                                ));
                            }
                            result.state_detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__granted_value => {
                            if !fields.insert(__FieldTag::__granted_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for granted_value",
                                ));
                            }
                            struct __With(std::option::Option<wkt::Int64Value>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.granted_value = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__trace_id => {
                            if !fields.insert(__FieldTag::__trace_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trace_id",
                                ));
                            }
                            result.trace_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_origin => {
                            if !fields.insert(__FieldTag::__request_origin) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_origin",
                                ));
                            }
                            result.request_origin = map.next_value::<std::option::Option<crate::model::quota_config::Origin>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QuotaConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.preferred_value) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("preferredValue", &__With(&self.preferred_value))?;
        }
        if !self.state_detail.is_empty() {
            state.serialize_entry("stateDetail", &self.state_detail)?;
        }
        if self.granted_value.is_some() {
            struct __With<'a>(&'a std::option::Option<wkt::Int64Value>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("grantedValue", &__With(&self.granted_value))?;
        }
        if !self.trace_id.is_empty() {
            state.serialize_entry("traceId", &self.trace_id)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !wkt::internal::is_default(&self.request_origin) {
            state.serialize_entry("requestOrigin", &self.request_origin)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [QuotaConfig].
pub mod quota_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumeration of the origins of quota preference requests.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Origin {
        /// The unspecified value.
        Unspecified,
        /// Created through Cloud Console.
        CloudConsole,
        /// Generated by automatic quota adjustment.
        AutoAdjuster,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Origin::value] or
        /// [Origin::name].
        UnknownValue(origin::UnknownValue),
    }

    #[doc(hidden)]
    pub mod origin {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Origin {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::CloudConsole => std::option::Option::Some(1),
                Self::AutoAdjuster => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ORIGIN_UNSPECIFIED"),
                Self::CloudConsole => std::option::Option::Some("CLOUD_CONSOLE"),
                Self::AutoAdjuster => std::option::Option::Some("AUTO_ADJUSTER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Origin {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Origin {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Origin {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::CloudConsole,
                2 => Self::AutoAdjuster,
                _ => Self::UnknownValue(origin::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Origin {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ORIGIN_UNSPECIFIED" => Self::Unspecified,
                "CLOUD_CONSOLE" => Self::CloudConsole,
                "AUTO_ADJUSTER" => Self::AutoAdjuster,
                _ => Self::UnknownValue(origin::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Origin {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::CloudConsole => serializer.serialize_i32(1),
                Self::AutoAdjuster => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Origin {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Origin>::new(
                ".google.api.cloudquotas.v1.QuotaConfig.Origin",
            ))
        }
    }
}

/// The detailed quota information such as effective quota value for a
/// combination of dimensions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DimensionsInfo {
    /// The map of dimensions for this dimensions info. The key of a map entry
    /// is "region", "zone" or the name of a service specific dimension, and the
    /// value of a map entry is the value of the dimension.  If a dimension does
    /// not appear in the map of dimensions, the dimensions info applies to all
    /// the dimension values except for those that have another DimenisonInfo
    /// instance configured for the specific value.
    /// Example: {"provider" : "Foo Inc"} where "provider" is a service specific
    /// dimension of a quota.
    pub dimensions: std::collections::HashMap<std::string::String, std::string::String>,

    /// Quota details for the specified dimensions.
    pub details: std::option::Option<crate::model::QuotaDetails>,

    /// The applicable regions or zones of this dimensions info. The field will be
    /// set to ['global'] for quotas that are not per region or per zone.
    /// Otherwise, it will be set to the list of locations this dimension info is
    /// applicable to.
    pub applicable_locations: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DimensionsInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimensions][crate::model::DimensionsInfo::dimensions].
    pub fn set_dimensions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [details][crate::model::DimensionsInfo::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaDetails>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::DimensionsInfo::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaDetails>,
    {
        self.details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [applicable_locations][crate::model::DimensionsInfo::applicable_locations].
    pub fn set_applicable_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.applicable_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for DimensionsInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.DimensionsInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DimensionsInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __dimensions,
            __details,
            __applicable_locations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DimensionsInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "dimensions" => Ok(__FieldTag::__dimensions),
                            "details" => Ok(__FieldTag::__details),
                            "applicableLocations" => Ok(__FieldTag::__applicable_locations),
                            "applicable_locations" => Ok(__FieldTag::__applicable_locations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DimensionsInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DimensionsInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__dimensions => {
                            if !fields.insert(__FieldTag::__dimensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dimensions",
                                ));
                            }
                            result.dimensions = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map
                                .next_value::<std::option::Option<crate::model::QuotaDetails>>()?;
                        }
                        __FieldTag::__applicable_locations => {
                            if !fields.insert(__FieldTag::__applicable_locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applicable_locations",
                                ));
                            }
                            result.applicable_locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DimensionsInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.dimensions.is_empty() {
            state.serialize_entry("dimensions", &self.dimensions)?;
        }
        if self.details.is_some() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self.applicable_locations.is_empty() {
            state.serialize_entry("applicableLocations", &self.applicable_locations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The quota details for a map of dimensions.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QuotaDetails {
    /// The value currently in effect and being enforced.
    pub value: i64,

    /// Rollout information of this quota.
    /// This field is present only if the effective limit will change due to the
    /// ongoing rollout of the service config.
    pub rollout_info: std::option::Option<crate::model::RolloutInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [value][crate::model::QuotaDetails::value].
    pub fn set_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value = v.into();
        self
    }

    /// Sets the value of [rollout_info][crate::model::QuotaDetails::rollout_info].
    pub fn set_rollout_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RolloutInfo>,
    {
        self.rollout_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout_info][crate::model::QuotaDetails::rollout_info].
    pub fn set_or_clear_rollout_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RolloutInfo>,
    {
        self.rollout_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for QuotaDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.QuotaDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QuotaDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __value,
            __rollout_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QuotaDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "value" => Ok(__FieldTag::__value),
                            "rolloutInfo" => Ok(__FieldTag::__rollout_info),
                            "rollout_info" => Ok(__FieldTag::__rollout_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QuotaDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QuotaDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__value => {
                            if !fields.insert(__FieldTag::__value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.value = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__rollout_info => {
                            if !fields.insert(__FieldTag::__rollout_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_info",
                                ));
                            }
                            result.rollout_info =
                                map.next_value::<std::option::Option<crate::model::RolloutInfo>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QuotaDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.value) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("value", &__With(&self.value))?;
        }
        if self.rollout_info.is_some() {
            state.serialize_entry("rolloutInfo", &self.rollout_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// [Output only] Rollout information of a quota.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RolloutInfo {
    /// Whether there is an ongoing rollout for a quota or not.
    pub ongoing_rollout: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RolloutInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ongoing_rollout][crate::model::RolloutInfo::ongoing_rollout].
    pub fn set_ongoing_rollout<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.ongoing_rollout = v.into();
        self
    }
}

impl wkt::message::Message for RolloutInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.cloudquotas.v1.RolloutInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RolloutInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __ongoing_rollout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RolloutInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "ongoingRollout" => Ok(__FieldTag::__ongoing_rollout),
                            "ongoing_rollout" => Ok(__FieldTag::__ongoing_rollout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RolloutInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RolloutInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__ongoing_rollout => {
                            if !fields.insert(__FieldTag::__ongoing_rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ongoing_rollout",
                                ));
                            }
                            result.ongoing_rollout = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RolloutInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.ongoing_rollout) {
            state.serialize_entry("ongoingRollout", &self.ongoing_rollout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Enumerations of quota safety checks.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum QuotaSafetyCheck {
    /// Unspecified quota safety check.
    Unspecified,
    /// Validates that a quota mutation would not cause the consumer's effective
    /// limit to be lower than the consumer's quota usage.
    QuotaDecreaseBelowUsage,
    /// Validates that a quota mutation would not cause the consumer's effective
    /// limit to decrease by more than 10 percent.
    QuotaDecreasePercentageTooHigh,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [QuotaSafetyCheck::value] or
    /// [QuotaSafetyCheck::name].
    UnknownValue(quota_safety_check::UnknownValue),
}

#[doc(hidden)]
pub mod quota_safety_check {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl QuotaSafetyCheck {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::QuotaDecreaseBelowUsage => std::option::Option::Some(1),
            Self::QuotaDecreasePercentageTooHigh => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("QUOTA_SAFETY_CHECK_UNSPECIFIED"),
            Self::QuotaDecreaseBelowUsage => {
                std::option::Option::Some("QUOTA_DECREASE_BELOW_USAGE")
            }
            Self::QuotaDecreasePercentageTooHigh => {
                std::option::Option::Some("QUOTA_DECREASE_PERCENTAGE_TOO_HIGH")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for QuotaSafetyCheck {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for QuotaSafetyCheck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for QuotaSafetyCheck {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::QuotaDecreaseBelowUsage,
            2 => Self::QuotaDecreasePercentageTooHigh,
            _ => Self::UnknownValue(quota_safety_check::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for QuotaSafetyCheck {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "QUOTA_SAFETY_CHECK_UNSPECIFIED" => Self::Unspecified,
            "QUOTA_DECREASE_BELOW_USAGE" => Self::QuotaDecreaseBelowUsage,
            "QUOTA_DECREASE_PERCENTAGE_TOO_HIGH" => Self::QuotaDecreasePercentageTooHigh,
            _ => Self::UnknownValue(quota_safety_check::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for QuotaSafetyCheck {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::QuotaDecreaseBelowUsage => serializer.serialize_i32(1),
            Self::QuotaDecreasePercentageTooHigh => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for QuotaSafetyCheck {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<QuotaSafetyCheck>::new(
            ".google.api.cloudquotas.v1.QuotaSafetyCheck",
        ))
    }
}
