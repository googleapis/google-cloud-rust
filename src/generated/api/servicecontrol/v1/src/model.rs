// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate logging_type;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Defines the errors to be returned in
/// [google.api.servicecontrol.v1.CheckResponse.check_errors][google.api.servicecontrol.v1.CheckResponse.check_errors].
///
/// [google.api.servicecontrol.v1.CheckResponse.check_errors]: crate::model::CheckResponse::check_errors
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckError {
    /// The error code.
    pub code: crate::model::check_error::Code,

    /// Subject to whom this error applies. See the specific code enum for more
    /// details on this field. For example:
    ///
    /// - "project:\<project-id or project-number\>"
    /// - "folder:\<folder-id\>"
    /// - "organization:\<organization-id\>"
    pub subject: std::string::String,

    /// Free-form text providing details on the error cause of the error.
    pub detail: std::string::String,

    /// Contains public information about the check error. If available,
    /// `status.code` will be non zero and client can propagate it out as public
    /// error.
    pub status: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::CheckError::code].
    pub fn set_code<T: std::convert::Into<crate::model::check_error::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::CheckError::subject].
    pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::CheckError::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }

    /// Sets the value of [status][crate::model::CheckError::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::CheckError::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CheckError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.CheckError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __subject,
            __detail,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "subject" => Ok(__FieldTag::__subject),
                            "detail" => Ok(__FieldTag::__detail),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<crate::model::check_error::Code>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__detail => {
                            if !fields.insert(__FieldTag::__detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for detail",
                                ));
                            }
                            result.detail = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.subject.is_empty() {
            state.serialize_entry("subject", &self.subject)?;
        }
        if !self.detail.is_empty() {
            state.serialize_entry("detail", &self.detail)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CheckError].
pub mod check_error {
    #[allow(unused_imports)]
    use super::*;

    /// Error codes for Check responses.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Code {
        /// This is never used in `CheckResponse`.
        ErrorCodeUnspecified,
        /// The consumer's project id, network container, or resource container was
        /// not found. Same as [google.rpc.Code.NOT_FOUND][google.rpc.Code.NOT_FOUND].
        NotFound,
        /// The consumer doesn't have access to the specified resource.
        /// Same as [google.rpc.Code.PERMISSION_DENIED][google.rpc.Code.PERMISSION_DENIED].
        PermissionDenied,
        /// Quota check failed. Same as [google.rpc.Code.RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED].
        ResourceExhausted,
        /// The consumer hasn't activated the service.
        ServiceNotActivated,
        /// The consumer cannot access the service because billing is disabled.
        BillingDisabled,
        /// The consumer's project has been marked as deleted (soft deletion).
        ProjectDeleted,
        /// The consumer's project number or id does not represent a valid project.
        ProjectInvalid,
        /// The input consumer info does not represent a valid consumer folder or
        /// organization.
        ConsumerInvalid,
        /// The IP address of the consumer is invalid for the specific consumer
        /// project.
        IpAddressBlocked,
        /// The referer address of the consumer request is invalid for the specific
        /// consumer project.
        RefererBlocked,
        /// The client application of the consumer request is invalid for the
        /// specific consumer project.
        ClientAppBlocked,
        /// The API targeted by this request is invalid for the specified consumer
        /// project.
        ApiTargetBlocked,
        /// The consumer's API key is invalid.
        ApiKeyInvalid,
        /// The consumer's API Key has expired.
        ApiKeyExpired,
        /// The consumer's API Key was not found in config record.
        ApiKeyNotFound,
        /// The credential in the request can not be verified.
        InvalidCredential,
        /// The backend server for looking up project id/number is unavailable.
        NamespaceLookupUnavailable,
        /// The backend server for checking service status is unavailable.
        ServiceStatusUnavailable,
        /// The backend server for checking billing status is unavailable.
        BillingStatusUnavailable,
        /// Cloud Resource Manager backend server is unavailable.
        CloudResourceManagerBackendUnavailable,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Code::value] or
        /// [Code::name].
        UnknownValue(code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Code {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ErrorCodeUnspecified => std::option::Option::Some(0),
                Self::NotFound => std::option::Option::Some(5),
                Self::PermissionDenied => std::option::Option::Some(7),
                Self::ResourceExhausted => std::option::Option::Some(8),
                Self::ServiceNotActivated => std::option::Option::Some(104),
                Self::BillingDisabled => std::option::Option::Some(107),
                Self::ProjectDeleted => std::option::Option::Some(108),
                Self::ProjectInvalid => std::option::Option::Some(114),
                Self::ConsumerInvalid => std::option::Option::Some(125),
                Self::IpAddressBlocked => std::option::Option::Some(109),
                Self::RefererBlocked => std::option::Option::Some(110),
                Self::ClientAppBlocked => std::option::Option::Some(111),
                Self::ApiTargetBlocked => std::option::Option::Some(122),
                Self::ApiKeyInvalid => std::option::Option::Some(105),
                Self::ApiKeyExpired => std::option::Option::Some(112),
                Self::ApiKeyNotFound => std::option::Option::Some(113),
                Self::InvalidCredential => std::option::Option::Some(123),
                Self::NamespaceLookupUnavailable => std::option::Option::Some(300),
                Self::ServiceStatusUnavailable => std::option::Option::Some(301),
                Self::BillingStatusUnavailable => std::option::Option::Some(302),
                Self::CloudResourceManagerBackendUnavailable => std::option::Option::Some(305),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ErrorCodeUnspecified => std::option::Option::Some("ERROR_CODE_UNSPECIFIED"),
                Self::NotFound => std::option::Option::Some("NOT_FOUND"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::ResourceExhausted => std::option::Option::Some("RESOURCE_EXHAUSTED"),
                Self::ServiceNotActivated => std::option::Option::Some("SERVICE_NOT_ACTIVATED"),
                Self::BillingDisabled => std::option::Option::Some("BILLING_DISABLED"),
                Self::ProjectDeleted => std::option::Option::Some("PROJECT_DELETED"),
                Self::ProjectInvalid => std::option::Option::Some("PROJECT_INVALID"),
                Self::ConsumerInvalid => std::option::Option::Some("CONSUMER_INVALID"),
                Self::IpAddressBlocked => std::option::Option::Some("IP_ADDRESS_BLOCKED"),
                Self::RefererBlocked => std::option::Option::Some("REFERER_BLOCKED"),
                Self::ClientAppBlocked => std::option::Option::Some("CLIENT_APP_BLOCKED"),
                Self::ApiTargetBlocked => std::option::Option::Some("API_TARGET_BLOCKED"),
                Self::ApiKeyInvalid => std::option::Option::Some("API_KEY_INVALID"),
                Self::ApiKeyExpired => std::option::Option::Some("API_KEY_EXPIRED"),
                Self::ApiKeyNotFound => std::option::Option::Some("API_KEY_NOT_FOUND"),
                Self::InvalidCredential => std::option::Option::Some("INVALID_CREDENTIAL"),
                Self::NamespaceLookupUnavailable => {
                    std::option::Option::Some("NAMESPACE_LOOKUP_UNAVAILABLE")
                }
                Self::ServiceStatusUnavailable => {
                    std::option::Option::Some("SERVICE_STATUS_UNAVAILABLE")
                }
                Self::BillingStatusUnavailable => {
                    std::option::Option::Some("BILLING_STATUS_UNAVAILABLE")
                }
                Self::CloudResourceManagerBackendUnavailable => {
                    std::option::Option::Some("CLOUD_RESOURCE_MANAGER_BACKEND_UNAVAILABLE")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Code {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ErrorCodeUnspecified,
                5 => Self::NotFound,
                7 => Self::PermissionDenied,
                8 => Self::ResourceExhausted,
                104 => Self::ServiceNotActivated,
                105 => Self::ApiKeyInvalid,
                107 => Self::BillingDisabled,
                108 => Self::ProjectDeleted,
                109 => Self::IpAddressBlocked,
                110 => Self::RefererBlocked,
                111 => Self::ClientAppBlocked,
                112 => Self::ApiKeyExpired,
                113 => Self::ApiKeyNotFound,
                114 => Self::ProjectInvalid,
                122 => Self::ApiTargetBlocked,
                123 => Self::InvalidCredential,
                125 => Self::ConsumerInvalid,
                300 => Self::NamespaceLookupUnavailable,
                301 => Self::ServiceStatusUnavailable,
                302 => Self::BillingStatusUnavailable,
                305 => Self::CloudResourceManagerBackendUnavailable,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Code {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_CODE_UNSPECIFIED" => Self::ErrorCodeUnspecified,
                "NOT_FOUND" => Self::NotFound,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                "RESOURCE_EXHAUSTED" => Self::ResourceExhausted,
                "SERVICE_NOT_ACTIVATED" => Self::ServiceNotActivated,
                "BILLING_DISABLED" => Self::BillingDisabled,
                "PROJECT_DELETED" => Self::ProjectDeleted,
                "PROJECT_INVALID" => Self::ProjectInvalid,
                "CONSUMER_INVALID" => Self::ConsumerInvalid,
                "IP_ADDRESS_BLOCKED" => Self::IpAddressBlocked,
                "REFERER_BLOCKED" => Self::RefererBlocked,
                "CLIENT_APP_BLOCKED" => Self::ClientAppBlocked,
                "API_TARGET_BLOCKED" => Self::ApiTargetBlocked,
                "API_KEY_INVALID" => Self::ApiKeyInvalid,
                "API_KEY_EXPIRED" => Self::ApiKeyExpired,
                "API_KEY_NOT_FOUND" => Self::ApiKeyNotFound,
                "INVALID_CREDENTIAL" => Self::InvalidCredential,
                "NAMESPACE_LOOKUP_UNAVAILABLE" => Self::NamespaceLookupUnavailable,
                "SERVICE_STATUS_UNAVAILABLE" => Self::ServiceStatusUnavailable,
                "BILLING_STATUS_UNAVAILABLE" => Self::BillingStatusUnavailable,
                "CLOUD_RESOURCE_MANAGER_BACKEND_UNAVAILABLE" => {
                    Self::CloudResourceManagerBackendUnavailable
                }
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Code {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ErrorCodeUnspecified => serializer.serialize_i32(0),
                Self::NotFound => serializer.serialize_i32(5),
                Self::PermissionDenied => serializer.serialize_i32(7),
                Self::ResourceExhausted => serializer.serialize_i32(8),
                Self::ServiceNotActivated => serializer.serialize_i32(104),
                Self::BillingDisabled => serializer.serialize_i32(107),
                Self::ProjectDeleted => serializer.serialize_i32(108),
                Self::ProjectInvalid => serializer.serialize_i32(114),
                Self::ConsumerInvalid => serializer.serialize_i32(125),
                Self::IpAddressBlocked => serializer.serialize_i32(109),
                Self::RefererBlocked => serializer.serialize_i32(110),
                Self::ClientAppBlocked => serializer.serialize_i32(111),
                Self::ApiTargetBlocked => serializer.serialize_i32(122),
                Self::ApiKeyInvalid => serializer.serialize_i32(105),
                Self::ApiKeyExpired => serializer.serialize_i32(112),
                Self::ApiKeyNotFound => serializer.serialize_i32(113),
                Self::InvalidCredential => serializer.serialize_i32(123),
                Self::NamespaceLookupUnavailable => serializer.serialize_i32(300),
                Self::ServiceStatusUnavailable => serializer.serialize_i32(301),
                Self::BillingStatusUnavailable => serializer.serialize_i32(302),
                Self::CloudResourceManagerBackendUnavailable => serializer.serialize_i32(305),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Code {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                ".google.api.servicecontrol.v1.CheckError.Code",
            ))
        }
    }
}

/// Distribution represents a frequency distribution of double-valued sample
/// points. It contains the size of the population of sample points plus
/// additional optional information:
///
/// * the arithmetic mean of the samples
/// * the minimum and maximum of the samples
/// * the sum-squared-deviation of the samples, used to compute variance
/// * a histogram of the values of the sample points
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Distribution {
    /// The total number of samples in the distribution. Must be >= 0.
    pub count: i64,

    /// The arithmetic mean of the samples in the distribution. If `count` is
    /// zero then this field must be zero.
    pub mean: f64,

    /// The minimum of the population of values. Ignored if `count` is zero.
    pub minimum: f64,

    /// The maximum of the population of values. Ignored if `count` is zero.
    pub maximum: f64,

    /// The sum of squared deviations from the mean:
    /// Sum[i=1..count]((x_i - mean)^2)
    /// where each x_i is a sample values. If `count` is zero then this field
    /// must be zero, otherwise validation of the request fails.
    pub sum_of_squared_deviation: f64,

    /// The number of samples in each histogram bucket. `bucket_counts` are
    /// optional. If present, they must sum to the `count` value.
    ///
    /// The buckets are defined below in `bucket_option`. There are N buckets.
    /// `bucket_counts[0]` is the number of samples in the underflow bucket.
    /// `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
    /// in each of the finite buckets. And `bucket_counts[N] is the number
    /// of samples in the overflow bucket. See the comments of `bucket_option`
    /// below for more details.
    ///
    /// Any suffix of trailing zeros may be omitted.
    pub bucket_counts: std::vec::Vec<i64>,

    /// Example points. Must be in increasing order of `value` field.
    pub exemplars: std::vec::Vec<api::model::distribution::Exemplar>,

    /// Defines the buckets in the histogram. `bucket_option` and `bucket_counts`
    /// must be both set, or both unset.
    ///
    /// Buckets are numbered in the range of [0, N], with a total of N+1 buckets.
    /// There must be at least two buckets (a single-bucket histogram gives
    /// no information that isn't already provided by `count`).
    ///
    /// The first bucket is the underflow bucket which has a lower bound
    /// of -inf. The last bucket is the overflow bucket which has an
    /// upper bound of +inf. All other buckets (if any) are called "finite"
    /// buckets because they have finite lower and upper bounds. As described
    /// below, there are three ways to define the finite buckets.
    ///
    /// (1) Buckets with constant width.
    /// (2) Buckets with exponentially growing widths.
    /// (3) Buckets with arbitrary user-provided widths.
    ///
    /// In all cases, the buckets cover the entire real number line (-inf,
    /// +inf). Bucket upper bounds are exclusive and lower bounds are
    /// inclusive. The upper bound of the underflow bucket is equal to the
    /// lower bound of the smallest finite bucket; the lower bound of the
    /// overflow bucket is equal to the upper bound of the largest finite
    /// bucket.
    pub bucket_option: std::option::Option<crate::model::distribution::BucketOption>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Distribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [count][crate::model::Distribution::count].
    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.count = v.into();
        self
    }

    /// Sets the value of [mean][crate::model::Distribution::mean].
    pub fn set_mean<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.mean = v.into();
        self
    }

    /// Sets the value of [minimum][crate::model::Distribution::minimum].
    pub fn set_minimum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.minimum = v.into();
        self
    }

    /// Sets the value of [maximum][crate::model::Distribution::maximum].
    pub fn set_maximum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.maximum = v.into();
        self
    }

    /// Sets the value of [sum_of_squared_deviation][crate::model::Distribution::sum_of_squared_deviation].
    pub fn set_sum_of_squared_deviation<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.sum_of_squared_deviation = v.into();
        self
    }

    /// Sets the value of [bucket_counts][crate::model::Distribution::bucket_counts].
    pub fn set_bucket_counts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.bucket_counts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exemplars][crate::model::Distribution::exemplars].
    pub fn set_exemplars<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::distribution::Exemplar>,
    {
        use std::iter::Iterator;
        self.exemplars = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bucket_option][crate::model::Distribution::bucket_option].
    ///
    /// Note that all the setters affecting `bucket_option` are mutually
    /// exclusive.
    pub fn set_bucket_option<
        T: std::convert::Into<std::option::Option<crate::model::distribution::BucketOption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_option = v.into();
        self
    }

    /// The value of [bucket_option][crate::model::Distribution::bucket_option]
    /// if it holds a `LinearBuckets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn linear_buckets(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::distribution::LinearBuckets>> {
        #[allow(unreachable_patterns)]
        self.bucket_option.as_ref().and_then(|v| match v {
            crate::model::distribution::BucketOption::LinearBuckets(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [bucket_option][crate::model::Distribution::bucket_option]
    /// to hold a `LinearBuckets`.
    ///
    /// Note that all the setters affecting `bucket_option` are
    /// mutually exclusive.
    pub fn set_linear_buckets<
        T: std::convert::Into<std::boxed::Box<crate::model::distribution::LinearBuckets>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_option = std::option::Option::Some(
            crate::model::distribution::BucketOption::LinearBuckets(v.into()),
        );
        self
    }

    /// The value of [bucket_option][crate::model::Distribution::bucket_option]
    /// if it holds a `ExponentialBuckets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn exponential_buckets(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::distribution::ExponentialBuckets>> {
        #[allow(unreachable_patterns)]
        self.bucket_option.as_ref().and_then(|v| match v {
            crate::model::distribution::BucketOption::ExponentialBuckets(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [bucket_option][crate::model::Distribution::bucket_option]
    /// to hold a `ExponentialBuckets`.
    ///
    /// Note that all the setters affecting `bucket_option` are
    /// mutually exclusive.
    pub fn set_exponential_buckets<
        T: std::convert::Into<std::boxed::Box<crate::model::distribution::ExponentialBuckets>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_option = std::option::Option::Some(
            crate::model::distribution::BucketOption::ExponentialBuckets(v.into()),
        );
        self
    }

    /// The value of [bucket_option][crate::model::Distribution::bucket_option]
    /// if it holds a `ExplicitBuckets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn explicit_buckets(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::distribution::ExplicitBuckets>> {
        #[allow(unreachable_patterns)]
        self.bucket_option.as_ref().and_then(|v| match v {
            crate::model::distribution::BucketOption::ExplicitBuckets(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [bucket_option][crate::model::Distribution::bucket_option]
    /// to hold a `ExplicitBuckets`.
    ///
    /// Note that all the setters affecting `bucket_option` are
    /// mutually exclusive.
    pub fn set_explicit_buckets<
        T: std::convert::Into<std::boxed::Box<crate::model::distribution::ExplicitBuckets>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_option = std::option::Option::Some(
            crate::model::distribution::BucketOption::ExplicitBuckets(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Distribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.Distribution"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Distribution {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __count,
            __mean,
            __minimum,
            __maximum,
            __sum_of_squared_deviation,
            __bucket_counts,
            __linear_buckets,
            __exponential_buckets,
            __explicit_buckets,
            __exemplars,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Distribution")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "count" => Ok(__FieldTag::__count),
                            "mean" => Ok(__FieldTag::__mean),
                            "minimum" => Ok(__FieldTag::__minimum),
                            "maximum" => Ok(__FieldTag::__maximum),
                            "sumOfSquaredDeviation" => Ok(__FieldTag::__sum_of_squared_deviation),
                            "sum_of_squared_deviation" => {
                                Ok(__FieldTag::__sum_of_squared_deviation)
                            }
                            "bucketCounts" => Ok(__FieldTag::__bucket_counts),
                            "bucket_counts" => Ok(__FieldTag::__bucket_counts),
                            "linearBuckets" => Ok(__FieldTag::__linear_buckets),
                            "linear_buckets" => Ok(__FieldTag::__linear_buckets),
                            "exponentialBuckets" => Ok(__FieldTag::__exponential_buckets),
                            "exponential_buckets" => Ok(__FieldTag::__exponential_buckets),
                            "explicitBuckets" => Ok(__FieldTag::__explicit_buckets),
                            "explicit_buckets" => Ok(__FieldTag::__explicit_buckets),
                            "exemplars" => Ok(__FieldTag::__exemplars),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Distribution;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Distribution")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__count => {
                            if !fields.insert(__FieldTag::__count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__mean => {
                            if !fields.insert(__FieldTag::__mean) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mean",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.mean = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__minimum => {
                            if !fields.insert(__FieldTag::__minimum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for minimum",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.minimum = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__maximum => {
                            if !fields.insert(__FieldTag::__maximum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maximum",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.maximum = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__sum_of_squared_deviation => {
                            if !fields.insert(__FieldTag::__sum_of_squared_deviation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sum_of_squared_deviation",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.sum_of_squared_deviation =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bucket_counts => {
                            if !fields.insert(__FieldTag::__bucket_counts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket_counts",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<i64>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<std::vec::Vec<wkt::internal::I64>>,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.bucket_counts =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__linear_buckets => {
                            if !fields.insert(__FieldTag::__linear_buckets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for linear_buckets",
                                ));
                            }
                            if result.bucket_option.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `bucket_option`, a oneof with full ID .google.api.servicecontrol.v1.Distribution.linear_buckets, latest field was linearBuckets",
                                ));
                            }
                            result.bucket_option = std::option::Option::Some(
                                crate::model::distribution::BucketOption::LinearBuckets(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::distribution::LinearBuckets>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__exponential_buckets => {
                            if !fields.insert(__FieldTag::__exponential_buckets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exponential_buckets",
                                ));
                            }
                            if result.bucket_option.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `bucket_option`, a oneof with full ID .google.api.servicecontrol.v1.Distribution.exponential_buckets, latest field was exponentialBuckets",
                                ));
                            }
                            result.bucket_option = std::option::Option::Some(
                                crate::model::distribution::BucketOption::ExponentialBuckets(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::distribution::ExponentialBuckets,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__explicit_buckets => {
                            if !fields.insert(__FieldTag::__explicit_buckets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for explicit_buckets",
                                ));
                            }
                            if result.bucket_option.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `bucket_option`, a oneof with full ID .google.api.servicecontrol.v1.Distribution.explicit_buckets, latest field was explicitBuckets",
                                ));
                            }
                            result.bucket_option = std::option::Option::Some(
                                crate::model::distribution::BucketOption::ExplicitBuckets(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::distribution::ExplicitBuckets,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__exemplars => {
                            if !fields.insert(__FieldTag::__exemplars) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exemplars",
                                ));
                            }
                            result.exemplars = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<api::model::distribution::Exemplar>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Distribution {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("count", &__With(&self.count))?;
        }
        if !wkt::internal::is_default(&self.mean) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("mean", &__With(&self.mean))?;
        }
        if !wkt::internal::is_default(&self.minimum) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minimum", &__With(&self.minimum))?;
        }
        if !wkt::internal::is_default(&self.maximum) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maximum", &__With(&self.maximum))?;
        }
        if !wkt::internal::is_default(&self.sum_of_squared_deviation) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "sumOfSquaredDeviation",
                &__With(&self.sum_of_squared_deviation),
            )?;
        }
        if !self.bucket_counts.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("bucketCounts", &__With(&self.bucket_counts))?;
        }
        if let Some(value) = self.linear_buckets() {
            state.serialize_entry("linearBuckets", value)?;
        }
        if let Some(value) = self.exponential_buckets() {
            state.serialize_entry("exponentialBuckets", value)?;
        }
        if let Some(value) = self.explicit_buckets() {
            state.serialize_entry("explicitBuckets", value)?;
        }
        if !self.exemplars.is_empty() {
            state.serialize_entry("exemplars", &self.exemplars)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Distribution].
pub mod distribution {
    #[allow(unused_imports)]
    use super::*;

    /// Describing buckets with constant width.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LinearBuckets {
        /// The number of finite buckets. With the underflow and overflow buckets,
        /// the total number of buckets is `num_finite_buckets` + 2.
        /// See comments on `bucket_options` for details.
        pub num_finite_buckets: i32,

        /// The i'th linear bucket covers the interval
        /// [offset + (i-1) * width, offset + i * width)
        /// where i ranges from 1 to num_finite_buckets, inclusive.
        /// Must be strictly positive.
        pub width: f64,

        /// The i'th linear bucket covers the interval
        /// [offset + (i-1) * width, offset + i * width)
        /// where i ranges from 1 to num_finite_buckets, inclusive.
        pub offset: f64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LinearBuckets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [num_finite_buckets][crate::model::distribution::LinearBuckets::num_finite_buckets].
        pub fn set_num_finite_buckets<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.num_finite_buckets = v.into();
            self
        }

        /// Sets the value of [width][crate::model::distribution::LinearBuckets::width].
        pub fn set_width<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.width = v.into();
            self
        }

        /// Sets the value of [offset][crate::model::distribution::LinearBuckets::offset].
        pub fn set_offset<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.offset = v.into();
            self
        }
    }

    impl wkt::message::Message for LinearBuckets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.Distribution.LinearBuckets"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LinearBuckets {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __num_finite_buckets,
                __width,
                __offset,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LinearBuckets")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "numFiniteBuckets" => Ok(__FieldTag::__num_finite_buckets),
                                "num_finite_buckets" => Ok(__FieldTag::__num_finite_buckets),
                                "width" => Ok(__FieldTag::__width),
                                "offset" => Ok(__FieldTag::__offset),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LinearBuckets;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LinearBuckets")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__num_finite_buckets => {
                                if !fields.insert(__FieldTag::__num_finite_buckets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for num_finite_buckets",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.num_finite_buckets =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__width => {
                                if !fields.insert(__FieldTag::__width) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for width",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.width = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__offset => {
                                if !fields.insert(__FieldTag::__offset) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for offset",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.offset = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LinearBuckets {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.num_finite_buckets) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("numFiniteBuckets", &__With(&self.num_finite_buckets))?;
            }
            if !wkt::internal::is_default(&self.width) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("width", &__With(&self.width))?;
            }
            if !wkt::internal::is_default(&self.offset) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("offset", &__With(&self.offset))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Describing buckets with exponentially growing width.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ExponentialBuckets {
        /// The number of finite buckets. With the underflow and overflow buckets,
        /// the total number of buckets is `num_finite_buckets` + 2.
        /// See comments on `bucket_options` for details.
        pub num_finite_buckets: i32,

        /// The i'th exponential bucket covers the interval
        /// [scale * growth_factor^(i-1), scale * growth_factor^i)
        /// where i ranges from 1 to num_finite_buckets inclusive.
        /// Must be larger than 1.0.
        pub growth_factor: f64,

        /// The i'th exponential bucket covers the interval
        /// [scale * growth_factor^(i-1), scale * growth_factor^i)
        /// where i ranges from 1 to num_finite_buckets inclusive.
        /// Must be > 0.
        pub scale: f64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExponentialBuckets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [num_finite_buckets][crate::model::distribution::ExponentialBuckets::num_finite_buckets].
        pub fn set_num_finite_buckets<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.num_finite_buckets = v.into();
            self
        }

        /// Sets the value of [growth_factor][crate::model::distribution::ExponentialBuckets::growth_factor].
        pub fn set_growth_factor<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.growth_factor = v.into();
            self
        }

        /// Sets the value of [scale][crate::model::distribution::ExponentialBuckets::scale].
        pub fn set_scale<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.scale = v.into();
            self
        }
    }

    impl wkt::message::Message for ExponentialBuckets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.Distribution.ExponentialBuckets"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ExponentialBuckets {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __num_finite_buckets,
                __growth_factor,
                __scale,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ExponentialBuckets")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "numFiniteBuckets" => Ok(__FieldTag::__num_finite_buckets),
                                "num_finite_buckets" => Ok(__FieldTag::__num_finite_buckets),
                                "growthFactor" => Ok(__FieldTag::__growth_factor),
                                "growth_factor" => Ok(__FieldTag::__growth_factor),
                                "scale" => Ok(__FieldTag::__scale),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ExponentialBuckets;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ExponentialBuckets")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__num_finite_buckets => {
                                if !fields.insert(__FieldTag::__num_finite_buckets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for num_finite_buckets",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.num_finite_buckets =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__growth_factor => {
                                if !fields.insert(__FieldTag::__growth_factor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for growth_factor",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.growth_factor =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__scale => {
                                if !fields.insert(__FieldTag::__scale) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for scale",
                                    ));
                                }
                                struct __With(std::option::Option<f64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.scale = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ExponentialBuckets {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.num_finite_buckets) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("numFiniteBuckets", &__With(&self.num_finite_buckets))?;
            }
            if !wkt::internal::is_default(&self.growth_factor) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("growthFactor", &__With(&self.growth_factor))?;
            }
            if !wkt::internal::is_default(&self.scale) {
                struct __With<'a>(&'a f64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("scale", &__With(&self.scale))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Describing buckets with arbitrary user-provided width.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ExplicitBuckets {
        /// 'bound' is a list of strictly increasing boundaries between
        /// buckets. Note that a list of length N-1 defines N buckets because
        /// of fenceposting. See comments on `bucket_options` for details.
        ///
        /// The i'th finite bucket covers the interval
        /// [bound[i-1], bound[i])
        /// where i ranges from 1 to bound_size() - 1. Note that there are no
        /// finite buckets at all if 'bound' only contains a single element; in
        /// that special case the single bound defines the boundary between the
        /// underflow and overflow buckets.
        ///
        /// bucket number                   lower bound    upper bound
        /// i == 0 (underflow)              -inf           bound[i]
        /// 0 < i < bound_size()            bound[i-1]     bound[i]
        /// i == bound_size() (overflow)    bound[i-1]     +inf
        pub bounds: std::vec::Vec<f64>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ExplicitBuckets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bounds][crate::model::distribution::ExplicitBuckets::bounds].
        pub fn set_bounds<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<f64>,
        {
            use std::iter::Iterator;
            self.bounds = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ExplicitBuckets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.Distribution.ExplicitBuckets"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ExplicitBuckets {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __bounds,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ExplicitBuckets")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "bounds" => Ok(__FieldTag::__bounds),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ExplicitBuckets;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ExplicitBuckets")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__bounds => {
                                if !fields.insert(__FieldTag::__bounds) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bounds",
                                    ));
                                }
                                struct __With(std::option::Option<std::vec::Vec<f64>>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<std::vec::Vec<wkt::internal::F64>>,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.bounds = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ExplicitBuckets {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.bounds.is_empty() {
                struct __With<'a>(&'a std::vec::Vec<f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<std::vec::Vec<wkt::internal::F64>>::serialize(
                            self.0, serializer,
                        )
                    }
                }
                state.serialize_entry("bounds", &__With(&self.bounds))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines the buckets in the histogram. `bucket_option` and `bucket_counts`
    /// must be both set, or both unset.
    ///
    /// Buckets are numbered in the range of [0, N], with a total of N+1 buckets.
    /// There must be at least two buckets (a single-bucket histogram gives
    /// no information that isn't already provided by `count`).
    ///
    /// The first bucket is the underflow bucket which has a lower bound
    /// of -inf. The last bucket is the overflow bucket which has an
    /// upper bound of +inf. All other buckets (if any) are called "finite"
    /// buckets because they have finite lower and upper bounds. As described
    /// below, there are three ways to define the finite buckets.
    ///
    /// (1) Buckets with constant width.
    /// (2) Buckets with exponentially growing widths.
    /// (3) Buckets with arbitrary user-provided widths.
    ///
    /// In all cases, the buckets cover the entire real number line (-inf,
    /// +inf). Bucket upper bounds are exclusive and lower bounds are
    /// inclusive. The upper bound of the underflow bucket is equal to the
    /// lower bound of the smallest finite bucket; the lower bound of the
    /// overflow bucket is equal to the upper bound of the largest finite
    /// bucket.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BucketOption {
        /// Buckets with constant width.
        LinearBuckets(std::boxed::Box<crate::model::distribution::LinearBuckets>),
        /// Buckets with exponentially growing width.
        ExponentialBuckets(std::boxed::Box<crate::model::distribution::ExponentialBuckets>),
        /// Buckets with arbitrary user-provided width.
        ExplicitBuckets(std::boxed::Box<crate::model::distribution::ExplicitBuckets>),
    }
}

/// A common proto for logging HTTP requests. Only contains semantics
/// defined by the HTTP specification. Product-specific logging
/// information MUST be defined in a separate message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct HttpRequest {
    /// The request method. Examples: `"GET"`, `"HEAD"`, `"PUT"`, `"POST"`.
    pub request_method: std::string::String,

    /// The scheme (http, https), the host name, the path, and the query
    /// portion of the URL that was requested.
    /// Example: ``http://example.com/some/info?color=red``.
    pub request_url: std::string::String,

    /// The size of the HTTP request message in bytes, including the request
    /// headers and the request body.
    pub request_size: i64,

    /// The response code indicating the status of the response.
    /// Examples: 200, 404.
    pub status: i32,

    /// The size of the HTTP response message sent back to the client, in bytes,
    /// including the response headers and the response body.
    pub response_size: i64,

    /// The user agent sent by the client. Example:
    /// `"Mozilla/4.0 (compatible; MSIE 6.0; Windows 98; Q312461; .NET
    /// CLR 1.0.3705)"`.
    pub user_agent: std::string::String,

    /// The IP address (IPv4 or IPv6) of the client that issued the HTTP
    /// request. Examples: `"192.168.1.1"`, `"FE80::0202:B3FF:FE1E:8329"`.
    pub remote_ip: std::string::String,

    /// The IP address (IPv4 or IPv6) of the origin server that the request was
    /// sent to.
    pub server_ip: std::string::String,

    /// The referer URL of the request, as defined in
    /// [HTTP/1.1 Header Field
    /// Definitions](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html).
    pub referer: std::string::String,

    /// The request processing latency on the server, from the time the request was
    /// received until the response was sent.
    pub latency: std::option::Option<wkt::Duration>,

    /// Whether or not a cache lookup was attempted.
    pub cache_lookup: bool,

    /// Whether or not an entity was served from cache
    /// (with or without validation).
    pub cache_hit: bool,

    /// Whether or not the response was validated with the origin server before
    /// being served from cache. This field is only meaningful if `cache_hit` is
    /// True.
    pub cache_validated_with_origin_server: bool,

    /// The number of HTTP response bytes inserted into cache. Set only when a
    /// cache fill was attempted.
    pub cache_fill_bytes: i64,

    /// Protocol used for the request. Examples: "HTTP/1.1", "HTTP/2", "websocket"
    pub protocol: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl HttpRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_method][crate::model::HttpRequest::request_method].
    pub fn set_request_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_method = v.into();
        self
    }

    /// Sets the value of [request_url][crate::model::HttpRequest::request_url].
    pub fn set_request_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_url = v.into();
        self
    }

    /// Sets the value of [request_size][crate::model::HttpRequest::request_size].
    pub fn set_request_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.request_size = v.into();
        self
    }

    /// Sets the value of [status][crate::model::HttpRequest::status].
    pub fn set_status<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [response_size][crate::model::HttpRequest::response_size].
    pub fn set_response_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.response_size = v.into();
        self
    }

    /// Sets the value of [user_agent][crate::model::HttpRequest::user_agent].
    pub fn set_user_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_agent = v.into();
        self
    }

    /// Sets the value of [remote_ip][crate::model::HttpRequest::remote_ip].
    pub fn set_remote_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remote_ip = v.into();
        self
    }

    /// Sets the value of [server_ip][crate::model::HttpRequest::server_ip].
    pub fn set_server_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server_ip = v.into();
        self
    }

    /// Sets the value of [referer][crate::model::HttpRequest::referer].
    pub fn set_referer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.referer = v.into();
        self
    }

    /// Sets the value of [latency][crate::model::HttpRequest::latency].
    pub fn set_latency<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.latency = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latency][crate::model::HttpRequest::latency].
    pub fn set_or_clear_latency<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.latency = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cache_lookup][crate::model::HttpRequest::cache_lookup].
    pub fn set_cache_lookup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cache_lookup = v.into();
        self
    }

    /// Sets the value of [cache_hit][crate::model::HttpRequest::cache_hit].
    pub fn set_cache_hit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cache_hit = v.into();
        self
    }

    /// Sets the value of [cache_validated_with_origin_server][crate::model::HttpRequest::cache_validated_with_origin_server].
    pub fn set_cache_validated_with_origin_server<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.cache_validated_with_origin_server = v.into();
        self
    }

    /// Sets the value of [cache_fill_bytes][crate::model::HttpRequest::cache_fill_bytes].
    pub fn set_cache_fill_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.cache_fill_bytes = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::HttpRequest::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }
}

impl wkt::message::Message for HttpRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.HttpRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for HttpRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request_method,
            __request_url,
            __request_size,
            __status,
            __response_size,
            __user_agent,
            __remote_ip,
            __server_ip,
            __referer,
            __latency,
            __cache_lookup,
            __cache_hit,
            __cache_validated_with_origin_server,
            __cache_fill_bytes,
            __protocol,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for HttpRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requestMethod" => Ok(__FieldTag::__request_method),
                            "request_method" => Ok(__FieldTag::__request_method),
                            "requestUrl" => Ok(__FieldTag::__request_url),
                            "request_url" => Ok(__FieldTag::__request_url),
                            "requestSize" => Ok(__FieldTag::__request_size),
                            "request_size" => Ok(__FieldTag::__request_size),
                            "status" => Ok(__FieldTag::__status),
                            "responseSize" => Ok(__FieldTag::__response_size),
                            "response_size" => Ok(__FieldTag::__response_size),
                            "userAgent" => Ok(__FieldTag::__user_agent),
                            "user_agent" => Ok(__FieldTag::__user_agent),
                            "remoteIp" => Ok(__FieldTag::__remote_ip),
                            "remote_ip" => Ok(__FieldTag::__remote_ip),
                            "serverIp" => Ok(__FieldTag::__server_ip),
                            "server_ip" => Ok(__FieldTag::__server_ip),
                            "referer" => Ok(__FieldTag::__referer),
                            "latency" => Ok(__FieldTag::__latency),
                            "cacheLookup" => Ok(__FieldTag::__cache_lookup),
                            "cache_lookup" => Ok(__FieldTag::__cache_lookup),
                            "cacheHit" => Ok(__FieldTag::__cache_hit),
                            "cache_hit" => Ok(__FieldTag::__cache_hit),
                            "cacheValidatedWithOriginServer" => {
                                Ok(__FieldTag::__cache_validated_with_origin_server)
                            }
                            "cache_validated_with_origin_server" => {
                                Ok(__FieldTag::__cache_validated_with_origin_server)
                            }
                            "cacheFillBytes" => Ok(__FieldTag::__cache_fill_bytes),
                            "cache_fill_bytes" => Ok(__FieldTag::__cache_fill_bytes),
                            "protocol" => Ok(__FieldTag::__protocol),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = HttpRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct HttpRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request_method => {
                            if !fields.insert(__FieldTag::__request_method) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_method",
                                ));
                            }
                            result.request_method = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_url => {
                            if !fields.insert(__FieldTag::__request_url) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_url",
                                ));
                            }
                            result.request_url = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_size => {
                            if !fields.insert(__FieldTag::__request_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.request_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.status = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__response_size => {
                            if !fields.insert(__FieldTag::__response_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_size",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.response_size =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__user_agent => {
                            if !fields.insert(__FieldTag::__user_agent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_agent",
                                ));
                            }
                            result.user_agent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remote_ip => {
                            if !fields.insert(__FieldTag::__remote_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_ip",
                                ));
                            }
                            result.remote_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__server_ip => {
                            if !fields.insert(__FieldTag::__server_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_ip",
                                ));
                            }
                            result.server_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__referer => {
                            if !fields.insert(__FieldTag::__referer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for referer",
                                ));
                            }
                            result.referer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__latency => {
                            if !fields.insert(__FieldTag::__latency) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for latency",
                                ));
                            }
                            result.latency =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__cache_lookup => {
                            if !fields.insert(__FieldTag::__cache_lookup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cache_lookup",
                                ));
                            }
                            result.cache_lookup = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cache_hit => {
                            if !fields.insert(__FieldTag::__cache_hit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cache_hit",
                                ));
                            }
                            result.cache_hit = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cache_validated_with_origin_server => {
                            if !fields.insert(__FieldTag::__cache_validated_with_origin_server) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cache_validated_with_origin_server",
                                ));
                            }
                            result.cache_validated_with_origin_server = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cache_fill_bytes => {
                            if !fields.insert(__FieldTag::__cache_fill_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cache_fill_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cache_fill_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__protocol => {
                            if !fields.insert(__FieldTag::__protocol) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for protocol",
                                ));
                            }
                            result.protocol = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for HttpRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.request_method.is_empty() {
            state.serialize_entry("requestMethod", &self.request_method)?;
        }
        if !self.request_url.is_empty() {
            state.serialize_entry("requestUrl", &self.request_url)?;
        }
        if !wkt::internal::is_default(&self.request_size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("requestSize", &__With(&self.request_size))?;
        }
        if !wkt::internal::is_default(&self.status) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("status", &__With(&self.status))?;
        }
        if !wkt::internal::is_default(&self.response_size) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("responseSize", &__With(&self.response_size))?;
        }
        if !self.user_agent.is_empty() {
            state.serialize_entry("userAgent", &self.user_agent)?;
        }
        if !self.remote_ip.is_empty() {
            state.serialize_entry("remoteIp", &self.remote_ip)?;
        }
        if !self.server_ip.is_empty() {
            state.serialize_entry("serverIp", &self.server_ip)?;
        }
        if !self.referer.is_empty() {
            state.serialize_entry("referer", &self.referer)?;
        }
        if self.latency.is_some() {
            state.serialize_entry("latency", &self.latency)?;
        }
        if !wkt::internal::is_default(&self.cache_lookup) {
            state.serialize_entry("cacheLookup", &self.cache_lookup)?;
        }
        if !wkt::internal::is_default(&self.cache_hit) {
            state.serialize_entry("cacheHit", &self.cache_hit)?;
        }
        if !wkt::internal::is_default(&self.cache_validated_with_origin_server) {
            state.serialize_entry(
                "cacheValidatedWithOriginServer",
                &self.cache_validated_with_origin_server,
            )?;
        }
        if !wkt::internal::is_default(&self.cache_fill_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cacheFillBytes", &__With(&self.cache_fill_bytes))?;
        }
        if !self.protocol.is_empty() {
            state.serialize_entry("protocol", &self.protocol)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An individual log entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogEntry {
    /// Required. The log to which this log entry belongs. Examples: `"syslog"`,
    /// `"book_log"`.
    pub name: std::string::String,

    /// The time the event described by the log entry occurred. If
    /// omitted, defaults to operation start time.
    pub timestamp: std::option::Option<wkt::Timestamp>,

    /// The severity of the log entry. The default value is
    /// `LogSeverity.DEFAULT`.
    pub severity: logging_type::model::LogSeverity,

    /// Optional. Information about the HTTP request associated with this
    /// log entry, if applicable.
    pub http_request: std::option::Option<crate::model::HttpRequest>,

    /// Optional. Resource name of the trace associated with the log entry, if any.
    /// If this field contains a relative resource name, you can assume the name is
    /// relative to `//tracing.googleapis.com`. Example:
    /// `projects/my-projectid/traces/06796866738c859f2f19b7cfb3214824`
    pub trace: std::string::String,

    /// A unique ID for the log entry used for deduplication. If omitted,
    /// the implementation will generate one based on operation_id.
    pub insert_id: std::string::String,

    /// A set of user-defined (key, value) data that provides additional
    /// information about the log entry.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Information about an operation associated with the log entry, if
    /// applicable.
    pub operation: std::option::Option<crate::model::LogEntryOperation>,

    /// Optional. Source code location information associated with the log entry,
    /// if any.
    pub source_location: std::option::Option<crate::model::LogEntrySourceLocation>,

    /// The log entry payload, which can be one of multiple types.
    pub payload: std::option::Option<crate::model::log_entry::Payload>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogEntry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [timestamp][crate::model::LogEntry::timestamp].
    pub fn set_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timestamp][crate::model::LogEntry::timestamp].
    pub fn set_or_clear_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [severity][crate::model::LogEntry::severity].
    pub fn set_severity<T: std::convert::Into<logging_type::model::LogSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [http_request][crate::model::LogEntry::http_request].
    pub fn set_http_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::HttpRequest>,
    {
        self.http_request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http_request][crate::model::LogEntry::http_request].
    pub fn set_or_clear_http_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::HttpRequest>,
    {
        self.http_request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [trace][crate::model::LogEntry::trace].
    pub fn set_trace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace = v.into();
        self
    }

    /// Sets the value of [insert_id][crate::model::LogEntry::insert_id].
    pub fn set_insert_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.insert_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::LogEntry::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [operation][crate::model::LogEntry::operation].
    pub fn set_operation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogEntryOperation>,
    {
        self.operation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operation][crate::model::LogEntry::operation].
    pub fn set_or_clear_operation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogEntryOperation>,
    {
        self.operation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_location][crate::model::LogEntry::source_location].
    pub fn set_source_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LogEntrySourceLocation>,
    {
        self.source_location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_location][crate::model::LogEntry::source_location].
    pub fn set_or_clear_source_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LogEntrySourceLocation>,
    {
        self.source_location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload].
    ///
    /// Note that all the setters affecting `payload` are mutually
    /// exclusive.
    pub fn set_payload<
        T: std::convert::Into<std::option::Option<crate::model::log_entry::Payload>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `ProtoPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn proto_payload(&self) -> std::option::Option<&std::boxed::Box<wkt::Any>> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::ProtoPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `ProtoPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_proto_payload<T: std::convert::Into<std::boxed::Box<wkt::Any>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::ProtoPayload(v.into()));
        self
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `TextPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::TextPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `TextPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_text_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::TextPayload(v.into()));
        self
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `StructPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn struct_payload(&self) -> std::option::Option<&std::boxed::Box<wkt::Struct>> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::StructPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `StructPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_struct_payload<T: std::convert::Into<std::boxed::Box<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::StructPayload(v.into()));
        self
    }
}

impl wkt::message::Message for LogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.LogEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __timestamp,
            __severity,
            __http_request,
            __trace,
            __insert_id,
            __labels,
            __proto_payload,
            __text_payload,
            __struct_payload,
            __operation,
            __source_location,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "timestamp" => Ok(__FieldTag::__timestamp),
                            "severity" => Ok(__FieldTag::__severity),
                            "httpRequest" => Ok(__FieldTag::__http_request),
                            "http_request" => Ok(__FieldTag::__http_request),
                            "trace" => Ok(__FieldTag::__trace),
                            "insertId" => Ok(__FieldTag::__insert_id),
                            "insert_id" => Ok(__FieldTag::__insert_id),
                            "labels" => Ok(__FieldTag::__labels),
                            "protoPayload" => Ok(__FieldTag::__proto_payload),
                            "proto_payload" => Ok(__FieldTag::__proto_payload),
                            "textPayload" => Ok(__FieldTag::__text_payload),
                            "text_payload" => Ok(__FieldTag::__text_payload),
                            "structPayload" => Ok(__FieldTag::__struct_payload),
                            "struct_payload" => Ok(__FieldTag::__struct_payload),
                            "operation" => Ok(__FieldTag::__operation),
                            "sourceLocation" => Ok(__FieldTag::__source_location),
                            "source_location" => Ok(__FieldTag::__source_location),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timestamp => {
                            if !fields.insert(__FieldTag::__timestamp) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timestamp",
                                ));
                            }
                            result.timestamp =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map.next_value::<std::option::Option<logging_type::model::LogSeverity>>()?.unwrap_or_default();
                        }
                        __FieldTag::__http_request => {
                            if !fields.insert(__FieldTag::__http_request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for http_request",
                                ));
                            }
                            result.http_request =
                                map.next_value::<std::option::Option<crate::model::HttpRequest>>()?;
                        }
                        __FieldTag::__trace => {
                            if !fields.insert(__FieldTag::__trace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trace",
                                ));
                            }
                            result.trace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__insert_id => {
                            if !fields.insert(__FieldTag::__insert_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for insert_id",
                                ));
                            }
                            result.insert_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__proto_payload => {
                            if !fields.insert(__FieldTag::__proto_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proto_payload",
                                ));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .google.api.servicecontrol.v1.LogEntry.proto_payload, latest field was protoPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::model::log_entry::Payload::ProtoPayload(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Any>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__text_payload => {
                            if !fields.insert(__FieldTag::__text_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text_payload",
                                ));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .google.api.servicecontrol.v1.LogEntry.text_payload, latest field was textPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::model::log_entry::Payload::TextPayload(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__struct_payload => {
                            if !fields.insert(__FieldTag::__struct_payload) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for struct_payload",
                                ));
                            }
                            if result.payload.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `payload`, a oneof with full ID .google.api.servicecontrol.v1.LogEntry.struct_payload, latest field was structPayload",
                                ));
                            }
                            result.payload = std::option::Option::Some(
                                crate::model::log_entry::Payload::StructPayload(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Struct>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation = map
                                .next_value::<std::option::Option<crate::model::LogEntryOperation>>(
                                )?;
                        }
                        __FieldTag::__source_location => {
                            if !fields.insert(__FieldTag::__source_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_location",
                                ));
                            }
                            result.source_location = map.next_value::<std::option::Option<crate::model::LogEntrySourceLocation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.timestamp.is_some() {
            state.serialize_entry("timestamp", &self.timestamp)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if self.http_request.is_some() {
            state.serialize_entry("httpRequest", &self.http_request)?;
        }
        if !self.trace.is_empty() {
            state.serialize_entry("trace", &self.trace)?;
        }
        if !self.insert_id.is_empty() {
            state.serialize_entry("insertId", &self.insert_id)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if let Some(value) = self.proto_payload() {
            state.serialize_entry("protoPayload", value)?;
        }
        if let Some(value) = self.text_payload() {
            state.serialize_entry("textPayload", value)?;
        }
        if let Some(value) = self.struct_payload() {
            state.serialize_entry("structPayload", value)?;
        }
        if self.operation.is_some() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if self.source_location.is_some() {
            state.serialize_entry("sourceLocation", &self.source_location)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [LogEntry].
pub mod log_entry {
    #[allow(unused_imports)]
    use super::*;

    /// The log entry payload, which can be one of multiple types.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Payload {
        /// The log entry payload, represented as a protocol buffer that is
        /// expressed as a JSON object. The only accepted type currently is
        /// [AuditLog][google.cloud.audit.AuditLog].
        ProtoPayload(std::boxed::Box<wkt::Any>),
        /// The log entry payload, represented as a Unicode string (UTF-8).
        TextPayload(std::string::String),
        /// The log entry payload, represented as a structure that
        /// is expressed as a JSON object.
        StructPayload(std::boxed::Box<wkt::Struct>),
    }
}

/// Additional information about a potentially long-running operation with which
/// a log entry is associated.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogEntryOperation {
    /// Optional. An arbitrary operation identifier. Log entries with the
    /// same identifier are assumed to be part of the same operation.
    pub id: std::string::String,

    /// Optional. An arbitrary producer identifier. The combination of
    /// `id` and `producer` must be globally unique.  Examples for `producer`:
    /// `"MyDivision.MyBigCompany.com"`, `"github.com/MyProject/MyApplication"`.
    pub producer: std::string::String,

    /// Optional. Set this to True if this is the first log entry in the operation.
    pub first: bool,

    /// Optional. Set this to True if this is the last log entry in the operation.
    pub last: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogEntryOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::LogEntryOperation::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [producer][crate::model::LogEntryOperation::producer].
    pub fn set_producer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.producer = v.into();
        self
    }

    /// Sets the value of [first][crate::model::LogEntryOperation::first].
    pub fn set_first<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.first = v.into();
        self
    }

    /// Sets the value of [last][crate::model::LogEntryOperation::last].
    pub fn set_last<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.last = v.into();
        self
    }
}

impl wkt::message::Message for LogEntryOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.LogEntryOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogEntryOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __producer,
            __first,
            __last,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogEntryOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "producer" => Ok(__FieldTag::__producer),
                            "first" => Ok(__FieldTag::__first),
                            "last" => Ok(__FieldTag::__last),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogEntryOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogEntryOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__producer => {
                            if !fields.insert(__FieldTag::__producer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for producer",
                                ));
                            }
                            result.producer = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__first => {
                            if !fields.insert(__FieldTag::__first) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for first",
                                ));
                            }
                            result.first = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last => {
                            if !fields.insert(__FieldTag::__last) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last",
                                ));
                            }
                            result.last = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogEntryOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.producer.is_empty() {
            state.serialize_entry("producer", &self.producer)?;
        }
        if !wkt::internal::is_default(&self.first) {
            state.serialize_entry("first", &self.first)?;
        }
        if !wkt::internal::is_default(&self.last) {
            state.serialize_entry("last", &self.last)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Additional information about the source code location that produced the log
/// entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct LogEntrySourceLocation {
    /// Optional. Source file name. Depending on the runtime environment, this
    /// might be a simple name or a fully-qualified name.
    pub file: std::string::String,

    /// Optional. Line within the source file. 1-based; 0 indicates no line number
    /// available.
    pub line: i64,

    /// Optional. Human-readable name of the function or method being invoked, with
    /// optional context such as the class or package name. This information may be
    /// used in contexts such as the logs viewer, where a file and line number are
    /// less meaningful. The format can vary by language. For example:
    /// `qual.if.ied.Class.method` (Java), `dir/package.func` (Go), `function`
    /// (Python).
    pub function: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LogEntrySourceLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file][crate::model::LogEntrySourceLocation::file].
    pub fn set_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file = v.into();
        self
    }

    /// Sets the value of [line][crate::model::LogEntrySourceLocation::line].
    pub fn set_line<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.line = v.into();
        self
    }

    /// Sets the value of [function][crate::model::LogEntrySourceLocation::function].
    pub fn set_function<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.function = v.into();
        self
    }
}

impl wkt::message::Message for LogEntrySourceLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.LogEntrySourceLocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LogEntrySourceLocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file,
            __line,
            __function,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LogEntrySourceLocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "file" => Ok(__FieldTag::__file),
                            "line" => Ok(__FieldTag::__line),
                            "function" => Ok(__FieldTag::__function),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LogEntrySourceLocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LogEntrySourceLocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file => {
                            if !fields.insert(__FieldTag::__file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file",
                                ));
                            }
                            result.file = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__line => {
                            if !fields.insert(__FieldTag::__line) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for line",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.line = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__function => {
                            if !fields.insert(__FieldTag::__function) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for function",
                                ));
                            }
                            result.function = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LogEntrySourceLocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file.is_empty() {
            state.serialize_entry("file", &self.file)?;
        }
        if !wkt::internal::is_default(&self.line) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("line", &__With(&self.line))?;
        }
        if !self.function.is_empty() {
            state.serialize_entry("function", &self.function)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a single metric value.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MetricValue {
    /// The labels describing the metric value.
    /// See comments on [google.api.servicecontrol.v1.Operation.labels][google.api.servicecontrol.v1.Operation.labels] for
    /// the overriding relationship.
    /// Note that this map must not contain monitored resource labels.
    ///
    /// [google.api.servicecontrol.v1.Operation.labels]: crate::model::Operation::labels
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The start of the time period over which this metric value's measurement
    /// applies. The time period has different semantics for different metric
    /// types (cumulative, delta, and gauge). See the metric definition
    /// documentation in the service configuration for details. If not specified,
    /// [google.api.servicecontrol.v1.Operation.start_time][google.api.servicecontrol.v1.Operation.start_time] will be used.
    ///
    /// [google.api.servicecontrol.v1.Operation.start_time]: crate::model::Operation::start_time
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end of the time period over which this metric value's measurement
    /// applies.  If not specified,
    /// [google.api.servicecontrol.v1.Operation.end_time][google.api.servicecontrol.v1.Operation.end_time] will be used.
    ///
    /// [google.api.servicecontrol.v1.Operation.end_time]: crate::model::Operation::end_time
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The value. The type of value used in the request must
    /// agree with the metric definition in the service configuration, otherwise
    /// the MetricValue is rejected.
    pub value: std::option::Option<crate::model::metric_value::Value>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::MetricValue::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [start_time][crate::model::MetricValue::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::MetricValue::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::MetricValue::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::MetricValue::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value][crate::model::MetricValue::value].
    ///
    /// Note that all the setters affecting `value` are mutually
    /// exclusive.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::metric_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::MetricValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::metric_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::MetricValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::metric_value::Value::BoolValue(v.into()));
        self
    }

    /// The value of [value][crate::model::MetricValue::value]
    /// if it holds a `Int64Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn int64_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::metric_value::Value::Int64Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::MetricValue::value]
    /// to hold a `Int64Value`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::metric_value::Value::Int64Value(v.into()));
        self
    }

    /// The value of [value][crate::model::MetricValue::value]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::metric_value::Value::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::MetricValue::value]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::metric_value::Value::DoubleValue(v.into()));
        self
    }

    /// The value of [value][crate::model::MetricValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::metric_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::MetricValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::metric_value::Value::StringValue(v.into()));
        self
    }

    /// The value of [value][crate::model::MetricValue::value]
    /// if it holds a `DistributionValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn distribution_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::Distribution>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::metric_value::Value::DistributionValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::MetricValue::value]
    /// to hold a `DistributionValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_distribution_value<
        T: std::convert::Into<std::boxed::Box<crate::model::Distribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::metric_value::Value::DistributionValue(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.MetricValue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MetricValue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __labels,
            __start_time,
            __end_time,
            __bool_value,
            __int64_value,
            __double_value,
            __string_value,
            __distribution_value,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MetricValue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "labels" => Ok(__FieldTag::__labels),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "boolValue" => Ok(__FieldTag::__bool_value),
                            "bool_value" => Ok(__FieldTag::__bool_value),
                            "int64Value" => Ok(__FieldTag::__int64_value),
                            "int64_value" => Ok(__FieldTag::__int64_value),
                            "doubleValue" => Ok(__FieldTag::__double_value),
                            "double_value" => Ok(__FieldTag::__double_value),
                            "stringValue" => Ok(__FieldTag::__string_value),
                            "string_value" => Ok(__FieldTag::__string_value),
                            "distributionValue" => Ok(__FieldTag::__distribution_value),
                            "distribution_value" => Ok(__FieldTag::__distribution_value),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MetricValue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MetricValue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__bool_value => {
                            if !fields.insert(__FieldTag::__bool_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bool_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.api.servicecontrol.v1.MetricValue.bool_value, latest field was boolValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::metric_value::Value::BoolValue(
                                    map.next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__int64_value => {
                            if !fields.insert(__FieldTag::__int64_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for int64_value",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.api.servicecontrol.v1.MetricValue.int64_value, latest field was int64Value",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::metric_value::Value::Int64Value(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__double_value => {
                            if !fields.insert(__FieldTag::__double_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for double_value",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.api.servicecontrol.v1.MetricValue.double_value, latest field was doubleValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::metric_value::Value::DoubleValue(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__string_value => {
                            if !fields.insert(__FieldTag::__string_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for string_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.api.servicecontrol.v1.MetricValue.string_value, latest field was stringValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::metric_value::Value::StringValue(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__distribution_value => {
                            if !fields.insert(__FieldTag::__distribution_value) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for distribution_value",
                                ));
                            }
                            if result.value.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `value`, a oneof with full ID .google.api.servicecontrol.v1.MetricValue.distribution_value, latest field was distributionValue",
                                ));
                            }
                            result.value = std::option::Option::Some(
                                crate::model::metric_value::Value::DistributionValue(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::Distribution>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MetricValue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if let Some(value) = self.bool_value() {
            state.serialize_entry("boolValue", value)?;
        }
        if let Some(value) = self.int64_value() {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("int64Value", &__With(value))?;
        }
        if let Some(value) = self.double_value() {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("doubleValue", &__With(value))?;
        }
        if let Some(value) = self.string_value() {
            state.serialize_entry("stringValue", value)?;
        }
        if let Some(value) = self.distribution_value() {
            state.serialize_entry("distributionValue", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [MetricValue].
pub mod metric_value {
    #[allow(unused_imports)]
    use super::*;

    /// The value. The type of value used in the request must
    /// agree with the metric definition in the service configuration, otherwise
    /// the MetricValue is rejected.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Value {
        /// A boolean value.
        BoolValue(bool),
        /// A signed 64-bit integer value.
        Int64Value(i64),
        /// A double precision floating point value.
        DoubleValue(f64),
        /// A text string value.
        StringValue(std::string::String),
        /// A distribution value.
        DistributionValue(std::boxed::Box<crate::model::Distribution>),
    }
}

/// Represents a set of metric values in the same metric.
/// Each metric value in the set should have a unique combination of start time,
/// end time, and label values.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MetricValueSet {
    /// The metric name defined in the service configuration.
    pub metric_name: std::string::String,

    /// The values in this metric.
    pub metric_values: std::vec::Vec<crate::model::MetricValue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MetricValueSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_name][crate::model::MetricValueSet::metric_name].
    pub fn set_metric_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_name = v.into();
        self
    }

    /// Sets the value of [metric_values][crate::model::MetricValueSet::metric_values].
    pub fn set_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetricValue>,
    {
        use std::iter::Iterator;
        self.metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MetricValueSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.MetricValueSet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MetricValueSet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metric_name,
            __metric_values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MetricValueSet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metricName" => Ok(__FieldTag::__metric_name),
                            "metric_name" => Ok(__FieldTag::__metric_name),
                            "metricValues" => Ok(__FieldTag::__metric_values),
                            "metric_values" => Ok(__FieldTag::__metric_values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MetricValueSet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MetricValueSet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metric_name => {
                            if !fields.insert(__FieldTag::__metric_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_name",
                                ));
                            }
                            result.metric_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metric_values => {
                            if !fields.insert(__FieldTag::__metric_values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_values",
                                ));
                            }
                            result.metric_values = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MetricValue>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MetricValueSet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metric_name.is_empty() {
            state.serialize_entry("metricName", &self.metric_name)?;
        }
        if !self.metric_values.is_empty() {
            state.serialize_entry("metricValues", &self.metric_values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents information regarding an operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Operation {
    /// Identity of the operation. This must be unique within the scope of the
    /// service that generated the operation. If the service calls
    /// Check() and Report() on the same operation, the two calls should carry
    /// the same id.
    ///
    /// UUID version 4 is recommended, though not required.
    /// In scenarios where an operation is computed from existing information
    /// and an idempotent id is desirable for deduplication purpose, UUID version 5
    /// is recommended. See RFC 4122 for details.
    pub operation_id: std::string::String,

    /// Fully qualified name of the operation. Reserved for future use.
    pub operation_name: std::string::String,

    /// Identity of the consumer who is using the service.
    /// This field should be filled in for the operations initiated by a
    /// consumer, but not for service-initiated operations that are
    /// not related to a specific consumer.
    ///
    /// - This can be in one of the following formats:
    ///   - project:PROJECT_ID,
    ///   - project`_`number:PROJECT_NUMBER,
    ///   - projects/PROJECT_ID or PROJECT_NUMBER,
    ///   - folders/FOLDER_NUMBER,
    ///   - organizations/ORGANIZATION_NUMBER,
    ///   - api`_`key:API_KEY.
    pub consumer_id: std::string::String,

    /// Required. Start time of the operation.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End time of the operation.
    /// Required when the operation is used in
    /// [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
    /// but optional when the operation is used in
    /// [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
    ///
    /// [google.api.servicecontrol.v1.ServiceController.Check]: crate::client::ServiceController::check
    /// [google.api.servicecontrol.v1.ServiceController.Report]: crate::client::ServiceController::report
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Labels describing the operation. Only the following labels are allowed:
    ///
    /// - Labels describing monitored resources as defined in
    ///   the service configuration.
    /// - Default labels of metric values. When specified, labels defined in the
    ///   metric value override these default.
    /// - The following labels defined by Google Cloud Platform:
    ///   - `cloud.googleapis.com/location` describing the location where the
    ///     operation happened,
    ///   - `servicecontrol.googleapis.com/user_agent` describing the user agent
    ///     of the API request,
    ///   - `servicecontrol.googleapis.com/service_agent` describing the service
    ///     used to handle the API request (e.g. ESP),
    ///   - `servicecontrol.googleapis.com/platform` describing the platform
    ///     where the API is served, such as App Engine, Compute Engine, or
    ///     Kubernetes Engine.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Represents information about this operation. Each MetricValueSet
    /// corresponds to a metric defined in the service configuration.
    /// The data type used in the MetricValueSet must agree with
    /// the data type specified in the metric definition.
    ///
    /// Within a single operation, it is not allowed to have more than one
    /// MetricValue instances that have the same metric names and identical
    /// label value combinations. If a request has such duplicated MetricValue
    /// instances, the entire request is rejected with
    /// an invalid argument error.
    pub metric_value_sets: std::vec::Vec<crate::model::MetricValueSet>,

    /// Represents information to be logged.
    pub log_entries: std::vec::Vec<crate::model::LogEntry>,

    /// DO NOT USE. This is an experimental field.
    pub importance: crate::model::operation::Importance,

    /// Unimplemented.
    pub extensions: std::vec::Vec<wkt::Any>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::Operation::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [operation_name][crate::model::Operation::operation_name].
    pub fn set_operation_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_name = v.into();
        self
    }

    /// Sets the value of [consumer_id][crate::model::Operation::consumer_id].
    pub fn set_consumer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.consumer_id = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Operation::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Operation::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Operation::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Operation::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Operation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [metric_value_sets][crate::model::Operation::metric_value_sets].
    pub fn set_metric_value_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetricValueSet>,
    {
        use std::iter::Iterator;
        self.metric_value_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [log_entries][crate::model::Operation::log_entries].
    pub fn set_log_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogEntry>,
    {
        use std::iter::Iterator;
        self.log_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [importance][crate::model::Operation::importance].
    pub fn set_importance<T: std::convert::Into<crate::model::operation::Importance>>(
        mut self,
        v: T,
    ) -> Self {
        self.importance = v.into();
        self
    }

    /// Sets the value of [extensions][crate::model::Operation::extensions].
    pub fn set_extensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.extensions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.Operation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Operation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation_id,
            __operation_name,
            __consumer_id,
            __start_time,
            __end_time,
            __labels,
            __metric_value_sets,
            __log_entries,
            __importance,
            __extensions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Operation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operationId" => Ok(__FieldTag::__operation_id),
                            "operation_id" => Ok(__FieldTag::__operation_id),
                            "operationName" => Ok(__FieldTag::__operation_name),
                            "operation_name" => Ok(__FieldTag::__operation_name),
                            "consumerId" => Ok(__FieldTag::__consumer_id),
                            "consumer_id" => Ok(__FieldTag::__consumer_id),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "metricValueSets" => Ok(__FieldTag::__metric_value_sets),
                            "metric_value_sets" => Ok(__FieldTag::__metric_value_sets),
                            "logEntries" => Ok(__FieldTag::__log_entries),
                            "log_entries" => Ok(__FieldTag::__log_entries),
                            "importance" => Ok(__FieldTag::__importance),
                            "extensions" => Ok(__FieldTag::__extensions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Operation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Operation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation_id => {
                            if !fields.insert(__FieldTag::__operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_id",
                                ));
                            }
                            result.operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation_name => {
                            if !fields.insert(__FieldTag::__operation_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_name",
                                ));
                            }
                            result.operation_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__consumer_id => {
                            if !fields.insert(__FieldTag::__consumer_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consumer_id",
                                ));
                            }
                            result.consumer_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metric_value_sets => {
                            if !fields.insert(__FieldTag::__metric_value_sets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric_value_sets",
                                ));
                            }
                            result.metric_value_sets =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MetricValueSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__log_entries => {
                            if !fields.insert(__FieldTag::__log_entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_entries",
                                ));
                            }
                            result.log_entries = map.next_value::<std::option::Option<std::vec::Vec<crate::model::LogEntry>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__importance => {
                            if !fields.insert(__FieldTag::__importance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for importance",
                                ));
                            }
                            result.importance = map.next_value::<std::option::Option<crate::model::operation::Importance>>()?.unwrap_or_default();
                        }
                        __FieldTag::__extensions => {
                            if !fields.insert(__FieldTag::__extensions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for extensions",
                                ));
                            }
                            result.extensions = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Any>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Operation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation_id.is_empty() {
            state.serialize_entry("operationId", &self.operation_id)?;
        }
        if !self.operation_name.is_empty() {
            state.serialize_entry("operationName", &self.operation_name)?;
        }
        if !self.consumer_id.is_empty() {
            state.serialize_entry("consumerId", &self.consumer_id)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.metric_value_sets.is_empty() {
            state.serialize_entry("metricValueSets", &self.metric_value_sets)?;
        }
        if !self.log_entries.is_empty() {
            state.serialize_entry("logEntries", &self.log_entries)?;
        }
        if !wkt::internal::is_default(&self.importance) {
            state.serialize_entry("importance", &self.importance)?;
        }
        if !self.extensions.is_empty() {
            state.serialize_entry("extensions", &self.extensions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Operation].
pub mod operation {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the importance of the data contained in the operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Importance {
        /// Allows data caching, batching, and aggregation. It provides
        /// higher performance with higher data loss risk.
        Low,
        /// Disables data aggregation to minimize data loss. It is for operations
        /// that contains significant monetary value or audit trail. This feature
        /// only applies to the client libraries.
        High,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Importance::value] or
        /// [Importance::name].
        UnknownValue(importance::UnknownValue),
    }

    #[doc(hidden)]
    pub mod importance {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Importance {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Low => std::option::Option::Some(0),
                Self::High => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Low => std::option::Option::Some("LOW"),
                Self::High => std::option::Option::Some("HIGH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Importance {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Importance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Importance {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Low,
                1 => Self::High,
                _ => Self::UnknownValue(importance::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Importance {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LOW" => Self::Low,
                "HIGH" => Self::High,
                _ => Self::UnknownValue(importance::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Importance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Low => serializer.serialize_i32(0),
                Self::High => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Importance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Importance>::new(
                ".google.api.servicecontrol.v1.Operation.Importance",
            ))
        }
    }
}

/// Request message for the AllocateQuota method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AllocateQuotaRequest {
    /// Name of the service as specified in the service configuration. For example,
    /// `"pubsub.googleapis.com"`.
    ///
    /// See [google.api.Service][google.api.Service] for the definition of a service name.
    pub service_name: std::string::String,

    /// Operation that describes the quota allocation.
    pub allocate_operation: std::option::Option<crate::model::QuotaOperation>,

    /// Specifies which version of service configuration should be used to process
    /// the request. If unspecified or no matching version can be found, the latest
    /// one will be used.
    pub service_config_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllocateQuotaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::AllocateQuotaRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [allocate_operation][crate::model::AllocateQuotaRequest::allocate_operation].
    pub fn set_allocate_operation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::QuotaOperation>,
    {
        self.allocate_operation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [allocate_operation][crate::model::AllocateQuotaRequest::allocate_operation].
    pub fn set_or_clear_allocate_operation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::QuotaOperation>,
    {
        self.allocate_operation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_config_id][crate::model::AllocateQuotaRequest::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }
}

impl wkt::message::Message for AllocateQuotaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.AllocateQuotaRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AllocateQuotaRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __allocate_operation,
            __service_config_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllocateQuotaRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "allocateOperation" => Ok(__FieldTag::__allocate_operation),
                            "allocate_operation" => Ok(__FieldTag::__allocate_operation),
                            "serviceConfigId" => Ok(__FieldTag::__service_config_id),
                            "service_config_id" => Ok(__FieldTag::__service_config_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AllocateQuotaRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllocateQuotaRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allocate_operation => {
                            if !fields.insert(__FieldTag::__allocate_operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allocate_operation",
                                ));
                            }
                            result.allocate_operation = map
                                .next_value::<std::option::Option<crate::model::QuotaOperation>>(
                                )?;
                        }
                        __FieldTag::__service_config_id => {
                            if !fields.insert(__FieldTag::__service_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_config_id",
                                ));
                            }
                            result.service_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AllocateQuotaRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if self.allocate_operation.is_some() {
            state.serialize_entry("allocateOperation", &self.allocate_operation)?;
        }
        if !self.service_config_id.is_empty() {
            state.serialize_entry("serviceConfigId", &self.service_config_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents information regarding a quota operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QuotaOperation {
    /// Identity of the operation. This is expected to be unique within the scope
    /// of the service that generated the operation, and guarantees idempotency in
    /// case of retries.
    ///
    /// In order to ensure best performance and latency in the Quota backends,
    /// operation_ids are optimally associated with time, so that related
    /// operations can be accessed fast in storage. For this reason, the
    /// recommended token for services that intend to operate at a high QPS is
    /// Unix time in nanos + UUID
    pub operation_id: std::string::String,

    /// Fully qualified name of the API method for which this quota operation is
    /// requested. This name is used for matching quota rules or metric rules and
    /// billing status rules defined in service configuration.
    ///
    /// This field should not be set if any of the following is true:
    /// (1) the quota operation is performed on non-API resources.
    /// (2) quota_metrics is set because the caller is doing quota override.
    ///
    /// Example of an RPC method name:
    /// google.example.library.v1.LibraryService.CreateShelf
    pub method_name: std::string::String,

    /// Identity of the consumer for whom this quota operation is being performed.
    ///
    /// This can be in one of the following formats:
    /// project:<project_id>,
    /// project_number:<project_number>,
    /// api_key:<api_key>.
    pub consumer_id: std::string::String,

    /// Labels describing the operation.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Represents information about this operation. Each MetricValueSet
    /// corresponds to a metric defined in the service configuration.
    /// The data type used in the MetricValueSet must agree with
    /// the data type specified in the metric definition.
    ///
    /// Within a single operation, it is not allowed to have more than one
    /// MetricValue instances that have the same metric names and identical
    /// label value combinations. If a request has such duplicated MetricValue
    /// instances, the entire request is rejected with
    /// an invalid argument error.
    ///
    /// This field is mutually exclusive with method_name.
    pub quota_metrics: std::vec::Vec<crate::model::MetricValueSet>,

    /// Quota mode for this operation.
    pub quota_mode: crate::model::quota_operation::QuotaMode,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::QuotaOperation::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [method_name][crate::model::QuotaOperation::method_name].
    pub fn set_method_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method_name = v.into();
        self
    }

    /// Sets the value of [consumer_id][crate::model::QuotaOperation::consumer_id].
    pub fn set_consumer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.consumer_id = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::QuotaOperation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [quota_metrics][crate::model::QuotaOperation::quota_metrics].
    pub fn set_quota_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetricValueSet>,
    {
        use std::iter::Iterator;
        self.quota_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [quota_mode][crate::model::QuotaOperation::quota_mode].
    pub fn set_quota_mode<T: std::convert::Into<crate::model::quota_operation::QuotaMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.quota_mode = v.into();
        self
    }
}

impl wkt::message::Message for QuotaOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.QuotaOperation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QuotaOperation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation_id,
            __method_name,
            __consumer_id,
            __labels,
            __quota_metrics,
            __quota_mode,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QuotaOperation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operationId" => Ok(__FieldTag::__operation_id),
                            "operation_id" => Ok(__FieldTag::__operation_id),
                            "methodName" => Ok(__FieldTag::__method_name),
                            "method_name" => Ok(__FieldTag::__method_name),
                            "consumerId" => Ok(__FieldTag::__consumer_id),
                            "consumer_id" => Ok(__FieldTag::__consumer_id),
                            "labels" => Ok(__FieldTag::__labels),
                            "quotaMetrics" => Ok(__FieldTag::__quota_metrics),
                            "quota_metrics" => Ok(__FieldTag::__quota_metrics),
                            "quotaMode" => Ok(__FieldTag::__quota_mode),
                            "quota_mode" => Ok(__FieldTag::__quota_mode),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QuotaOperation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QuotaOperation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation_id => {
                            if !fields.insert(__FieldTag::__operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_id",
                                ));
                            }
                            result.operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__method_name => {
                            if !fields.insert(__FieldTag::__method_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for method_name",
                                ));
                            }
                            result.method_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__consumer_id => {
                            if !fields.insert(__FieldTag::__consumer_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consumer_id",
                                ));
                            }
                            result.consumer_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quota_metrics => {
                            if !fields.insert(__FieldTag::__quota_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_metrics",
                                ));
                            }
                            result.quota_metrics =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MetricValueSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__quota_mode => {
                            if !fields.insert(__FieldTag::__quota_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_mode",
                                ));
                            }
                            result.quota_mode = map.next_value::<std::option::Option<crate::model::quota_operation::QuotaMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QuotaOperation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation_id.is_empty() {
            state.serialize_entry("operationId", &self.operation_id)?;
        }
        if !self.method_name.is_empty() {
            state.serialize_entry("methodName", &self.method_name)?;
        }
        if !self.consumer_id.is_empty() {
            state.serialize_entry("consumerId", &self.consumer_id)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.quota_metrics.is_empty() {
            state.serialize_entry("quotaMetrics", &self.quota_metrics)?;
        }
        if !wkt::internal::is_default(&self.quota_mode) {
            state.serialize_entry("quotaMode", &self.quota_mode)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [QuotaOperation].
pub mod quota_operation {
    #[allow(unused_imports)]
    use super::*;

    /// Supported quota modes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum QuotaMode {
        /// Guard against implicit default. Must not be used.
        Unspecified,
        /// For AllocateQuota request, allocates quota for the amount specified in
        /// the service configuration or specified using the quota metrics. If the
        /// amount is higher than the available quota, allocation error will be
        /// returned and no quota will be allocated.
        /// If multiple quotas are part of the request, and one fails, none of the
        /// quotas are allocated or released.
        Normal,
        /// The operation allocates quota for the amount specified in the service
        /// configuration or specified using the quota metrics. If the amount is
        /// higher than the available quota, request does not fail but all available
        /// quota will be allocated.
        /// For rate quota, BEST_EFFORT will continue to deduct from other groups
        /// even if one does not have enough quota. For allocation, it will find the
        /// minimum available amount across all groups and deduct that amount from
        /// all the affected groups.
        BestEffort,
        /// For AllocateQuota request, only checks if there is enough quota
        /// available and does not change the available quota. No lock is placed on
        /// the available quota either.
        CheckOnly,
        /// Unimplemented. When used in AllocateQuotaRequest, this returns the
        /// effective quota limit(s) in the response, and no quota check will be
        /// performed. Not supported for other requests, and even for
        /// AllocateQuotaRequest, this is currently supported only for allowlisted
        /// services.
        QueryOnly,
        /// The operation allocates quota for the amount specified in the service
        /// configuration or specified using the quota metrics. If the requested
        /// amount is higher than the available quota, request does not fail and
        /// remaining quota would become negative (going over the limit).
        /// Not supported for Rate Quota.
        AdjustOnly,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [QuotaMode::value] or
        /// [QuotaMode::name].
        UnknownValue(quota_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod quota_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl QuotaMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Normal => std::option::Option::Some(1),
                Self::BestEffort => std::option::Option::Some(2),
                Self::CheckOnly => std::option::Option::Some(3),
                Self::QueryOnly => std::option::Option::Some(4),
                Self::AdjustOnly => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::Normal => std::option::Option::Some("NORMAL"),
                Self::BestEffort => std::option::Option::Some("BEST_EFFORT"),
                Self::CheckOnly => std::option::Option::Some("CHECK_ONLY"),
                Self::QueryOnly => std::option::Option::Some("QUERY_ONLY"),
                Self::AdjustOnly => std::option::Option::Some("ADJUST_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for QuotaMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for QuotaMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for QuotaMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Normal,
                2 => Self::BestEffort,
                3 => Self::CheckOnly,
                4 => Self::QueryOnly,
                5 => Self::AdjustOnly,
                _ => Self::UnknownValue(quota_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for QuotaMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "NORMAL" => Self::Normal,
                "BEST_EFFORT" => Self::BestEffort,
                "CHECK_ONLY" => Self::CheckOnly,
                "QUERY_ONLY" => Self::QueryOnly,
                "ADJUST_ONLY" => Self::AdjustOnly,
                _ => Self::UnknownValue(quota_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for QuotaMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Normal => serializer.serialize_i32(1),
                Self::BestEffort => serializer.serialize_i32(2),
                Self::CheckOnly => serializer.serialize_i32(3),
                Self::QueryOnly => serializer.serialize_i32(4),
                Self::AdjustOnly => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for QuotaMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<QuotaMode>::new(
                ".google.api.servicecontrol.v1.QuotaOperation.QuotaMode",
            ))
        }
    }
}

/// Response message for the AllocateQuota method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AllocateQuotaResponse {
    /// The same operation_id value used in the AllocateQuotaRequest. Used for
    /// logging and diagnostics purposes.
    pub operation_id: std::string::String,

    /// Indicates the decision of the allocate.
    pub allocate_errors: std::vec::Vec<crate::model::QuotaError>,

    /// Quota metrics to indicate the result of allocation. Depending on the
    /// request, one or more of the following metrics will be included:
    ///
    /// 1. Per quota group or per quota metric incremental usage will be specified
    ///    using the following delta metric :
    ///    "serviceruntime.googleapis.com/api/consumer/quota_used_count"
    ///
    /// 1. The quota limit reached condition will be specified using the following
    ///    boolean metric :
    ///    "serviceruntime.googleapis.com/quota/exceeded"
    ///
    pub quota_metrics: std::vec::Vec<crate::model::MetricValueSet>,

    /// ID of the actual config used to process the request.
    pub service_config_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AllocateQuotaResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::AllocateQuotaResponse::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [allocate_errors][crate::model::AllocateQuotaResponse::allocate_errors].
    pub fn set_allocate_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaError>,
    {
        use std::iter::Iterator;
        self.allocate_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [quota_metrics][crate::model::AllocateQuotaResponse::quota_metrics].
    pub fn set_quota_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetricValueSet>,
    {
        use std::iter::Iterator;
        self.quota_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_config_id][crate::model::AllocateQuotaResponse::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }
}

impl wkt::message::Message for AllocateQuotaResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.AllocateQuotaResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AllocateQuotaResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation_id,
            __allocate_errors,
            __quota_metrics,
            __service_config_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AllocateQuotaResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operationId" => Ok(__FieldTag::__operation_id),
                            "operation_id" => Ok(__FieldTag::__operation_id),
                            "allocateErrors" => Ok(__FieldTag::__allocate_errors),
                            "allocate_errors" => Ok(__FieldTag::__allocate_errors),
                            "quotaMetrics" => Ok(__FieldTag::__quota_metrics),
                            "quota_metrics" => Ok(__FieldTag::__quota_metrics),
                            "serviceConfigId" => Ok(__FieldTag::__service_config_id),
                            "service_config_id" => Ok(__FieldTag::__service_config_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AllocateQuotaResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AllocateQuotaResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation_id => {
                            if !fields.insert(__FieldTag::__operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_id",
                                ));
                            }
                            result.operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allocate_errors => {
                            if !fields.insert(__FieldTag::__allocate_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allocate_errors",
                                ));
                            }
                            result.allocate_errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::QuotaError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__quota_metrics => {
                            if !fields.insert(__FieldTag::__quota_metrics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota_metrics",
                                ));
                            }
                            result.quota_metrics =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MetricValueSet>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_config_id => {
                            if !fields.insert(__FieldTag::__service_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_config_id",
                                ));
                            }
                            result.service_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AllocateQuotaResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation_id.is_empty() {
            state.serialize_entry("operationId", &self.operation_id)?;
        }
        if !self.allocate_errors.is_empty() {
            state.serialize_entry("allocateErrors", &self.allocate_errors)?;
        }
        if !self.quota_metrics.is_empty() {
            state.serialize_entry("quotaMetrics", &self.quota_metrics)?;
        }
        if !self.service_config_id.is_empty() {
            state.serialize_entry("serviceConfigId", &self.service_config_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents error information for [QuotaOperation][google.api.servicecontrol.v1.QuotaOperation].
///
/// [google.api.servicecontrol.v1.QuotaOperation]: crate::model::QuotaOperation
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QuotaError {
    /// Error code.
    pub code: crate::model::quota_error::Code,

    /// Subject to whom this error applies. See the specific enum for more details
    /// on this field. For example, "clientip:\<ip address of client\>" or
    /// "project:\<Google developer project id\>".
    pub subject: std::string::String,

    /// Free-form text that provides details on the cause of the error.
    pub description: std::string::String,

    /// Contains additional information about the quota error.
    /// If available, `status.code` will be non zero.
    pub status: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QuotaError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::QuotaError::code].
    pub fn set_code<T: std::convert::Into<crate::model::quota_error::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::QuotaError::subject].
    pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject = v.into();
        self
    }

    /// Sets the value of [description][crate::model::QuotaError::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [status][crate::model::QuotaError::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::QuotaError::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for QuotaError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.QuotaError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QuotaError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __subject,
            __description,
            __status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QuotaError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "subject" => Ok(__FieldTag::__subject),
                            "description" => Ok(__FieldTag::__description),
                            "status" => Ok(__FieldTag::__status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QuotaError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QuotaError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map
                                .next_value::<std::option::Option<crate::model::quota_error::Code>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subject => {
                            if !fields.insert(__FieldTag::__subject) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subject",
                                ));
                            }
                            result.subject = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QuotaError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.subject.is_empty() {
            state.serialize_entry("subject", &self.subject)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [QuotaError].
pub mod quota_error {
    #[allow(unused_imports)]
    use super::*;

    /// Error codes related to project config validations are deprecated since the
    /// quota controller methods do not perform these validations. Instead services
    /// have to call the Check method, without quota_properties field, to perform
    /// these validations before calling the quota controller methods. These
    /// methods check only for project deletion to be wipe out compliant.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Code {
        /// This is never used.
        Unspecified,
        /// Quota allocation failed.
        /// Same as [google.rpc.Code.RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED].
        ResourceExhausted,
        /// Consumer cannot access the service because the service requires active
        /// billing.
        BillingNotActive,
        /// Consumer's project has been marked as deleted (soft deletion).
        ProjectDeleted,
        /// Specified API key is invalid.
        ApiKeyInvalid,
        /// Specified API Key has expired.
        ApiKeyExpired,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Code::value] or
        /// [Code::name].
        UnknownValue(code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Code {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ResourceExhausted => std::option::Option::Some(8),
                Self::BillingNotActive => std::option::Option::Some(107),
                Self::ProjectDeleted => std::option::Option::Some(108),
                Self::ApiKeyInvalid => std::option::Option::Some(105),
                Self::ApiKeyExpired => std::option::Option::Some(112),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::ResourceExhausted => std::option::Option::Some("RESOURCE_EXHAUSTED"),
                Self::BillingNotActive => std::option::Option::Some("BILLING_NOT_ACTIVE"),
                Self::ProjectDeleted => std::option::Option::Some("PROJECT_DELETED"),
                Self::ApiKeyInvalid => std::option::Option::Some("API_KEY_INVALID"),
                Self::ApiKeyExpired => std::option::Option::Some("API_KEY_EXPIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Code {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                8 => Self::ResourceExhausted,
                105 => Self::ApiKeyInvalid,
                107 => Self::BillingNotActive,
                108 => Self::ProjectDeleted,
                112 => Self::ApiKeyExpired,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Code {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "UNSPECIFIED" => Self::Unspecified,
                "RESOURCE_EXHAUSTED" => Self::ResourceExhausted,
                "BILLING_NOT_ACTIVE" => Self::BillingNotActive,
                "PROJECT_DELETED" => Self::ProjectDeleted,
                "API_KEY_INVALID" => Self::ApiKeyInvalid,
                "API_KEY_EXPIRED" => Self::ApiKeyExpired,
                _ => Self::UnknownValue(code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Code {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ResourceExhausted => serializer.serialize_i32(8),
                Self::BillingNotActive => serializer.serialize_i32(107),
                Self::ProjectDeleted => serializer.serialize_i32(108),
                Self::ApiKeyInvalid => serializer.serialize_i32(105),
                Self::ApiKeyExpired => serializer.serialize_i32(112),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Code {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                ".google.api.servicecontrol.v1.QuotaError.Code",
            ))
        }
    }
}

/// Request message for the Check method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckRequest {
    /// The service name as specified in its service configuration. For example,
    /// `"pubsub.googleapis.com"`.
    ///
    /// See
    /// [google.api.Service](https://cloud.google.com/service-management/reference/rpc/google.api#google.api.Service)
    /// for the definition of a service name.
    pub service_name: std::string::String,

    /// The operation to be checked.
    pub operation: std::option::Option<crate::model::Operation>,

    /// Specifies which version of service configuration should be used to process
    /// the request.
    ///
    /// If unspecified or no matching version can be found, the
    /// latest one will be used.
    pub service_config_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::CheckRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::CheckRequest::operation].
    pub fn set_operation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Operation>,
    {
        self.operation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operation][crate::model::CheckRequest::operation].
    pub fn set_or_clear_operation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Operation>,
    {
        self.operation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_config_id][crate::model::CheckRequest::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }
}

impl wkt::message::Message for CheckRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.CheckRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __operation,
            __service_config_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "operation" => Ok(__FieldTag::__operation),
                            "serviceConfigId" => Ok(__FieldTag::__service_config_id),
                            "service_config_id" => Ok(__FieldTag::__service_config_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operation => {
                            if !fields.insert(__FieldTag::__operation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation",
                                ));
                            }
                            result.operation =
                                map.next_value::<std::option::Option<crate::model::Operation>>()?;
                        }
                        __FieldTag::__service_config_id => {
                            if !fields.insert(__FieldTag::__service_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_config_id",
                                ));
                            }
                            result.service_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if self.operation.is_some() {
            state.serialize_entry("operation", &self.operation)?;
        }
        if !self.service_config_id.is_empty() {
            state.serialize_entry("serviceConfigId", &self.service_config_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the Check method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckResponse {
    /// The same operation_id value used in the
    /// [CheckRequest][google.api.servicecontrol.v1.CheckRequest]. Used for logging
    /// and diagnostics purposes.
    ///
    /// [google.api.servicecontrol.v1.CheckRequest]: crate::model::CheckRequest
    pub operation_id: std::string::String,

    /// Indicate the decision of the check.
    ///
    /// If no check errors are present, the service should process the operation.
    /// Otherwise the service should use the list of errors to determine the
    /// appropriate action.
    pub check_errors: std::vec::Vec<crate::model::CheckError>,

    /// The actual config id used to process the request.
    pub service_config_id: std::string::String,

    /// The current service rollout id used to process the request.
    pub service_rollout_id: std::string::String,

    /// Feedback data returned from the server during processing a Check request.
    pub check_info: std::option::Option<crate::model::check_response::CheckInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::CheckResponse::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [check_errors][crate::model::CheckResponse::check_errors].
    pub fn set_check_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CheckError>,
    {
        use std::iter::Iterator;
        self.check_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_config_id][crate::model::CheckResponse::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }

    /// Sets the value of [service_rollout_id][crate::model::CheckResponse::service_rollout_id].
    pub fn set_service_rollout_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_rollout_id = v.into();
        self
    }

    /// Sets the value of [check_info][crate::model::CheckResponse::check_info].
    pub fn set_check_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::check_response::CheckInfo>,
    {
        self.check_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [check_info][crate::model::CheckResponse::check_info].
    pub fn set_or_clear_check_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::check_response::CheckInfo>,
    {
        self.check_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CheckResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.CheckResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __operation_id,
            __check_errors,
            __service_config_id,
            __service_rollout_id,
            __check_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "operationId" => Ok(__FieldTag::__operation_id),
                            "operation_id" => Ok(__FieldTag::__operation_id),
                            "checkErrors" => Ok(__FieldTag::__check_errors),
                            "check_errors" => Ok(__FieldTag::__check_errors),
                            "serviceConfigId" => Ok(__FieldTag::__service_config_id),
                            "service_config_id" => Ok(__FieldTag::__service_config_id),
                            "serviceRolloutId" => Ok(__FieldTag::__service_rollout_id),
                            "service_rollout_id" => Ok(__FieldTag::__service_rollout_id),
                            "checkInfo" => Ok(__FieldTag::__check_info),
                            "check_info" => Ok(__FieldTag::__check_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__operation_id => {
                            if !fields.insert(__FieldTag::__operation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operation_id",
                                ));
                            }
                            result.operation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__check_errors => {
                            if !fields.insert(__FieldTag::__check_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for check_errors",
                                ));
                            }
                            result.check_errors = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CheckError>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_config_id => {
                            if !fields.insert(__FieldTag::__service_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_config_id",
                                ));
                            }
                            result.service_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_rollout_id => {
                            if !fields.insert(__FieldTag::__service_rollout_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_rollout_id",
                                ));
                            }
                            result.service_rollout_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__check_info => {
                            if !fields.insert(__FieldTag::__check_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for check_info",
                                ));
                            }
                            result.check_info = map.next_value::<std::option::Option<crate::model::check_response::CheckInfo>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.operation_id.is_empty() {
            state.serialize_entry("operationId", &self.operation_id)?;
        }
        if !self.check_errors.is_empty() {
            state.serialize_entry("checkErrors", &self.check_errors)?;
        }
        if !self.service_config_id.is_empty() {
            state.serialize_entry("serviceConfigId", &self.service_config_id)?;
        }
        if !self.service_rollout_id.is_empty() {
            state.serialize_entry("serviceRolloutId", &self.service_rollout_id)?;
        }
        if self.check_info.is_some() {
            state.serialize_entry("checkInfo", &self.check_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CheckResponse].
pub mod check_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains additional information about the check operation.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CheckInfo {
        /// A list of fields and label keys that are ignored by the server.
        /// The client doesn't need to send them for following requests to improve
        /// performance and allow better aggregation.
        pub unused_arguments: std::vec::Vec<std::string::String>,

        /// Consumer info of this check.
        pub consumer_info: std::option::Option<crate::model::check_response::ConsumerInfo>,

        /// The unique id of the api key in the format of "apikey:\<UID\>".
        /// This field will be populated when the consumer passed to Service Control
        /// is an API key and all the API key related validations are successful.
        pub api_key_uid: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CheckInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [unused_arguments][crate::model::check_response::CheckInfo::unused_arguments].
        pub fn set_unused_arguments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.unused_arguments = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [consumer_info][crate::model::check_response::CheckInfo::consumer_info].
        pub fn set_consumer_info<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::check_response::ConsumerInfo>,
        {
            self.consumer_info = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [consumer_info][crate::model::check_response::CheckInfo::consumer_info].
        pub fn set_or_clear_consumer_info<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::check_response::ConsumerInfo>,
        {
            self.consumer_info = v.map(|x| x.into());
            self
        }

        /// Sets the value of [api_key_uid][crate::model::check_response::CheckInfo::api_key_uid].
        pub fn set_api_key_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.api_key_uid = v.into();
            self
        }
    }

    impl wkt::message::Message for CheckInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.CheckResponse.CheckInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CheckInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __unused_arguments,
                __consumer_info,
                __api_key_uid,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CheckInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "unusedArguments" => Ok(__FieldTag::__unused_arguments),
                                "unused_arguments" => Ok(__FieldTag::__unused_arguments),
                                "consumerInfo" => Ok(__FieldTag::__consumer_info),
                                "consumer_info" => Ok(__FieldTag::__consumer_info),
                                "apiKeyUid" => Ok(__FieldTag::__api_key_uid),
                                "api_key_uid" => Ok(__FieldTag::__api_key_uid),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CheckInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CheckInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__unused_arguments => {
                                if !fields.insert(__FieldTag::__unused_arguments) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for unused_arguments",
                                    ));
                                }
                                result.unused_arguments = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__consumer_info => {
                                if !fields.insert(__FieldTag::__consumer_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for consumer_info",
                                    ));
                                }
                                result.consumer_info = map.next_value::<std::option::Option<
                                    crate::model::check_response::ConsumerInfo,
                                >>()?;
                            }
                            __FieldTag::__api_key_uid => {
                                if !fields.insert(__FieldTag::__api_key_uid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for api_key_uid",
                                    ));
                                }
                                result.api_key_uid = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CheckInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.unused_arguments.is_empty() {
                state.serialize_entry("unusedArguments", &self.unused_arguments)?;
            }
            if self.consumer_info.is_some() {
                state.serialize_entry("consumerInfo", &self.consumer_info)?;
            }
            if !self.api_key_uid.is_empty() {
                state.serialize_entry("apiKeyUid", &self.api_key_uid)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// `ConsumerInfo` provides information about the consumer.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConsumerInfo {
        /// The Google cloud project number, e.g. 1234567890. A value of 0 indicates
        /// no project number is found.
        ///
        /// NOTE: This field is deprecated after we support flexible consumer
        /// id. New code should not depend on this field anymore.
        pub project_number: i64,

        /// The type of the consumer which should have been defined in
        /// [Google Resource Manager](https://cloud.google.com/resource-manager/).
        pub r#type: crate::model::check_response::consumer_info::ConsumerType,

        /// The consumer identity number, can be Google cloud project number, folder
        /// number or organization number e.g. 1234567890. A value of 0 indicates no
        /// consumer number is found.
        pub consumer_number: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConsumerInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_number][crate::model::check_response::ConsumerInfo::project_number].
        pub fn set_project_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.project_number = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::check_response::ConsumerInfo::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::check_response::consumer_info::ConsumerType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [consumer_number][crate::model::check_response::ConsumerInfo::consumer_number].
        pub fn set_consumer_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.consumer_number = v.into();
            self
        }
    }

    impl wkt::message::Message for ConsumerInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.CheckResponse.ConsumerInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConsumerInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __project_number,
                __type,
                __consumer_number,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConsumerInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "projectNumber" => Ok(__FieldTag::__project_number),
                                "project_number" => Ok(__FieldTag::__project_number),
                                "type" => Ok(__FieldTag::__type),
                                "consumerNumber" => Ok(__FieldTag::__consumer_number),
                                "consumer_number" => Ok(__FieldTag::__consumer_number),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConsumerInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConsumerInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__project_number => {
                                if !fields.insert(__FieldTag::__project_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project_number",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.project_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::check_response::consumer_info::ConsumerType,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__consumer_number => {
                                if !fields.insert(__FieldTag::__consumer_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for consumer_number",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.consumer_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConsumerInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.project_number) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("projectNumber", &__With(&self.project_number))?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !wkt::internal::is_default(&self.consumer_number) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("consumerNumber", &__With(&self.consumer_number))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ConsumerInfo].
    pub mod consumer_info {
        #[allow(unused_imports)]
        use super::*;

        /// The type of the consumer as defined in
        /// [Google Resource Manager](https://cloud.google.com/resource-manager/).
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ConsumerType {
            /// This is never used.
            Unspecified,
            /// The consumer is a Google Cloud Project.
            Project,
            /// The consumer is a Google Cloud Folder.
            Folder,
            /// The consumer is a Google Cloud Organization.
            Organization,
            /// Service-specific resource container which is defined by the service
            /// producer to offer their users the ability to manage service control
            /// functionalities at a finer level of granularity than the PROJECT.
            ServiceSpecific,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ConsumerType::value] or
            /// [ConsumerType::name].
            UnknownValue(consumer_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod consumer_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl ConsumerType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Project => std::option::Option::Some(1),
                    Self::Folder => std::option::Option::Some(2),
                    Self::Organization => std::option::Option::Some(3),
                    Self::ServiceSpecific => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("CONSUMER_TYPE_UNSPECIFIED"),
                    Self::Project => std::option::Option::Some("PROJECT"),
                    Self::Folder => std::option::Option::Some("FOLDER"),
                    Self::Organization => std::option::Option::Some("ORGANIZATION"),
                    Self::ServiceSpecific => std::option::Option::Some("SERVICE_SPECIFIC"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for ConsumerType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for ConsumerType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for ConsumerType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Project,
                    2 => Self::Folder,
                    3 => Self::Organization,
                    4 => Self::ServiceSpecific,
                    _ => Self::UnknownValue(consumer_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for ConsumerType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CONSUMER_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "PROJECT" => Self::Project,
                    "FOLDER" => Self::Folder,
                    "ORGANIZATION" => Self::Organization,
                    "SERVICE_SPECIFIC" => Self::ServiceSpecific,
                    _ => Self::UnknownValue(consumer_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for ConsumerType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Project => serializer.serialize_i32(1),
                    Self::Folder => serializer.serialize_i32(2),
                    Self::Organization => serializer.serialize_i32(3),
                    Self::ServiceSpecific => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for ConsumerType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConsumerType>::new(
                    ".google.api.servicecontrol.v1.CheckResponse.ConsumerInfo.ConsumerType",
                ))
            }
        }
    }
}

/// Request message for the Report method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReportRequest {
    /// The service name as specified in its service configuration. For example,
    /// `"pubsub.googleapis.com"`.
    ///
    /// See
    /// [google.api.Service](https://cloud.google.com/service-management/reference/rpc/google.api#google.api.Service)
    /// for the definition of a service name.
    pub service_name: std::string::String,

    /// Operations to be reported.
    ///
    /// Typically the service should report one operation per request.
    /// Putting multiple operations into a single request is allowed, but should
    /// be used only when multiple operations are natually available at the time
    /// of the report.
    ///
    /// There is no limit on the number of operations in the same ReportRequest,
    /// however the ReportRequest size should be no larger than 1MB. See
    /// [ReportResponse.report_errors][google.api.servicecontrol.v1.ReportResponse.report_errors]
    /// for partial failure behavior.
    ///
    /// [google.api.servicecontrol.v1.ReportResponse.report_errors]: crate::model::ReportResponse::report_errors
    pub operations: std::vec::Vec<crate::model::Operation>,

    /// Specifies which version of service config should be used to process the
    /// request.
    ///
    /// If unspecified or no matching version can be found, the
    /// latest one will be used.
    pub service_config_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::ReportRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [operations][crate::model::ReportRequest::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_config_id][crate::model::ReportRequest::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }
}

impl wkt::message::Message for ReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.ReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __operations,
            __service_config_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "operations" => Ok(__FieldTag::__operations),
                            "serviceConfigId" => Ok(__FieldTag::__service_config_id),
                            "service_config_id" => Ok(__FieldTag::__service_config_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operations => {
                            if !fields.insert(__FieldTag::__operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations",
                                ));
                            }
                            result.operations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Operation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service_config_id => {
                            if !fields.insert(__FieldTag::__service_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_config_id",
                                ));
                            }
                            result.service_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self.operations.is_empty() {
            state.serialize_entry("operations", &self.operations)?;
        }
        if !self.service_config_id.is_empty() {
            state.serialize_entry("serviceConfigId", &self.service_config_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for the Report method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReportResponse {
    /// Partial failures, one for each `Operation` in the request that failed
    /// processing. There are three possible combinations of the RPC status:
    ///
    /// 1. The combination of a successful RPC status and an empty `report_errors`
    ///    list indicates a complete success where all `Operations` in the
    ///    request are processed successfully.
    /// 1. The combination of a successful RPC status and a non-empty
    ///    `report_errors` list indicates a partial success where some
    ///    `Operations` in the request succeeded. Each
    ///    `Operation` that failed processing has a corresponding item
    ///    in this list.
    /// 1. A failed RPC status indicates a general non-deterministic failure.
    ///    When this happens, it's impossible to know which of the
    ///    'Operations' in the request succeeded or failed.
    pub report_errors: std::vec::Vec<crate::model::report_response::ReportError>,

    /// The actual config id used to process the request.
    pub service_config_id: std::string::String,

    /// The current service rollout id used to process the request.
    pub service_rollout_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [report_errors][crate::model::ReportResponse::report_errors].
    pub fn set_report_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::report_response::ReportError>,
    {
        use std::iter::Iterator;
        self.report_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_config_id][crate::model::ReportResponse::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }

    /// Sets the value of [service_rollout_id][crate::model::ReportResponse::service_rollout_id].
    pub fn set_service_rollout_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_rollout_id = v.into();
        self
    }
}

impl wkt::message::Message for ReportResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.ReportResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReportResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __report_errors,
            __service_config_id,
            __service_rollout_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReportResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reportErrors" => Ok(__FieldTag::__report_errors),
                            "report_errors" => Ok(__FieldTag::__report_errors),
                            "serviceConfigId" => Ok(__FieldTag::__service_config_id),
                            "service_config_id" => Ok(__FieldTag::__service_config_id),
                            "serviceRolloutId" => Ok(__FieldTag::__service_rollout_id),
                            "service_rollout_id" => Ok(__FieldTag::__service_rollout_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReportResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReportResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__report_errors => {
                            if !fields.insert(__FieldTag::__report_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_errors",
                                ));
                            }
                            result.report_errors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::report_response::ReportError>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_config_id => {
                            if !fields.insert(__FieldTag::__service_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_config_id",
                                ));
                            }
                            result.service_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_rollout_id => {
                            if !fields.insert(__FieldTag::__service_rollout_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_rollout_id",
                                ));
                            }
                            result.service_rollout_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReportResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.report_errors.is_empty() {
            state.serialize_entry("reportErrors", &self.report_errors)?;
        }
        if !self.service_config_id.is_empty() {
            state.serialize_entry("serviceConfigId", &self.service_config_id)?;
        }
        if !self.service_rollout_id.is_empty() {
            state.serialize_entry("serviceRolloutId", &self.service_rollout_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ReportResponse].
pub mod report_response {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the processing error of one
    /// [Operation][google.api.servicecontrol.v1.Operation] in the request.
    ///
    /// [google.api.servicecontrol.v1.Operation]: crate::model::Operation
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReportError {
        /// The
        /// [Operation.operation_id][google.api.servicecontrol.v1.Operation.operation_id]
        /// value from the request.
        ///
        /// [google.api.servicecontrol.v1.Operation.operation_id]: crate::model::Operation::operation_id
        pub operation_id: std::string::String,

        /// Details of the error when processing the
        /// [Operation][google.api.servicecontrol.v1.Operation].
        ///
        /// [google.api.servicecontrol.v1.Operation]: crate::model::Operation
        pub status: std::option::Option<rpc::model::Status>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReportError {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation_id][crate::model::report_response::ReportError::operation_id].
        pub fn set_operation_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.operation_id = v.into();
            self
        }

        /// Sets the value of [status][crate::model::report_response::ReportError::status].
        pub fn set_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [status][crate::model::report_response::ReportError::status].
        pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ReportError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.ReportResponse.ReportError"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReportError {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __operation_id,
                __status,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReportError")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "operationId" => Ok(__FieldTag::__operation_id),
                                "operation_id" => Ok(__FieldTag::__operation_id),
                                "status" => Ok(__FieldTag::__status),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReportError;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReportError")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__operation_id => {
                                if !fields.insert(__FieldTag::__operation_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for operation_id",
                                    ));
                                }
                                result.operation_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReportError {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.operation_id.is_empty() {
                state.serialize_entry("operationId", &self.operation_id)?;
            }
            if self.status.is_some() {
                state.serialize_entry("status", &self.status)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}
