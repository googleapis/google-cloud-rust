// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate logging_type;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Defines the errors to be returned in
/// [google.api.servicecontrol.v1.CheckResponse.check_errors][google.api.servicecontrol.v1.CheckResponse.check_errors].
///
/// [google.api.servicecontrol.v1.CheckResponse.check_errors]: crate::model::CheckResponse::check_errors
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckError {
    /// The error code.
    pub code: crate::model::check_error::Code,

    /// Subject to whom this error applies. See the specific code enum for more
    /// details on this field. For example:
    ///
    /// - "project:\<project-id or project-number\>"
    /// - "folder:\<folder-id\>"
    /// - "organization:\<organization-id\>"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subject: std::string::String,

    /// Free-form text providing details on the error cause of the error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub detail: std::string::String,

    /// Contains public information about the check error. If available,
    /// `status.code` will be non zero and client can propagate it out as public
    /// error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,
}

impl CheckError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::CheckError::code].
    pub fn set_code<T: std::convert::Into<crate::model::check_error::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::CheckError::subject].
    pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject = v.into();
        self
    }

    /// Sets the value of [detail][crate::model::CheckError::detail].
    pub fn set_detail<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.detail = v.into();
        self
    }

    /// Sets the value of [status][crate::model::CheckError::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for CheckError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.CheckError"
    }
}

/// Defines additional types related to CheckError
pub mod check_error {
    #[allow(unused_imports)]
    use super::*;

    /// Error codes for Check responses.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Code(i32);

    impl Code {
        /// This is never used in `CheckResponse`.
        pub const ERROR_CODE_UNSPECIFIED: Code = Code::new(0);

        /// The consumer's project id, network container, or resource container was
        /// not found. Same as [google.rpc.Code.NOT_FOUND][google.rpc.Code.NOT_FOUND].
        pub const NOT_FOUND: Code = Code::new(5);

        /// The consumer doesn't have access to the specified resource.
        /// Same as [google.rpc.Code.PERMISSION_DENIED][google.rpc.Code.PERMISSION_DENIED].
        pub const PERMISSION_DENIED: Code = Code::new(7);

        /// Quota check failed. Same as [google.rpc.Code.RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED].
        pub const RESOURCE_EXHAUSTED: Code = Code::new(8);

        /// The consumer hasn't activated the service.
        pub const SERVICE_NOT_ACTIVATED: Code = Code::new(104);

        /// The consumer cannot access the service because billing is disabled.
        pub const BILLING_DISABLED: Code = Code::new(107);

        /// The consumer's project has been marked as deleted (soft deletion).
        pub const PROJECT_DELETED: Code = Code::new(108);

        /// The consumer's project number or id does not represent a valid project.
        pub const PROJECT_INVALID: Code = Code::new(114);

        /// The input consumer info does not represent a valid consumer folder or
        /// organization.
        pub const CONSUMER_INVALID: Code = Code::new(125);

        /// The IP address of the consumer is invalid for the specific consumer
        /// project.
        pub const IP_ADDRESS_BLOCKED: Code = Code::new(109);

        /// The referer address of the consumer request is invalid for the specific
        /// consumer project.
        pub const REFERER_BLOCKED: Code = Code::new(110);

        /// The client application of the consumer request is invalid for the
        /// specific consumer project.
        pub const CLIENT_APP_BLOCKED: Code = Code::new(111);

        /// The API targeted by this request is invalid for the specified consumer
        /// project.
        pub const API_TARGET_BLOCKED: Code = Code::new(122);

        /// The consumer's API key is invalid.
        pub const API_KEY_INVALID: Code = Code::new(105);

        /// The consumer's API Key has expired.
        pub const API_KEY_EXPIRED: Code = Code::new(112);

        /// The consumer's API Key was not found in config record.
        pub const API_KEY_NOT_FOUND: Code = Code::new(113);

        /// The credential in the request can not be verified.
        pub const INVALID_CREDENTIAL: Code = Code::new(123);

        /// The backend server for looking up project id/number is unavailable.
        pub const NAMESPACE_LOOKUP_UNAVAILABLE: Code = Code::new(300);

        /// The backend server for checking service status is unavailable.
        pub const SERVICE_STATUS_UNAVAILABLE: Code = Code::new(301);

        /// The backend server for checking billing status is unavailable.
        pub const BILLING_STATUS_UNAVAILABLE: Code = Code::new(302);

        /// Cloud Resource Manager backend server is unavailable.
        pub const CLOUD_RESOURCE_MANAGER_BACKEND_UNAVAILABLE: Code = Code::new(305);

        /// Creates a new Code instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ERROR_CODE_UNSPECIFIED"),
                5 => std::borrow::Cow::Borrowed("NOT_FOUND"),
                7 => std::borrow::Cow::Borrowed("PERMISSION_DENIED"),
                8 => std::borrow::Cow::Borrowed("RESOURCE_EXHAUSTED"),
                104 => std::borrow::Cow::Borrowed("SERVICE_NOT_ACTIVATED"),
                105 => std::borrow::Cow::Borrowed("API_KEY_INVALID"),
                107 => std::borrow::Cow::Borrowed("BILLING_DISABLED"),
                108 => std::borrow::Cow::Borrowed("PROJECT_DELETED"),
                109 => std::borrow::Cow::Borrowed("IP_ADDRESS_BLOCKED"),
                110 => std::borrow::Cow::Borrowed("REFERER_BLOCKED"),
                111 => std::borrow::Cow::Borrowed("CLIENT_APP_BLOCKED"),
                112 => std::borrow::Cow::Borrowed("API_KEY_EXPIRED"),
                113 => std::borrow::Cow::Borrowed("API_KEY_NOT_FOUND"),
                114 => std::borrow::Cow::Borrowed("PROJECT_INVALID"),
                122 => std::borrow::Cow::Borrowed("API_TARGET_BLOCKED"),
                123 => std::borrow::Cow::Borrowed("INVALID_CREDENTIAL"),
                125 => std::borrow::Cow::Borrowed("CONSUMER_INVALID"),
                300 => std::borrow::Cow::Borrowed("NAMESPACE_LOOKUP_UNAVAILABLE"),
                301 => std::borrow::Cow::Borrowed("SERVICE_STATUS_UNAVAILABLE"),
                302 => std::borrow::Cow::Borrowed("BILLING_STATUS_UNAVAILABLE"),
                305 => std::borrow::Cow::Borrowed("CLOUD_RESOURCE_MANAGER_BACKEND_UNAVAILABLE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ERROR_CODE_UNSPECIFIED" => std::option::Option::Some(Self::ERROR_CODE_UNSPECIFIED),
                "NOT_FOUND" => std::option::Option::Some(Self::NOT_FOUND),
                "PERMISSION_DENIED" => std::option::Option::Some(Self::PERMISSION_DENIED),
                "RESOURCE_EXHAUSTED" => std::option::Option::Some(Self::RESOURCE_EXHAUSTED),
                "SERVICE_NOT_ACTIVATED" => std::option::Option::Some(Self::SERVICE_NOT_ACTIVATED),
                "BILLING_DISABLED" => std::option::Option::Some(Self::BILLING_DISABLED),
                "PROJECT_DELETED" => std::option::Option::Some(Self::PROJECT_DELETED),
                "PROJECT_INVALID" => std::option::Option::Some(Self::PROJECT_INVALID),
                "CONSUMER_INVALID" => std::option::Option::Some(Self::CONSUMER_INVALID),
                "IP_ADDRESS_BLOCKED" => std::option::Option::Some(Self::IP_ADDRESS_BLOCKED),
                "REFERER_BLOCKED" => std::option::Option::Some(Self::REFERER_BLOCKED),
                "CLIENT_APP_BLOCKED" => std::option::Option::Some(Self::CLIENT_APP_BLOCKED),
                "API_TARGET_BLOCKED" => std::option::Option::Some(Self::API_TARGET_BLOCKED),
                "API_KEY_INVALID" => std::option::Option::Some(Self::API_KEY_INVALID),
                "API_KEY_EXPIRED" => std::option::Option::Some(Self::API_KEY_EXPIRED),
                "API_KEY_NOT_FOUND" => std::option::Option::Some(Self::API_KEY_NOT_FOUND),
                "INVALID_CREDENTIAL" => std::option::Option::Some(Self::INVALID_CREDENTIAL),
                "NAMESPACE_LOOKUP_UNAVAILABLE" => {
                    std::option::Option::Some(Self::NAMESPACE_LOOKUP_UNAVAILABLE)
                }
                "SERVICE_STATUS_UNAVAILABLE" => {
                    std::option::Option::Some(Self::SERVICE_STATUS_UNAVAILABLE)
                }
                "BILLING_STATUS_UNAVAILABLE" => {
                    std::option::Option::Some(Self::BILLING_STATUS_UNAVAILABLE)
                }
                "CLOUD_RESOURCE_MANAGER_BACKEND_UNAVAILABLE" => {
                    std::option::Option::Some(Self::CLOUD_RESOURCE_MANAGER_BACKEND_UNAVAILABLE)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Distribution represents a frequency distribution of double-valued sample
/// points. It contains the size of the population of sample points plus
/// additional optional information:
///
/// * the arithmetic mean of the samples
/// * the minimum and maximum of the samples
/// * the sum-squared-deviation of the samples, used to compute variance
/// * a histogram of the values of the sample points
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Distribution {
    /// The total number of samples in the distribution. Must be >= 0.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub count: i64,

    /// The arithmetic mean of the samples in the distribution. If `count` is
    /// zero then this field must be zero.
    pub mean: f64,

    /// The minimum of the population of values. Ignored if `count` is zero.
    pub minimum: f64,

    /// The maximum of the population of values. Ignored if `count` is zero.
    pub maximum: f64,

    /// The sum of squared deviations from the mean:
    /// Sum[i=1..count]((x_i - mean)^2)
    /// where each x_i is a sample values. If `count` is zero then this field
    /// must be zero, otherwise validation of the request fails.
    pub sum_of_squared_deviation: f64,

    /// The number of samples in each histogram bucket. `bucket_counts` are
    /// optional. If present, they must sum to the `count` value.
    ///
    /// The buckets are defined below in `bucket_option`. There are N buckets.
    /// `bucket_counts[0]` is the number of samples in the underflow bucket.
    /// `bucket_counts[1]` to `bucket_counts[N-1]` are the numbers of samples
    /// in each of the finite buckets. And `bucket_counts[N] is the number
    /// of samples in the overflow bucket. See the comments of `bucket_option`
    /// below for more details.
    ///
    /// Any suffix of trailing zeros may be omitted.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::DisplayFromStr>")]
    pub bucket_counts: std::vec::Vec<i64>,

    /// Example points. Must be in increasing order of `value` field.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exemplars: std::vec::Vec<api::model::distribution::Exemplar>,

    /// Defines the buckets in the histogram. `bucket_option` and `bucket_counts`
    /// must be both set, or both unset.
    ///
    /// Buckets are numbered in the range of [0, N], with a total of N+1 buckets.
    /// There must be at least two buckets (a single-bucket histogram gives
    /// no information that isn't already provided by `count`).
    ///
    /// The first bucket is the underflow bucket which has a lower bound
    /// of -inf. The last bucket is the overflow bucket which has an
    /// upper bound of +inf. All other buckets (if any) are called "finite"
    /// buckets because they have finite lower and upper bounds. As described
    /// below, there are three ways to define the finite buckets.
    ///
    /// (1) Buckets with constant width.
    /// (2) Buckets with exponentially growing widths.
    /// (3) Buckets with arbitrary user-provided widths.
    ///
    /// In all cases, the buckets cover the entire real number line (-inf,
    /// +inf). Bucket upper bounds are exclusive and lower bounds are
    /// inclusive. The upper bound of the underflow bucket is equal to the
    /// lower bound of the smallest finite bucket; the lower bound of the
    /// overflow bucket is equal to the upper bound of the largest finite
    /// bucket.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub bucket_option: std::option::Option<crate::model::distribution::BucketOption>,
}

impl Distribution {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [count][crate::model::Distribution::count].
    pub fn set_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.count = v.into();
        self
    }

    /// Sets the value of [mean][crate::model::Distribution::mean].
    pub fn set_mean<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.mean = v.into();
        self
    }

    /// Sets the value of [minimum][crate::model::Distribution::minimum].
    pub fn set_minimum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.minimum = v.into();
        self
    }

    /// Sets the value of [maximum][crate::model::Distribution::maximum].
    pub fn set_maximum<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.maximum = v.into();
        self
    }

    /// Sets the value of [sum_of_squared_deviation][crate::model::Distribution::sum_of_squared_deviation].
    pub fn set_sum_of_squared_deviation<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.sum_of_squared_deviation = v.into();
        self
    }

    /// Sets the value of [bucket_counts][crate::model::Distribution::bucket_counts].
    pub fn set_bucket_counts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.bucket_counts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [exemplars][crate::model::Distribution::exemplars].
    pub fn set_exemplars<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::distribution::Exemplar>,
    {
        use std::iter::Iterator;
        self.exemplars = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of `bucket_option`.
    pub fn set_bucket_option<
        T: std::convert::Into<std::option::Option<crate::model::distribution::BucketOption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_option = v.into();
        self
    }

    /// The value of [bucket_option][crate::model::Distribution::bucket_option]
    /// if it holds a `LinearBuckets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_linear_buckets(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::distribution::LinearBuckets>> {
        #[allow(unreachable_patterns)]
        self.bucket_option.as_ref().and_then(|v| match v {
            crate::model::distribution::BucketOption::LinearBuckets(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [bucket_option][crate::model::Distribution::bucket_option]
    /// if it holds a `ExponentialBuckets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_exponential_buckets(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::distribution::ExponentialBuckets>> {
        #[allow(unreachable_patterns)]
        self.bucket_option.as_ref().and_then(|v| match v {
            crate::model::distribution::BucketOption::ExponentialBuckets(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [bucket_option][crate::model::Distribution::bucket_option]
    /// if it holds a `ExplicitBuckets`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_explicit_buckets(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::distribution::ExplicitBuckets>> {
        #[allow(unreachable_patterns)]
        self.bucket_option.as_ref().and_then(|v| match v {
            crate::model::distribution::BucketOption::ExplicitBuckets(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [bucket_option][crate::model::Distribution::bucket_option]
    /// to hold a `LinearBuckets`.
    ///
    /// Note that all the setters affecting `bucket_option` are
    /// mutually exclusive.
    pub fn set_linear_buckets<
        T: std::convert::Into<std::boxed::Box<crate::model::distribution::LinearBuckets>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_option = std::option::Option::Some(
            crate::model::distribution::BucketOption::LinearBuckets(v.into()),
        );
        self
    }

    /// Sets the value of [bucket_option][crate::model::Distribution::bucket_option]
    /// to hold a `ExponentialBuckets`.
    ///
    /// Note that all the setters affecting `bucket_option` are
    /// mutually exclusive.
    pub fn set_exponential_buckets<
        T: std::convert::Into<std::boxed::Box<crate::model::distribution::ExponentialBuckets>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_option = std::option::Option::Some(
            crate::model::distribution::BucketOption::ExponentialBuckets(v.into()),
        );
        self
    }

    /// Sets the value of [bucket_option][crate::model::Distribution::bucket_option]
    /// to hold a `ExplicitBuckets`.
    ///
    /// Note that all the setters affecting `bucket_option` are
    /// mutually exclusive.
    pub fn set_explicit_buckets<
        T: std::convert::Into<std::boxed::Box<crate::model::distribution::ExplicitBuckets>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bucket_option = std::option::Option::Some(
            crate::model::distribution::BucketOption::ExplicitBuckets(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Distribution {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.Distribution"
    }
}

/// Defines additional types related to Distribution
pub mod distribution {
    #[allow(unused_imports)]
    use super::*;

    /// Describing buckets with constant width.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LinearBuckets {
        /// The number of finite buckets. With the underflow and overflow buckets,
        /// the total number of buckets is `num_finite_buckets` + 2.
        /// See comments on `bucket_options` for details.
        pub num_finite_buckets: i32,

        /// The i'th linear bucket covers the interval
        /// [offset + (i-1) * width, offset + i * width)
        /// where i ranges from 1 to num_finite_buckets, inclusive.
        /// Must be strictly positive.
        pub width: f64,

        /// The i'th linear bucket covers the interval
        /// [offset + (i-1) * width, offset + i * width)
        /// where i ranges from 1 to num_finite_buckets, inclusive.
        pub offset: f64,
    }

    impl LinearBuckets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [num_finite_buckets][crate::model::distribution::LinearBuckets::num_finite_buckets].
        pub fn set_num_finite_buckets<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.num_finite_buckets = v.into();
            self
        }

        /// Sets the value of [width][crate::model::distribution::LinearBuckets::width].
        pub fn set_width<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.width = v.into();
            self
        }

        /// Sets the value of [offset][crate::model::distribution::LinearBuckets::offset].
        pub fn set_offset<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.offset = v.into();
            self
        }
    }

    impl wkt::message::Message for LinearBuckets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.Distribution.LinearBuckets"
        }
    }

    /// Describing buckets with exponentially growing width.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExponentialBuckets {
        /// The number of finite buckets. With the underflow and overflow buckets,
        /// the total number of buckets is `num_finite_buckets` + 2.
        /// See comments on `bucket_options` for details.
        pub num_finite_buckets: i32,

        /// The i'th exponential bucket covers the interval
        /// [scale * growth_factor^(i-1), scale * growth_factor^i)
        /// where i ranges from 1 to num_finite_buckets inclusive.
        /// Must be larger than 1.0.
        pub growth_factor: f64,

        /// The i'th exponential bucket covers the interval
        /// [scale * growth_factor^(i-1), scale * growth_factor^i)
        /// where i ranges from 1 to num_finite_buckets inclusive.
        /// Must be > 0.
        pub scale: f64,
    }

    impl ExponentialBuckets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [num_finite_buckets][crate::model::distribution::ExponentialBuckets::num_finite_buckets].
        pub fn set_num_finite_buckets<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.num_finite_buckets = v.into();
            self
        }

        /// Sets the value of [growth_factor][crate::model::distribution::ExponentialBuckets::growth_factor].
        pub fn set_growth_factor<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.growth_factor = v.into();
            self
        }

        /// Sets the value of [scale][crate::model::distribution::ExponentialBuckets::scale].
        pub fn set_scale<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
            self.scale = v.into();
            self
        }
    }

    impl wkt::message::Message for ExponentialBuckets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.Distribution.ExponentialBuckets"
        }
    }

    /// Describing buckets with arbitrary user-provided width.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ExplicitBuckets {
        /// 'bound' is a list of strictly increasing boundaries between
        /// buckets. Note that a list of length N-1 defines N buckets because
        /// of fenceposting. See comments on `bucket_options` for details.
        ///
        /// The i'th finite bucket covers the interval
        /// [bound[i-1], bound[i])
        /// where i ranges from 1 to bound_size() - 1. Note that there are no
        /// finite buckets at all if 'bound' only contains a single element; in
        /// that special case the single bound defines the boundary between the
        /// underflow and overflow buckets.
        ///
        /// bucket number                   lower bound    upper bound
        /// i == 0 (underflow)              -inf           bound[i]
        /// 0 < i < bound_size()            bound[i-1]     bound[i]
        /// i == bound_size() (overflow)    bound[i-1]     +inf
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub bounds: std::vec::Vec<f64>,
    }

    impl ExplicitBuckets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [bounds][crate::model::distribution::ExplicitBuckets::bounds].
        pub fn set_bounds<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<f64>,
        {
            use std::iter::Iterator;
            self.bounds = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ExplicitBuckets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.Distribution.ExplicitBuckets"
        }
    }

    /// Defines the buckets in the histogram. `bucket_option` and `bucket_counts`
    /// must be both set, or both unset.
    ///
    /// Buckets are numbered in the range of [0, N], with a total of N+1 buckets.
    /// There must be at least two buckets (a single-bucket histogram gives
    /// no information that isn't already provided by `count`).
    ///
    /// The first bucket is the underflow bucket which has a lower bound
    /// of -inf. The last bucket is the overflow bucket which has an
    /// upper bound of +inf. All other buckets (if any) are called "finite"
    /// buckets because they have finite lower and upper bounds. As described
    /// below, there are three ways to define the finite buckets.
    ///
    /// (1) Buckets with constant width.
    /// (2) Buckets with exponentially growing widths.
    /// (3) Buckets with arbitrary user-provided widths.
    ///
    /// In all cases, the buckets cover the entire real number line (-inf,
    /// +inf). Bucket upper bounds are exclusive and lower bounds are
    /// inclusive. The upper bound of the underflow bucket is equal to the
    /// lower bound of the smallest finite bucket; the lower bound of the
    /// overflow bucket is equal to the upper bound of the largest finite
    /// bucket.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum BucketOption {
        /// Buckets with constant width.
        LinearBuckets(std::boxed::Box<crate::model::distribution::LinearBuckets>),
        /// Buckets with exponentially growing width.
        ExponentialBuckets(std::boxed::Box<crate::model::distribution::ExponentialBuckets>),
        /// Buckets with arbitrary user-provided width.
        ExplicitBuckets(std::boxed::Box<crate::model::distribution::ExplicitBuckets>),
    }
}

/// A common proto for logging HTTP requests. Only contains semantics
/// defined by the HTTP specification. Product-specific logging
/// information MUST be defined in a separate message.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct HttpRequest {
    /// The request method. Examples: `"GET"`, `"HEAD"`, `"PUT"`, `"POST"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_method: std::string::String,

    /// The scheme (http, https), the host name, the path, and the query
    /// portion of the URL that was requested.
    /// Example: ``http://example.com/some/info?color=red``.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_url: std::string::String,

    /// The size of the HTTP request message in bytes, including the request
    /// headers and the request body.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub request_size: i64,

    /// The response code indicating the status of the response.
    /// Examples: 200, 404.
    pub status: i32,

    /// The size of the HTTP response message sent back to the client, in bytes,
    /// including the response headers and the response body.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub response_size: i64,

    /// The user agent sent by the client. Example:
    /// `"Mozilla/4.0 (compatible; MSIE 6.0; Windows 98; Q312461; .NET
    /// CLR 1.0.3705)"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_agent: std::string::String,

    /// The IP address (IPv4 or IPv6) of the client that issued the HTTP
    /// request. Examples: `"192.168.1.1"`, `"FE80::0202:B3FF:FE1E:8329"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub remote_ip: std::string::String,

    /// The IP address (IPv4 or IPv6) of the origin server that the request was
    /// sent to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub server_ip: std::string::String,

    /// The referer URL of the request, as defined in
    /// [HTTP/1.1 Header Field
    /// Definitions](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub referer: std::string::String,

    /// The request processing latency on the server, from the time the request was
    /// received until the response was sent.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub latency: std::option::Option<wkt::Duration>,

    /// Whether or not a cache lookup was attempted.
    pub cache_lookup: bool,

    /// Whether or not an entity was served from cache
    /// (with or without validation).
    pub cache_hit: bool,

    /// Whether or not the response was validated with the origin server before
    /// being served from cache. This field is only meaningful if `cache_hit` is
    /// True.
    pub cache_validated_with_origin_server: bool,

    /// The number of HTTP response bytes inserted into cache. Set only when a
    /// cache fill was attempted.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub cache_fill_bytes: i64,

    /// Protocol used for the request. Examples: "HTTP/1.1", "HTTP/2", "websocket"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub protocol: std::string::String,
}

impl HttpRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_method][crate::model::HttpRequest::request_method].
    pub fn set_request_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_method = v.into();
        self
    }

    /// Sets the value of [request_url][crate::model::HttpRequest::request_url].
    pub fn set_request_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_url = v.into();
        self
    }

    /// Sets the value of [request_size][crate::model::HttpRequest::request_size].
    pub fn set_request_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.request_size = v.into();
        self
    }

    /// Sets the value of [status][crate::model::HttpRequest::status].
    pub fn set_status<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [response_size][crate::model::HttpRequest::response_size].
    pub fn set_response_size<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.response_size = v.into();
        self
    }

    /// Sets the value of [user_agent][crate::model::HttpRequest::user_agent].
    pub fn set_user_agent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_agent = v.into();
        self
    }

    /// Sets the value of [remote_ip][crate::model::HttpRequest::remote_ip].
    pub fn set_remote_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remote_ip = v.into();
        self
    }

    /// Sets the value of [server_ip][crate::model::HttpRequest::server_ip].
    pub fn set_server_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server_ip = v.into();
        self
    }

    /// Sets the value of [referer][crate::model::HttpRequest::referer].
    pub fn set_referer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.referer = v.into();
        self
    }

    /// Sets the value of [latency][crate::model::HttpRequest::latency].
    pub fn set_latency<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.latency = v.into();
        self
    }

    /// Sets the value of [cache_lookup][crate::model::HttpRequest::cache_lookup].
    pub fn set_cache_lookup<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cache_lookup = v.into();
        self
    }

    /// Sets the value of [cache_hit][crate::model::HttpRequest::cache_hit].
    pub fn set_cache_hit<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.cache_hit = v.into();
        self
    }

    /// Sets the value of [cache_validated_with_origin_server][crate::model::HttpRequest::cache_validated_with_origin_server].
    pub fn set_cache_validated_with_origin_server<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.cache_validated_with_origin_server = v.into();
        self
    }

    /// Sets the value of [cache_fill_bytes][crate::model::HttpRequest::cache_fill_bytes].
    pub fn set_cache_fill_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.cache_fill_bytes = v.into();
        self
    }

    /// Sets the value of [protocol][crate::model::HttpRequest::protocol].
    pub fn set_protocol<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.protocol = v.into();
        self
    }
}

impl wkt::message::Message for HttpRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.HttpRequest"
    }
}

/// An individual log entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogEntry {
    /// Required. The log to which this log entry belongs. Examples: `"syslog"`,
    /// `"book_log"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The time the event described by the log entry occurred. If
    /// omitted, defaults to operation start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timestamp: std::option::Option<wkt::Timestamp>,

    /// The severity of the log entry. The default value is
    /// `LogSeverity.DEFAULT`.
    pub severity: logging_type::model::LogSeverity,

    /// Optional. Information about the HTTP request associated with this
    /// log entry, if applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub http_request: std::option::Option<crate::model::HttpRequest>,

    /// Optional. Resource name of the trace associated with the log entry, if any.
    /// If this field contains a relative resource name, you can assume the name is
    /// relative to `//tracing.googleapis.com`. Example:
    /// `projects/my-projectid/traces/06796866738c859f2f19b7cfb3214824`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trace: std::string::String,

    /// A unique ID for the log entry used for deduplication. If omitted,
    /// the implementation will generate one based on operation_id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub insert_id: std::string::String,

    /// A set of user-defined (key, value) data that provides additional
    /// information about the log entry.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Information about an operation associated with the log entry, if
    /// applicable.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub operation: std::option::Option<crate::model::LogEntryOperation>,

    /// Optional. Source code location information associated with the log entry,
    /// if any.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source_location: std::option::Option<crate::model::LogEntrySourceLocation>,

    /// The log entry payload, which can be one of multiple types.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<crate::model::log_entry::Payload>,
}

impl LogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::LogEntry::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [timestamp][crate::model::LogEntry::timestamp].
    pub fn set_timestamp<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.timestamp = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::LogEntry::severity].
    pub fn set_severity<T: std::convert::Into<logging_type::model::LogSeverity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [http_request][crate::model::LogEntry::http_request].
    pub fn set_http_request<
        T: std::convert::Into<std::option::Option<crate::model::HttpRequest>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.http_request = v.into();
        self
    }

    /// Sets the value of [trace][crate::model::LogEntry::trace].
    pub fn set_trace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.trace = v.into();
        self
    }

    /// Sets the value of [insert_id][crate::model::LogEntry::insert_id].
    pub fn set_insert_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.insert_id = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::LogEntry::operation].
    pub fn set_operation<
        T: std::convert::Into<std::option::Option<crate::model::LogEntryOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [source_location][crate::model::LogEntry::source_location].
    pub fn set_source_location<
        T: std::convert::Into<std::option::Option<crate::model::LogEntrySourceLocation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_location = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::LogEntry::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `payload`.
    pub fn set_payload<
        T: std::convert::Into<std::option::Option<crate::model::log_entry::Payload>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `ProtoPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_proto_payload(&self) -> std::option::Option<&std::boxed::Box<wkt::Any>> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::ProtoPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `TextPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_text_payload(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::TextPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [payload][crate::model::LogEntry::payload]
    /// if it holds a `StructPayload`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_struct_payload(&self) -> std::option::Option<&std::boxed::Box<wkt::Struct>> {
        #[allow(unreachable_patterns)]
        self.payload.as_ref().and_then(|v| match v {
            crate::model::log_entry::Payload::StructPayload(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `ProtoPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_proto_payload<T: std::convert::Into<std::boxed::Box<wkt::Any>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::ProtoPayload(v.into()));
        self
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `TextPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_text_payload<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::TextPayload(v.into()));
        self
    }

    /// Sets the value of [payload][crate::model::LogEntry::payload]
    /// to hold a `StructPayload`.
    ///
    /// Note that all the setters affecting `payload` are
    /// mutually exclusive.
    pub fn set_struct_payload<T: std::convert::Into<std::boxed::Box<wkt::Struct>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload =
            std::option::Option::Some(crate::model::log_entry::Payload::StructPayload(v.into()));
        self
    }
}

impl wkt::message::Message for LogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.LogEntry"
    }
}

/// Defines additional types related to LogEntry
pub mod log_entry {
    #[allow(unused_imports)]
    use super::*;

    /// The log entry payload, which can be one of multiple types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Payload {
        /// The log entry payload, represented as a protocol buffer that is
        /// expressed as a JSON object. The only accepted type currently is
        /// [AuditLog][google.cloud.audit.AuditLog].
        ProtoPayload(std::boxed::Box<wkt::Any>),
        /// The log entry payload, represented as a Unicode string (UTF-8).
        TextPayload(std::string::String),
        /// The log entry payload, represented as a structure that
        /// is expressed as a JSON object.
        StructPayload(std::boxed::Box<wkt::Struct>),
    }
}

/// Additional information about a potentially long-running operation with which
/// a log entry is associated.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogEntryOperation {
    /// Optional. An arbitrary operation identifier. Log entries with the
    /// same identifier are assumed to be part of the same operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Optional. An arbitrary producer identifier. The combination of
    /// `id` and `producer` must be globally unique.  Examples for `producer`:
    /// `"MyDivision.MyBigCompany.com"`, `"github.com/MyProject/MyApplication"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub producer: std::string::String,

    /// Optional. Set this to True if this is the first log entry in the operation.
    pub first: bool,

    /// Optional. Set this to True if this is the last log entry in the operation.
    pub last: bool,
}

impl LogEntryOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::LogEntryOperation::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [producer][crate::model::LogEntryOperation::producer].
    pub fn set_producer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.producer = v.into();
        self
    }

    /// Sets the value of [first][crate::model::LogEntryOperation::first].
    pub fn set_first<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.first = v.into();
        self
    }

    /// Sets the value of [last][crate::model::LogEntryOperation::last].
    pub fn set_last<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.last = v.into();
        self
    }
}

impl wkt::message::Message for LogEntryOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.LogEntryOperation"
    }
}

/// Additional information about the source code location that produced the log
/// entry.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LogEntrySourceLocation {
    /// Optional. Source file name. Depending on the runtime environment, this
    /// might be a simple name or a fully-qualified name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file: std::string::String,

    /// Optional. Line within the source file. 1-based; 0 indicates no line number
    /// available.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub line: i64,

    /// Optional. Human-readable name of the function or method being invoked, with
    /// optional context such as the class or package name. This information may be
    /// used in contexts such as the logs viewer, where a file and line number are
    /// less meaningful. The format can vary by language. For example:
    /// `qual.if.ied.Class.method` (Java), `dir/package.func` (Go), `function`
    /// (Python).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub function: std::string::String,
}

impl LogEntrySourceLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file][crate::model::LogEntrySourceLocation::file].
    pub fn set_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file = v.into();
        self
    }

    /// Sets the value of [line][crate::model::LogEntrySourceLocation::line].
    pub fn set_line<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.line = v.into();
        self
    }

    /// Sets the value of [function][crate::model::LogEntrySourceLocation::function].
    pub fn set_function<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.function = v.into();
        self
    }
}

impl wkt::message::Message for LogEntrySourceLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.LogEntrySourceLocation"
    }
}

/// Represents a single metric value.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetricValue {
    /// The labels describing the metric value.
    /// See comments on [google.api.servicecontrol.v1.Operation.labels][google.api.servicecontrol.v1.Operation.labels] for
    /// the overriding relationship.
    /// Note that this map must not contain monitored resource labels.
    ///
    /// [google.api.servicecontrol.v1.Operation.labels]: crate::model::Operation::labels
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The start of the time period over which this metric value's measurement
    /// applies. The time period has different semantics for different metric
    /// types (cumulative, delta, and gauge). See the metric definition
    /// documentation in the service configuration for details. If not specified,
    /// [google.api.servicecontrol.v1.Operation.start_time][google.api.servicecontrol.v1.Operation.start_time] will be used.
    ///
    /// [google.api.servicecontrol.v1.Operation.start_time]: crate::model::Operation::start_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The end of the time period over which this metric value's measurement
    /// applies.  If not specified,
    /// [google.api.servicecontrol.v1.Operation.end_time][google.api.servicecontrol.v1.Operation.end_time] will be used.
    ///
    /// [google.api.servicecontrol.v1.Operation.end_time]: crate::model::Operation::end_time
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The value. The type of value used in the request must
    /// agree with the metric definition in the service configuration, otherwise
    /// the MetricValue is rejected.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub value: std::option::Option<crate::model::metric_value::Value>,
}

impl MetricValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::MetricValue::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::MetricValue::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::MetricValue::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `value`.
    pub fn set_value<
        T: std::convert::Into<std::option::Option<crate::model::metric_value::Value>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = v.into();
        self
    }

    /// The value of [value][crate::model::MetricValue::value]
    /// if it holds a `BoolValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_bool_value(&self) -> std::option::Option<&bool> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::metric_value::Value::BoolValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::MetricValue::value]
    /// if it holds a `Int64Value`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_int64_value(&self) -> std::option::Option<&i64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::metric_value::Value::Int64Value(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::MetricValue::value]
    /// if it holds a `DoubleValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_double_value(&self) -> std::option::Option<&f64> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::metric_value::Value::DoubleValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::MetricValue::value]
    /// if it holds a `StringValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_string_value(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::metric_value::Value::StringValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [value][crate::model::MetricValue::value]
    /// if it holds a `DistributionValue`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_distribution_value(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::Distribution>> {
        #[allow(unreachable_patterns)]
        self.value.as_ref().and_then(|v| match v {
            crate::model::metric_value::Value::DistributionValue(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [value][crate::model::MetricValue::value]
    /// to hold a `BoolValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_bool_value<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::metric_value::Value::BoolValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::MetricValue::value]
    /// to hold a `Int64Value`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_int64_value<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::metric_value::Value::Int64Value(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::MetricValue::value]
    /// to hold a `DoubleValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_double_value<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::metric_value::Value::DoubleValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::MetricValue::value]
    /// to hold a `StringValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_string_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.value =
            std::option::Option::Some(crate::model::metric_value::Value::StringValue(v.into()));
        self
    }

    /// Sets the value of [value][crate::model::MetricValue::value]
    /// to hold a `DistributionValue`.
    ///
    /// Note that all the setters affecting `value` are
    /// mutually exclusive.
    pub fn set_distribution_value<
        T: std::convert::Into<std::boxed::Box<crate::model::Distribution>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.value = std::option::Option::Some(
            crate::model::metric_value::Value::DistributionValue(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MetricValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.MetricValue"
    }
}

/// Defines additional types related to MetricValue
pub mod metric_value {
    #[allow(unused_imports)]
    use super::*;

    /// The value. The type of value used in the request must
    /// agree with the metric definition in the service configuration, otherwise
    /// the MetricValue is rejected.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Value {
        /// A boolean value.
        BoolValue(bool),
        /// A signed 64-bit integer value.
        Int64Value(i64),
        /// A double precision floating point value.
        DoubleValue(f64),
        /// A text string value.
        StringValue(std::string::String),
        /// A distribution value.
        DistributionValue(std::boxed::Box<crate::model::Distribution>),
    }
}

/// Represents a set of metric values in the same metric.
/// Each metric value in the set should have a unique combination of start time,
/// end time, and label values.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MetricValueSet {
    /// The metric name defined in the service configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metric_name: std::string::String,

    /// The values in this metric.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metric_values: std::vec::Vec<crate::model::MetricValue>,
}

impl MetricValueSet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric_name][crate::model::MetricValueSet::metric_name].
    pub fn set_metric_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric_name = v.into();
        self
    }

    /// Sets the value of [metric_values][crate::model::MetricValueSet::metric_values].
    pub fn set_metric_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetricValue>,
    {
        use std::iter::Iterator;
        self.metric_values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MetricValueSet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.MetricValueSet"
    }
}

/// Represents information regarding an operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Operation {
    /// Identity of the operation. This must be unique within the scope of the
    /// service that generated the operation. If the service calls
    /// Check() and Report() on the same operation, the two calls should carry
    /// the same id.
    ///
    /// UUID version 4 is recommended, though not required.
    /// In scenarios where an operation is computed from existing information
    /// and an idempotent id is desirable for deduplication purpose, UUID version 5
    /// is recommended. See RFC 4122 for details.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_id: std::string::String,

    /// Fully qualified name of the operation. Reserved for future use.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_name: std::string::String,

    /// Identity of the consumer who is using the service.
    /// This field should be filled in for the operations initiated by a
    /// consumer, but not for service-initiated operations that are
    /// not related to a specific consumer.
    ///
    /// - This can be in one of the following formats:
    ///   - project:PROJECT_ID,
    ///   - project`_`number:PROJECT_NUMBER,
    ///   - projects/PROJECT_ID or PROJECT_NUMBER,
    ///   - folders/FOLDER_NUMBER,
    ///   - organizations/ORGANIZATION_NUMBER,
    ///   - api`_`key:API_KEY.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub consumer_id: std::string::String,

    /// Required. Start time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// End time of the operation.
    /// Required when the operation is used in
    /// [ServiceController.Report][google.api.servicecontrol.v1.ServiceController.Report],
    /// but optional when the operation is used in
    /// [ServiceController.Check][google.api.servicecontrol.v1.ServiceController.Check].
    ///
    /// [google.api.servicecontrol.v1.ServiceController.Check]: crate::client::ServiceController::check
    /// [google.api.servicecontrol.v1.ServiceController.Report]: crate::client::ServiceController::report
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Labels describing the operation. Only the following labels are allowed:
    ///
    /// - Labels describing monitored resources as defined in
    ///   the service configuration.
    /// - Default labels of metric values. When specified, labels defined in the
    ///   metric value override these default.
    /// - The following labels defined by Google Cloud Platform:
    ///   - `cloud.googleapis.com/location` describing the location where the
    ///     operation happened,
    ///   - `servicecontrol.googleapis.com/user_agent` describing the user agent
    ///     of the API request,
    ///   - `servicecontrol.googleapis.com/service_agent` describing the service
    ///     used to handle the API request (e.g. ESP),
    ///   - `servicecontrol.googleapis.com/platform` describing the platform
    ///     where the API is served, such as App Engine, Compute Engine, or
    ///     Kubernetes Engine.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Represents information about this operation. Each MetricValueSet
    /// corresponds to a metric defined in the service configuration.
    /// The data type used in the MetricValueSet must agree with
    /// the data type specified in the metric definition.
    ///
    /// Within a single operation, it is not allowed to have more than one
    /// MetricValue instances that have the same metric names and identical
    /// label value combinations. If a request has such duplicated MetricValue
    /// instances, the entire request is rejected with
    /// an invalid argument error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub metric_value_sets: std::vec::Vec<crate::model::MetricValueSet>,

    /// Represents information to be logged.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub log_entries: std::vec::Vec<crate::model::LogEntry>,

    /// DO NOT USE. This is an experimental field.
    pub importance: crate::model::operation::Importance,

    /// Unimplemented.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub extensions: std::vec::Vec<wkt::Any>,
}

impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::Operation::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [operation_name][crate::model::Operation::operation_name].
    pub fn set_operation_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_name = v.into();
        self
    }

    /// Sets the value of [consumer_id][crate::model::Operation::consumer_id].
    pub fn set_consumer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.consumer_id = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Operation::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Operation::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [importance][crate::model::Operation::importance].
    pub fn set_importance<T: std::convert::Into<crate::model::operation::Importance>>(
        mut self,
        v: T,
    ) -> Self {
        self.importance = v.into();
        self
    }

    /// Sets the value of [metric_value_sets][crate::model::Operation::metric_value_sets].
    pub fn set_metric_value_sets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetricValueSet>,
    {
        use std::iter::Iterator;
        self.metric_value_sets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [log_entries][crate::model::Operation::log_entries].
    pub fn set_log_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LogEntry>,
    {
        use std::iter::Iterator;
        self.log_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [extensions][crate::model::Operation::extensions].
    pub fn set_extensions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.extensions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Operation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.Operation"
    }
}

/// Defines additional types related to Operation
pub mod operation {
    #[allow(unused_imports)]
    use super::*;

    /// Defines the importance of the data contained in the operation.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Importance(i32);

    impl Importance {
        /// Allows data caching, batching, and aggregation. It provides
        /// higher performance with higher data loss risk.
        pub const LOW: Importance = Importance::new(0);

        /// Disables data aggregation to minimize data loss. It is for operations
        /// that contains significant monetary value or audit trail. This feature
        /// only applies to the client libraries.
        pub const HIGH: Importance = Importance::new(1);

        /// Creates a new Importance instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("LOW"),
                1 => std::borrow::Cow::Borrowed("HIGH"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "LOW" => std::option::Option::Some(Self::LOW),
                "HIGH" => std::option::Option::Some(Self::HIGH),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Importance {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Importance {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request message for the AllocateQuota method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AllocateQuotaRequest {
    /// Name of the service as specified in the service configuration. For example,
    /// `"pubsub.googleapis.com"`.
    ///
    /// See [google.api.Service][google.api.Service] for the definition of a service name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// Operation that describes the quota allocation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub allocate_operation: std::option::Option<crate::model::QuotaOperation>,

    /// Specifies which version of service configuration should be used to process
    /// the request. If unspecified or no matching version can be found, the latest
    /// one will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_config_id: std::string::String,
}

impl AllocateQuotaRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::AllocateQuotaRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [allocate_operation][crate::model::AllocateQuotaRequest::allocate_operation].
    pub fn set_allocate_operation<
        T: std::convert::Into<std::option::Option<crate::model::QuotaOperation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.allocate_operation = v.into();
        self
    }

    /// Sets the value of [service_config_id][crate::model::AllocateQuotaRequest::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }
}

impl wkt::message::Message for AllocateQuotaRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.AllocateQuotaRequest"
    }
}

/// Represents information regarding a quota operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuotaOperation {
    /// Identity of the operation. This is expected to be unique within the scope
    /// of the service that generated the operation, and guarantees idempotency in
    /// case of retries.
    ///
    /// In order to ensure best performance and latency in the Quota backends,
    /// operation_ids are optimally associated with time, so that related
    /// operations can be accessed fast in storage. For this reason, the
    /// recommended token for services that intend to operate at a high QPS is
    /// Unix time in nanos + UUID
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_id: std::string::String,

    /// Fully qualified name of the API method for which this quota operation is
    /// requested. This name is used for matching quota rules or metric rules and
    /// billing status rules defined in service configuration.
    ///
    /// This field should not be set if any of the following is true:
    /// (1) the quota operation is performed on non-API resources.
    /// (2) quota_metrics is set because the caller is doing quota override.
    ///
    /// Example of an RPC method name:
    /// google.example.library.v1.LibraryService.CreateShelf
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub method_name: std::string::String,

    /// Identity of the consumer for whom this quota operation is being performed.
    ///
    /// This can be in one of the following formats:
    /// project:<project_id>,
    /// project_number:<project_number>,
    /// api_key:<api_key>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub consumer_id: std::string::String,

    /// Labels describing the operation.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Represents information about this operation. Each MetricValueSet
    /// corresponds to a metric defined in the service configuration.
    /// The data type used in the MetricValueSet must agree with
    /// the data type specified in the metric definition.
    ///
    /// Within a single operation, it is not allowed to have more than one
    /// MetricValue instances that have the same metric names and identical
    /// label value combinations. If a request has such duplicated MetricValue
    /// instances, the entire request is rejected with
    /// an invalid argument error.
    ///
    /// This field is mutually exclusive with method_name.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub quota_metrics: std::vec::Vec<crate::model::MetricValueSet>,

    /// Quota mode for this operation.
    pub quota_mode: crate::model::quota_operation::QuotaMode,
}

impl QuotaOperation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::QuotaOperation::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [method_name][crate::model::QuotaOperation::method_name].
    pub fn set_method_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.method_name = v.into();
        self
    }

    /// Sets the value of [consumer_id][crate::model::QuotaOperation::consumer_id].
    pub fn set_consumer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.consumer_id = v.into();
        self
    }

    /// Sets the value of [quota_mode][crate::model::QuotaOperation::quota_mode].
    pub fn set_quota_mode<T: std::convert::Into<crate::model::quota_operation::QuotaMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.quota_mode = v.into();
        self
    }

    /// Sets the value of [quota_metrics][crate::model::QuotaOperation::quota_metrics].
    pub fn set_quota_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetricValueSet>,
    {
        use std::iter::Iterator;
        self.quota_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::QuotaOperation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for QuotaOperation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.QuotaOperation"
    }
}

/// Defines additional types related to QuotaOperation
pub mod quota_operation {
    #[allow(unused_imports)]
    use super::*;

    /// Supported quota modes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct QuotaMode(i32);

    impl QuotaMode {
        /// Guard against implicit default. Must not be used.
        pub const UNSPECIFIED: QuotaMode = QuotaMode::new(0);

        /// For AllocateQuota request, allocates quota for the amount specified in
        /// the service configuration or specified using the quota metrics. If the
        /// amount is higher than the available quota, allocation error will be
        /// returned and no quota will be allocated.
        /// If multiple quotas are part of the request, and one fails, none of the
        /// quotas are allocated or released.
        pub const NORMAL: QuotaMode = QuotaMode::new(1);

        /// The operation allocates quota for the amount specified in the service
        /// configuration or specified using the quota metrics. If the amount is
        /// higher than the available quota, request does not fail but all available
        /// quota will be allocated.
        /// For rate quota, BEST_EFFORT will continue to deduct from other groups
        /// even if one does not have enough quota. For allocation, it will find the
        /// minimum available amount across all groups and deduct that amount from
        /// all the affected groups.
        pub const BEST_EFFORT: QuotaMode = QuotaMode::new(2);

        /// For AllocateQuota request, only checks if there is enough quota
        /// available and does not change the available quota. No lock is placed on
        /// the available quota either.
        pub const CHECK_ONLY: QuotaMode = QuotaMode::new(3);

        /// Unimplemented. When used in AllocateQuotaRequest, this returns the
        /// effective quota limit(s) in the response, and no quota check will be
        /// performed. Not supported for other requests, and even for
        /// AllocateQuotaRequest, this is currently supported only for allowlisted
        /// services.
        pub const QUERY_ONLY: QuotaMode = QuotaMode::new(4);

        /// The operation allocates quota for the amount specified in the service
        /// configuration or specified using the quota metrics. If the requested
        /// amount is higher than the available quota, request does not fail and
        /// remaining quota would become negative (going over the limit).
        /// Not supported for Rate Quota.
        pub const ADJUST_ONLY: QuotaMode = QuotaMode::new(5);

        /// Creates a new QuotaMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NORMAL"),
                2 => std::borrow::Cow::Borrowed("BEST_EFFORT"),
                3 => std::borrow::Cow::Borrowed("CHECK_ONLY"),
                4 => std::borrow::Cow::Borrowed("QUERY_ONLY"),
                5 => std::borrow::Cow::Borrowed("ADJUST_ONLY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "UNSPECIFIED" => std::option::Option::Some(Self::UNSPECIFIED),
                "NORMAL" => std::option::Option::Some(Self::NORMAL),
                "BEST_EFFORT" => std::option::Option::Some(Self::BEST_EFFORT),
                "CHECK_ONLY" => std::option::Option::Some(Self::CHECK_ONLY),
                "QUERY_ONLY" => std::option::Option::Some(Self::QUERY_ONLY),
                "ADJUST_ONLY" => std::option::Option::Some(Self::ADJUST_ONLY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for QuotaMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for QuotaMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Response message for the AllocateQuota method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AllocateQuotaResponse {
    /// The same operation_id value used in the AllocateQuotaRequest. Used for
    /// logging and diagnostics purposes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_id: std::string::String,

    /// Indicates the decision of the allocate.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub allocate_errors: std::vec::Vec<crate::model::QuotaError>,

    /// Quota metrics to indicate the result of allocation. Depending on the
    /// request, one or more of the following metrics will be included:
    ///
    /// . Per quota group or per quota metric incremental usage will be specified
    ///   using the following delta metric :
    ///   "serviceruntime.googleapis.com/api/consumer/quota_used_count"
    ///
    /// . The quota limit reached condition will be specified using the following
    ///   boolean metric :
    ///   "serviceruntime.googleapis.com/quota/exceeded"
    ///
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub quota_metrics: std::vec::Vec<crate::model::MetricValueSet>,

    /// ID of the actual config used to process the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_config_id: std::string::String,
}

impl AllocateQuotaResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::AllocateQuotaResponse::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [service_config_id][crate::model::AllocateQuotaResponse::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }

    /// Sets the value of [allocate_errors][crate::model::AllocateQuotaResponse::allocate_errors].
    pub fn set_allocate_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::QuotaError>,
    {
        use std::iter::Iterator;
        self.allocate_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [quota_metrics][crate::model::AllocateQuotaResponse::quota_metrics].
    pub fn set_quota_metrics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MetricValueSet>,
    {
        use std::iter::Iterator;
        self.quota_metrics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AllocateQuotaResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.AllocateQuotaResponse"
    }
}

/// Represents error information for [QuotaOperation][google.api.servicecontrol.v1.QuotaOperation].
///
/// [google.api.servicecontrol.v1.QuotaOperation]: crate::model::QuotaOperation
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct QuotaError {
    /// Error code.
    pub code: crate::model::quota_error::Code,

    /// Subject to whom this error applies. See the specific enum for more details
    /// on this field. For example, "clientip:\<ip address of client\>" or
    /// "project:\<Google developer project id\>".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subject: std::string::String,

    /// Free-form text that provides details on the cause of the error.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Contains additional information about the quota error.
    /// If available, `status.code` will be non zero.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub status: std::option::Option<rpc::model::Status>,
}

impl QuotaError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::QuotaError::code].
    pub fn set_code<T: std::convert::Into<crate::model::quota_error::Code>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [subject][crate::model::QuotaError::subject].
    pub fn set_subject<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subject = v.into();
        self
    }

    /// Sets the value of [description][crate::model::QuotaError::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [status][crate::model::QuotaError::status].
    pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }
}

impl wkt::message::Message for QuotaError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.QuotaError"
    }
}

/// Defines additional types related to QuotaError
pub mod quota_error {
    #[allow(unused_imports)]
    use super::*;

    /// Error codes related to project config validations are deprecated since the
    /// quota controller methods do not perform these validations. Instead services
    /// have to call the Check method, without quota_properties field, to perform
    /// these validations before calling the quota controller methods. These
    /// methods check only for project deletion to be wipe out compliant.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Code(i32);

    impl Code {
        /// This is never used.
        pub const UNSPECIFIED: Code = Code::new(0);

        /// Quota allocation failed.
        /// Same as [google.rpc.Code.RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED].
        pub const RESOURCE_EXHAUSTED: Code = Code::new(8);

        /// Consumer cannot access the service because the service requires active
        /// billing.
        pub const BILLING_NOT_ACTIVE: Code = Code::new(107);

        /// Consumer's project has been marked as deleted (soft deletion).
        pub const PROJECT_DELETED: Code = Code::new(108);

        /// Specified API key is invalid.
        pub const API_KEY_INVALID: Code = Code::new(105);

        /// Specified API Key has expired.
        pub const API_KEY_EXPIRED: Code = Code::new(112);

        /// Creates a new Code instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("UNSPECIFIED"),
                8 => std::borrow::Cow::Borrowed("RESOURCE_EXHAUSTED"),
                105 => std::borrow::Cow::Borrowed("API_KEY_INVALID"),
                107 => std::borrow::Cow::Borrowed("BILLING_NOT_ACTIVE"),
                108 => std::borrow::Cow::Borrowed("PROJECT_DELETED"),
                112 => std::borrow::Cow::Borrowed("API_KEY_EXPIRED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "UNSPECIFIED" => std::option::Option::Some(Self::UNSPECIFIED),
                "RESOURCE_EXHAUSTED" => std::option::Option::Some(Self::RESOURCE_EXHAUSTED),
                "BILLING_NOT_ACTIVE" => std::option::Option::Some(Self::BILLING_NOT_ACTIVE),
                "PROJECT_DELETED" => std::option::Option::Some(Self::PROJECT_DELETED),
                "API_KEY_INVALID" => std::option::Option::Some(Self::API_KEY_INVALID),
                "API_KEY_EXPIRED" => std::option::Option::Some(Self::API_KEY_EXPIRED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Code {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Code {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request message for the Check method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckRequest {
    /// The service name as specified in its service configuration. For example,
    /// `"pubsub.googleapis.com"`.
    ///
    /// See
    /// [google.api.Service](https://cloud.google.com/service-management/reference/rpc/google.api#google.api.Service)
    /// for the definition of a service name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// The operation to be checked.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub operation: std::option::Option<crate::model::Operation>,

    /// Specifies which version of service configuration should be used to process
    /// the request.
    ///
    /// If unspecified or no matching version can be found, the
    /// latest one will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_config_id: std::string::String,
}

impl CheckRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::CheckRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [operation][crate::model::CheckRequest::operation].
    pub fn set_operation<T: std::convert::Into<std::option::Option<crate::model::Operation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.operation = v.into();
        self
    }

    /// Sets the value of [service_config_id][crate::model::CheckRequest::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }
}

impl wkt::message::Message for CheckRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.CheckRequest"
    }
}

/// Response message for the Check method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckResponse {
    /// The same operation_id value used in the
    /// [CheckRequest][google.api.servicecontrol.v1.CheckRequest]. Used for logging
    /// and diagnostics purposes.
    ///
    /// [google.api.servicecontrol.v1.CheckRequest]: crate::model::CheckRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub operation_id: std::string::String,

    /// Indicate the decision of the check.
    ///
    /// If no check errors are present, the service should process the operation.
    /// Otherwise the service should use the list of errors to determine the
    /// appropriate action.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub check_errors: std::vec::Vec<crate::model::CheckError>,

    /// The actual config id used to process the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_config_id: std::string::String,

    /// The current service rollout id used to process the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_rollout_id: std::string::String,

    /// Feedback data returned from the server during processing a Check request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub check_info: std::option::Option<crate::model::check_response::CheckInfo>,
}

impl CheckResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operation_id][crate::model::CheckResponse::operation_id].
    pub fn set_operation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.operation_id = v.into();
        self
    }

    /// Sets the value of [service_config_id][crate::model::CheckResponse::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }

    /// Sets the value of [service_rollout_id][crate::model::CheckResponse::service_rollout_id].
    pub fn set_service_rollout_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_rollout_id = v.into();
        self
    }

    /// Sets the value of [check_info][crate::model::CheckResponse::check_info].
    pub fn set_check_info<
        T: std::convert::Into<std::option::Option<crate::model::check_response::CheckInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.check_info = v.into();
        self
    }

    /// Sets the value of [check_errors][crate::model::CheckResponse::check_errors].
    pub fn set_check_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CheckError>,
    {
        use std::iter::Iterator;
        self.check_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CheckResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.CheckResponse"
    }
}

/// Defines additional types related to CheckResponse
pub mod check_response {
    #[allow(unused_imports)]
    use super::*;

    /// Contains additional information about the check operation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CheckInfo {
        /// A list of fields and label keys that are ignored by the server.
        /// The client doesn't need to send them for following requests to improve
        /// performance and allow better aggregation.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub unused_arguments: std::vec::Vec<std::string::String>,

        /// Consumer info of this check.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub consumer_info: std::option::Option<crate::model::check_response::ConsumerInfo>,

        /// The unique id of the api key in the format of "apikey:\<UID\>".
        /// This field will be populated when the consumer passed to Service Control
        /// is an API key and all the API key related validations are successful.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub api_key_uid: std::string::String,
    }

    impl CheckInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [consumer_info][crate::model::check_response::CheckInfo::consumer_info].
        pub fn set_consumer_info<
            T: std::convert::Into<std::option::Option<crate::model::check_response::ConsumerInfo>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.consumer_info = v.into();
            self
        }

        /// Sets the value of [api_key_uid][crate::model::check_response::CheckInfo::api_key_uid].
        pub fn set_api_key_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.api_key_uid = v.into();
            self
        }

        /// Sets the value of [unused_arguments][crate::model::check_response::CheckInfo::unused_arguments].
        pub fn set_unused_arguments<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.unused_arguments = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for CheckInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.CheckResponse.CheckInfo"
        }
    }

    /// `ConsumerInfo` provides information about the consumer.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConsumerInfo {
        /// The Google cloud project number, e.g. 1234567890. A value of 0 indicates
        /// no project number is found.
        ///
        /// NOTE: This field is deprecated after we support flexible consumer
        /// id. New code should not depend on this field anymore.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub project_number: i64,

        /// The type of the consumer which should have been defined in
        /// [Google Resource Manager](https://cloud.google.com/resource-manager/).
        #[serde(rename = "type")]
        pub r#type: crate::model::check_response::consumer_info::ConsumerType,

        /// The consumer identity number, can be Google cloud project number, folder
        /// number or organization number e.g. 1234567890. A value of 0 indicates no
        /// consumer number is found.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub consumer_number: i64,
    }

    impl ConsumerInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_number][crate::model::check_response::ConsumerInfo::project_number].
        pub fn set_project_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.project_number = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::check_response::ConsumerInfo::type].
        pub fn set_type<
            T: std::convert::Into<crate::model::check_response::consumer_info::ConsumerType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [consumer_number][crate::model::check_response::ConsumerInfo::consumer_number].
        pub fn set_consumer_number<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.consumer_number = v.into();
            self
        }
    }

    impl wkt::message::Message for ConsumerInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.CheckResponse.ConsumerInfo"
        }
    }

    /// Defines additional types related to ConsumerInfo
    pub mod consumer_info {
        #[allow(unused_imports)]
        use super::*;

        /// The type of the consumer as defined in
        /// [Google Resource Manager](https://cloud.google.com/resource-manager/).
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct ConsumerType(i32);

        impl ConsumerType {
            /// This is never used.
            pub const CONSUMER_TYPE_UNSPECIFIED: ConsumerType = ConsumerType::new(0);

            /// The consumer is a Google Cloud Project.
            pub const PROJECT: ConsumerType = ConsumerType::new(1);

            /// The consumer is a Google Cloud Folder.
            pub const FOLDER: ConsumerType = ConsumerType::new(2);

            /// The consumer is a Google Cloud Organization.
            pub const ORGANIZATION: ConsumerType = ConsumerType::new(3);

            /// Service-specific resource container which is defined by the service
            /// producer to offer their users the ability to manage service control
            /// functionalities at a finer level of granularity than the PROJECT.
            pub const SERVICE_SPECIFIC: ConsumerType = ConsumerType::new(4);

            /// Creates a new ConsumerType instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("CONSUMER_TYPE_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("PROJECT"),
                    2 => std::borrow::Cow::Borrowed("FOLDER"),
                    3 => std::borrow::Cow::Borrowed("ORGANIZATION"),
                    4 => std::borrow::Cow::Borrowed("SERVICE_SPECIFIC"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "CONSUMER_TYPE_UNSPECIFIED" => {
                        std::option::Option::Some(Self::CONSUMER_TYPE_UNSPECIFIED)
                    }
                    "PROJECT" => std::option::Option::Some(Self::PROJECT),
                    "FOLDER" => std::option::Option::Some(Self::FOLDER),
                    "ORGANIZATION" => std::option::Option::Some(Self::ORGANIZATION),
                    "SERVICE_SPECIFIC" => std::option::Option::Some(Self::SERVICE_SPECIFIC),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for ConsumerType {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for ConsumerType {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }
}

/// Request message for the Report method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReportRequest {
    /// The service name as specified in its service configuration. For example,
    /// `"pubsub.googleapis.com"`.
    ///
    /// See
    /// [google.api.Service](https://cloud.google.com/service-management/reference/rpc/google.api#google.api.Service)
    /// for the definition of a service name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// Operations to be reported.
    ///
    /// Typically the service should report one operation per request.
    /// Putting multiple operations into a single request is allowed, but should
    /// be used only when multiple operations are natually available at the time
    /// of the report.
    ///
    /// There is no limit on the number of operations in the same ReportRequest,
    /// however the ReportRequest size should be no larger than 1MB. See
    /// [ReportResponse.report_errors][google.api.servicecontrol.v1.ReportResponse.report_errors]
    /// for partial failure behavior.
    ///
    /// [google.api.servicecontrol.v1.ReportResponse.report_errors]: crate::model::ReportResponse::report_errors
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub operations: std::vec::Vec<crate::model::Operation>,

    /// Specifies which version of service config should be used to process the
    /// request.
    ///
    /// If unspecified or no matching version can be found, the
    /// latest one will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_config_id: std::string::String,
}

impl ReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::ReportRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [service_config_id][crate::model::ReportRequest::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }

    /// Sets the value of [operations][crate::model::ReportRequest::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.ReportRequest"
    }
}

/// Response message for the Report method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReportResponse {
    /// Partial failures, one for each `Operation` in the request that failed
    /// processing. There are three possible combinations of the RPC status:
    ///
    /// . The combination of a successful RPC status and an empty `report_errors`
    ///   list indicates a complete success where all `Operations` in the
    ///   request are processed successfully.
    /// . The combination of a successful RPC status and a non-empty
    ///   `report_errors` list indicates a partial success where some
    ///   `Operations` in the request succeeded. Each
    ///   `Operation` that failed processing has a corresponding item
    ///   in this list.
    /// . A failed RPC status indicates a general non-deterministic failure.
    ///   When this happens, it's impossible to know which of the
    ///   'Operations' in the request succeeded or failed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub report_errors: std::vec::Vec<crate::model::report_response::ReportError>,

    /// The actual config id used to process the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_config_id: std::string::String,

    /// The current service rollout id used to process the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_rollout_id: std::string::String,
}

impl ReportResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_config_id][crate::model::ReportResponse::service_config_id].
    pub fn set_service_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config_id = v.into();
        self
    }

    /// Sets the value of [service_rollout_id][crate::model::ReportResponse::service_rollout_id].
    pub fn set_service_rollout_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_rollout_id = v.into();
        self
    }

    /// Sets the value of [report_errors][crate::model::ReportResponse::report_errors].
    pub fn set_report_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::report_response::ReportError>,
    {
        use std::iter::Iterator;
        self.report_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReportResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicecontrol.v1.ReportResponse"
    }
}

/// Defines additional types related to ReportResponse
pub mod report_response {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the processing error of one
    /// [Operation][google.api.servicecontrol.v1.Operation] in the request.
    ///
    /// [google.api.servicecontrol.v1.Operation]: crate::model::Operation
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ReportError {
        /// The
        /// [Operation.operation_id][google.api.servicecontrol.v1.Operation.operation_id]
        /// value from the request.
        ///
        /// [google.api.servicecontrol.v1.Operation.operation_id]: crate::model::Operation::operation_id
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub operation_id: std::string::String,

        /// Details of the error when processing the
        /// [Operation][google.api.servicecontrol.v1.Operation].
        ///
        /// [google.api.servicecontrol.v1.Operation]: crate::model::Operation
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub status: std::option::Option<rpc::model::Status>,
    }

    impl ReportError {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation_id][crate::model::report_response::ReportError::operation_id].
        pub fn set_operation_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.operation_id = v.into();
            self
        }

        /// Sets the value of [status][crate::model::report_response::ReportError::status].
        pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }
    }

    impl wkt::message::Message for ReportError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicecontrol.v1.ReportResponse.ReportError"
        }
    }
}
