// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::CheckError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckError");
        debug_struct.field("code", &self.code);
        debug_struct.field("subject", &self.subject);
        debug_struct.field("detail", &self.detail);
        debug_struct.field("status", &self.status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Distribution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Distribution");
        debug_struct.field("count", &self.count);
        debug_struct.field("mean", &self.mean);
        debug_struct.field("minimum", &self.minimum);
        debug_struct.field("maximum", &self.maximum);
        debug_struct.field("sum_of_squared_deviation", &self.sum_of_squared_deviation);
        debug_struct.field("bucket_counts", &self.bucket_counts);
        debug_struct.field("exemplars", &self.exemplars);
        debug_struct.field("bucket_option", &self.bucket_option);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::distribution::LinearBuckets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LinearBuckets");
        debug_struct.field("num_finite_buckets", &self.num_finite_buckets);
        debug_struct.field("width", &self.width);
        debug_struct.field("offset", &self.offset);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::distribution::ExponentialBuckets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExponentialBuckets");
        debug_struct.field("num_finite_buckets", &self.num_finite_buckets);
        debug_struct.field("growth_factor", &self.growth_factor);
        debug_struct.field("scale", &self.scale);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::distribution::ExplicitBuckets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExplicitBuckets");
        debug_struct.field("bounds", &self.bounds);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HttpRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpRequest");
        debug_struct.field("request_method", &self.request_method);
        debug_struct.field("request_url", &self.request_url);
        debug_struct.field("request_size", &self.request_size);
        debug_struct.field("status", &self.status);
        debug_struct.field("response_size", &self.response_size);
        debug_struct.field("user_agent", &self.user_agent);
        debug_struct.field("remote_ip", &self.remote_ip);
        debug_struct.field("server_ip", &self.server_ip);
        debug_struct.field("referer", &self.referer);
        debug_struct.field("latency", &self.latency);
        debug_struct.field("cache_lookup", &self.cache_lookup);
        debug_struct.field("cache_hit", &self.cache_hit);
        debug_struct.field(
            "cache_validated_with_origin_server",
            &self.cache_validated_with_origin_server,
        );
        debug_struct.field("cache_fill_bytes", &self.cache_fill_bytes);
        debug_struct.field("protocol", &self.protocol);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LogEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LogEntry");
        debug_struct.field("name", &self.name);
        debug_struct.field("timestamp", &self.timestamp);
        debug_struct.field("severity", &self.severity);
        debug_struct.field("http_request", &self.http_request);
        debug_struct.field("trace", &self.trace);
        debug_struct.field("insert_id", &self.insert_id);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("operation", &self.operation);
        debug_struct.field("source_location", &self.source_location);
        debug_struct.field("payload", &self.payload);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LogEntryOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LogEntryOperation");
        debug_struct.field("id", &self.id);
        debug_struct.field("producer", &self.producer);
        debug_struct.field("first", &self.first);
        debug_struct.field("last", &self.last);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LogEntrySourceLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LogEntrySourceLocation");
        debug_struct.field("file", &self.file);
        debug_struct.field("line", &self.line);
        debug_struct.field("function", &self.function);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MetricValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MetricValue");
        debug_struct.field("labels", &self.labels);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("value", &self.value);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MetricValueSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MetricValueSet");
        debug_struct.field("metric_name", &self.metric_name);
        debug_struct.field("metric_values", &self.metric_values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Operation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Operation");
        debug_struct.field("operation_id", &self.operation_id);
        debug_struct.field("operation_name", &self.operation_name);
        debug_struct.field("consumer_id", &self.consumer_id);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("metric_value_sets", &self.metric_value_sets);
        debug_struct.field("log_entries", &self.log_entries);
        debug_struct.field("importance", &self.importance);
        debug_struct.field("extensions", &self.extensions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AllocateQuotaRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AllocateQuotaRequest");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("allocate_operation", &self.allocate_operation);
        debug_struct.field("service_config_id", &self.service_config_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::QuotaOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QuotaOperation");
        debug_struct.field("operation_id", &self.operation_id);
        debug_struct.field("method_name", &self.method_name);
        debug_struct.field("consumer_id", &self.consumer_id);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("quota_metrics", &self.quota_metrics);
        debug_struct.field("quota_mode", &self.quota_mode);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AllocateQuotaResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AllocateQuotaResponse");
        debug_struct.field("operation_id", &self.operation_id);
        debug_struct.field("allocate_errors", &self.allocate_errors);
        debug_struct.field("quota_metrics", &self.quota_metrics);
        debug_struct.field("service_config_id", &self.service_config_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::QuotaError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QuotaError");
        debug_struct.field("code", &self.code);
        debug_struct.field("subject", &self.subject);
        debug_struct.field("description", &self.description);
        debug_struct.field("status", &self.status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CheckRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckRequest");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("operation", &self.operation);
        debug_struct.field("service_config_id", &self.service_config_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CheckResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckResponse");
        debug_struct.field("operation_id", &self.operation_id);
        debug_struct.field("check_errors", &self.check_errors);
        debug_struct.field("service_config_id", &self.service_config_id);
        debug_struct.field("service_rollout_id", &self.service_rollout_id);
        debug_struct.field("check_info", &self.check_info);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::check_response::CheckInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckInfo");
        debug_struct.field("unused_arguments", &self.unused_arguments);
        debug_struct.field("consumer_info", &self.consumer_info);
        debug_struct.field("api_key_uid", &self.api_key_uid);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::check_response::ConsumerInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConsumerInfo");
        debug_struct.field("project_number", &self.project_number);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("consumer_number", &self.consumer_number);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReportRequest");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("operations", &self.operations);
        debug_struct.field("service_config_id", &self.service_config_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ReportResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReportResponse");
        debug_struct.field("report_errors", &self.report_errors);
        debug_struct.field("service_config_id", &self.service_config_id);
        debug_struct.field("service_rollout_id", &self.service_rollout_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::report_response::ReportError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReportError");
        debug_struct.field("operation_id", &self.operation_id);
        debug_struct.field("status", &self.status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
