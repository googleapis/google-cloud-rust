// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::Authentication {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Authentication");
        debug_struct.field("rules", &self.rules);
        debug_struct.field("providers", &self.providers);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AuthenticationRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthenticationRule");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("oauth", &self.oauth);
        debug_struct.field("allow_without_credential", &self.allow_without_credential);
        debug_struct.field("requirements", &self.requirements);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JwtLocation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JwtLocation");
        debug_struct.field("value_prefix", &self.value_prefix);
        debug_struct.field("r#in", &self.r#in);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AuthProvider {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthProvider");
        debug_struct.field("id", &self.id);
        debug_struct.field("issuer", &self.issuer);
        debug_struct.field("jwks_uri", &self.jwks_uri);
        debug_struct.field("audiences", &self.audiences);
        debug_struct.field("authorization_url", &self.authorization_url);
        debug_struct.field("jwt_locations", &self.jwt_locations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OAuthRequirements {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OAuthRequirements");
        debug_struct.field("canonical_scopes", &self.canonical_scopes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AuthRequirement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AuthRequirement");
        debug_struct.field("provider_id", &self.provider_id);
        debug_struct.field("audiences", &self.audiences);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Backend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Backend");
        debug_struct.field("rules", &self.rules);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BackendRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackendRule");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("address", &self.address);
        debug_struct.field("deadline", &self.deadline);
        debug_struct.field("min_deadline", &self.min_deadline);
        debug_struct.field("operation_deadline", &self.operation_deadline);
        debug_struct.field("path_translation", &self.path_translation);
        debug_struct.field("protocol", &self.protocol);
        debug_struct.field(
            "overrides_by_request_protocol",
            &self.overrides_by_request_protocol,
        );
        debug_struct.field("authentication", &self.authentication);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Billing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Billing");
        debug_struct.field("consumer_destinations", &self.consumer_destinations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::billing::BillingDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BillingDestination");
        debug_struct.field("monitored_resource", &self.monitored_resource);
        debug_struct.field("metrics", &self.metrics);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CommonLanguageSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CommonLanguageSettings");
        debug_struct.field("reference_docs_uri", &self.reference_docs_uri);
        debug_struct.field("destinations", &self.destinations);
        debug_struct.field(
            "selective_gapic_generation",
            &self.selective_gapic_generation,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ClientLibrarySettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClientLibrarySettings");
        debug_struct.field("version", &self.version);
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("rest_numeric_enums", &self.rest_numeric_enums);
        debug_struct.field("java_settings", &self.java_settings);
        debug_struct.field("cpp_settings", &self.cpp_settings);
        debug_struct.field("php_settings", &self.php_settings);
        debug_struct.field("python_settings", &self.python_settings);
        debug_struct.field("node_settings", &self.node_settings);
        debug_struct.field("dotnet_settings", &self.dotnet_settings);
        debug_struct.field("ruby_settings", &self.ruby_settings);
        debug_struct.field("go_settings", &self.go_settings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Publishing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Publishing");
        debug_struct.field("method_settings", &self.method_settings);
        debug_struct.field("new_issue_uri", &self.new_issue_uri);
        debug_struct.field("documentation_uri", &self.documentation_uri);
        debug_struct.field("api_short_name", &self.api_short_name);
        debug_struct.field("github_label", &self.github_label);
        debug_struct.field("codeowner_github_teams", &self.codeowner_github_teams);
        debug_struct.field("doc_tag_prefix", &self.doc_tag_prefix);
        debug_struct.field("organization", &self.organization);
        debug_struct.field("library_settings", &self.library_settings);
        debug_struct.field(
            "proto_reference_documentation_uri",
            &self.proto_reference_documentation_uri,
        );
        debug_struct.field(
            "rest_reference_documentation_uri",
            &self.rest_reference_documentation_uri,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::JavaSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("JavaSettings");
        debug_struct.field("library_package", &self.library_package);
        debug_struct.field("service_class_names", &self.service_class_names);
        debug_struct.field("common", &self.common);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CppSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CppSettings");
        debug_struct.field("common", &self.common);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PhpSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PhpSettings");
        debug_struct.field("common", &self.common);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::PythonSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PythonSettings");
        debug_struct.field("common", &self.common);
        debug_struct.field("experimental_features", &self.experimental_features);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::python_settings::ExperimentalFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExperimentalFeatures");
        debug_struct.field("rest_async_io_enabled", &self.rest_async_io_enabled);
        debug_struct.field(
            "protobuf_pythonic_types_enabled",
            &self.protobuf_pythonic_types_enabled,
        );
        debug_struct.field(
            "unversioned_package_disabled",
            &self.unversioned_package_disabled,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::NodeSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodeSettings");
        debug_struct.field("common", &self.common);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DotnetSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DotnetSettings");
        debug_struct.field("common", &self.common);
        debug_struct.field("renamed_services", &self.renamed_services);
        debug_struct.field("renamed_resources", &self.renamed_resources);
        debug_struct.field("ignored_resources", &self.ignored_resources);
        debug_struct.field("forced_namespace_aliases", &self.forced_namespace_aliases);
        debug_struct.field("handwritten_signatures", &self.handwritten_signatures);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RubySettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RubySettings");
        debug_struct.field("common", &self.common);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GoSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GoSettings");
        debug_struct.field("common", &self.common);
        debug_struct.field("renamed_services", &self.renamed_services);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MethodSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MethodSettings");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("long_running", &self.long_running);
        debug_struct.field("auto_populated_fields", &self.auto_populated_fields);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::method_settings::LongRunning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LongRunning");
        debug_struct.field("initial_poll_delay", &self.initial_poll_delay);
        debug_struct.field("poll_delay_multiplier", &self.poll_delay_multiplier);
        debug_struct.field("max_poll_delay", &self.max_poll_delay);
        debug_struct.field("total_poll_timeout", &self.total_poll_timeout);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SelectiveGapicGeneration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SelectiveGapicGeneration");
        debug_struct.field("methods", &self.methods);
        debug_struct.field(
            "generate_omitted_as_internal",
            &self.generate_omitted_as_internal,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ConfigChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigChange");
        debug_struct.field("element", &self.element);
        debug_struct.field("old_value", &self.old_value);
        debug_struct.field("new_value", &self.new_value);
        debug_struct.field("change_type", &self.change_type);
        debug_struct.field("advices", &self.advices);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Advice {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Advice");
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ProjectProperties {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProjectProperties");
        debug_struct.field("properties", &self.properties);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Property {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Property");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Context {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Context");
        debug_struct.field("rules", &self.rules);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ContextRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ContextRule");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("requested", &self.requested);
        debug_struct.field("provided", &self.provided);
        debug_struct.field(
            "allowed_request_extensions",
            &self.allowed_request_extensions,
        );
        debug_struct.field(
            "allowed_response_extensions",
            &self.allowed_response_extensions,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Control {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Control");
        debug_struct.field("environment", &self.environment);
        debug_struct.field("method_policies", &self.method_policies);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Distribution {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Distribution");
        debug_struct.field("count", &self.count);
        debug_struct.field("mean", &self.mean);
        debug_struct.field("sum_of_squared_deviation", &self.sum_of_squared_deviation);
        debug_struct.field("range", &self.range);
        debug_struct.field("bucket_options", &self.bucket_options);
        debug_struct.field("bucket_counts", &self.bucket_counts);
        debug_struct.field("exemplars", &self.exemplars);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::distribution::Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Range");
        debug_struct.field("min", &self.min);
        debug_struct.field("max", &self.max);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::distribution::BucketOptions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BucketOptions");
        debug_struct.field("options", &self.options);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::distribution::bucket_options::Linear {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Linear");
        debug_struct.field("num_finite_buckets", &self.num_finite_buckets);
        debug_struct.field("width", &self.width);
        debug_struct.field("offset", &self.offset);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::distribution::bucket_options::Exponential {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Exponential");
        debug_struct.field("num_finite_buckets", &self.num_finite_buckets);
        debug_struct.field("growth_factor", &self.growth_factor);
        debug_struct.field("scale", &self.scale);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::distribution::bucket_options::Explicit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Explicit");
        debug_struct.field("bounds", &self.bounds);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::distribution::Exemplar {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Exemplar");
        debug_struct.field("value", &self.value);
        debug_struct.field("timestamp", &self.timestamp);
        debug_struct.field("attachments", &self.attachments);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Documentation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Documentation");
        debug_struct.field("summary", &self.summary);
        debug_struct.field("pages", &self.pages);
        debug_struct.field("rules", &self.rules);
        debug_struct.field("documentation_root_url", &self.documentation_root_url);
        debug_struct.field("service_root_url", &self.service_root_url);
        debug_struct.field("overview", &self.overview);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DocumentationRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DocumentationRule");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("description", &self.description);
        debug_struct.field("deprecation_description", &self.deprecation_description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Page {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Page");
        debug_struct.field("name", &self.name);
        debug_struct.field("content", &self.content);
        debug_struct.field("subpages", &self.subpages);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Endpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Endpoint");
        debug_struct.field("name", &self.name);
        debug_struct.field("aliases", &self.aliases);
        debug_struct.field("target", &self.target);
        debug_struct.field("allow_cors", &self.allow_cors);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FieldInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FieldInfo");
        debug_struct.field("format", &self.format);
        debug_struct.field("referenced_types", &self.referenced_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::TypeReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TypeReference");
        debug_struct.field("type_name", &self.type_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Http {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Http");
        debug_struct.field("rules", &self.rules);
        debug_struct.field(
            "fully_decode_reserved_expansion",
            &self.fully_decode_reserved_expansion,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HttpRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpRule");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("body", &self.body);
        debug_struct.field("response_body", &self.response_body);
        debug_struct.field("additional_bindings", &self.additional_bindings);
        debug_struct.field("pattern", &self.pattern);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CustomHttpPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CustomHttpPattern");
        debug_struct.field("kind", &self.kind);
        debug_struct.field("path", &self.path);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::HttpBody {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("HttpBody");
        debug_struct.field("content_type", &self.content_type);
        debug_struct.field("data", &self.data);
        debug_struct.field("extensions", &self.extensions);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LabelDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LabelDescriptor");
        debug_struct.field("key", &self.key);
        debug_struct.field("value_type", &self.value_type);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LogDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LogDescriptor");
        debug_struct.field("name", &self.name);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("description", &self.description);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Logging {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Logging");
        debug_struct.field("producer_destinations", &self.producer_destinations);
        debug_struct.field("consumer_destinations", &self.consumer_destinations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::logging::LoggingDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoggingDestination");
        debug_struct.field("monitored_resource", &self.monitored_resource);
        debug_struct.field("logs", &self.logs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MetricDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MetricDescriptor");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("metric_kind", &self.metric_kind);
        debug_struct.field("value_type", &self.value_type);
        debug_struct.field("unit", &self.unit);
        debug_struct.field("description", &self.description);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("monitored_resource_types", &self.monitored_resource_types);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::metric_descriptor::MetricDescriptorMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MetricDescriptorMetadata");
        debug_struct.field("launch_stage", &self.launch_stage);
        debug_struct.field("sample_period", &self.sample_period);
        debug_struct.field("ingest_delay", &self.ingest_delay);
        debug_struct.field(
            "time_series_resource_hierarchy_level",
            &self.time_series_resource_hierarchy_level,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Metric {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Metric");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MonitoredResourceDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MonitoredResourceDescriptor");
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("launch_stage", &self.launch_stage);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MonitoredResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MonitoredResource");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("labels", &self.labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MonitoredResourceMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MonitoredResourceMetadata");
        debug_struct.field("system_labels", &self.system_labels);
        debug_struct.field("user_labels", &self.user_labels);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Monitoring {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Monitoring");
        debug_struct.field("producer_destinations", &self.producer_destinations);
        debug_struct.field("consumer_destinations", &self.consumer_destinations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::monitoring::MonitoringDestination {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MonitoringDestination");
        debug_struct.field("monitored_resource", &self.monitored_resource);
        debug_struct.field("metrics", &self.metrics);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FieldPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FieldPolicy");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("resource_permission", &self.resource_permission);
        debug_struct.field("resource_type", &self.resource_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MethodPolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MethodPolicy");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("request_policies", &self.request_policies);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Quota {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Quota");
        debug_struct.field("limits", &self.limits);
        debug_struct.field("metric_rules", &self.metric_rules);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::MetricRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MetricRule");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("metric_costs", &self.metric_costs);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::QuotaLimit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("QuotaLimit");
        debug_struct.field("name", &self.name);
        debug_struct.field("description", &self.description);
        debug_struct.field("default_limit", &self.default_limit);
        debug_struct.field("max_limit", &self.max_limit);
        debug_struct.field("free_tier", &self.free_tier);
        debug_struct.field("duration", &self.duration);
        debug_struct.field("metric", &self.metric);
        debug_struct.field("unit", &self.unit);
        debug_struct.field("values", &self.values);
        debug_struct.field("display_name", &self.display_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ResourceDescriptor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceDescriptor");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("pattern", &self.pattern);
        debug_struct.field("name_field", &self.name_field);
        debug_struct.field("history", &self.history);
        debug_struct.field("plural", &self.plural);
        debug_struct.field("singular", &self.singular);
        debug_struct.field("style", &self.style);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ResourceReference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResourceReference");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("child_type", &self.child_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RoutingRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RoutingRule");
        debug_struct.field("routing_parameters", &self.routing_parameters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::RoutingParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RoutingParameter");
        debug_struct.field("field", &self.field);
        debug_struct.field("path_template", &self.path_template);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Service {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Service");
        debug_struct.field("name", &self.name);
        debug_struct.field("title", &self.title);
        debug_struct.field("producer_project_id", &self.producer_project_id);
        debug_struct.field("id", &self.id);
        debug_struct.field("apis", &self.apis);
        debug_struct.field("types", &self.types);
        debug_struct.field("enums", &self.enums);
        debug_struct.field("documentation", &self.documentation);
        debug_struct.field("backend", &self.backend);
        debug_struct.field("http", &self.http);
        debug_struct.field("quota", &self.quota);
        debug_struct.field("authentication", &self.authentication);
        debug_struct.field("context", &self.context);
        debug_struct.field("usage", &self.usage);
        debug_struct.field("endpoints", &self.endpoints);
        debug_struct.field("control", &self.control);
        debug_struct.field("logs", &self.logs);
        debug_struct.field("metrics", &self.metrics);
        debug_struct.field("monitored_resources", &self.monitored_resources);
        debug_struct.field("billing", &self.billing);
        debug_struct.field("logging", &self.logging);
        debug_struct.field("monitoring", &self.monitoring);
        debug_struct.field("system_parameters", &self.system_parameters);
        debug_struct.field("source_info", &self.source_info);
        debug_struct.field("publishing", &self.publishing);
        debug_struct.field("config_version", &self.config_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SourceInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceInfo");
        debug_struct.field("source_files", &self.source_files);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SystemParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SystemParameters");
        debug_struct.field("rules", &self.rules);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SystemParameterRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SystemParameterRule");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("parameters", &self.parameters);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::SystemParameter {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SystemParameter");
        debug_struct.field("name", &self.name);
        debug_struct.field("http_header", &self.http_header);
        debug_struct.field("url_query_parameter", &self.url_query_parameter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Usage {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Usage");
        debug_struct.field("requirements", &self.requirements);
        debug_struct.field("rules", &self.rules);
        debug_struct.field(
            "producer_notification_channel",
            &self.producer_notification_channel,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UsageRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UsageRule");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("allow_unregistered_calls", &self.allow_unregistered_calls);
        debug_struct.field("skip_service_control", &self.skip_service_control);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Visibility {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Visibility");
        debug_struct.field("rules", &self.rules);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::VisibilityRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VisibilityRule");
        debug_struct.field("selector", &self.selector);
        debug_struct.field("restriction", &self.restriction);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
