// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The full representation of a Service that is managed by
/// Google Service Management.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManagedService {
    /// The name of the service. See the
    /// [overview](https://cloud.google.com/service-infrastructure/docs/overview)
    /// for naming requirements.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// ID of the project that produces and owns this service.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub producer_project_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedService {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::ManagedService::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [producer_project_id][crate::model::ManagedService::producer_project_id].
    pub fn set_producer_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.producer_project_id = v.into();
        self
    }
}

impl wkt::message::Message for ManagedService {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ManagedService"
    }
}

/// The metadata associated with a long running operation resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The full name of the resources that this operation is directly
    /// associated with.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub resource_names: std::vec::Vec<std::string::String>,

    /// Detailed status information for each step. The order is undetermined.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub steps: std::vec::Vec<crate::model::operation_metadata::Step>,

    /// Percentage of completion of this operation, ranging from 0 to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub progress_percentage: i32,

    /// The start time of the operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_names][crate::model::OperationMetadata::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [steps][crate::model::OperationMetadata::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::operation_metadata::Step>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [progress_percentage][crate::model::OperationMetadata::progress_percentage].
    pub fn set_progress_percentage<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percentage = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::OperationMetadata::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.OperationMetadata"
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the status of one operation step.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Step {
        /// The short description of the step.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,

        /// The status code.
        pub status: crate::model::operation_metadata::Status,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Step {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [description][crate::model::operation_metadata::Step::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [status][crate::model::operation_metadata::Step::status].
        pub fn set_status<T: std::convert::Into<crate::model::operation_metadata::Status>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }
    }

    impl wkt::message::Message for Step {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicemanagement.v1.OperationMetadata.Step"
        }
    }

    /// Code describes the status of the operation (or one of its steps).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Unspecifed code.
        Unspecified,
        /// The operation or step has completed without errors.
        Done,
        /// The operation or step has not started yet.
        NotStarted,
        /// The operation or step is in progress.
        InProgress,
        /// The operation or step has completed with errors. If the operation is
        /// rollbackable, the rollback completed with errors too.
        Failed,
        /// The operation or step has completed with cancellation.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Done => std::option::Option::Some(1),
                Self::NotStarted => std::option::Option::Some(2),
                Self::InProgress => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Done,
                2 => Self::NotStarted,
                3 => Self::InProgress,
                4 => Self::Failed,
                5 => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "DONE" => Self::Done,
                "NOT_STARTED" => Self::NotStarted,
                "IN_PROGRESS" => Self::InProgress,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Done => serializer.serialize_i32(1),
                Self::NotStarted => serializer.serialize_i32(2),
                Self::InProgress => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.api.servicemanagement.v1.OperationMetadata.Status",
            ))
        }
    }
}

/// Represents a diagnostic message (error or warning)
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Diagnostic {
    /// File name and line number of the error or warning.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub location: std::string::String,

    /// The kind of diagnostic information provided.
    pub kind: crate::model::diagnostic::Kind,

    /// Message describing the error or warning.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Diagnostic {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::Diagnostic::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Diagnostic::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::diagnostic::Kind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [message][crate::model::Diagnostic::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for Diagnostic {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.Diagnostic"
    }
}

/// Defines additional types related to [Diagnostic].
pub mod diagnostic {
    #[allow(unused_imports)]
    use super::*;

    /// The kind of diagnostic information possible.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// Warnings and errors
        Warning,
        /// Only errors
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Kind::value] or
        /// [Kind::name].
        UnknownValue(kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Kind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Warning => std::option::Option::Some(0),
                Self::Error => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Kind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Kind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Kind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Warning,
                1 => Self::Error,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Kind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Kind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Warning => serializer.serialize_i32(0),
                Self::Error => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Kind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Kind>::new(
                ".google.api.servicemanagement.v1.Diagnostic.Kind",
            ))
        }
    }
}

/// Represents a source file which is used to generate the service configuration
/// defined by `google.api.Service`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigSource {
    /// A unique ID for a specific instance of this message, typically assigned
    /// by the client for tracking purpose. If empty, the server may choose to
    /// generate one instead.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Set of source configuration files that are used to generate a service
    /// configuration (`google.api.Service`).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub files: std::vec::Vec<crate::model::ConfigFile>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::ConfigSource::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [files][crate::model::ConfigSource::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigFile>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConfigSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ConfigSource"
    }
}

/// Generic specification of a source configuration file
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigFile {
    /// The file name of the configuration file (full or relative path).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_path: std::string::String,

    /// The bytes that constitute the file.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub file_contents: ::bytes::Bytes,

    /// The type of configuration file this represents.
    pub file_type: crate::model::config_file::FileType,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_path][crate::model::ConfigFile::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }

    /// Sets the value of [file_contents][crate::model::ConfigFile::file_contents].
    pub fn set_file_contents<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.file_contents = v.into();
        self
    }

    /// Sets the value of [file_type][crate::model::ConfigFile::file_type].
    pub fn set_file_type<T: std::convert::Into<crate::model::config_file::FileType>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_type = v.into();
        self
    }
}

impl wkt::message::Message for ConfigFile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ConfigFile"
    }
}

/// Defines additional types related to [ConfigFile].
pub mod config_file {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FileType {
        /// Unknown file type.
        Unspecified,
        /// YAML-specification of service.
        ServiceConfigYaml,
        /// OpenAPI specification, serialized in JSON.
        OpenApiJson,
        /// OpenAPI specification, serialized in YAML.
        OpenApiYaml,
        /// FileDescriptorSet, generated by protoc.
        ///
        /// To generate, use protoc with imports and source info included.
        /// For an example test.proto file, the following command would put the value
        /// in a new file named out.pb.
        ///
        /// $protoc --include_imports --include_source_info test.proto -o out.pb
        FileDescriptorSetProto,
        /// Uncompiled Proto file. Used for storage and display purposes only,
        /// currently server-side compilation is not supported. Should match the
        /// inputs to 'protoc' command used to generated FILE_DESCRIPTOR_SET_PROTO. A
        /// file of this type can only be included if at least one file of type
        /// FILE_DESCRIPTOR_SET_PROTO is included.
        ProtoFile,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FileType::value] or
        /// [FileType::name].
        UnknownValue(file_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod file_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FileType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ServiceConfigYaml => std::option::Option::Some(1),
                Self::OpenApiJson => std::option::Option::Some(2),
                Self::OpenApiYaml => std::option::Option::Some(3),
                Self::FileDescriptorSetProto => std::option::Option::Some(4),
                Self::ProtoFile => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FILE_TYPE_UNSPECIFIED"),
                Self::ServiceConfigYaml => std::option::Option::Some("SERVICE_CONFIG_YAML"),
                Self::OpenApiJson => std::option::Option::Some("OPEN_API_JSON"),
                Self::OpenApiYaml => std::option::Option::Some("OPEN_API_YAML"),
                Self::FileDescriptorSetProto => {
                    std::option::Option::Some("FILE_DESCRIPTOR_SET_PROTO")
                }
                Self::ProtoFile => std::option::Option::Some("PROTO_FILE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FileType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FileType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FileType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ServiceConfigYaml,
                2 => Self::OpenApiJson,
                3 => Self::OpenApiYaml,
                4 => Self::FileDescriptorSetProto,
                6 => Self::ProtoFile,
                _ => Self::UnknownValue(file_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FileType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FILE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SERVICE_CONFIG_YAML" => Self::ServiceConfigYaml,
                "OPEN_API_JSON" => Self::OpenApiJson,
                "OPEN_API_YAML" => Self::OpenApiYaml,
                "FILE_DESCRIPTOR_SET_PROTO" => Self::FileDescriptorSetProto,
                "PROTO_FILE" => Self::ProtoFile,
                _ => Self::UnknownValue(file_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FileType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ServiceConfigYaml => serializer.serialize_i32(1),
                Self::OpenApiJson => serializer.serialize_i32(2),
                Self::OpenApiYaml => serializer.serialize_i32(3),
                Self::FileDescriptorSetProto => serializer.serialize_i32(4),
                Self::ProtoFile => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FileType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FileType>::new(
                ".google.api.servicemanagement.v1.ConfigFile.FileType",
            ))
        }
    }
}

/// Represents a service configuration with its name and id.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigRef {
    /// Resource name of a service config. It must have the following
    /// format: "services/{service name}/configs/{config id}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigRef {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConfigRef::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ConfigRef {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ConfigRef"
    }
}

/// Change report associated with a particular service configuration.
///
/// It contains a list of ConfigChanges based on the comparison between
/// two service configurations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ChangeReport {
    /// List of changes between two service configurations.
    /// The changes will be alphabetically sorted based on the identifier
    /// of each change.
    /// A ConfigChange identifier is a dot separated path to the configuration.
    /// Example: visibility.rules[selector='LibraryService.CreateBook'].restriction
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub config_changes: std::vec::Vec<api::model::ConfigChange>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChangeReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config_changes][crate::model::ChangeReport::config_changes].
    pub fn set_config_changes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::ConfigChange>,
    {
        use std::iter::Iterator;
        self.config_changes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ChangeReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ChangeReport"
    }
}

/// A rollout resource that defines how service configuration versions are pushed
/// to control plane systems. Typically, you create a new version of the
/// service config, and then create a Rollout to push the service config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Rollout {
    /// Optional. Unique identifier of this Rollout. Must be no longer than 63
    /// characters and only lower case letters, digits, '.', '_' and '-' are
    /// allowed.
    ///
    /// If not specified by client, the server will generate one. The generated id
    /// will have the form of \<date\>\<revision number\>, where "date" is the create
    /// date in ISO 8601 format.  "revision number" is a monotonically increasing
    /// positive number that is reset every day for each service.
    /// An example of the generated rollout_id is '2016-02-16r1'
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rollout_id: std::string::String,

    /// Creation time of the rollout. Readonly.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The user who created the Rollout. Readonly.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub created_by: std::string::String,

    /// The status of this rollout. Readonly. In case of a failed rollout,
    /// the system will automatically rollback to the current Rollout
    /// version. Readonly.
    pub status: crate::model::rollout::RolloutStatus,

    /// The name of the service associated with this Rollout.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// Strategy that defines which versions of service configurations should be
    /// pushed
    /// and how they should be used at runtime.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub strategy: std::option::Option<crate::model::rollout::Strategy>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rollout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout_id][crate::model::Rollout::rollout_id].
    pub fn set_rollout_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Rollout::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [created_by][crate::model::Rollout::created_by].
    pub fn set_created_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.created_by = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Rollout::status].
    pub fn set_status<T: std::convert::Into<crate::model::rollout::RolloutStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [service_name][crate::model::Rollout::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [strategy][crate::model::Rollout::strategy].
    ///
    /// Note that all the setters affecting `strategy` are mutually
    /// exclusive.
    pub fn set_strategy<
        T: std::convert::Into<std::option::Option<crate::model::rollout::Strategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.strategy = v.into();
        self
    }

    /// The value of [strategy][crate::model::Rollout::strategy]
    /// if it holds a `TrafficPercentStrategy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn traffic_percent_strategy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rollout::TrafficPercentStrategy>> {
        #[allow(unreachable_patterns)]
        self.strategy.as_ref().and_then(|v| match v {
            crate::model::rollout::Strategy::TrafficPercentStrategy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [strategy][crate::model::Rollout::strategy]
    /// to hold a `TrafficPercentStrategy`.
    ///
    /// Note that all the setters affecting `strategy` are
    /// mutually exclusive.
    pub fn set_traffic_percent_strategy<
        T: std::convert::Into<std::boxed::Box<crate::model::rollout::TrafficPercentStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.strategy = std::option::Option::Some(
            crate::model::rollout::Strategy::TrafficPercentStrategy(v.into()),
        );
        self
    }

    /// The value of [strategy][crate::model::Rollout::strategy]
    /// if it holds a `DeleteServiceStrategy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_service_strategy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rollout::DeleteServiceStrategy>> {
        #[allow(unreachable_patterns)]
        self.strategy.as_ref().and_then(|v| match v {
            crate::model::rollout::Strategy::DeleteServiceStrategy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [strategy][crate::model::Rollout::strategy]
    /// to hold a `DeleteServiceStrategy`.
    ///
    /// Note that all the setters affecting `strategy` are
    /// mutually exclusive.
    pub fn set_delete_service_strategy<
        T: std::convert::Into<std::boxed::Box<crate::model::rollout::DeleteServiceStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.strategy = std::option::Option::Some(
            crate::model::rollout::Strategy::DeleteServiceStrategy(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Rollout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.Rollout"
    }
}

/// Defines additional types related to [Rollout].
pub mod rollout {
    #[allow(unused_imports)]
    use super::*;

    /// Strategy that specifies how clients of Google Service Controller want to
    /// send traffic to use different config versions. This is generally
    /// used by API proxy to split traffic based on your configured percentage for
    /// each config version.
    ///
    /// One example of how to gradually rollout a new service configuration using
    /// this
    /// strategy:
    /// Day 1
    ///
    /// ```norust
    /// Rollout {
    ///   id: "example.googleapis.com/rollout_20160206"
    ///   traffic_percent_strategy {
    ///     percentages: {
    ///       "example.googleapis.com/20160201": 70.00
    ///       "example.googleapis.com/20160206": 30.00
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// Day 2
    ///
    /// ```norust
    /// Rollout {
    ///   id: "example.googleapis.com/rollout_20160207"
    ///   traffic_percent_strategy: {
    ///     percentages: {
    ///       "example.googleapis.com/20160206": 100.00
    ///     }
    ///   }
    /// }
    /// ```
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct TrafficPercentStrategy {
        /// Maps service configuration IDs to their corresponding traffic percentage.
        /// Key is the service configuration ID, Value is the traffic percentage
        /// which must be greater than 0.0 and the sum must equal to 100.0.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        #[serde_as(as = "std::collections::HashMap<_, wkt::internal::F64>")]
        pub percentages: std::collections::HashMap<std::string::String, f64>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TrafficPercentStrategy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [percentages][crate::model::rollout::TrafficPercentStrategy::percentages].
        pub fn set_percentages<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<f64>,
        {
            use std::iter::Iterator;
            self.percentages = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for TrafficPercentStrategy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy"
        }
    }

    /// Strategy used to delete a service. This strategy is a placeholder only
    /// used by the system generated rollout to delete a service.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct DeleteServiceStrategy {
        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DeleteServiceStrategy {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for DeleteServiceStrategy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy"
        }
    }

    /// Status of a Rollout.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutStatus {
        /// No status specified.
        Unspecified,
        /// The Rollout is in progress.
        InProgress,
        /// The Rollout has completed successfully.
        Success,
        /// The Rollout has been cancelled. This can happen if you have overlapping
        /// Rollout pushes, and the previous ones will be cancelled.
        Cancelled,
        /// The Rollout has failed and the rollback attempt has failed too.
        Failed,
        /// The Rollout has not started yet and is pending for execution.
        Pending,
        /// The Rollout has failed and rolled back to the previous successful
        /// Rollout.
        FailedRolledBack,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutStatus::value] or
        /// [RolloutStatus::name].
        UnknownValue(rollout_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Success => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Pending => std::option::Option::Some(5),
                Self::FailedRolledBack => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLLOUT_STATUS_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::FailedRolledBack => std::option::Option::Some("FAILED_ROLLED_BACK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Success,
                3 => Self::Cancelled,
                4 => Self::Failed,
                5 => Self::Pending,
                6 => Self::FailedRolledBack,
                _ => Self::UnknownValue(rollout_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLLOUT_STATUS_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCESS" => Self::Success,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                "PENDING" => Self::Pending,
                "FAILED_ROLLED_BACK" => Self::FailedRolledBack,
                _ => Self::UnknownValue(rollout_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Success => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Pending => serializer.serialize_i32(5),
                Self::FailedRolledBack => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutStatus>::new(
                ".google.api.servicemanagement.v1.Rollout.RolloutStatus",
            ))
        }
    }

    /// Strategy that defines which versions of service configurations should be
    /// pushed
    /// and how they should be used at runtime.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Strategy {
        /// Google Service Control selects service configurations based on
        /// traffic percentage.
        TrafficPercentStrategy(std::boxed::Box<crate::model::rollout::TrafficPercentStrategy>),
        /// The strategy associated with a rollout to delete a `ManagedService`.
        /// Readonly.
        DeleteServiceStrategy(std::boxed::Box<crate::model::rollout::DeleteServiceStrategy>),
    }
}

/// Request message for `ListServices` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Include services produced by the specified project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub producer_project_id: std::string::String,

    /// The max number of items to include in the response list. Page size is 50
    /// if not specified. Maximum value is 500.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Token identifying which result to start with; returned by a previous list
    /// call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Include services consumed by the specified consumer.
    ///
    /// The Google Service Management implementation accepts the following
    /// forms:
    ///
    /// - project:<project_id>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    #[deprecated]
    pub consumer_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [producer_project_id][crate::model::ListServicesRequest::producer_project_id].
    pub fn set_producer_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.producer_project_id = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [consumer_id][crate::model::ListServicesRequest::consumer_id].
    #[deprecated]
    pub fn set_consumer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.consumer_id = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServicesRequest"
    }
}

/// Response message for `ListServices` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// The returned services will only have the name field set.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub services: std::vec::Vec<crate::model::ManagedService>,

    /// Token that can be passed to `ListServices` to resume a paginated query.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ManagedService>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServicesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::ManagedService;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for `GetService` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServiceRequest {
    /// Required. The name of the service.  See the `ServiceManager` overview for
    /// naming requirements.  For example: `example.googleapis.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::GetServiceRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.GetServiceRequest"
    }
}

/// Request message for CreateService method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateServiceRequest {
    /// Required. Initial values for the service resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::ManagedService>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::CreateServiceRequest::service].
    pub fn set_service<T: std::convert::Into<std::option::Option<crate::model::ManagedService>>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for CreateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.CreateServiceRequest"
    }
}

/// Request message for DeleteService method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteServiceRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::DeleteServiceRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.DeleteServiceRequest"
    }
}

/// Request message for UndeleteService method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeleteServiceRequest {
    /// Required. The name of the service. See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements. For example: `example.googleapis.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::UndeleteServiceRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.UndeleteServiceRequest"
    }
}

/// Response message for UndeleteService method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UndeleteServiceResponse {
    /// Revived service resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<crate::model::ManagedService>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteServiceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::UndeleteServiceResponse::service].
    pub fn set_service<T: std::convert::Into<std::option::Option<crate::model::ManagedService>>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteServiceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.UndeleteServiceResponse"
    }
}

/// Request message for GetServiceConfig method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServiceConfigRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// Required. The id of the service configuration resource.
    ///
    /// This field must be specified for the server to return all fields, including
    /// `SourceInfo`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub config_id: std::string::String,

    /// Specifies which parts of the Service Config should be returned in the
    /// response.
    pub view: crate::model::get_service_config_request::ConfigView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::GetServiceConfigRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [config_id][crate::model::GetServiceConfigRequest::config_id].
    pub fn set_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config_id = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetServiceConfigRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::get_service_config_request::ConfigView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.GetServiceConfigRequest"
    }
}

/// Defines additional types related to [GetServiceConfigRequest].
pub mod get_service_config_request {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConfigView {
        /// Server response includes all fields except SourceInfo.
        Basic,
        /// Server response includes all fields including SourceInfo.
        /// SourceFiles are of type 'google.api.servicemanagement.v1.ConfigFile'
        /// and are only available for configs created using the
        /// SubmitConfigSource method.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConfigView::value] or
        /// [ConfigView::name].
        UnknownValue(config_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod config_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConfigView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Basic => std::option::Option::Some(0),
                Self::Full => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConfigView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConfigView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConfigView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Basic,
                1 => Self::Full,
                _ => Self::UnknownValue(config_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConfigView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BASIC" => Self::Basic,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(config_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConfigView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Basic => serializer.serialize_i32(0),
                Self::Full => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConfigView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConfigView>::new(
                ".google.api.servicemanagement.v1.GetServiceConfigRequest.ConfigView",
            ))
        }
    }
}

/// Request message for ListServiceConfigs method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServiceConfigsRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// The token of the page to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The max number of items to include in the response list. Page size is 50
    /// if not specified. Maximum value is 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServiceConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::ListServiceConfigsRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServiceConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServiceConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListServiceConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServiceConfigsRequest"
    }
}

/// Response message for ListServiceConfigs method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServiceConfigsResponse {
    /// The list of service configuration resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_configs: std::vec::Vec<api::model::Service>,

    /// The token of the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServiceConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_configs][crate::model::ListServiceConfigsResponse::service_configs].
    pub fn set_service_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::Service>,
    {
        use std::iter::Iterator;
        self.service_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServiceConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServiceConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServiceConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServiceConfigsResponse {
    type PageItem = api::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.service_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for CreateServiceConfig method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateServiceConfigRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// Required. The service configuration resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_config: std::option::Option<api::model::Service>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServiceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::CreateServiceConfigRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [service_config][crate::model::CreateServiceConfigRequest::service_config].
    pub fn set_service_config<T: std::convert::Into<std::option::Option<api::model::Service>>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config = v.into();
        self
    }
}

impl wkt::message::Message for CreateServiceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.CreateServiceConfigRequest"
    }
}

/// Request message for SubmitConfigSource method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitConfigSourceRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// Required. The source configuration for the service.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_source: std::option::Option<crate::model::ConfigSource>,

    /// Optional. If set, this will result in the generation of a
    /// `google.api.Service` configuration based on the `ConfigSource` provided,
    /// but the generated config and the sources will NOT be persisted.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitConfigSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::SubmitConfigSourceRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [config_source][crate::model::SubmitConfigSourceRequest::config_source].
    pub fn set_config_source<
        T: std::convert::Into<std::option::Option<crate::model::ConfigSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.config_source = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::SubmitConfigSourceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for SubmitConfigSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.SubmitConfigSourceRequest"
    }
}

/// Response message for SubmitConfigSource method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SubmitConfigSourceResponse {
    /// The generated service configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_config: std::option::Option<api::model::Service>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitConfigSourceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_config][crate::model::SubmitConfigSourceResponse::service_config].
    pub fn set_service_config<T: std::convert::Into<std::option::Option<api::model::Service>>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_config = v.into();
        self
    }
}

impl wkt::message::Message for SubmitConfigSourceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.SubmitConfigSourceResponse"
    }
}

/// Request message for 'CreateServiceRollout'
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateServiceRolloutRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// Required. The rollout resource. The `service_name` field is output only.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rollout: std::option::Option<crate::model::Rollout>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServiceRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::CreateServiceRolloutRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::CreateServiceRolloutRequest::rollout].
    pub fn set_rollout<T: std::convert::Into<std::option::Option<crate::model::Rollout>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rollout = v.into();
        self
    }
}

impl wkt::message::Message for CreateServiceRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.CreateServiceRolloutRequest"
    }
}

/// Request message for 'ListServiceRollouts'
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServiceRolloutsRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// The token of the page to retrieve.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// The max number of items to include in the response list. Page size is 50
    /// if not specified. Maximum value is 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Required. Use `filter` to return subset of rollouts.
    /// The following filters are supported:
    ///
    /// -- By [status]
    /// [google.api.servicemanagement.v1.Rollout.RolloutStatus]. For example,
    /// `filter='status=SUCCESS'`
    ///
    /// -- By [strategy]
    /// [google.api.servicemanagement.v1.Rollout.strategy]. For example,
    /// `filter='strategy=TrafficPercentStrategy'`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServiceRolloutsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::ListServiceRolloutsRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServiceRolloutsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServiceRolloutsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListServiceRolloutsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListServiceRolloutsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServiceRolloutsRequest"
    }
}

/// Response message for ListServiceRollouts method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListServiceRolloutsResponse {
    /// The list of rollout resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rollouts: std::vec::Vec<crate::model::Rollout>,

    /// The token of the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServiceRolloutsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollouts][crate::model::ListServiceRolloutsResponse::rollouts].
    pub fn set_rollouts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Rollout>,
    {
        use std::iter::Iterator;
        self.rollouts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServiceRolloutsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServiceRolloutsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServiceRolloutsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServiceRolloutsResponse {
    type PageItem = crate::model::Rollout;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rollouts
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for GetServiceRollout method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServiceRolloutRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// Required. The id of the rollout resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub rollout_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::GetServiceRolloutRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [rollout_id][crate::model::GetServiceRolloutRequest::rollout_id].
    pub fn set_rollout_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_id = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.GetServiceRolloutRequest"
    }
}

/// Operation payload for EnableService method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnableServiceResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableServiceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for EnableServiceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.EnableServiceResponse"
    }
}

/// Request message for GenerateConfigReport method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateConfigReportRequest {
    /// Required. Service configuration for which we want to generate the report.
    /// For this version of API, the supported types are
    /// [google.api.servicemanagement.v1.ConfigRef][google.api.servicemanagement.v1.ConfigRef],
    /// [google.api.servicemanagement.v1.ConfigSource][google.api.servicemanagement.v1.ConfigSource],
    /// and [google.api.Service][google.api.Service]
    ///
    /// [google.api.Service]: api::model::Service
    /// [google.api.servicemanagement.v1.ConfigRef]: crate::model::ConfigRef
    /// [google.api.servicemanagement.v1.ConfigSource]: crate::model::ConfigSource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub new_config: std::option::Option<wkt::Any>,

    /// Optional. Service configuration against which the comparison will be done.
    /// For this version of API, the supported types are
    /// [google.api.servicemanagement.v1.ConfigRef][google.api.servicemanagement.v1.ConfigRef],
    /// [google.api.servicemanagement.v1.ConfigSource][google.api.servicemanagement.v1.ConfigSource],
    /// and [google.api.Service][google.api.Service]
    ///
    /// [google.api.Service]: api::model::Service
    /// [google.api.servicemanagement.v1.ConfigRef]: crate::model::ConfigRef
    /// [google.api.servicemanagement.v1.ConfigSource]: crate::model::ConfigSource
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub old_config: std::option::Option<wkt::Any>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateConfigReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_config][crate::model::GenerateConfigReportRequest::new_config].
    pub fn set_new_config<T: std::convert::Into<std::option::Option<wkt::Any>>>(
        mut self,
        v: T,
    ) -> Self {
        self.new_config = v.into();
        self
    }

    /// Sets the value of [old_config][crate::model::GenerateConfigReportRequest::old_config].
    pub fn set_old_config<T: std::convert::Into<std::option::Option<wkt::Any>>>(
        mut self,
        v: T,
    ) -> Self {
        self.old_config = v.into();
        self
    }
}

impl wkt::message::Message for GenerateConfigReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.GenerateConfigReportRequest"
    }
}

/// Response message for GenerateConfigReport method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateConfigReportResponse {
    /// Name of the service this report belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_name: std::string::String,

    /// ID of the service configuration this report belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// list of ChangeReport, each corresponding to comparison between two
    /// service configurations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub change_reports: std::vec::Vec<crate::model::ChangeReport>,

    /// Errors / Linter warnings associated with the service definition this
    /// report
    /// belongs to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub diagnostics: std::vec::Vec<crate::model::Diagnostic>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateConfigReportResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::GenerateConfigReportResponse::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::GenerateConfigReportResponse::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [change_reports][crate::model::GenerateConfigReportResponse::change_reports].
    pub fn set_change_reports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ChangeReport>,
    {
        use std::iter::Iterator;
        self.change_reports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [diagnostics][crate::model::GenerateConfigReportResponse::diagnostics].
    pub fn set_diagnostics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Diagnostic>,
    {
        use std::iter::Iterator;
        self.diagnostics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GenerateConfigReportResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.GenerateConfigReportResponse"
    }
}
