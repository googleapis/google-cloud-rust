// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate api;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The full representation of a Service that is managed by
/// Google Service Management.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagedService {
    /// The name of the service. See the
    /// [overview](https://cloud.google.com/service-infrastructure/docs/overview)
    /// for naming requirements.
    pub service_name: std::string::String,

    /// ID of the project that produces and owns this service.
    pub producer_project_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManagedService {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::ManagedService::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [producer_project_id][crate::model::ManagedService::producer_project_id].
    pub fn set_producer_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.producer_project_id = v.into();
        self
    }
}

impl wkt::message::Message for ManagedService {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ManagedService"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManagedService {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __producer_project_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManagedService")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "producerProjectId" => Ok(__FieldTag::__producer_project_id),
                            "producer_project_id" => Ok(__FieldTag::__producer_project_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManagedService;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManagedService")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__producer_project_id => {
                            if !fields.insert(__FieldTag::__producer_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for producer_project_id",
                                ));
                            }
                            result.producer_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManagedService {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self.producer_project_id.is_empty() {
            state.serialize_entry("producerProjectId", &self.producer_project_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ManagedService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManagedService");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("producer_project_id", &self.producer_project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The metadata associated with a long running operation resource.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The full name of the resources that this operation is directly
    /// associated with.
    pub resource_names: std::vec::Vec<std::string::String>,

    /// Detailed status information for each step. The order is undetermined.
    pub steps: std::vec::Vec<crate::model::operation_metadata::Step>,

    /// Percentage of completion of this operation, ranging from 0 to 100.
    pub progress_percentage: i32,

    /// The start time of the operation.
    pub start_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_names][crate::model::OperationMetadata::resource_names].
    pub fn set_resource_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [steps][crate::model::OperationMetadata::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::operation_metadata::Step>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [progress_percentage][crate::model::OperationMetadata::progress_percentage].
    pub fn set_progress_percentage<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percentage = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::OperationMetadata::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::OperationMetadata::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource_names,
            __steps,
            __progress_percentage,
            __start_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resourceNames" => Ok(__FieldTag::__resource_names),
                            "resource_names" => Ok(__FieldTag::__resource_names),
                            "steps" => Ok(__FieldTag::__steps),
                            "progressPercentage" => Ok(__FieldTag::__progress_percentage),
                            "progress_percentage" => Ok(__FieldTag::__progress_percentage),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource_names => {
                            if !fields.insert(__FieldTag::__resource_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_names",
                                ));
                            }
                            result.resource_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::operation_metadata::Step>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__progress_percentage => {
                            if !fields.insert(__FieldTag::__progress_percentage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percentage",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percentage =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resource_names.is_empty() {
            state.serialize_entry("resourceNames", &self.resource_names)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !wkt::internal::is_default(&self.progress_percentage) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progressPercentage", &__With(&self.progress_percentage))?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("resource_names", &self.resource_names);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("progress_percentage", &self.progress_percentage);
        debug_struct.field("start_time", &self.start_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the status of one operation step.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Step {
        /// The short description of the step.
        pub description: std::string::String,

        /// The status code.
        pub status: crate::model::operation_metadata::Status,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Step {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [description][crate::model::operation_metadata::Step::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [status][crate::model::operation_metadata::Step::status].
        pub fn set_status<T: std::convert::Into<crate::model::operation_metadata::Status>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }
    }

    impl wkt::message::Message for Step {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicemanagement.v1.OperationMetadata.Step"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Step {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __description,
                __status,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Step")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "description" => Ok(__FieldTag::__description),
                                "status" => Ok(__FieldTag::__status),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Step;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Step")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status =
                                    map.next_value::<std::option::Option<
                                        crate::model::operation_metadata::Status,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Step {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !wkt::internal::is_default(&self.status) {
                state.serialize_entry("status", &self.status)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Step {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Step");
            debug_struct.field("description", &self.description);
            debug_struct.field("status", &self.status);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Code describes the status of the operation (or one of its steps).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Unspecifed code.
        Unspecified,
        /// The operation or step has completed without errors.
        Done,
        /// The operation or step has not started yet.
        NotStarted,
        /// The operation or step is in progress.
        InProgress,
        /// The operation or step has completed with errors. If the operation is
        /// rollbackable, the rollback completed with errors too.
        Failed,
        /// The operation or step has completed with cancellation.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Done => std::option::Option::Some(1),
                Self::NotStarted => std::option::Option::Some(2),
                Self::InProgress => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::NotStarted => std::option::Option::Some("NOT_STARTED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Done,
                2 => Self::NotStarted,
                3 => Self::InProgress,
                4 => Self::Failed,
                5 => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "DONE" => Self::Done,
                "NOT_STARTED" => Self::NotStarted,
                "IN_PROGRESS" => Self::InProgress,
                "FAILED" => Self::Failed,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Done => serializer.serialize_i32(1),
                Self::NotStarted => serializer.serialize_i32(2),
                Self::InProgress => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.api.servicemanagement.v1.OperationMetadata.Status",
            ))
        }
    }
}

/// Represents a diagnostic message (error or warning)
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Diagnostic {
    /// File name and line number of the error or warning.
    pub location: std::string::String,

    /// The kind of diagnostic information provided.
    pub kind: crate::model::diagnostic::Kind,

    /// Message describing the error or warning.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Diagnostic {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::Diagnostic::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [kind][crate::model::Diagnostic::kind].
    pub fn set_kind<T: std::convert::Into<crate::model::diagnostic::Kind>>(mut self, v: T) -> Self {
        self.kind = v.into();
        self
    }

    /// Sets the value of [message][crate::model::Diagnostic::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for Diagnostic {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.Diagnostic"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Diagnostic {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __location,
            __kind,
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Diagnostic")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "location" => Ok(__FieldTag::__location),
                            "kind" => Ok(__FieldTag::__kind),
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Diagnostic;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Diagnostic")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__location => {
                            if !fields.insert(__FieldTag::__location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for location",
                                ));
                            }
                            result.location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kind => {
                            if !fields.insert(__FieldTag::__kind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kind",
                                ));
                            }
                            result.kind = map
                                .next_value::<std::option::Option<crate::model::diagnostic::Kind>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Diagnostic {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.location.is_empty() {
            state.serialize_entry("location", &self.location)?;
        }
        if !wkt::internal::is_default(&self.kind) {
            state.serialize_entry("kind", &self.kind)?;
        }
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Diagnostic {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Diagnostic");
        debug_struct.field("location", &self.location);
        debug_struct.field("kind", &self.kind);
        debug_struct.field("message", &self.message);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Diagnostic].
pub mod diagnostic {
    #[allow(unused_imports)]
    use super::*;

    /// The kind of diagnostic information possible.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Kind {
        /// Warnings and errors
        Warning,
        /// Only errors
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Kind::value] or
        /// [Kind::name].
        UnknownValue(kind::UnknownValue),
    }

    #[doc(hidden)]
    pub mod kind {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Kind {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Warning => std::option::Option::Some(0),
                Self::Error => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Kind {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Kind {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Kind {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Warning,
                1 => Self::Error,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Kind {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WARNING" => Self::Warning,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(kind::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Kind {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Warning => serializer.serialize_i32(0),
                Self::Error => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Kind {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Kind>::new(
                ".google.api.servicemanagement.v1.Diagnostic.Kind",
            ))
        }
    }
}

/// Represents a source file which is used to generate the service configuration
/// defined by `google.api.Service`.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfigSource {
    /// A unique ID for a specific instance of this message, typically assigned
    /// by the client for tracking purpose. If empty, the server may choose to
    /// generate one instead.
    pub id: std::string::String,

    /// Set of source configuration files that are used to generate a service
    /// configuration (`google.api.Service`).
    pub files: std::vec::Vec<crate::model::ConfigFile>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigSource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::ConfigSource::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [files][crate::model::ConfigSource::files].
    pub fn set_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConfigFile>,
    {
        use std::iter::Iterator;
        self.files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConfigSource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ConfigSource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfigSource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __files,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigSource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "files" => Ok(__FieldTag::__files),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfigSource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigSource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__files => {
                            if !fields.insert(__FieldTag::__files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for files",
                                ));
                            }
                            result.files = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ConfigFile>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfigSource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.files.is_empty() {
            state.serialize_entry("files", &self.files)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConfigSource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigSource");
        debug_struct.field("id", &self.id);
        debug_struct.field("files", &self.files);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Generic specification of a source configuration file
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfigFile {
    /// The file name of the configuration file (full or relative path).
    pub file_path: std::string::String,

    /// The bytes that constitute the file.
    pub file_contents: ::bytes::Bytes,

    /// The type of configuration file this represents.
    pub file_type: crate::model::config_file::FileType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_path][crate::model::ConfigFile::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }

    /// Sets the value of [file_contents][crate::model::ConfigFile::file_contents].
    pub fn set_file_contents<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.file_contents = v.into();
        self
    }

    /// Sets the value of [file_type][crate::model::ConfigFile::file_type].
    pub fn set_file_type<T: std::convert::Into<crate::model::config_file::FileType>>(
        mut self,
        v: T,
    ) -> Self {
        self.file_type = v.into();
        self
    }
}

impl wkt::message::Message for ConfigFile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ConfigFile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfigFile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_path,
            __file_contents,
            __file_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigFile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "filePath" => Ok(__FieldTag::__file_path),
                            "file_path" => Ok(__FieldTag::__file_path),
                            "fileContents" => Ok(__FieldTag::__file_contents),
                            "file_contents" => Ok(__FieldTag::__file_contents),
                            "fileType" => Ok(__FieldTag::__file_type),
                            "file_type" => Ok(__FieldTag::__file_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfigFile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigFile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_path => {
                            if !fields.insert(__FieldTag::__file_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_path",
                                ));
                            }
                            result.file_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_contents => {
                            if !fields.insert(__FieldTag::__file_contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_contents",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.file_contents =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__file_type => {
                            if !fields.insert(__FieldTag::__file_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_type",
                                ));
                            }
                            result.file_type = map.next_value::<std::option::Option<crate::model::config_file::FileType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfigFile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_path.is_empty() {
            state.serialize_entry("filePath", &self.file_path)?;
        }
        if !self.file_contents.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fileContents", &__With(&self.file_contents))?;
        }
        if !wkt::internal::is_default(&self.file_type) {
            state.serialize_entry("fileType", &self.file_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConfigFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigFile");
        debug_struct.field("file_path", &self.file_path);
        debug_struct.field("file_contents", &self.file_contents);
        debug_struct.field("file_type", &self.file_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConfigFile].
pub mod config_file {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FileType {
        /// Unknown file type.
        Unspecified,
        /// YAML-specification of service.
        ServiceConfigYaml,
        /// OpenAPI specification, serialized in JSON.
        OpenApiJson,
        /// OpenAPI specification, serialized in YAML.
        OpenApiYaml,
        /// FileDescriptorSet, generated by protoc.
        ///
        /// To generate, use protoc with imports and source info included.
        /// For an example test.proto file, the following command would put the value
        /// in a new file named out.pb.
        ///
        /// $protoc --include_imports --include_source_info test.proto -o out.pb
        FileDescriptorSetProto,
        /// Uncompiled Proto file. Used for storage and display purposes only,
        /// currently server-side compilation is not supported. Should match the
        /// inputs to 'protoc' command used to generated FILE_DESCRIPTOR_SET_PROTO. A
        /// file of this type can only be included if at least one file of type
        /// FILE_DESCRIPTOR_SET_PROTO is included.
        ProtoFile,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FileType::value] or
        /// [FileType::name].
        UnknownValue(file_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod file_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl FileType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ServiceConfigYaml => std::option::Option::Some(1),
                Self::OpenApiJson => std::option::Option::Some(2),
                Self::OpenApiYaml => std::option::Option::Some(3),
                Self::FileDescriptorSetProto => std::option::Option::Some(4),
                Self::ProtoFile => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FILE_TYPE_UNSPECIFIED"),
                Self::ServiceConfigYaml => std::option::Option::Some("SERVICE_CONFIG_YAML"),
                Self::OpenApiJson => std::option::Option::Some("OPEN_API_JSON"),
                Self::OpenApiYaml => std::option::Option::Some("OPEN_API_YAML"),
                Self::FileDescriptorSetProto => {
                    std::option::Option::Some("FILE_DESCRIPTOR_SET_PROTO")
                }
                Self::ProtoFile => std::option::Option::Some("PROTO_FILE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for FileType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for FileType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for FileType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ServiceConfigYaml,
                2 => Self::OpenApiJson,
                3 => Self::OpenApiYaml,
                4 => Self::FileDescriptorSetProto,
                6 => Self::ProtoFile,
                _ => Self::UnknownValue(file_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for FileType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FILE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SERVICE_CONFIG_YAML" => Self::ServiceConfigYaml,
                "OPEN_API_JSON" => Self::OpenApiJson,
                "OPEN_API_YAML" => Self::OpenApiYaml,
                "FILE_DESCRIPTOR_SET_PROTO" => Self::FileDescriptorSetProto,
                "PROTO_FILE" => Self::ProtoFile,
                _ => Self::UnknownValue(file_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for FileType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ServiceConfigYaml => serializer.serialize_i32(1),
                Self::OpenApiJson => serializer.serialize_i32(2),
                Self::OpenApiYaml => serializer.serialize_i32(3),
                Self::FileDescriptorSetProto => serializer.serialize_i32(4),
                Self::ProtoFile => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for FileType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FileType>::new(
                ".google.api.servicemanagement.v1.ConfigFile.FileType",
            ))
        }
    }
}

/// Represents a service configuration with its name and id.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfigRef {
    /// Resource name of a service config. It must have the following
    /// format: "services/{service name}/configs/{config id}".
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigRef {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ConfigRef::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ConfigRef {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ConfigRef"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfigRef {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigRef")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfigRef;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigRef")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfigRef {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConfigRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigRef");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Change report associated with a particular service configuration.
///
/// It contains a list of ConfigChanges based on the comparison between
/// two service configurations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ChangeReport {
    /// List of changes between two service configurations.
    /// The changes will be alphabetically sorted based on the identifier
    /// of each change.
    /// A ConfigChange identifier is a dot separated path to the configuration.
    /// Example: visibility.rules[selector='LibraryService.CreateBook'].restriction
    pub config_changes: std::vec::Vec<api::model::ConfigChange>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChangeReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config_changes][crate::model::ChangeReport::config_changes].
    pub fn set_config_changes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::ConfigChange>,
    {
        use std::iter::Iterator;
        self.config_changes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ChangeReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ChangeReport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ChangeReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config_changes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ChangeReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "configChanges" => Ok(__FieldTag::__config_changes),
                            "config_changes" => Ok(__FieldTag::__config_changes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ChangeReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ChangeReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config_changes => {
                            if !fields.insert(__FieldTag::__config_changes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_changes",
                                ));
                            }
                            result.config_changes = map.next_value::<std::option::Option<std::vec::Vec<api::model::ConfigChange>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ChangeReport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.config_changes.is_empty() {
            state.serialize_entry("configChanges", &self.config_changes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ChangeReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ChangeReport");
        debug_struct.field("config_changes", &self.config_changes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A rollout resource that defines how service configuration versions are pushed
/// to control plane systems. Typically, you create a new version of the
/// service config, and then create a Rollout to push the service config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Rollout {
    /// Optional. Unique identifier of this Rollout. Must be no longer than 63
    /// characters and only lower case letters, digits, '.', '_' and '-' are
    /// allowed.
    ///
    /// If not specified by client, the server will generate one. The generated id
    /// will have the form of \<date\>\<revision number\>, where "date" is the create
    /// date in ISO 8601 format.  "revision number" is a monotonically increasing
    /// positive number that is reset every day for each service.
    /// An example of the generated rollout_id is '2016-02-16r1'
    pub rollout_id: std::string::String,

    /// Creation time of the rollout. Readonly.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The user who created the Rollout. Readonly.
    pub created_by: std::string::String,

    /// The status of this rollout. Readonly. In case of a failed rollout,
    /// the system will automatically rollback to the current Rollout
    /// version. Readonly.
    pub status: crate::model::rollout::RolloutStatus,

    /// The name of the service associated with this Rollout.
    pub service_name: std::string::String,

    /// Strategy that defines which versions of service configurations should be
    /// pushed
    /// and how they should be used at runtime.
    pub strategy: std::option::Option<crate::model::rollout::Strategy>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rollout {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollout_id][crate::model::Rollout::rollout_id].
    pub fn set_rollout_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_id = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Rollout::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Rollout::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [created_by][crate::model::Rollout::created_by].
    pub fn set_created_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.created_by = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Rollout::status].
    pub fn set_status<T: std::convert::Into<crate::model::rollout::RolloutStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [service_name][crate::model::Rollout::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [strategy][crate::model::Rollout::strategy].
    ///
    /// Note that all the setters affecting `strategy` are mutually
    /// exclusive.
    pub fn set_strategy<
        T: std::convert::Into<std::option::Option<crate::model::rollout::Strategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.strategy = v.into();
        self
    }

    /// The value of [strategy][crate::model::Rollout::strategy]
    /// if it holds a `TrafficPercentStrategy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn traffic_percent_strategy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rollout::TrafficPercentStrategy>> {
        #[allow(unreachable_patterns)]
        self.strategy.as_ref().and_then(|v| match v {
            crate::model::rollout::Strategy::TrafficPercentStrategy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [strategy][crate::model::Rollout::strategy]
    /// to hold a `TrafficPercentStrategy`.
    ///
    /// Note that all the setters affecting `strategy` are
    /// mutually exclusive.
    pub fn set_traffic_percent_strategy<
        T: std::convert::Into<std::boxed::Box<crate::model::rollout::TrafficPercentStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.strategy = std::option::Option::Some(
            crate::model::rollout::Strategy::TrafficPercentStrategy(v.into()),
        );
        self
    }

    /// The value of [strategy][crate::model::Rollout::strategy]
    /// if it holds a `DeleteServiceStrategy`, `None` if the field is not set or
    /// holds a different branch.
    pub fn delete_service_strategy(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::rollout::DeleteServiceStrategy>> {
        #[allow(unreachable_patterns)]
        self.strategy.as_ref().and_then(|v| match v {
            crate::model::rollout::Strategy::DeleteServiceStrategy(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [strategy][crate::model::Rollout::strategy]
    /// to hold a `DeleteServiceStrategy`.
    ///
    /// Note that all the setters affecting `strategy` are
    /// mutually exclusive.
    pub fn set_delete_service_strategy<
        T: std::convert::Into<std::boxed::Box<crate::model::rollout::DeleteServiceStrategy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.strategy = std::option::Option::Some(
            crate::model::rollout::Strategy::DeleteServiceStrategy(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Rollout {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.Rollout"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Rollout {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollout_id,
            __create_time,
            __created_by,
            __status,
            __traffic_percent_strategy,
            __delete_service_strategy,
            __service_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Rollout")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rolloutId" => Ok(__FieldTag::__rollout_id),
                            "rollout_id" => Ok(__FieldTag::__rollout_id),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "createdBy" => Ok(__FieldTag::__created_by),
                            "created_by" => Ok(__FieldTag::__created_by),
                            "status" => Ok(__FieldTag::__status),
                            "trafficPercentStrategy" => Ok(__FieldTag::__traffic_percent_strategy),
                            "traffic_percent_strategy" => {
                                Ok(__FieldTag::__traffic_percent_strategy)
                            }
                            "deleteServiceStrategy" => Ok(__FieldTag::__delete_service_strategy),
                            "delete_service_strategy" => Ok(__FieldTag::__delete_service_strategy),
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Rollout;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Rollout")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollout_id => {
                            if !fields.insert(__FieldTag::__rollout_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_id",
                                ));
                            }
                            result.rollout_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__created_by => {
                            if !fields.insert(__FieldTag::__created_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for created_by",
                                ));
                            }
                            result.created_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map.next_value::<std::option::Option<crate::model::rollout::RolloutStatus>>()?.unwrap_or_default();
                        }
                        __FieldTag::__traffic_percent_strategy => {
                            if !fields.insert(__FieldTag::__traffic_percent_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for traffic_percent_strategy",
                                ));
                            }
                            if result.strategy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `strategy`, a oneof with full ID .google.api.servicemanagement.v1.Rollout.traffic_percent_strategy, latest field was trafficPercentStrategy",
                                ));
                            }
                            result.strategy = std::option::Option::Some(
                                crate::model::rollout::Strategy::TrafficPercentStrategy(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::rollout::TrafficPercentStrategy,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__delete_service_strategy => {
                            if !fields.insert(__FieldTag::__delete_service_strategy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_service_strategy",
                                ));
                            }
                            if result.strategy.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `strategy`, a oneof with full ID .google.api.servicemanagement.v1.Rollout.delete_service_strategy, latest field was deleteServiceStrategy",
                                ));
                            }
                            result.strategy = std::option::Option::Some(
                                crate::model::rollout::Strategy::DeleteServiceStrategy(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::rollout::DeleteServiceStrategy,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Rollout {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rollout_id.is_empty() {
            state.serialize_entry("rolloutId", &self.rollout_id)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.created_by.is_empty() {
            state.serialize_entry("createdBy", &self.created_by)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if let Some(value) = self.traffic_percent_strategy() {
            state.serialize_entry("trafficPercentStrategy", value)?;
        }
        if let Some(value) = self.delete_service_strategy() {
            state.serialize_entry("deleteServiceStrategy", value)?;
        }
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Rollout {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Rollout");
        debug_struct.field("rollout_id", &self.rollout_id);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("created_by", &self.created_by);
        debug_struct.field("status", &self.status);
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("strategy", &self.strategy);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Rollout].
pub mod rollout {
    #[allow(unused_imports)]
    use super::*;

    /// Strategy that specifies how clients of Google Service Controller want to
    /// send traffic to use different config versions. This is generally
    /// used by API proxy to split traffic based on your configured percentage for
    /// each config version.
    ///
    /// One example of how to gradually rollout a new service configuration using
    /// this
    /// strategy:
    /// Day 1
    ///
    /// ```norust
    /// Rollout {
    ///   id: "example.googleapis.com/rollout_20160206"
    ///   traffic_percent_strategy {
    ///     percentages: {
    ///       "example.googleapis.com/20160201": 70.00
    ///       "example.googleapis.com/20160206": 30.00
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// Day 2
    ///
    /// ```norust
    /// Rollout {
    ///   id: "example.googleapis.com/rollout_20160207"
    ///   traffic_percent_strategy: {
    ///     percentages: {
    ///       "example.googleapis.com/20160206": 100.00
    ///     }
    ///   }
    /// }
    /// ```
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TrafficPercentStrategy {
        /// Maps service configuration IDs to their corresponding traffic percentage.
        /// Key is the service configuration ID, Value is the traffic percentage
        /// which must be greater than 0.0 and the sum must equal to 100.0.
        pub percentages: std::collections::HashMap<std::string::String, f64>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl TrafficPercentStrategy {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [percentages][crate::model::rollout::TrafficPercentStrategy::percentages].
        pub fn set_percentages<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<f64>,
        {
            use std::iter::Iterator;
            self.percentages = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for TrafficPercentStrategy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicemanagement.v1.Rollout.TrafficPercentStrategy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for TrafficPercentStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __percentages,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for TrafficPercentStrategy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "percentages" => Ok(__FieldTag::__percentages),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = TrafficPercentStrategy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct TrafficPercentStrategy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__percentages => {
                                if !fields.insert(__FieldTag::__percentages) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for percentages",
                                    ));
                                }
                                struct __With(
                                    std::option::Option<
                                        std::collections::HashMap<std::string::String, f64>,
                                    >,
                                );
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::<
                                            std::option::Option<
                                                std::collections::HashMap<
                                                    serde_with::Same,
                                                    wkt::internal::F64,
                                                >,
                                            >,
                                        >::deserialize(
                                            deserializer
                                        )
                                        .map(__With)
                                    }
                                }
                                result.percentages =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for TrafficPercentStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.percentages.is_empty() {
                struct __With<'a>(&'a std::collections::HashMap<std::string::String, f64>);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<
                            std::collections::HashMap<serde_with::Same, wkt::internal::F64>,
                        >::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("percentages", &__With(&self.percentages))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for TrafficPercentStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("TrafficPercentStrategy");
            debug_struct.field("percentages", &self.percentages);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Strategy used to delete a service. This strategy is a placeholder only
    /// used by the system generated rollout to delete a service.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteServiceStrategy {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DeleteServiceStrategy {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for DeleteServiceStrategy {
        fn typename() -> &'static str {
            "type.googleapis.com/google.api.servicemanagement.v1.Rollout.DeleteServiceStrategy"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DeleteServiceStrategy {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DeleteServiceStrategy")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DeleteServiceStrategy;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DeleteServiceStrategy")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DeleteServiceStrategy {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DeleteServiceStrategy {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DeleteServiceStrategy");
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Status of a Rollout.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutStatus {
        /// No status specified.
        Unspecified,
        /// The Rollout is in progress.
        InProgress,
        /// The Rollout has completed successfully.
        Success,
        /// The Rollout has been cancelled. This can happen if you have overlapping
        /// Rollout pushes, and the previous ones will be cancelled.
        Cancelled,
        /// The Rollout has failed and the rollback attempt has failed too.
        Failed,
        /// The Rollout has not started yet and is pending for execution.
        Pending,
        /// The Rollout has failed and rolled back to the previous successful
        /// Rollout.
        FailedRolledBack,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutStatus::value] or
        /// [RolloutStatus::name].
        UnknownValue(rollout_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rollout_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RolloutStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::InProgress => std::option::Option::Some(1),
                Self::Success => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Pending => std::option::Option::Some(5),
                Self::FailedRolledBack => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ROLLOUT_STATUS_UNSPECIFIED"),
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Success => std::option::Option::Some("SUCCESS"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::FailedRolledBack => std::option::Option::Some("FAILED_ROLLED_BACK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RolloutStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RolloutStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RolloutStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::InProgress,
                2 => Self::Success,
                3 => Self::Cancelled,
                4 => Self::Failed,
                5 => Self::Pending,
                6 => Self::FailedRolledBack,
                _ => Self::UnknownValue(rollout_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RolloutStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ROLLOUT_STATUS_UNSPECIFIED" => Self::Unspecified,
                "IN_PROGRESS" => Self::InProgress,
                "SUCCESS" => Self::Success,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                "PENDING" => Self::Pending,
                "FAILED_ROLLED_BACK" => Self::FailedRolledBack,
                _ => Self::UnknownValue(rollout_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RolloutStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::InProgress => serializer.serialize_i32(1),
                Self::Success => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Pending => serializer.serialize_i32(5),
                Self::FailedRolledBack => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RolloutStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutStatus>::new(
                ".google.api.servicemanagement.v1.Rollout.RolloutStatus",
            ))
        }
    }

    /// Strategy that defines which versions of service configurations should be
    /// pushed
    /// and how they should be used at runtime.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Strategy {
        /// Google Service Control selects service configurations based on
        /// traffic percentage.
        TrafficPercentStrategy(std::boxed::Box<crate::model::rollout::TrafficPercentStrategy>),
        /// The strategy associated with a rollout to delete a `ManagedService`.
        /// Readonly.
        DeleteServiceStrategy(std::boxed::Box<crate::model::rollout::DeleteServiceStrategy>),
    }
}

/// Request message for `ListServices` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesRequest {
    /// Include services produced by the specified project.
    pub producer_project_id: std::string::String,

    /// The max number of items to include in the response list. Page size is 50
    /// if not specified. Maximum value is 500.
    pub page_size: i32,

    /// Token identifying which result to start with; returned by a previous list
    /// call.
    pub page_token: std::string::String,

    /// Include services consumed by the specified consumer.
    ///
    /// The Google Service Management implementation accepts the following
    /// forms:
    ///
    /// - project:<project_id>
    #[deprecated]
    pub consumer_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [producer_project_id][crate::model::ListServicesRequest::producer_project_id].
    pub fn set_producer_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.producer_project_id = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServicesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServicesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [consumer_id][crate::model::ListServicesRequest::consumer_id].
    #[deprecated]
    pub fn set_consumer_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.consumer_id = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServicesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __producer_project_id,
            __page_size,
            __page_token,
            __consumer_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "producerProjectId" => Ok(__FieldTag::__producer_project_id),
                            "producer_project_id" => Ok(__FieldTag::__producer_project_id),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "consumerId" => Ok(__FieldTag::__consumer_id),
                            "consumer_id" => Ok(__FieldTag::__consumer_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__producer_project_id => {
                            if !fields.insert(__FieldTag::__producer_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for producer_project_id",
                                ));
                            }
                            result.producer_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__consumer_id => {
                            if !fields.insert(__FieldTag::__consumer_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for consumer_id",
                                ));
                            }
                            result.consumer_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.producer_project_id.is_empty() {
            state.serialize_entry("producerProjectId", &self.producer_project_id)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.consumer_id.is_empty() {
            state.serialize_entry("consumerId", &self.consumer_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListServicesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServicesRequest");
        debug_struct.field("producer_project_id", &self.producer_project_id);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("consumer_id", &self.consumer_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for `ListServices` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServicesResponse {
    /// The returned services will only have the name field set.
    pub services: std::vec::Vec<crate::model::ManagedService>,

    /// Token that can be passed to `ListServices` to resume a paginated query.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServicesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [services][crate::model::ListServicesResponse::services].
    pub fn set_services<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ManagedService>,
    {
        use std::iter::Iterator;
        self.services = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServicesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServicesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServicesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServicesResponse {
    type PageItem = crate::model::ManagedService;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.services
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServicesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __services,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServicesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "services" => Ok(__FieldTag::__services),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServicesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServicesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__services => {
                            if !fields.insert(__FieldTag::__services) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services",
                                ));
                            }
                            result.services =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ManagedService>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServicesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.services.is_empty() {
            state.serialize_entry("services", &self.services)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListServicesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServicesResponse");
        debug_struct.field("services", &self.services);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `GetService` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServiceRequest {
    /// Required. The name of the service.  See the `ServiceManager` overview for
    /// naming requirements.  For example: `example.googleapis.com`.
    pub service_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::GetServiceRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.GetServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetServiceRequest");
        debug_struct.field("service_name", &self.service_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for CreateService method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateServiceRequest {
    /// Required. Initial values for the service resource.
    pub service: std::option::Option<crate::model::ManagedService>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::CreateServiceRequest::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagedService>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::CreateServiceRequest::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagedService>,
    {
        self.service = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.CreateServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<crate::model::ManagedService>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateServiceRequest");
        debug_struct.field("service", &self.service);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for DeleteService method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteServiceRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    pub service_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::DeleteServiceRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.DeleteServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteServiceRequest");
        debug_struct.field("service_name", &self.service_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for UndeleteService method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeleteServiceRequest {
    /// Required. The name of the service. See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements. For example: `example.googleapis.com`.
    pub service_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteServiceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::UndeleteServiceRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }
}

impl wkt::message::Message for UndeleteServiceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.UndeleteServiceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeleteServiceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeleteServiceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeleteServiceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeleteServiceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeleteServiceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UndeleteServiceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeleteServiceRequest");
        debug_struct.field("service_name", &self.service_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for UndeleteService method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UndeleteServiceResponse {
    /// Revived service resource.
    pub service: std::option::Option<crate::model::ManagedService>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UndeleteServiceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::UndeleteServiceResponse::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagedService>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::UndeleteServiceResponse::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagedService>,
    {
        self.service = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UndeleteServiceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.UndeleteServiceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UndeleteServiceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UndeleteServiceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UndeleteServiceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UndeleteServiceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<crate::model::ManagedService>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UndeleteServiceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service.is_some() {
            state.serialize_entry("service", &self.service)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UndeleteServiceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UndeleteServiceResponse");
        debug_struct.field("service", &self.service);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for GetServiceConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServiceConfigRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    pub service_name: std::string::String,

    /// Required. The id of the service configuration resource.
    ///
    /// This field must be specified for the server to return all fields, including
    /// `SourceInfo`.
    pub config_id: std::string::String,

    /// Specifies which parts of the Service Config should be returned in the
    /// response.
    pub view: crate::model::get_service_config_request::ConfigView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::GetServiceConfigRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [config_id][crate::model::GetServiceConfigRequest::config_id].
    pub fn set_config_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.config_id = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetServiceConfigRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::get_service_config_request::ConfigView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.GetServiceConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServiceConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __config_id,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "configId" => Ok(__FieldTag::__config_id),
                            "config_id" => Ok(__FieldTag::__config_id),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServiceConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_id => {
                            if !fields.insert(__FieldTag::__config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_id",
                                ));
                            }
                            result.config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<
                                    crate::model::get_service_config_request::ConfigView,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServiceConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self.config_id.is_empty() {
            state.serialize_entry("configId", &self.config_id)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetServiceConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetServiceConfigRequest");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("config_id", &self.config_id);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [GetServiceConfigRequest].
pub mod get_service_config_request {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConfigView {
        /// Server response includes all fields except SourceInfo.
        Basic,
        /// Server response includes all fields including SourceInfo.
        /// SourceFiles are of type 'google.api.servicemanagement.v1.ConfigFile'
        /// and are only available for configs created using the
        /// SubmitConfigSource method.
        Full,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConfigView::value] or
        /// [ConfigView::name].
        UnknownValue(config_view::UnknownValue),
    }

    #[doc(hidden)]
    pub mod config_view {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ConfigView {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Basic => std::option::Option::Some(0),
                Self::Full => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Basic => std::option::Option::Some("BASIC"),
                Self::Full => std::option::Option::Some("FULL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ConfigView {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ConfigView {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ConfigView {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Basic,
                1 => Self::Full,
                _ => Self::UnknownValue(config_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ConfigView {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BASIC" => Self::Basic,
                "FULL" => Self::Full,
                _ => Self::UnknownValue(config_view::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ConfigView {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Basic => serializer.serialize_i32(0),
                Self::Full => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ConfigView {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConfigView>::new(
                ".google.api.servicemanagement.v1.GetServiceConfigRequest.ConfigView",
            ))
        }
    }
}

/// Request message for ListServiceConfigs method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServiceConfigsRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    pub service_name: std::string::String,

    /// The token of the page to retrieve.
    pub page_token: std::string::String,

    /// The max number of items to include in the response list. Page size is 50
    /// if not specified. Maximum value is 100.
    pub page_size: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServiceConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::ListServiceConfigsRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServiceConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServiceConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }
}

impl wkt::message::Message for ListServiceConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServiceConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServiceConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __page_token,
            __page_size,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServiceConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServiceConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServiceConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServiceConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListServiceConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServiceConfigsRequest");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for ListServiceConfigs method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServiceConfigsResponse {
    /// The list of service configuration resources.
    pub service_configs: std::vec::Vec<api::model::Service>,

    /// The token of the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServiceConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_configs][crate::model::ListServiceConfigsResponse::service_configs].
    pub fn set_service_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<api::model::Service>,
    {
        use std::iter::Iterator;
        self.service_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServiceConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServiceConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServiceConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServiceConfigsResponse {
    type PageItem = api::model::Service;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.service_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServiceConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_configs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServiceConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceConfigs" => Ok(__FieldTag::__service_configs),
                            "service_configs" => Ok(__FieldTag::__service_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServiceConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServiceConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_configs => {
                            if !fields.insert(__FieldTag::__service_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_configs",
                                ));
                            }
                            result.service_configs = map.next_value::<std::option::Option<std::vec::Vec<api::model::Service>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServiceConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_configs.is_empty() {
            state.serialize_entry("serviceConfigs", &self.service_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListServiceConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServiceConfigsResponse");
        debug_struct.field("service_configs", &self.service_configs);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for CreateServiceConfig method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateServiceConfigRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    pub service_name: std::string::String,

    /// Required. The service configuration resource.
    pub service_config: std::option::Option<api::model::Service>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServiceConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::CreateServiceConfigRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [service_config][crate::model::CreateServiceConfigRequest::service_config].
    pub fn set_service_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::Service>,
    {
        self.service_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_config][crate::model::CreateServiceConfigRequest::service_config].
    pub fn set_or_clear_service_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::Service>,
    {
        self.service_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateServiceConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.CreateServiceConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateServiceConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __service_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateServiceConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "serviceConfig" => Ok(__FieldTag::__service_config),
                            "service_config" => Ok(__FieldTag::__service_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateServiceConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateServiceConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_config => {
                            if !fields.insert(__FieldTag::__service_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_config",
                                ));
                            }
                            result.service_config =
                                map.next_value::<std::option::Option<api::model::Service>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateServiceConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if self.service_config.is_some() {
            state.serialize_entry("serviceConfig", &self.service_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateServiceConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateServiceConfigRequest");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("service_config", &self.service_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for SubmitConfigSource method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitConfigSourceRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    pub service_name: std::string::String,

    /// Required. The source configuration for the service.
    pub config_source: std::option::Option<crate::model::ConfigSource>,

    /// Optional. If set, this will result in the generation of a
    /// `google.api.Service` configuration based on the `ConfigSource` provided,
    /// but the generated config and the sources will NOT be persisted.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitConfigSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::SubmitConfigSourceRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [config_source][crate::model::SubmitConfigSourceRequest::config_source].
    pub fn set_config_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfigSource>,
    {
        self.config_source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_source][crate::model::SubmitConfigSourceRequest::config_source].
    pub fn set_or_clear_config_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfigSource>,
    {
        self.config_source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::SubmitConfigSourceRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for SubmitConfigSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.SubmitConfigSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubmitConfigSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __config_source,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubmitConfigSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "configSource" => Ok(__FieldTag::__config_source),
                            "config_source" => Ok(__FieldTag::__config_source),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubmitConfigSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubmitConfigSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_source => {
                            if !fields.insert(__FieldTag::__config_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_source",
                                ));
                            }
                            result.config_source = map
                                .next_value::<std::option::Option<crate::model::ConfigSource>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SubmitConfigSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if self.config_source.is_some() {
            state.serialize_entry("configSource", &self.config_source)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SubmitConfigSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SubmitConfigSourceRequest");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("config_source", &self.config_source);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for SubmitConfigSource method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SubmitConfigSourceResponse {
    /// The generated service configuration.
    pub service_config: std::option::Option<api::model::Service>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SubmitConfigSourceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_config][crate::model::SubmitConfigSourceResponse::service_config].
    pub fn set_service_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<api::model::Service>,
    {
        self.service_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_config][crate::model::SubmitConfigSourceResponse::service_config].
    pub fn set_or_clear_service_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<api::model::Service>,
    {
        self.service_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SubmitConfigSourceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.SubmitConfigSourceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SubmitConfigSourceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SubmitConfigSourceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceConfig" => Ok(__FieldTag::__service_config),
                            "service_config" => Ok(__FieldTag::__service_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SubmitConfigSourceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SubmitConfigSourceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_config => {
                            if !fields.insert(__FieldTag::__service_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_config",
                                ));
                            }
                            result.service_config =
                                map.next_value::<std::option::Option<api::model::Service>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SubmitConfigSourceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.service_config.is_some() {
            state.serialize_entry("serviceConfig", &self.service_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SubmitConfigSourceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SubmitConfigSourceResponse");
        debug_struct.field("service_config", &self.service_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateServiceRollout'
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateServiceRolloutRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    pub service_name: std::string::String,

    /// Required. The rollout resource. The `service_name` field is output only.
    pub rollout: std::option::Option<crate::model::Rollout>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateServiceRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::CreateServiceRolloutRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [rollout][crate::model::CreateServiceRolloutRequest::rollout].
    pub fn set_rollout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Rollout>,
    {
        self.rollout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout][crate::model::CreateServiceRolloutRequest::rollout].
    pub fn set_or_clear_rollout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Rollout>,
    {
        self.rollout = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateServiceRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.CreateServiceRolloutRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateServiceRolloutRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __rollout,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateServiceRolloutRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "rollout" => Ok(__FieldTag::__rollout),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateServiceRolloutRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateServiceRolloutRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout => {
                            if !fields.insert(__FieldTag::__rollout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout",
                                ));
                            }
                            result.rollout =
                                map.next_value::<std::option::Option<crate::model::Rollout>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateServiceRolloutRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if self.rollout.is_some() {
            state.serialize_entry("rollout", &self.rollout)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateServiceRolloutRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateServiceRolloutRequest");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("rollout", &self.rollout);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListServiceRollouts'
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServiceRolloutsRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    pub service_name: std::string::String,

    /// The token of the page to retrieve.
    pub page_token: std::string::String,

    /// The max number of items to include in the response list. Page size is 50
    /// if not specified. Maximum value is 100.
    pub page_size: i32,

    /// Required. Use `filter` to return subset of rollouts.
    /// The following filters are supported:
    ///
    /// -- By [status]
    /// [google.api.servicemanagement.v1.Rollout.RolloutStatus]. For example,
    /// `filter='status=SUCCESS'`
    ///
    /// -- By [strategy]
    /// [google.api.servicemanagement.v1.Rollout.strategy]. For example,
    /// `filter='strategy=TrafficPercentStrategy'`
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServiceRolloutsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::ListServiceRolloutsRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListServiceRolloutsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListServiceRolloutsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListServiceRolloutsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListServiceRolloutsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServiceRolloutsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServiceRolloutsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __page_token,
            __page_size,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServiceRolloutsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServiceRolloutsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServiceRolloutsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServiceRolloutsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListServiceRolloutsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServiceRolloutsRequest");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("filter", &self.filter);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for ListServiceRollouts method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListServiceRolloutsResponse {
    /// The list of rollout resources.
    pub rollouts: std::vec::Vec<crate::model::Rollout>,

    /// The token of the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListServiceRolloutsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rollouts][crate::model::ListServiceRolloutsResponse::rollouts].
    pub fn set_rollouts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Rollout>,
    {
        use std::iter::Iterator;
        self.rollouts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListServiceRolloutsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListServiceRolloutsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.ListServiceRolloutsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListServiceRolloutsResponse {
    type PageItem = crate::model::Rollout;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rollouts
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListServiceRolloutsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rollouts,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListServiceRolloutsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rollouts" => Ok(__FieldTag::__rollouts),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListServiceRolloutsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListServiceRolloutsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rollouts => {
                            if !fields.insert(__FieldTag::__rollouts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollouts",
                                ));
                            }
                            result.rollouts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Rollout>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListServiceRolloutsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rollouts.is_empty() {
            state.serialize_entry("rollouts", &self.rollouts)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListServiceRolloutsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListServiceRolloutsResponse");
        debug_struct.field("rollouts", &self.rollouts);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for GetServiceRollout method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServiceRolloutRequest {
    /// Required. The name of the service.  See the
    /// [overview](https://cloud.google.com/service-management/overview) for naming
    /// requirements.  For example: `example.googleapis.com`.
    pub service_name: std::string::String,

    /// Required. The id of the rollout resource.
    pub rollout_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServiceRolloutRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::GetServiceRolloutRequest::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [rollout_id][crate::model::GetServiceRolloutRequest::rollout_id].
    pub fn set_rollout_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.rollout_id = v.into();
        self
    }
}

impl wkt::message::Message for GetServiceRolloutRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.GetServiceRolloutRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServiceRolloutRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __rollout_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServiceRolloutRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "rolloutId" => Ok(__FieldTag::__rollout_id),
                            "rollout_id" => Ok(__FieldTag::__rollout_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServiceRolloutRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServiceRolloutRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rollout_id => {
                            if !fields.insert(__FieldTag::__rollout_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rollout_id",
                                ));
                            }
                            result.rollout_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServiceRolloutRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self.rollout_id.is_empty() {
            state.serialize_entry("rolloutId", &self.rollout_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetServiceRolloutRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetServiceRolloutRequest");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("rollout_id", &self.rollout_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Operation payload for EnableService method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EnableServiceResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableServiceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for EnableServiceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.EnableServiceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnableServiceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnableServiceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnableServiceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnableServiceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnableServiceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EnableServiceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EnableServiceResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for GenerateConfigReport method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateConfigReportRequest {
    /// Required. Service configuration for which we want to generate the report.
    /// For this version of API, the supported types are
    /// [google.api.servicemanagement.v1.ConfigRef][google.api.servicemanagement.v1.ConfigRef],
    /// [google.api.servicemanagement.v1.ConfigSource][google.api.servicemanagement.v1.ConfigSource],
    /// and [google.api.Service][google.api.Service]
    ///
    /// [google.api.Service]: api::model::Service
    /// [google.api.servicemanagement.v1.ConfigRef]: crate::model::ConfigRef
    /// [google.api.servicemanagement.v1.ConfigSource]: crate::model::ConfigSource
    pub new_config: std::option::Option<wkt::Any>,

    /// Optional. Service configuration against which the comparison will be done.
    /// For this version of API, the supported types are
    /// [google.api.servicemanagement.v1.ConfigRef][google.api.servicemanagement.v1.ConfigRef],
    /// [google.api.servicemanagement.v1.ConfigSource][google.api.servicemanagement.v1.ConfigSource],
    /// and [google.api.Service][google.api.Service]
    ///
    /// [google.api.Service]: api::model::Service
    /// [google.api.servicemanagement.v1.ConfigRef]: crate::model::ConfigRef
    /// [google.api.servicemanagement.v1.ConfigSource]: crate::model::ConfigSource
    pub old_config: std::option::Option<wkt::Any>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateConfigReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_config][crate::model::GenerateConfigReportRequest::new_config].
    pub fn set_new_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Any>,
    {
        self.new_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [new_config][crate::model::GenerateConfigReportRequest::new_config].
    pub fn set_or_clear_new_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Any>,
    {
        self.new_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [old_config][crate::model::GenerateConfigReportRequest::old_config].
    pub fn set_old_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Any>,
    {
        self.old_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [old_config][crate::model::GenerateConfigReportRequest::old_config].
    pub fn set_or_clear_old_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Any>,
    {
        self.old_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateConfigReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.GenerateConfigReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateConfigReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __new_config,
            __old_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateConfigReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "newConfig" => Ok(__FieldTag::__new_config),
                            "new_config" => Ok(__FieldTag::__new_config),
                            "oldConfig" => Ok(__FieldTag::__old_config),
                            "old_config" => Ok(__FieldTag::__old_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateConfigReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateConfigReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__new_config => {
                            if !fields.insert(__FieldTag::__new_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_config",
                                ));
                            }
                            result.new_config =
                                map.next_value::<std::option::Option<wkt::Any>>()?;
                        }
                        __FieldTag::__old_config => {
                            if !fields.insert(__FieldTag::__old_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for old_config",
                                ));
                            }
                            result.old_config =
                                map.next_value::<std::option::Option<wkt::Any>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateConfigReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.new_config.is_some() {
            state.serialize_entry("newConfig", &self.new_config)?;
        }
        if self.old_config.is_some() {
            state.serialize_entry("oldConfig", &self.old_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateConfigReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateConfigReportRequest");
        debug_struct.field("new_config", &self.new_config);
        debug_struct.field("old_config", &self.old_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for GenerateConfigReport method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateConfigReportResponse {
    /// Name of the service this report belongs to.
    pub service_name: std::string::String,

    /// ID of the service configuration this report belongs to.
    pub id: std::string::String,

    /// list of ChangeReport, each corresponding to comparison between two
    /// service configurations.
    pub change_reports: std::vec::Vec<crate::model::ChangeReport>,

    /// Errors / Linter warnings associated with the service definition this
    /// report
    /// belongs to.
    pub diagnostics: std::vec::Vec<crate::model::Diagnostic>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateConfigReportResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_name][crate::model::GenerateConfigReportResponse::service_name].
    pub fn set_service_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_name = v.into();
        self
    }

    /// Sets the value of [id][crate::model::GenerateConfigReportResponse::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [change_reports][crate::model::GenerateConfigReportResponse::change_reports].
    pub fn set_change_reports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ChangeReport>,
    {
        use std::iter::Iterator;
        self.change_reports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [diagnostics][crate::model::GenerateConfigReportResponse::diagnostics].
    pub fn set_diagnostics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Diagnostic>,
    {
        use std::iter::Iterator;
        self.diagnostics = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for GenerateConfigReportResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.api.servicemanagement.v1.GenerateConfigReportResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateConfigReportResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_name,
            __id,
            __change_reports,
            __diagnostics,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateConfigReportResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceName" => Ok(__FieldTag::__service_name),
                            "service_name" => Ok(__FieldTag::__service_name),
                            "id" => Ok(__FieldTag::__id),
                            "changeReports" => Ok(__FieldTag::__change_reports),
                            "change_reports" => Ok(__FieldTag::__change_reports),
                            "diagnostics" => Ok(__FieldTag::__diagnostics),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateConfigReportResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateConfigReportResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_name => {
                            if !fields.insert(__FieldTag::__service_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_name",
                                ));
                            }
                            result.service_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__change_reports => {
                            if !fields.insert(__FieldTag::__change_reports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for change_reports",
                                ));
                            }
                            result.change_reports = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ChangeReport>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__diagnostics => {
                            if !fields.insert(__FieldTag::__diagnostics) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diagnostics",
                                ));
                            }
                            result.diagnostics = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Diagnostic>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateConfigReportResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_name.is_empty() {
            state.serialize_entry("serviceName", &self.service_name)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.change_reports.is_empty() {
            state.serialize_entry("changeReports", &self.change_reports)?;
        }
        if !self.diagnostics.is_empty() {
            state.serialize_entry("diagnostics", &self.diagnostics)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateConfigReportResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateConfigReportResponse");
        debug_struct.field("service_name", &self.service_name);
        debug_struct.field("id", &self.id);
        debug_struct.field("change_reports", &self.change_reports);
        debug_struct.field("diagnostics", &self.diagnostics);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
