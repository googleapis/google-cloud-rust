// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::SetIamPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource,
            __policy,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SetIamPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resource" => Ok(__FieldTag::__resource),
                            "policy" => Ok(__FieldTag::__policy),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::SetIamPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SetIamPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy =
                                map.next_value::<std::option::Option<crate::model::Policy>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetIamPolicyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource,
            __options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetIamPolicyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resource" => Ok(__FieldTag::__resource),
                            "options" => Ok(__FieldTag::__options),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetIamPolicyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetIamPolicyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__options => {
                            if !fields.insert(__FieldTag::__options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for options",
                                ));
                            }
                            result.options = map
                                .next_value::<std::option::Option<crate::model::GetPolicyOptions>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TestIamPermissionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resource,
            __permissions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestIamPermissionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resource" => Ok(__FieldTag::__resource),
                            "permissions" => Ok(__FieldTag::__permissions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TestIamPermissionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestIamPermissionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resource => {
                            if !fields.insert(__FieldTag::__resource) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource",
                                ));
                            }
                            result.resource = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__permissions => {
                            if !fields.insert(__FieldTag::__permissions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permissions",
                                ));
                            }
                            result.permissions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::TestIamPermissionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __permissions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestIamPermissionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "permissions" => Ok(__FieldTag::__permissions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::TestIamPermissionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestIamPermissionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__permissions => {
                            if !fields.insert(__FieldTag::__permissions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for permissions",
                                ));
                            }
                            result.permissions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::GetPolicyOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __requested_policy_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetPolicyOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requestedPolicyVersion" => Ok(__FieldTag::__requested_policy_version),
                            "requested_policy_version" => {
                                Ok(__FieldTag::__requested_policy_version)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::GetPolicyOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetPolicyOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__requested_policy_version => {
                            if !fields.insert(__FieldTag::__requested_policy_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_policy_version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.requested_policy_version =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Policy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __bindings,
            __audit_configs,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Policy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "bindings" => Ok(__FieldTag::__bindings),
                            "auditConfigs" => Ok(__FieldTag::__audit_configs),
                            "audit_configs" => Ok(__FieldTag::__audit_configs),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Policy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Policy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.version = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__bindings => {
                            if !fields.insert(__FieldTag::__bindings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bindings",
                                ));
                            }
                            result.bindings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Binding>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__audit_configs => {
                            if !fields.insert(__FieldTag::__audit_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audit_configs",
                                ));
                            }
                            result.audit_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AuditConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.etag = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::Binding {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __role,
            __members,
            __condition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Binding")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "role" => Ok(__FieldTag::__role),
                            "members" => Ok(__FieldTag::__members),
                            "condition" => Ok(__FieldTag::__condition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::Binding;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Binding")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__members => {
                            if !fields.insert(__FieldTag::__members) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for members",
                                ));
                            }
                            result.members = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition =
                                map.next_value::<std::option::Option<gtype::model::Expr>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AuditConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service,
            __audit_log_configs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuditConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "service" => Ok(__FieldTag::__service),
                            "auditLogConfigs" => Ok(__FieldTag::__audit_log_configs),
                            "audit_log_configs" => Ok(__FieldTag::__audit_log_configs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AuditConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuditConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__audit_log_configs => {
                            if !fields.insert(__FieldTag::__audit_log_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audit_log_configs",
                                ));
                            }
                            result.audit_log_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AuditLogConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AuditLogConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __log_type,
            __exempted_members,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuditLogConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "logType" => Ok(__FieldTag::__log_type),
                            "log_type" => Ok(__FieldTag::__log_type),
                            "exemptedMembers" => Ok(__FieldTag::__exempted_members),
                            "exempted_members" => Ok(__FieldTag::__exempted_members),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AuditLogConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuditLogConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__log_type => {
                            if !fields.insert(__FieldTag::__log_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_type",
                                ));
                            }
                            result.log_type = map.next_value::<std::option::Option<crate::model::audit_log_config::LogType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__exempted_members => {
                            if !fields.insert(__FieldTag::__exempted_members) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exempted_members",
                                ));
                            }
                            result.exempted_members = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::PolicyDelta {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __binding_deltas,
            __audit_config_deltas,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PolicyDelta")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bindingDeltas" => Ok(__FieldTag::__binding_deltas),
                            "binding_deltas" => Ok(__FieldTag::__binding_deltas),
                            "auditConfigDeltas" => Ok(__FieldTag::__audit_config_deltas),
                            "audit_config_deltas" => Ok(__FieldTag::__audit_config_deltas),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::PolicyDelta;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PolicyDelta")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__binding_deltas => {
                            if !fields.insert(__FieldTag::__binding_deltas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binding_deltas",
                                ));
                            }
                            result.binding_deltas = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BindingDelta>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__audit_config_deltas => {
                            if !fields.insert(__FieldTag::__audit_config_deltas) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audit_config_deltas",
                                ));
                            }
                            result.audit_config_deltas =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AuditConfigDelta>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::BindingDelta {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __action,
            __role,
            __member,
            __condition,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BindingDelta")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "action" => Ok(__FieldTag::__action),
                            "role" => Ok(__FieldTag::__role),
                            "member" => Ok(__FieldTag::__member),
                            "condition" => Ok(__FieldTag::__condition),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::BindingDelta;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BindingDelta")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map.next_value::<std::option::Option<crate::model::binding_delta::Action>>()?.unwrap_or_default();
                        }
                        __FieldTag::__role => {
                            if !fields.insert(__FieldTag::__role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for role",
                                ));
                            }
                            result.role = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__member => {
                            if !fields.insert(__FieldTag::__member) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for member",
                                ));
                            }
                            result.member = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__condition => {
                            if !fields.insert(__FieldTag::__condition) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for condition",
                                ));
                            }
                            result.condition =
                                map.next_value::<std::option::Option<gtype::model::Expr>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::AuditConfigDelta {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __action,
            __service,
            __exempted_member,
            __log_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AuditConfigDelta")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "action" => Ok(__FieldTag::__action),
                            "service" => Ok(__FieldTag::__service),
                            "exemptedMember" => Ok(__FieldTag::__exempted_member),
                            "exempted_member" => Ok(__FieldTag::__exempted_member),
                            "logType" => Ok(__FieldTag::__log_type),
                            "log_type" => Ok(__FieldTag::__log_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::AuditConfigDelta;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AuditConfigDelta")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action = map.next_value::<std::option::Option<crate::model::audit_config_delta::Action>>()?.unwrap_or_default();
                        }
                        __FieldTag::__service => {
                            if !fields.insert(__FieldTag::__service) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service",
                                ));
                            }
                            result.service = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__exempted_member => {
                            if !fields.insert(__FieldTag::__exempted_member) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for exempted_member",
                                ));
                            }
                            result.exempted_member = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__log_type => {
                            if !fields.insert(__FieldTag::__log_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for log_type",
                                ));
                            }
                            result.log_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for super::ResourcePolicyMember {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __iam_policy_name_principal,
            __iam_policy_uid_principal,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResourcePolicyMember")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "iamPolicyNamePrincipal" => Ok(__FieldTag::__iam_policy_name_principal),
                            "iam_policy_name_principal" => {
                                Ok(__FieldTag::__iam_policy_name_principal)
                            }
                            "iamPolicyUidPrincipal" => Ok(__FieldTag::__iam_policy_uid_principal),
                            "iam_policy_uid_principal" => {
                                Ok(__FieldTag::__iam_policy_uid_principal)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = super::ResourcePolicyMember;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResourcePolicyMember")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__iam_policy_name_principal => {
                            if !fields.insert(__FieldTag::__iam_policy_name_principal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_policy_name_principal",
                                ));
                            }
                            result.iam_policy_name_principal = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__iam_policy_uid_principal => {
                            if !fields.insert(__FieldTag::__iam_policy_uid_principal) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for iam_policy_uid_principal",
                                ));
                            }
                            result.iam_policy_uid_principal = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}
