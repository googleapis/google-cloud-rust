// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RepeatRequest {
    pub name: std::string::String,

    pub info: std::option::Option<crate::model::ComplianceData>,

    /// If true, the server will verify that the received request matches
    /// the request with the same name in the compliance test suite.
    pub server_verify: bool,

    /// The URI template this request is expected to be bound to server-side.
    pub intended_binding_uri: std::option::Option<std::string::String>,

    /// Some top level fields, to test that these are encoded correctly
    /// in query params.
    pub f_int32: i32,

    pub f_int64: i64,

    pub f_double: f64,

    pub p_int32: std::option::Option<i32>,

    pub p_int64: std::option::Option<i64>,

    pub p_double: std::option::Option<f64>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepeatRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RepeatRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [info][crate::model::RepeatRequest::info].
    pub fn set_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceData>,
    {
        self.info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [info][crate::model::RepeatRequest::info].
    pub fn set_or_clear_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceData>,
    {
        self.info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [server_verify][crate::model::RepeatRequest::server_verify].
    pub fn set_server_verify<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.server_verify = v.into();
        self
    }

    /// Sets the value of [intended_binding_uri][crate::model::RepeatRequest::intended_binding_uri].
    pub fn set_intended_binding_uri<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.intended_binding_uri = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [intended_binding_uri][crate::model::RepeatRequest::intended_binding_uri].
    pub fn set_or_clear_intended_binding_uri<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.intended_binding_uri = v.map(|x| x.into());
        self
    }

    /// Sets the value of [f_int32][crate::model::RepeatRequest::f_int32].
    pub fn set_f_int32<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.f_int32 = v.into();
        self
    }

    /// Sets the value of [f_int64][crate::model::RepeatRequest::f_int64].
    pub fn set_f_int64<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.f_int64 = v.into();
        self
    }

    /// Sets the value of [f_double][crate::model::RepeatRequest::f_double].
    pub fn set_f_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.f_double = v.into();
        self
    }

    /// Sets the value of [p_int32][crate::model::RepeatRequest::p_int32].
    pub fn set_p_int32<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.p_int32 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_int32][crate::model::RepeatRequest::p_int32].
    pub fn set_or_clear_p_int32<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.p_int32 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_int64][crate::model::RepeatRequest::p_int64].
    pub fn set_p_int64<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.p_int64 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_int64][crate::model::RepeatRequest::p_int64].
    pub fn set_or_clear_p_int64<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.p_int64 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_double][crate::model::RepeatRequest::p_double].
    pub fn set_p_double<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.p_double = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_double][crate::model::RepeatRequest::p_double].
    pub fn set_or_clear_p_double<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.p_double = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RepeatRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.RepeatRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RepeatRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __info,
            __server_verify,
            __intended_binding_uri,
            __f_int32,
            __f_int64,
            __f_double,
            __p_int32,
            __p_int64,
            __p_double,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepeatRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "info" => Ok(__FieldTag::__info),
                            "serverVerify" => Ok(__FieldTag::__server_verify),
                            "server_verify" => Ok(__FieldTag::__server_verify),
                            "intendedBindingUri" => Ok(__FieldTag::__intended_binding_uri),
                            "intended_binding_uri" => Ok(__FieldTag::__intended_binding_uri),
                            "fInt32" => Ok(__FieldTag::__f_int32),
                            "f_int32" => Ok(__FieldTag::__f_int32),
                            "fInt64" => Ok(__FieldTag::__f_int64),
                            "f_int64" => Ok(__FieldTag::__f_int64),
                            "fDouble" => Ok(__FieldTag::__f_double),
                            "f_double" => Ok(__FieldTag::__f_double),
                            "pInt32" => Ok(__FieldTag::__p_int32),
                            "p_int32" => Ok(__FieldTag::__p_int32),
                            "pInt64" => Ok(__FieldTag::__p_int64),
                            "p_int64" => Ok(__FieldTag::__p_int64),
                            "pDouble" => Ok(__FieldTag::__p_double),
                            "p_double" => Ok(__FieldTag::__p_double),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RepeatRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepeatRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__info => {
                            if !fields.insert(__FieldTag::__info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for info",
                                ));
                            }
                            result.info = map
                                .next_value::<std::option::Option<crate::model::ComplianceData>>(
                                )?;
                        }
                        __FieldTag::__server_verify => {
                            if !fields.insert(__FieldTag::__server_verify) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for server_verify",
                                ));
                            }
                            result.server_verify = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__intended_binding_uri => {
                            if !fields.insert(__FieldTag::__intended_binding_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for intended_binding_uri",
                                ));
                            }
                            result.intended_binding_uri =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__f_int32 => {
                            if !fields.insert(__FieldTag::__f_int32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_int32",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_int32 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_int64 => {
                            if !fields.insert(__FieldTag::__f_int64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_int64",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_int64 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_double => {
                            if !fields.insert(__FieldTag::__f_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_double",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_double = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__p_int32 => {
                            if !fields.insert(__FieldTag::__p_int32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_int32",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.p_int32 = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__p_int64 => {
                            if !fields.insert(__FieldTag::__p_int64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_int64",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.p_int64 = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__p_double => {
                            if !fields.insert(__FieldTag::__p_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_double",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.p_double = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RepeatRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.info.is_some() {
            state.serialize_entry("info", &self.info)?;
        }
        if !wkt::internal::is_default(&self.server_verify) {
            state.serialize_entry("serverVerify", &self.server_verify)?;
        }
        if self.intended_binding_uri.is_some() {
            state.serialize_entry("intendedBindingUri", &self.intended_binding_uri)?;
        }
        if !wkt::internal::is_default(&self.f_int32) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fInt32", &__With(&self.f_int32))?;
        }
        if !wkt::internal::is_default(&self.f_int64) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fInt64", &__With(&self.f_int64))?;
        }
        if !wkt::internal::is_default(&self.f_double) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fDouble", &__With(&self.f_double))?;
        }
        if self.p_int32.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pInt32", &__With(&self.p_int32))?;
        }
        if self.p_int64.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pInt64", &__With(&self.p_int64))?;
        }
        if self.p_double.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pDouble", &__With(&self.p_double))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RepeatResponse {
    pub request: std::option::Option<crate::model::RepeatRequest>,

    /// The URI template the request was bound to server-side.
    pub binding_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepeatResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::RepeatResponse::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RepeatRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::RepeatResponse::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RepeatRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [binding_uri][crate::model::RepeatResponse::binding_uri].
    pub fn set_binding_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.binding_uri = v.into();
        self
    }
}

impl wkt::message::Message for RepeatResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.RepeatResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RepeatResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request,
            __binding_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RepeatResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "request" => Ok(__FieldTag::__request),
                            "bindingUri" => Ok(__FieldTag::__binding_uri),
                            "binding_uri" => Ok(__FieldTag::__binding_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RepeatResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RepeatResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request = map
                                .next_value::<std::option::Option<crate::model::RepeatRequest>>()?;
                        }
                        __FieldTag::__binding_uri => {
                            if !fields.insert(__FieldTag::__binding_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for binding_uri",
                                ));
                            }
                            result.binding_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RepeatResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !self.binding_uri.is_empty() {
            state.serialize_entry("bindingUri", &self.binding_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ComplianceSuite contains a set of requests that microgenerators should issue
/// over REST to the Compliance service to test their gRPC-to-REST transcoding
/// implementation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComplianceSuite {
    pub group: std::vec::Vec<crate::model::ComplianceGroup>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceSuite {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::ComplianceSuite::group].
    pub fn set_group<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ComplianceGroup>,
    {
        use std::iter::Iterator;
        self.group = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComplianceSuite {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ComplianceSuite"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComplianceSuite {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceSuite")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComplianceSuite;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceSuite")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ComplianceGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComplianceSuite {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ComplianceGroups encapsulates a group of RPC requests to the Compliance
/// server: one request for each combination of elements of `rpcs` and of
/// `requests`.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComplianceGroup {
    pub name: std::string::String,

    pub rpcs: std::vec::Vec<std::string::String>,

    pub requests: std::vec::Vec<crate::model::RepeatRequest>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ComplianceGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rpcs][crate::model::ComplianceGroup::rpcs].
    pub fn set_rpcs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.rpcs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [requests][crate::model::ComplianceGroup::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RepeatRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComplianceGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ComplianceGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComplianceGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __rpcs,
            __requests,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "rpcs" => Ok(__FieldTag::__rpcs),
                            "requests" => Ok(__FieldTag::__requests),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComplianceGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rpcs => {
                            if !fields.insert(__FieldTag::__rpcs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rpcs",
                                ));
                            }
                            result.rpcs = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__requests => {
                            if !fields.insert(__FieldTag::__requests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requests",
                                ));
                            }
                            result.requests = map.next_value::<std::option::Option<std::vec::Vec<crate::model::RepeatRequest>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComplianceGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.rpcs.is_empty() {
            state.serialize_entry("rpcs", &self.rpcs)?;
        }
        if !self.requests.is_empty() {
            state.serialize_entry("requests", &self.requests)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// ComplianceData is a message used for testing REST transcoding of
/// different data types.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComplianceData {
    pub f_string: std::string::String,

    pub f_int32: i32,

    pub f_sint32: i32,

    pub f_sfixed32: i32,

    pub f_uint32: u32,

    pub f_fixed32: u32,

    pub f_int64: i64,

    pub f_sint64: i64,

    pub f_sfixed64: i64,

    pub f_uint64: u64,

    pub f_fixed64: u64,

    pub f_double: f64,

    pub f_float: f32,

    pub f_bool: bool,

    pub f_bytes: ::bytes::Bytes,

    pub f_kingdom: crate::model::compliance_data::LifeKingdom,

    pub f_child: std::option::Option<crate::model::ComplianceDataChild>,

    pub p_string: std::option::Option<std::string::String>,

    pub p_int32: std::option::Option<i32>,

    pub p_double: std::option::Option<f64>,

    pub p_bool: std::option::Option<bool>,

    pub p_kingdom: std::option::Option<crate::model::compliance_data::LifeKingdom>,

    pub p_child: std::option::Option<crate::model::ComplianceDataChild>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [f_string][crate::model::ComplianceData::f_string].
    pub fn set_f_string<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.f_string = v.into();
        self
    }

    /// Sets the value of [f_int32][crate::model::ComplianceData::f_int32].
    pub fn set_f_int32<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.f_int32 = v.into();
        self
    }

    /// Sets the value of [f_sint32][crate::model::ComplianceData::f_sint32].
    pub fn set_f_sint32<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.f_sint32 = v.into();
        self
    }

    /// Sets the value of [f_sfixed32][crate::model::ComplianceData::f_sfixed32].
    pub fn set_f_sfixed32<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.f_sfixed32 = v.into();
        self
    }

    /// Sets the value of [f_uint32][crate::model::ComplianceData::f_uint32].
    pub fn set_f_uint32<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.f_uint32 = v.into();
        self
    }

    /// Sets the value of [f_fixed32][crate::model::ComplianceData::f_fixed32].
    pub fn set_f_fixed32<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.f_fixed32 = v.into();
        self
    }

    /// Sets the value of [f_int64][crate::model::ComplianceData::f_int64].
    pub fn set_f_int64<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.f_int64 = v.into();
        self
    }

    /// Sets the value of [f_sint64][crate::model::ComplianceData::f_sint64].
    pub fn set_f_sint64<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.f_sint64 = v.into();
        self
    }

    /// Sets the value of [f_sfixed64][crate::model::ComplianceData::f_sfixed64].
    pub fn set_f_sfixed64<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.f_sfixed64 = v.into();
        self
    }

    /// Sets the value of [f_uint64][crate::model::ComplianceData::f_uint64].
    pub fn set_f_uint64<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.f_uint64 = v.into();
        self
    }

    /// Sets the value of [f_fixed64][crate::model::ComplianceData::f_fixed64].
    pub fn set_f_fixed64<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.f_fixed64 = v.into();
        self
    }

    /// Sets the value of [f_double][crate::model::ComplianceData::f_double].
    pub fn set_f_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.f_double = v.into();
        self
    }

    /// Sets the value of [f_float][crate::model::ComplianceData::f_float].
    pub fn set_f_float<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.f_float = v.into();
        self
    }

    /// Sets the value of [f_bool][crate::model::ComplianceData::f_bool].
    pub fn set_f_bool<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.f_bool = v.into();
        self
    }

    /// Sets the value of [f_bytes][crate::model::ComplianceData::f_bytes].
    pub fn set_f_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.f_bytes = v.into();
        self
    }

    /// Sets the value of [f_kingdom][crate::model::ComplianceData::f_kingdom].
    pub fn set_f_kingdom<T: std::convert::Into<crate::model::compliance_data::LifeKingdom>>(
        mut self,
        v: T,
    ) -> Self {
        self.f_kingdom = v.into();
        self
    }

    /// Sets the value of [f_child][crate::model::ComplianceData::f_child].
    pub fn set_f_child<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceDataChild>,
    {
        self.f_child = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [f_child][crate::model::ComplianceData::f_child].
    pub fn set_or_clear_f_child<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceDataChild>,
    {
        self.f_child = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_string][crate::model::ComplianceData::p_string].
    pub fn set_p_string<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.p_string = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_string][crate::model::ComplianceData::p_string].
    pub fn set_or_clear_p_string<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.p_string = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_int32][crate::model::ComplianceData::p_int32].
    pub fn set_p_int32<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.p_int32 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_int32][crate::model::ComplianceData::p_int32].
    pub fn set_or_clear_p_int32<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.p_int32 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_double][crate::model::ComplianceData::p_double].
    pub fn set_p_double<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.p_double = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_double][crate::model::ComplianceData::p_double].
    pub fn set_or_clear_p_double<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.p_double = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_bool][crate::model::ComplianceData::p_bool].
    pub fn set_p_bool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.p_bool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_bool][crate::model::ComplianceData::p_bool].
    pub fn set_or_clear_p_bool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.p_bool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_kingdom][crate::model::ComplianceData::p_kingdom].
    pub fn set_p_kingdom<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::compliance_data::LifeKingdom>,
    {
        self.p_kingdom = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_kingdom][crate::model::ComplianceData::p_kingdom].
    pub fn set_or_clear_p_kingdom<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::compliance_data::LifeKingdom>,
    {
        self.p_kingdom = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_child][crate::model::ComplianceData::p_child].
    pub fn set_p_child<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceDataChild>,
    {
        self.p_child = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_child][crate::model::ComplianceData::p_child].
    pub fn set_or_clear_p_child<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceDataChild>,
    {
        self.p_child = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComplianceData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ComplianceData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComplianceData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __f_string,
            __f_int32,
            __f_sint32,
            __f_sfixed32,
            __f_uint32,
            __f_fixed32,
            __f_int64,
            __f_sint64,
            __f_sfixed64,
            __f_uint64,
            __f_fixed64,
            __f_double,
            __f_float,
            __f_bool,
            __f_bytes,
            __f_kingdom,
            __f_child,
            __p_string,
            __p_int32,
            __p_double,
            __p_bool,
            __p_kingdom,
            __p_child,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fString" => Ok(__FieldTag::__f_string),
                            "f_string" => Ok(__FieldTag::__f_string),
                            "fInt32" => Ok(__FieldTag::__f_int32),
                            "f_int32" => Ok(__FieldTag::__f_int32),
                            "fSint32" => Ok(__FieldTag::__f_sint32),
                            "f_sint32" => Ok(__FieldTag::__f_sint32),
                            "fSfixed32" => Ok(__FieldTag::__f_sfixed32),
                            "f_sfixed32" => Ok(__FieldTag::__f_sfixed32),
                            "fUint32" => Ok(__FieldTag::__f_uint32),
                            "f_uint32" => Ok(__FieldTag::__f_uint32),
                            "fFixed32" => Ok(__FieldTag::__f_fixed32),
                            "f_fixed32" => Ok(__FieldTag::__f_fixed32),
                            "fInt64" => Ok(__FieldTag::__f_int64),
                            "f_int64" => Ok(__FieldTag::__f_int64),
                            "fSint64" => Ok(__FieldTag::__f_sint64),
                            "f_sint64" => Ok(__FieldTag::__f_sint64),
                            "fSfixed64" => Ok(__FieldTag::__f_sfixed64),
                            "f_sfixed64" => Ok(__FieldTag::__f_sfixed64),
                            "fUint64" => Ok(__FieldTag::__f_uint64),
                            "f_uint64" => Ok(__FieldTag::__f_uint64),
                            "fFixed64" => Ok(__FieldTag::__f_fixed64),
                            "f_fixed64" => Ok(__FieldTag::__f_fixed64),
                            "fDouble" => Ok(__FieldTag::__f_double),
                            "f_double" => Ok(__FieldTag::__f_double),
                            "fFloat" => Ok(__FieldTag::__f_float),
                            "f_float" => Ok(__FieldTag::__f_float),
                            "fBool" => Ok(__FieldTag::__f_bool),
                            "f_bool" => Ok(__FieldTag::__f_bool),
                            "fBytes" => Ok(__FieldTag::__f_bytes),
                            "f_bytes" => Ok(__FieldTag::__f_bytes),
                            "fKingdom" => Ok(__FieldTag::__f_kingdom),
                            "f_kingdom" => Ok(__FieldTag::__f_kingdom),
                            "fChild" => Ok(__FieldTag::__f_child),
                            "f_child" => Ok(__FieldTag::__f_child),
                            "pString" => Ok(__FieldTag::__p_string),
                            "p_string" => Ok(__FieldTag::__p_string),
                            "pInt32" => Ok(__FieldTag::__p_int32),
                            "p_int32" => Ok(__FieldTag::__p_int32),
                            "pDouble" => Ok(__FieldTag::__p_double),
                            "p_double" => Ok(__FieldTag::__p_double),
                            "pBool" => Ok(__FieldTag::__p_bool),
                            "p_bool" => Ok(__FieldTag::__p_bool),
                            "pKingdom" => Ok(__FieldTag::__p_kingdom),
                            "p_kingdom" => Ok(__FieldTag::__p_kingdom),
                            "pChild" => Ok(__FieldTag::__p_child),
                            "p_child" => Ok(__FieldTag::__p_child),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComplianceData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__f_string => {
                            if !fields.insert(__FieldTag::__f_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_string",
                                ));
                            }
                            result.f_string = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__f_int32 => {
                            if !fields.insert(__FieldTag::__f_int32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_int32",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_int32 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_sint32 => {
                            if !fields.insert(__FieldTag::__f_sint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_sint32",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_sint32 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_sfixed32 => {
                            if !fields.insert(__FieldTag::__f_sfixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_sfixed32",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_sfixed32 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_uint32 => {
                            if !fields.insert(__FieldTag::__f_uint32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_uint32",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_uint32 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_fixed32 => {
                            if !fields.insert(__FieldTag::__f_fixed32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_fixed32",
                                ));
                            }
                            struct __With(std::option::Option<u32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_fixed32 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_int64 => {
                            if !fields.insert(__FieldTag::__f_int64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_int64",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_int64 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_sint64 => {
                            if !fields.insert(__FieldTag::__f_sint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_sint64",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_sint64 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_sfixed64 => {
                            if !fields.insert(__FieldTag::__f_sfixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_sfixed64",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_sfixed64 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_uint64 => {
                            if !fields.insert(__FieldTag::__f_uint64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_uint64",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_uint64 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_fixed64 => {
                            if !fields.insert(__FieldTag::__f_fixed64) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_fixed64",
                                ));
                            }
                            struct __With(std::option::Option<u64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::U64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_fixed64 = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_double => {
                            if !fields.insert(__FieldTag::__f_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_double",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_double = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_float => {
                            if !fields.insert(__FieldTag::__f_float) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_float",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_float = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_bool => {
                            if !fields.insert(__FieldTag::__f_bool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_bool",
                                ));
                            }
                            result.f_bool = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__f_bytes => {
                            if !fields.insert(__FieldTag::__f_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_bytes",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_kingdom => {
                            if !fields.insert(__FieldTag::__f_kingdom) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_kingdom",
                                ));
                            }
                            result.f_kingdom = map.next_value::<std::option::Option<crate::model::compliance_data::LifeKingdom>>()?.unwrap_or_default();
                        }
                        __FieldTag::__f_child => {
                            if !fields.insert(__FieldTag::__f_child) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_child",
                                ));
                            }
                            result.f_child = map.next_value::<std::option::Option<crate::model::ComplianceDataChild>>()?
                                ;
                        }
                        __FieldTag::__p_string => {
                            if !fields.insert(__FieldTag::__p_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_string",
                                ));
                            }
                            result.p_string =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__p_int32 => {
                            if !fields.insert(__FieldTag::__p_int32) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_int32",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.p_int32 = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__p_double => {
                            if !fields.insert(__FieldTag::__p_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_double",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.p_double = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__p_bool => {
                            if !fields.insert(__FieldTag::__p_bool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_bool",
                                ));
                            }
                            result.p_bool = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__p_kingdom => {
                            if !fields.insert(__FieldTag::__p_kingdom) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_kingdom",
                                ));
                            }
                            result.p_kingdom = map.next_value::<std::option::Option<crate::model::compliance_data::LifeKingdom>>()?
                                ;
                        }
                        __FieldTag::__p_child => {
                            if !fields.insert(__FieldTag::__p_child) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_child",
                                ));
                            }
                            result.p_child = map.next_value::<std::option::Option<crate::model::ComplianceDataChild>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComplianceData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.f_string.is_empty() {
            state.serialize_entry("fString", &self.f_string)?;
        }
        if !wkt::internal::is_default(&self.f_int32) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fInt32", &__With(&self.f_int32))?;
        }
        if !wkt::internal::is_default(&self.f_sint32) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fSint32", &__With(&self.f_sint32))?;
        }
        if !wkt::internal::is_default(&self.f_sfixed32) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fSfixed32", &__With(&self.f_sfixed32))?;
        }
        if !wkt::internal::is_default(&self.f_uint32) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fUint32", &__With(&self.f_uint32))?;
        }
        if !wkt::internal::is_default(&self.f_fixed32) {
            struct __With<'a>(&'a u32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fFixed32", &__With(&self.f_fixed32))?;
        }
        if !wkt::internal::is_default(&self.f_int64) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fInt64", &__With(&self.f_int64))?;
        }
        if !wkt::internal::is_default(&self.f_sint64) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fSint64", &__With(&self.f_sint64))?;
        }
        if !wkt::internal::is_default(&self.f_sfixed64) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fSfixed64", &__With(&self.f_sfixed64))?;
        }
        if !wkt::internal::is_default(&self.f_uint64) {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fUint64", &__With(&self.f_uint64))?;
        }
        if !wkt::internal::is_default(&self.f_fixed64) {
            struct __With<'a>(&'a u64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::U64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fFixed64", &__With(&self.f_fixed64))?;
        }
        if !wkt::internal::is_default(&self.f_double) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fDouble", &__With(&self.f_double))?;
        }
        if !wkt::internal::is_default(&self.f_float) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fFloat", &__With(&self.f_float))?;
        }
        if !wkt::internal::is_default(&self.f_bool) {
            state.serialize_entry("fBool", &self.f_bool)?;
        }
        if !self.f_bytes.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fBytes", &__With(&self.f_bytes))?;
        }
        if !wkt::internal::is_default(&self.f_kingdom) {
            state.serialize_entry("fKingdom", &self.f_kingdom)?;
        }
        if self.f_child.is_some() {
            state.serialize_entry("fChild", &self.f_child)?;
        }
        if self.p_string.is_some() {
            state.serialize_entry("pString", &self.p_string)?;
        }
        if self.p_int32.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pInt32", &__With(&self.p_int32))?;
        }
        if self.p_double.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pDouble", &__With(&self.p_double))?;
        }
        if self.p_bool.is_some() {
            state.serialize_entry("pBool", &self.p_bool)?;
        }
        if self.p_kingdom.is_some() {
            state.serialize_entry("pKingdom", &self.p_kingdom)?;
        }
        if self.p_child.is_some() {
            state.serialize_entry("pChild", &self.p_child)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ComplianceData].
pub mod compliance_data {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LifeKingdom {
        Unspecified,
        Archaebacteria,
        Eubacteria,
        Protista,
        Fungi,
        Plantae,
        Animalia,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LifeKingdom::value] or
        /// [LifeKingdom::name].
        UnknownValue(life_kingdom::UnknownValue),
    }

    #[doc(hidden)]
    pub mod life_kingdom {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl LifeKingdom {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Archaebacteria => std::option::Option::Some(1),
                Self::Eubacteria => std::option::Option::Some(2),
                Self::Protista => std::option::Option::Some(3),
                Self::Fungi => std::option::Option::Some(4),
                Self::Plantae => std::option::Option::Some(5),
                Self::Animalia => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("LIFE_KINGDOM_UNSPECIFIED"),
                Self::Archaebacteria => std::option::Option::Some("ARCHAEBACTERIA"),
                Self::Eubacteria => std::option::Option::Some("EUBACTERIA"),
                Self::Protista => std::option::Option::Some("PROTISTA"),
                Self::Fungi => std::option::Option::Some("FUNGI"),
                Self::Plantae => std::option::Option::Some("PLANTAE"),
                Self::Animalia => std::option::Option::Some("ANIMALIA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for LifeKingdom {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for LifeKingdom {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for LifeKingdom {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Archaebacteria,
                2 => Self::Eubacteria,
                3 => Self::Protista,
                4 => Self::Fungi,
                5 => Self::Plantae,
                6 => Self::Animalia,
                _ => Self::UnknownValue(life_kingdom::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for LifeKingdom {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "LIFE_KINGDOM_UNSPECIFIED" => Self::Unspecified,
                "ARCHAEBACTERIA" => Self::Archaebacteria,
                "EUBACTERIA" => Self::Eubacteria,
                "PROTISTA" => Self::Protista,
                "FUNGI" => Self::Fungi,
                "PLANTAE" => Self::Plantae,
                "ANIMALIA" => Self::Animalia,
                _ => Self::UnknownValue(life_kingdom::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for LifeKingdom {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Archaebacteria => serializer.serialize_i32(1),
                Self::Eubacteria => serializer.serialize_i32(2),
                Self::Protista => serializer.serialize_i32(3),
                Self::Fungi => serializer.serialize_i32(4),
                Self::Plantae => serializer.serialize_i32(5),
                Self::Animalia => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for LifeKingdom {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LifeKingdom>::new(
                ".google.showcase.v1beta1.ComplianceData.LifeKingdom",
            ))
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComplianceDataChild {
    pub f_string: std::string::String,

    pub f_float: f32,

    pub f_double: f64,

    pub f_bool: bool,

    pub f_continent: crate::model::Continent,

    pub f_child: std::option::Option<crate::model::ComplianceDataGrandchild>,

    pub p_string: std::option::Option<std::string::String>,

    pub p_float: std::option::Option<f32>,

    pub p_double: std::option::Option<f64>,

    pub p_bool: std::option::Option<bool>,

    pub p_continent: crate::model::Continent,

    pub p_child: std::option::Option<crate::model::ComplianceDataGrandchild>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceDataChild {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [f_string][crate::model::ComplianceDataChild::f_string].
    pub fn set_f_string<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.f_string = v.into();
        self
    }

    /// Sets the value of [f_float][crate::model::ComplianceDataChild::f_float].
    pub fn set_f_float<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.f_float = v.into();
        self
    }

    /// Sets the value of [f_double][crate::model::ComplianceDataChild::f_double].
    pub fn set_f_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.f_double = v.into();
        self
    }

    /// Sets the value of [f_bool][crate::model::ComplianceDataChild::f_bool].
    pub fn set_f_bool<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.f_bool = v.into();
        self
    }

    /// Sets the value of [f_continent][crate::model::ComplianceDataChild::f_continent].
    pub fn set_f_continent<T: std::convert::Into<crate::model::Continent>>(mut self, v: T) -> Self {
        self.f_continent = v.into();
        self
    }

    /// Sets the value of [f_child][crate::model::ComplianceDataChild::f_child].
    pub fn set_f_child<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceDataGrandchild>,
    {
        self.f_child = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [f_child][crate::model::ComplianceDataChild::f_child].
    pub fn set_or_clear_f_child<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceDataGrandchild>,
    {
        self.f_child = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_string][crate::model::ComplianceDataChild::p_string].
    pub fn set_p_string<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.p_string = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_string][crate::model::ComplianceDataChild::p_string].
    pub fn set_or_clear_p_string<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.p_string = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_float][crate::model::ComplianceDataChild::p_float].
    pub fn set_p_float<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.p_float = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_float][crate::model::ComplianceDataChild::p_float].
    pub fn set_or_clear_p_float<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f32>,
    {
        self.p_float = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_double][crate::model::ComplianceDataChild::p_double].
    pub fn set_p_double<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.p_double = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_double][crate::model::ComplianceDataChild::p_double].
    pub fn set_or_clear_p_double<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.p_double = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_bool][crate::model::ComplianceDataChild::p_bool].
    pub fn set_p_bool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.p_bool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_bool][crate::model::ComplianceDataChild::p_bool].
    pub fn set_or_clear_p_bool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.p_bool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [p_continent][crate::model::ComplianceDataChild::p_continent].
    pub fn set_p_continent<T: std::convert::Into<crate::model::Continent>>(mut self, v: T) -> Self {
        self.p_continent = v.into();
        self
    }

    /// Sets the value of [p_child][crate::model::ComplianceDataChild::p_child].
    pub fn set_p_child<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceDataGrandchild>,
    {
        self.p_child = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [p_child][crate::model::ComplianceDataChild::p_child].
    pub fn set_or_clear_p_child<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComplianceDataGrandchild>,
    {
        self.p_child = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ComplianceDataChild {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ComplianceDataChild"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComplianceDataChild {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __f_string,
            __f_float,
            __f_double,
            __f_bool,
            __f_continent,
            __f_child,
            __p_string,
            __p_float,
            __p_double,
            __p_bool,
            __p_continent,
            __p_child,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceDataChild")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fString" => Ok(__FieldTag::__f_string),
                            "f_string" => Ok(__FieldTag::__f_string),
                            "fFloat" => Ok(__FieldTag::__f_float),
                            "f_float" => Ok(__FieldTag::__f_float),
                            "fDouble" => Ok(__FieldTag::__f_double),
                            "f_double" => Ok(__FieldTag::__f_double),
                            "fBool" => Ok(__FieldTag::__f_bool),
                            "f_bool" => Ok(__FieldTag::__f_bool),
                            "fContinent" => Ok(__FieldTag::__f_continent),
                            "f_continent" => Ok(__FieldTag::__f_continent),
                            "fChild" => Ok(__FieldTag::__f_child),
                            "f_child" => Ok(__FieldTag::__f_child),
                            "pString" => Ok(__FieldTag::__p_string),
                            "p_string" => Ok(__FieldTag::__p_string),
                            "pFloat" => Ok(__FieldTag::__p_float),
                            "p_float" => Ok(__FieldTag::__p_float),
                            "pDouble" => Ok(__FieldTag::__p_double),
                            "p_double" => Ok(__FieldTag::__p_double),
                            "pBool" => Ok(__FieldTag::__p_bool),
                            "p_bool" => Ok(__FieldTag::__p_bool),
                            "pContinent" => Ok(__FieldTag::__p_continent),
                            "p_continent" => Ok(__FieldTag::__p_continent),
                            "pChild" => Ok(__FieldTag::__p_child),
                            "p_child" => Ok(__FieldTag::__p_child),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComplianceDataChild;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceDataChild")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__f_string => {
                            if !fields.insert(__FieldTag::__f_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_string",
                                ));
                            }
                            result.f_string = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__f_float => {
                            if !fields.insert(__FieldTag::__f_float) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_float",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_float = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_double => {
                            if !fields.insert(__FieldTag::__f_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_double",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_double = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_bool => {
                            if !fields.insert(__FieldTag::__f_bool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_bool",
                                ));
                            }
                            result.f_bool = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__f_continent => {
                            if !fields.insert(__FieldTag::__f_continent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_continent",
                                ));
                            }
                            result.f_continent = map
                                .next_value::<std::option::Option<crate::model::Continent>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__f_child => {
                            if !fields.insert(__FieldTag::__f_child) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_child",
                                ));
                            }
                            result.f_child = map.next_value::<std::option::Option<crate::model::ComplianceDataGrandchild>>()?
                                ;
                        }
                        __FieldTag::__p_string => {
                            if !fields.insert(__FieldTag::__p_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_string",
                                ));
                            }
                            result.p_string =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__p_float => {
                            if !fields.insert(__FieldTag::__p_float) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_float",
                                ));
                            }
                            struct __With(std::option::Option<f32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.p_float = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__p_double => {
                            if !fields.insert(__FieldTag::__p_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_double",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.p_double = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__p_bool => {
                            if !fields.insert(__FieldTag::__p_bool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_bool",
                                ));
                            }
                            result.p_bool = map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__p_continent => {
                            if !fields.insert(__FieldTag::__p_continent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_continent",
                                ));
                            }
                            result.p_continent = map
                                .next_value::<std::option::Option<crate::model::Continent>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__p_child => {
                            if !fields.insert(__FieldTag::__p_child) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for p_child",
                                ));
                            }
                            result.p_child = map.next_value::<std::option::Option<crate::model::ComplianceDataGrandchild>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComplianceDataChild {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.f_string.is_empty() {
            state.serialize_entry("fString", &self.f_string)?;
        }
        if !wkt::internal::is_default(&self.f_float) {
            struct __With<'a>(&'a f32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fFloat", &__With(&self.f_float))?;
        }
        if !wkt::internal::is_default(&self.f_double) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fDouble", &__With(&self.f_double))?;
        }
        if !wkt::internal::is_default(&self.f_bool) {
            state.serialize_entry("fBool", &self.f_bool)?;
        }
        if !wkt::internal::is_default(&self.f_continent) {
            state.serialize_entry("fContinent", &self.f_continent)?;
        }
        if self.f_child.is_some() {
            state.serialize_entry("fChild", &self.f_child)?;
        }
        if self.p_string.is_some() {
            state.serialize_entry("pString", &self.p_string)?;
        }
        if self.p_float.is_some() {
            struct __With<'a>(&'a std::option::Option<f32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pFloat", &__With(&self.p_float))?;
        }
        if self.p_double.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("pDouble", &__With(&self.p_double))?;
        }
        if self.p_bool.is_some() {
            state.serialize_entry("pBool", &self.p_bool)?;
        }
        if !wkt::internal::is_default(&self.p_continent) {
            state.serialize_entry("pContinent", &self.p_continent)?;
        }
        if self.p_child.is_some() {
            state.serialize_entry("pChild", &self.p_child)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComplianceDataGrandchild {
    pub f_string: std::string::String,

    pub f_double: f64,

    pub f_bool: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceDataGrandchild {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [f_string][crate::model::ComplianceDataGrandchild::f_string].
    pub fn set_f_string<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.f_string = v.into();
        self
    }

    /// Sets the value of [f_double][crate::model::ComplianceDataGrandchild::f_double].
    pub fn set_f_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.f_double = v.into();
        self
    }

    /// Sets the value of [f_bool][crate::model::ComplianceDataGrandchild::f_bool].
    pub fn set_f_bool<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.f_bool = v.into();
        self
    }
}

impl wkt::message::Message for ComplianceDataGrandchild {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ComplianceDataGrandchild"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComplianceDataGrandchild {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __f_string,
            __f_double,
            __f_bool,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComplianceDataGrandchild")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fString" => Ok(__FieldTag::__f_string),
                            "f_string" => Ok(__FieldTag::__f_string),
                            "fDouble" => Ok(__FieldTag::__f_double),
                            "f_double" => Ok(__FieldTag::__f_double),
                            "fBool" => Ok(__FieldTag::__f_bool),
                            "f_bool" => Ok(__FieldTag::__f_bool),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComplianceDataGrandchild;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComplianceDataGrandchild")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__f_string => {
                            if !fields.insert(__FieldTag::__f_string) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_string",
                                ));
                            }
                            result.f_string = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__f_double => {
                            if !fields.insert(__FieldTag::__f_double) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_double",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.f_double = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__f_bool => {
                            if !fields.insert(__FieldTag::__f_bool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for f_bool",
                                ));
                            }
                            result.f_bool = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComplianceDataGrandchild {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.f_string.is_empty() {
            state.serialize_entry("fString", &self.f_string)?;
        }
        if !wkt::internal::is_default(&self.f_double) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fDouble", &__With(&self.f_double))?;
        }
        if !wkt::internal::is_default(&self.f_bool) {
            state.serialize_entry("fBool", &self.f_bool)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnumRequest {
    /// Whether the client is requesting a new, unknown enum value or a known enum value already declared in this proto file.
    pub unknown_enum: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnumRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [unknown_enum][crate::model::EnumRequest::unknown_enum].
    pub fn set_unknown_enum<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unknown_enum = v.into();
        self
    }
}

impl wkt::message::Message for EnumRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EnumRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnumRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __unknown_enum,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnumRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "unknownEnum" => Ok(__FieldTag::__unknown_enum),
                            "unknown_enum" => Ok(__FieldTag::__unknown_enum),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnumRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnumRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__unknown_enum => {
                            if !fields.insert(__FieldTag::__unknown_enum) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unknown_enum",
                                ));
                            }
                            result.unknown_enum = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnumRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.unknown_enum) {
            state.serialize_entry("unknownEnum", &self.unknown_enum)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EnumResponse {
    /// The original request for a known or unknown enum from the server.
    pub request: std::option::Option<crate::model::EnumRequest>,

    /// The actual enum the server provided.
    pub continent: crate::model::Continent,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnumResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::EnumResponse::request].
    pub fn set_request<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EnumRequest>,
    {
        self.request = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request][crate::model::EnumResponse::request].
    pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EnumRequest>,
    {
        self.request = v.map(|x| x.into());
        self
    }

    /// Sets the value of [continent][crate::model::EnumResponse::continent].
    pub fn set_continent<T: std::convert::Into<crate::model::Continent>>(mut self, v: T) -> Self {
        self.continent = v.into();
        self
    }
}

impl wkt::message::Message for EnumResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EnumResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EnumResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __request,
            __continent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EnumResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "request" => Ok(__FieldTag::__request),
                            "continent" => Ok(__FieldTag::__continent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EnumResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EnumResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__request => {
                            if !fields.insert(__FieldTag::__request) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request",
                                ));
                            }
                            result.request =
                                map.next_value::<std::option::Option<crate::model::EnumRequest>>()?;
                        }
                        __FieldTag::__continent => {
                            if !fields.insert(__FieldTag::__continent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for continent",
                                ));
                            }
                            result.continent = map
                                .next_value::<std::option::Option<crate::model::Continent>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EnumResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.request.is_some() {
            state.serialize_entry("request", &self.request)?;
        }
        if !wkt::internal::is_default(&self.continent) {
            state.serialize_entry("continent", &self.continent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message used for the Echo, Collect and Chat methods.
/// If content or opt are set in this message then the request will succeed.
/// If status is set in this message then the status will be returned as an
/// error.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EchoRequest {
    /// The severity to be echoed by the server.
    pub severity: crate::model::Severity,

    /// Optional. This field can be set to test the routing annotation on the Echo method.
    pub header: std::string::String,

    /// Optional. This field can be set to test the routing annotation on the Echo method.
    pub other_header: std::string::String,

    /// To facilitate testing of <https://google.aip.dev/client-libraries/4235>
    pub request_id: std::string::String,

    /// To facilitate testing of <https://google.aip.dev/client-libraries/4235>
    pub other_request_id: std::option::Option<std::string::String>,

    pub response: std::option::Option<crate::model::echo_request::Response>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EchoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [severity][crate::model::EchoRequest::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [header][crate::model::EchoRequest::header].
    pub fn set_header<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.header = v.into();
        self
    }

    /// Sets the value of [other_header][crate::model::EchoRequest::other_header].
    pub fn set_other_header<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.other_header = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::EchoRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [other_request_id][crate::model::EchoRequest::other_request_id].
    pub fn set_other_request_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.other_request_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [other_request_id][crate::model::EchoRequest::other_request_id].
    pub fn set_or_clear_other_request_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.other_request_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response][crate::model::EchoRequest::response].
    ///
    /// Note that all the setters affecting `response` are mutually
    /// exclusive.
    pub fn set_response<
        T: std::convert::Into<std::option::Option<crate::model::echo_request::Response>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }

    /// The value of [response][crate::model::EchoRequest::response]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::echo_request::Response::Content(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::EchoRequest::response]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response =
            std::option::Option::Some(crate::model::echo_request::Response::Content(v.into()));
        self
    }

    /// The value of [response][crate::model::EchoRequest::response]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::echo_request::Response::Error(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::EchoRequest::response]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response =
            std::option::Option::Some(crate::model::echo_request::Response::Error(v.into()));
        self
    }
}

impl wkt::message::Message for EchoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EchoRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EchoRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __error,
            __severity,
            __header,
            __other_header,
            __request_id,
            __other_request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EchoRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "error" => Ok(__FieldTag::__error),
                            "severity" => Ok(__FieldTag::__severity),
                            "header" => Ok(__FieldTag::__header),
                            "otherHeader" => Ok(__FieldTag::__other_header),
                            "other_header" => Ok(__FieldTag::__other_header),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "otherRequestId" => Ok(__FieldTag::__other_request_id),
                            "other_request_id" => Ok(__FieldTag::__other_request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EchoRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EchoRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            if result.response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response`, a oneof with full ID .google.showcase.v1beta1.EchoRequest.content, latest field was content",
                                ));
                            }
                            result.response = std::option::Option::Some(
                                crate::model::echo_request::Response::Content(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            if result.response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response`, a oneof with full ID .google.showcase.v1beta1.EchoRequest.error, latest field was error",
                                ));
                            }
                            result.response =
                                std::option::Option::Some(
                                    crate::model::echo_request::Response::Error(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<rpc::model::Status>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__header => {
                            if !fields.insert(__FieldTag::__header) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for header",
                                ));
                            }
                            result.header = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__other_header => {
                            if !fields.insert(__FieldTag::__other_header) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for other_header",
                                ));
                            }
                            result.other_header = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__other_request_id => {
                            if !fields.insert(__FieldTag::__other_request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for other_request_id",
                                ));
                            }
                            result.other_request_id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EchoRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.content() {
            state.serialize_entry("content", value)?;
        }
        if let Some(value) = self.error() {
            state.serialize_entry("error", value)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.header.is_empty() {
            state.serialize_entry("header", &self.header)?;
        }
        if !self.other_header.is_empty() {
            state.serialize_entry("otherHeader", &self.other_header)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if self.other_request_id.is_some() {
            state.serialize_entry("otherRequestId", &self.other_request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EchoRequest].
pub mod echo_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Response {
        /// The content to be echoed by the server.
        Content(std::string::String),
        /// The error to be thrown by the server.
        Error(std::boxed::Box<rpc::model::Status>),
    }
}

/// The response message for the Echo methods.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EchoResponse {
    /// The content specified in the request.
    pub content: std::string::String,

    /// The severity specified in the request.
    pub severity: crate::model::Severity,

    /// The request ID specified or autopopulated in the request.
    pub request_id: std::string::String,

    /// The other request ID specified or autopopulated in the request.
    pub other_request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EchoResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::EchoResponse::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::EchoResponse::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::EchoResponse::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [other_request_id][crate::model::EchoResponse::other_request_id].
    pub fn set_other_request_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.other_request_id = v.into();
        self
    }
}

impl wkt::message::Message for EchoResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EchoResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EchoResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __severity,
            __request_id,
            __other_request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EchoResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "severity" => Ok(__FieldTag::__severity),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "otherRequestId" => Ok(__FieldTag::__other_request_id),
                            "other_request_id" => Ok(__FieldTag::__other_request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EchoResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EchoResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__other_request_id => {
                            if !fields.insert(__FieldTag::__other_request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for other_request_id",
                                ));
                            }
                            result.other_request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EchoResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self.other_request_id.is_empty() {
            state.serialize_entry("otherRequestId", &self.other_request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message used for the EchoErrorDetails method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EchoErrorDetailsRequest {
    /// Content to return in a singular `*.error.details` field of type
    /// `google.protobuf.Any`
    pub single_detail_text: std::string::String,

    /// Content to return in a repeated `*.error.details` field of type
    /// `google.protobuf.Any`
    pub multi_detail_text: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EchoErrorDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [single_detail_text][crate::model::EchoErrorDetailsRequest::single_detail_text].
    pub fn set_single_detail_text<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.single_detail_text = v.into();
        self
    }

    /// Sets the value of [multi_detail_text][crate::model::EchoErrorDetailsRequest::multi_detail_text].
    pub fn set_multi_detail_text<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.multi_detail_text = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EchoErrorDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EchoErrorDetailsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EchoErrorDetailsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __single_detail_text,
            __multi_detail_text,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EchoErrorDetailsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singleDetailText" => Ok(__FieldTag::__single_detail_text),
                            "single_detail_text" => Ok(__FieldTag::__single_detail_text),
                            "multiDetailText" => Ok(__FieldTag::__multi_detail_text),
                            "multi_detail_text" => Ok(__FieldTag::__multi_detail_text),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EchoErrorDetailsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EchoErrorDetailsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__single_detail_text => {
                            if !fields.insert(__FieldTag::__single_detail_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_detail_text",
                                ));
                            }
                            result.single_detail_text = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__multi_detail_text => {
                            if !fields.insert(__FieldTag::__multi_detail_text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multi_detail_text",
                                ));
                            }
                            result.multi_detail_text = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EchoErrorDetailsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.single_detail_text.is_empty() {
            state.serialize_entry("singleDetailText", &self.single_detail_text)?;
        }
        if !self.multi_detail_text.is_empty() {
            state.serialize_entry("multiDetailText", &self.multi_detail_text)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message used for the EchoErrorDetails method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct EchoErrorDetailsResponse {
    pub single_detail: std::option::Option<crate::model::echo_error_details_response::SingleDetail>,

    pub multiple_details:
        std::option::Option<crate::model::echo_error_details_response::MultipleDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EchoErrorDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [single_detail][crate::model::EchoErrorDetailsResponse::single_detail].
    pub fn set_single_detail<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::echo_error_details_response::SingleDetail>,
    {
        self.single_detail = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [single_detail][crate::model::EchoErrorDetailsResponse::single_detail].
    pub fn set_or_clear_single_detail<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::echo_error_details_response::SingleDetail>,
    {
        self.single_detail = v.map(|x| x.into());
        self
    }

    /// Sets the value of [multiple_details][crate::model::EchoErrorDetailsResponse::multiple_details].
    pub fn set_multiple_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::echo_error_details_response::MultipleDetails>,
    {
        self.multiple_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [multiple_details][crate::model::EchoErrorDetailsResponse::multiple_details].
    pub fn set_or_clear_multiple_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::echo_error_details_response::MultipleDetails>,
    {
        self.multiple_details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EchoErrorDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EchoErrorDetailsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EchoErrorDetailsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __single_detail,
            __multiple_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EchoErrorDetailsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "singleDetail" => Ok(__FieldTag::__single_detail),
                            "single_detail" => Ok(__FieldTag::__single_detail),
                            "multipleDetails" => Ok(__FieldTag::__multiple_details),
                            "multiple_details" => Ok(__FieldTag::__multiple_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EchoErrorDetailsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EchoErrorDetailsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__single_detail => {
                            if !fields.insert(__FieldTag::__single_detail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_detail",
                                ));
                            }
                            result.single_detail = map.next_value::<std::option::Option<
                                crate::model::echo_error_details_response::SingleDetail,
                            >>()?;
                        }
                        __FieldTag::__multiple_details => {
                            if !fields.insert(__FieldTag::__multiple_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for multiple_details",
                                ));
                            }
                            result.multiple_details = map.next_value::<std::option::Option<
                                crate::model::echo_error_details_response::MultipleDetails,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EchoErrorDetailsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.single_detail.is_some() {
            state.serialize_entry("singleDetail", &self.single_detail)?;
        }
        if self.multiple_details.is_some() {
            state.serialize_entry("multipleDetails", &self.multiple_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [EchoErrorDetailsResponse].
pub mod echo_error_details_response {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SingleDetail {
        pub error: std::option::Option<crate::model::ErrorWithSingleDetail>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SingleDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error][crate::model::echo_error_details_response::SingleDetail::error].
        pub fn set_error<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ErrorWithSingleDetail>,
        {
            self.error = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [error][crate::model::echo_error_details_response::SingleDetail::error].
        pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ErrorWithSingleDetail>,
        {
            self.error = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SingleDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.EchoErrorDetailsResponse.SingleDetail"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SingleDetail {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __error,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SingleDetail")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "error" => Ok(__FieldTag::__error),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SingleDetail;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SingleDetail")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__error => {
                                if !fields.insert(__FieldTag::__error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error",
                                    ));
                                }
                                result.error = map.next_value::<std::option::Option<crate::model::ErrorWithSingleDetail>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SingleDetail {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.error.is_some() {
                state.serialize_entry("error", &self.error)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MultipleDetails {
        pub error: std::option::Option<crate::model::ErrorWithMultipleDetails>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MultipleDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error][crate::model::echo_error_details_response::MultipleDetails::error].
        pub fn set_error<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ErrorWithMultipleDetails>,
        {
            self.error = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [error][crate::model::echo_error_details_response::MultipleDetails::error].
        pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ErrorWithMultipleDetails>,
        {
            self.error = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for MultipleDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.EchoErrorDetailsResponse.MultipleDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MultipleDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __error,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MultipleDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "error" => Ok(__FieldTag::__error),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MultipleDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MultipleDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__error => {
                                if !fields.insert(__FieldTag::__error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error",
                                    ));
                                }
                                result.error = map.next_value::<std::option::Option<crate::model::ErrorWithMultipleDetails>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MultipleDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.error.is_some() {
                state.serialize_entry("error", &self.error)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorWithSingleDetail {
    pub details: std::option::Option<wkt::Any>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorWithSingleDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::ErrorWithSingleDetail::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Any>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::ErrorWithSingleDetail::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Any>,
    {
        self.details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ErrorWithSingleDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ErrorWithSingleDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ErrorWithSingleDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorWithSingleDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ErrorWithSingleDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorWithSingleDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map.next_value::<std::option::Option<wkt::Any>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ErrorWithSingleDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.details.is_some() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorWithMultipleDetails {
    pub details: std::vec::Vec<wkt::Any>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorWithMultipleDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::ErrorWithMultipleDetails::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ErrorWithMultipleDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ErrorWithMultipleDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ErrorWithMultipleDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ErrorWithMultipleDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ErrorWithMultipleDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ErrorWithMultipleDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map
                                .next_value::<std::option::Option<std::vec::Vec<wkt::Any>>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ErrorWithMultipleDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The custom error detail to be included in the error response from the
/// FailEchoWithDetails method. Client libraries should be able to
/// surface this custom error detail.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PoetryError {
    pub poem: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PoetryError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [poem][crate::model::PoetryError::poem].
    pub fn set_poem<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.poem = v.into();
        self
    }
}

impl wkt::message::Message for PoetryError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PoetryError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PoetryError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __poem,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PoetryError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "poem" => Ok(__FieldTag::__poem),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PoetryError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PoetryError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__poem => {
                            if !fields.insert(__FieldTag::__poem) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for poem",
                                ));
                            }
                            result.poem = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PoetryError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.poem.is_empty() {
            state.serialize_entry("poem", &self.poem)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message used for the FailEchoWithDetails method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FailEchoWithDetailsRequest {
    /// Optional message to echo back in the PoetryError. If empty, a value will be
    /// provided.
    pub message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailEchoWithDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::FailEchoWithDetailsRequest::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for FailEchoWithDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.FailEchoWithDetailsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FailEchoWithDetailsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FailEchoWithDetailsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "message" => Ok(__FieldTag::__message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FailEchoWithDetailsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FailEchoWithDetailsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__message => {
                            if !fields.insert(__FieldTag::__message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for message",
                                ));
                            }
                            result.message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FailEchoWithDetailsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.message.is_empty() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message declared (but never used) for the FailEchoWithDetails
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FailEchoWithDetailsResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailEchoWithDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for FailEchoWithDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.FailEchoWithDetailsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FailEchoWithDetailsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FailEchoWithDetailsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FailEchoWithDetailsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FailEchoWithDetailsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FailEchoWithDetailsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the Expand method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ExpandRequest {
    /// The content that will be split into words and returned on the stream.
    pub content: std::string::String,

    /// The error that is thrown after all words are sent on the stream.
    pub error: std::option::Option<rpc::model::Status>,

    /// The wait time between each server streaming messages
    pub stream_wait_time: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExpandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::ExpandRequest::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ExpandRequest::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::ExpandRequest::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stream_wait_time][crate::model::ExpandRequest::stream_wait_time].
    pub fn set_stream_wait_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.stream_wait_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stream_wait_time][crate::model::ExpandRequest::stream_wait_time].
    pub fn set_or_clear_stream_wait_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.stream_wait_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ExpandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ExpandRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExpandRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __error,
            __stream_wait_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExpandRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "error" => Ok(__FieldTag::__error),
                            "streamWaitTime" => Ok(__FieldTag::__stream_wait_time),
                            "stream_wait_time" => Ok(__FieldTag::__stream_wait_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExpandRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExpandRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__stream_wait_time => {
                            if !fields.insert(__FieldTag::__stream_wait_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for stream_wait_time",
                                ));
                            }
                            result.stream_wait_time =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExpandRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.stream_wait_time.is_some() {
            state.serialize_entry("streamWaitTime", &self.stream_wait_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for the PagedExpand method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PagedExpandRequest {
    /// The string to expand.
    pub content: std::string::String,

    /// The number of words to returned in each page.
    pub page_size: i32,

    /// The position of the page to be returned.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PagedExpandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::PagedExpandRequest::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::PagedExpandRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::PagedExpandRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for PagedExpandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PagedExpandRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PagedExpandRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PagedExpandRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PagedExpandRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PagedExpandRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PagedExpandRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for the PagedExpandLegacy method.  This is a pattern used by some legacy APIs. New
/// APIs should NOT use this pattern, but rather something like PagedExpandRequest which conforms to
/// aip.dev/158.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PagedExpandLegacyRequest {
    /// The string to expand.
    pub content: std::string::String,

    /// The number of words to returned in each page.
    /// (-- aip.dev/not-precedent: This is a legacy, non-standard pattern that
    /// violates aip.dev/158. Ordinarily, this should be page_size. --)
    pub max_results: i32,

    /// The position of the page to be returned.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PagedExpandLegacyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::PagedExpandLegacyRequest::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::PagedExpandLegacyRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::PagedExpandLegacyRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for PagedExpandLegacyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PagedExpandLegacyRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PagedExpandLegacyRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            __max_results,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PagedExpandLegacyRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            "maxResults" => Ok(__FieldTag::__max_results),
                            "max_results" => Ok(__FieldTag::__max_results),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PagedExpandLegacyRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PagedExpandLegacyRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__max_results => {
                            if !fields.insert(__FieldTag::__max_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_results",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.max_results = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PagedExpandLegacyRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !wkt::internal::is_default(&self.max_results) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("maxResults", &__With(&self.max_results))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response for the PagedExpand method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PagedExpandResponse {
    /// The words that were expanded.
    pub responses: std::vec::Vec<crate::model::EchoResponse>,

    /// The next page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PagedExpandResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [responses][crate::model::PagedExpandResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EchoResponse>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::PagedExpandResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for PagedExpandResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PagedExpandResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for PagedExpandResponse {
    type PageItem = crate::model::EchoResponse;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.responses
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PagedExpandResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __responses,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PagedExpandResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responses" => Ok(__FieldTag::__responses),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PagedExpandResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PagedExpandResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__responses => {
                            if !fields.insert(__FieldTag::__responses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for responses",
                                ));
                            }
                            result.responses = map.next_value::<std::option::Option<std::vec::Vec<crate::model::EchoResponse>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PagedExpandResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.responses.is_empty() {
            state.serialize_entry("responses", &self.responses)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A list of words.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PagedExpandResponseList {
    pub words: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PagedExpandResponseList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [words][crate::model::PagedExpandResponseList::words].
    pub fn set_words<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.words = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PagedExpandResponseList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PagedExpandResponseList"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PagedExpandResponseList {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __words,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PagedExpandResponseList")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "words" => Ok(__FieldTag::__words),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PagedExpandResponseList;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PagedExpandResponseList")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__words => {
                            if !fields.insert(__FieldTag::__words) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for words",
                                ));
                            }
                            result.words = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PagedExpandResponseList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.words.is_empty() {
            state.serialize_entry("words", &self.words)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PagedExpandLegacyMappedResponse {
    /// The words that were expanded, indexed by their initial character.
    /// (-- aip.dev/not-precedent: This is a legacy, non-standard pattern that violates
    /// aip.dev/158. Ordinarily, this should be a `repeated` field, as in PagedExpandResponse. --)
    pub alphabetized:
        std::collections::HashMap<std::string::String, crate::model::PagedExpandResponseList>,

    /// The next page token.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PagedExpandLegacyMappedResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [alphabetized][crate::model::PagedExpandLegacyMappedResponse::alphabetized].
    pub fn set_alphabetized<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::PagedExpandResponseList>,
    {
        use std::iter::Iterator;
        self.alphabetized = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::PagedExpandLegacyMappedResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for PagedExpandLegacyMappedResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PagedExpandLegacyMappedResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PagedExpandLegacyMappedResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __alphabetized,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PagedExpandLegacyMappedResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "alphabetized" => Ok(__FieldTag::__alphabetized),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PagedExpandLegacyMappedResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PagedExpandLegacyMappedResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__alphabetized => {
                            if !fields.insert(__FieldTag::__alphabetized) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for alphabetized",
                                ));
                            }
                            result.alphabetized = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::PagedExpandResponseList,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PagedExpandLegacyMappedResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.alphabetized.is_empty() {
            state.serialize_entry("alphabetized", &self.alphabetized)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for Wait method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WaitRequest {
    pub end: std::option::Option<crate::model::wait_request::End>,

    pub response: std::option::Option<crate::model::wait_request::Response>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WaitRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [end][crate::model::WaitRequest::end].
    ///
    /// Note that all the setters affecting `end` are mutually
    /// exclusive.
    pub fn set_end<T: std::convert::Into<std::option::Option<crate::model::wait_request::End>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end = v.into();
        self
    }

    /// The value of [end][crate::model::WaitRequest::end]
    /// if it holds a `EndTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn end_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.end.as_ref().and_then(|v| match v {
            crate::model::wait_request::End::EndTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [end][crate::model::WaitRequest::end]
    /// to hold a `EndTime`.
    ///
    /// Note that all the setters affecting `end` are
    /// mutually exclusive.
    pub fn set_end_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end = std::option::Option::Some(crate::model::wait_request::End::EndTime(v.into()));
        self
    }

    /// The value of [end][crate::model::WaitRequest::end]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.end.as_ref().and_then(|v| match v {
            crate::model::wait_request::End::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [end][crate::model::WaitRequest::end]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `end` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.end = std::option::Option::Some(crate::model::wait_request::End::Ttl(v.into()));
        self
    }

    /// Sets the value of [response][crate::model::WaitRequest::response].
    ///
    /// Note that all the setters affecting `response` are mutually
    /// exclusive.
    pub fn set_response<
        T: std::convert::Into<std::option::Option<crate::model::wait_request::Response>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }

    /// The value of [response][crate::model::WaitRequest::response]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::wait_request::Response::Error(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::WaitRequest::response]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response =
            std::option::Option::Some(crate::model::wait_request::Response::Error(v.into()));
        self
    }

    /// The value of [response][crate::model::WaitRequest::response]
    /// if it holds a `Success`, `None` if the field is not set or
    /// holds a different branch.
    pub fn success(&self) -> std::option::Option<&std::boxed::Box<crate::model::WaitResponse>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::wait_request::Response::Success(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::WaitRequest::response]
    /// to hold a `Success`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_success<T: std::convert::Into<std::boxed::Box<crate::model::WaitResponse>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response =
            std::option::Option::Some(crate::model::wait_request::Response::Success(v.into()));
        self
    }
}

impl wkt::message::Message for WaitRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.WaitRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WaitRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __end_time,
            __ttl,
            __error,
            __success,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WaitRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "error" => Ok(__FieldTag::__error),
                            "success" => Ok(__FieldTag::__success),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WaitRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WaitRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            if result.end.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `end`, a oneof with full ID .google.showcase.v1beta1.WaitRequest.end_time, latest field was endTime",
                                ));
                            }
                            result.end = std::option::Option::Some(
                                crate::model::wait_request::End::EndTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            if result.end.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `end`, a oneof with full ID .google.showcase.v1beta1.WaitRequest.ttl, latest field was ttl",
                                ));
                            }
                            result.end = std::option::Option::Some(
                                crate::model::wait_request::End::Ttl(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            if result.response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response`, a oneof with full ID .google.showcase.v1beta1.WaitRequest.error, latest field was error",
                                ));
                            }
                            result.response =
                                std::option::Option::Some(
                                    crate::model::wait_request::Response::Error(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<rpc::model::Status>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__success => {
                            if !fields.insert(__FieldTag::__success) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for success",
                                ));
                            }
                            if result.response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response`, a oneof with full ID .google.showcase.v1beta1.WaitRequest.success, latest field was success",
                                ));
                            }
                            result.response = std::option::Option::Some(
                                crate::model::wait_request::Response::Success(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::WaitResponse>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WaitRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.end_time() {
            state.serialize_entry("endTime", value)?;
        }
        if let Some(value) = self.ttl() {
            state.serialize_entry("ttl", value)?;
        }
        if let Some(value) = self.error() {
            state.serialize_entry("error", value)?;
        }
        if let Some(value) = self.success() {
            state.serialize_entry("success", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WaitRequest].
pub mod wait_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum End {
        /// The time that this operation will complete.
        EndTime(std::boxed::Box<wkt::Timestamp>),
        /// The duration of this operation.
        Ttl(std::boxed::Box<wkt::Duration>),
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Response {
        /// The error that will be returned by the server. If this code is specified
        /// to be the OK rpc code, an empty response will be returned.
        Error(std::boxed::Box<rpc::model::Status>),
        /// The response to be returned on operation completion.
        Success(std::boxed::Box<crate::model::WaitResponse>),
    }
}

/// The result of the Wait operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WaitResponse {
    /// This content of the result.
    pub content: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WaitResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::WaitResponse::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }
}

impl wkt::message::Message for WaitResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.WaitResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WaitResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WaitResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WaitResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WaitResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WaitResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The metadata for Wait operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WaitMetadata {
    /// The time that this operation will complete.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WaitMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [end_time][crate::model::WaitMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::WaitMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WaitMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.WaitMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WaitMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WaitMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WaitMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WaitMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WaitMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for Block method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BlockRequest {
    /// The amount of time to block before returning a response.
    pub response_delay: std::option::Option<wkt::Duration>,

    pub response: std::option::Option<crate::model::block_request::Response>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BlockRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_delay][crate::model::BlockRequest::response_delay].
    pub fn set_response_delay<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.response_delay = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [response_delay][crate::model::BlockRequest::response_delay].
    pub fn set_or_clear_response_delay<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.response_delay = v.map(|x| x.into());
        self
    }

    /// Sets the value of [response][crate::model::BlockRequest::response].
    ///
    /// Note that all the setters affecting `response` are mutually
    /// exclusive.
    pub fn set_response<
        T: std::convert::Into<std::option::Option<crate::model::block_request::Response>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }

    /// The value of [response][crate::model::BlockRequest::response]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::block_request::Response::Error(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::BlockRequest::response]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response =
            std::option::Option::Some(crate::model::block_request::Response::Error(v.into()));
        self
    }

    /// The value of [response][crate::model::BlockRequest::response]
    /// if it holds a `Success`, `None` if the field is not set or
    /// holds a different branch.
    pub fn success(&self) -> std::option::Option<&std::boxed::Box<crate::model::BlockResponse>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::block_request::Response::Success(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::BlockRequest::response]
    /// to hold a `Success`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_success<T: std::convert::Into<std::boxed::Box<crate::model::BlockResponse>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response =
            std::option::Option::Some(crate::model::block_request::Response::Success(v.into()));
        self
    }
}

impl wkt::message::Message for BlockRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.BlockRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BlockRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __response_delay,
            __error,
            __success,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BlockRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "responseDelay" => Ok(__FieldTag::__response_delay),
                            "response_delay" => Ok(__FieldTag::__response_delay),
                            "error" => Ok(__FieldTag::__error),
                            "success" => Ok(__FieldTag::__success),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BlockRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BlockRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__response_delay => {
                            if !fields.insert(__FieldTag::__response_delay) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for response_delay",
                                ));
                            }
                            result.response_delay =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            if result.response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response`, a oneof with full ID .google.showcase.v1beta1.BlockRequest.error, latest field was error",
                                ));
                            }
                            result.response =
                                std::option::Option::Some(
                                    crate::model::block_request::Response::Error(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<rpc::model::Status>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__success => {
                            if !fields.insert(__FieldTag::__success) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for success",
                                ));
                            }
                            if result.response.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `response`, a oneof with full ID .google.showcase.v1beta1.BlockRequest.success, latest field was success",
                                ));
                            }
                            result.response = std::option::Option::Some(
                                crate::model::block_request::Response::Success(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::BlockResponse>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BlockRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.response_delay.is_some() {
            state.serialize_entry("responseDelay", &self.response_delay)?;
        }
        if let Some(value) = self.error() {
            state.serialize_entry("error", value)?;
        }
        if let Some(value) = self.success() {
            state.serialize_entry("success", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [BlockRequest].
pub mod block_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Response {
        /// The error that will be returned by the server. If this code is specified
        /// to be the OK rpc code, an empty response will be returned.
        Error(std::boxed::Box<rpc::model::Status>),
        /// The response to be returned that will signify successful method call.
        Success(std::boxed::Box<crate::model::BlockResponse>),
    }
}

/// The response for Block method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BlockResponse {
    /// This content can contain anything, the server will not depend on a value
    /// here.
    pub content: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BlockResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::BlockResponse::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }
}

impl wkt::message::Message for BlockResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.BlockResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BlockResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BlockResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BlockResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BlockResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BlockResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A user.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct User {
    /// The resource name of the user.
    pub name: std::string::String,

    /// The display_name of the user.
    pub display_name: std::string::String,

    /// The email address of the user.
    pub email: std::string::String,

    /// The timestamp at which the user was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The latest timestamp at which the user was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The age of the user in years.
    pub age: std::option::Option<i32>,

    /// The height of the user in feet.
    pub height_feet: std::option::Option<f64>,

    /// The nickname of the user.
    ///
    /// (-- aip.dev/not-precedent: An empty string is a valid nickname.
    /// Ordinarily, proto3_optional should not be used on a `string` field. --)
    pub nickname: std::option::Option<std::string::String>,

    /// Enables the receiving of notifications. The default is true if unset.
    ///
    /// (-- aip.dev/not-precedent: The default for the feature is true.
    /// Ordinarily, the default for a `bool` field should be false. --)
    pub enable_notifications: std::option::Option<bool>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl User {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::User::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::User::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [email][crate::model::User::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::User::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::User::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::User::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::User::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [age][crate::model::User::age].
    pub fn set_age<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.age = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [age][crate::model::User::age].
    pub fn set_or_clear_age<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.age = v.map(|x| x.into());
        self
    }

    /// Sets the value of [height_feet][crate::model::User::height_feet].
    pub fn set_height_feet<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.height_feet = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [height_feet][crate::model::User::height_feet].
    pub fn set_or_clear_height_feet<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.height_feet = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nickname][crate::model::User::nickname].
    pub fn set_nickname<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.nickname = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nickname][crate::model::User::nickname].
    pub fn set_or_clear_nickname<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.nickname = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_notifications][crate::model::User::enable_notifications].
    pub fn set_enable_notifications<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_notifications = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_notifications][crate::model::User::enable_notifications].
    pub fn set_or_clear_enable_notifications<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_notifications = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for User {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.User"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for User {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __email,
            __create_time,
            __update_time,
            __age,
            __height_feet,
            __nickname,
            __enable_notifications,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for User")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "email" => Ok(__FieldTag::__email),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "age" => Ok(__FieldTag::__age),
                            "heightFeet" => Ok(__FieldTag::__height_feet),
                            "height_feet" => Ok(__FieldTag::__height_feet),
                            "nickname" => Ok(__FieldTag::__nickname),
                            "enableNotifications" => Ok(__FieldTag::__enable_notifications),
                            "enable_notifications" => Ok(__FieldTag::__enable_notifications),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = User;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct User")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__age => {
                            if !fields.insert(__FieldTag::__age) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for age",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.age = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__height_feet => {
                            if !fields.insert(__FieldTag::__height_feet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for height_feet",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.height_feet = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__nickname => {
                            if !fields.insert(__FieldTag::__nickname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nickname",
                                ));
                            }
                            result.nickname =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__enable_notifications => {
                            if !fields.insert(__FieldTag::__enable_notifications) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_notifications",
                                ));
                            }
                            result.enable_notifications =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for User {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.age.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("age", &__With(&self.age))?;
        }
        if self.height_feet.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("heightFeet", &__With(&self.height_feet))?;
        }
        if self.nickname.is_some() {
            state.serialize_entry("nickname", &self.nickname)?;
        }
        if self.enable_notifications.is_some() {
            state.serialize_entry("enableNotifications", &self.enable_notifications)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Identity\CreateUser
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateUserRequest {
    /// The user to create.
    pub user: std::option::Option<crate::model::User>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user][crate::model::CreateUserRequest::user].
    pub fn set_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user][crate::model::CreateUserRequest::user].
    pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateUserRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateUserRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateUserRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "user" => Ok(__FieldTag::__user),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateUserRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateUserRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user =
                                map.next_value::<std::option::Option<crate::model::User>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateUserRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.user.is_some() {
            state.serialize_entry("user", &self.user)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Identity\GetUser
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetUserRequest {
    /// The resource name of the requested user.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUserRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetUserRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetUserRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetUserRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetUserRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetUserRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetUserRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Identity\UpdateUser
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateUserRequest {
    /// The user to update.
    pub user: std::option::Option<crate::model::User>,

    /// The field mask to determine which fields are to be updated. If empty, the
    /// server will assume all fields are to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user][crate::model::UpdateUserRequest::user].
    pub fn set_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user][crate::model::UpdateUserRequest::user].
    pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::User>,
    {
        self.user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateUserRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateUserRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.UpdateUserRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateUserRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __user,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateUserRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "user" => Ok(__FieldTag::__user),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateUserRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateUserRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user =
                                map.next_value::<std::option::Option<crate::model::User>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateUserRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.user.is_some() {
            state.serialize_entry("user", &self.user)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Identity\DeleteUser
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteUserRequest {
    /// The resource name of the user to delete.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.DeleteUserRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteUserRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteUserRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteUserRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteUserRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteUserRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Identity\ListUsers
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsersRequest {
    /// The maximum number of users to return. Server may return fewer users
    /// than requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// The value of google.showcase.v1beta1.ListUsersResponse.next_page_token
    /// returned from the previous call to
    /// `google.showcase.v1beta1.Identity\ListUsers` method.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListUsersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUsersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListUsersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the google.showcase.v1beta1.Identity\ListUsers
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsersResponse {
    /// The list of users.
    pub users: std::vec::Vec<crate::model::User>,

    /// A token to retrieve next page of results.
    /// Pass this value in ListUsersRequest.page_token field in the subsequent
    /// call to `google.showcase.v1beta1.Message\ListUsers` method to retrieve the
    /// next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [users][crate::model::ListUsersResponse::users].
    pub fn set_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::User>,
    {
        use std::iter::Iterator;
        self.users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUsersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUsersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListUsersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUsersResponse {
    type PageItem = crate::model::User;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.users
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __users,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "users" => Ok(__FieldTag::__users),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__users => {
                            if !fields.insert(__FieldTag::__users) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for users",
                                ));
                            }
                            result.users = map.next_value::<std::option::Option<std::vec::Vec<crate::model::User>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.users.is_empty() {
            state.serialize_entry("users", &self.users)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A chat room.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Room {
    /// The resource name of the chat room.
    pub name: std::string::String,

    /// The human readable name of the chat room.
    pub display_name: std::string::String,

    /// The description of the chat room.
    pub description: std::string::String,

    /// The timestamp at which the room was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The latest timestamp at which the room was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Room {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Room::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Room::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Room::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Room::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Room::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Room::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Room::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Room {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Room"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Room {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __description,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Room")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Room;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Room")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Room {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\CreateRoom
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRoomRequest {
    /// The room to create.
    pub room: std::option::Option<crate::model::Room>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRoomRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [room][crate::model::CreateRoomRequest::room].
    pub fn set_room<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Room>,
    {
        self.room = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [room][crate::model::CreateRoomRequest::room].
    pub fn set_or_clear_room<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Room>,
    {
        self.room = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateRoomRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateRoomRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateRoomRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __room,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateRoomRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "room" => Ok(__FieldTag::__room),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateRoomRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateRoomRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__room => {
                            if !fields.insert(__FieldTag::__room) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for room",
                                ));
                            }
                            result.room =
                                map.next_value::<std::option::Option<crate::model::Room>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateRoomRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.room.is_some() {
            state.serialize_entry("room", &self.room)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\GetRoom
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRoomRequest {
    /// The resource name of the requested room.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRoomRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRoomRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRoomRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetRoomRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRoomRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRoomRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRoomRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRoomRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRoomRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\UpdateRoom
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateRoomRequest {
    /// The room to update.
    pub room: std::option::Option<crate::model::Room>,

    /// The field mask to determine which fields are to be updated. If empty, the
    /// server will assume all fields are to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRoomRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [room][crate::model::UpdateRoomRequest::room].
    pub fn set_room<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Room>,
    {
        self.room = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [room][crate::model::UpdateRoomRequest::room].
    pub fn set_or_clear_room<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Room>,
    {
        self.room = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRoomRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateRoomRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateRoomRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.UpdateRoomRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateRoomRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __room,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateRoomRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "room" => Ok(__FieldTag::__room),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateRoomRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateRoomRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__room => {
                            if !fields.insert(__FieldTag::__room) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for room",
                                ));
                            }
                            result.room =
                                map.next_value::<std::option::Option<crate::model::Room>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateRoomRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.room.is_some() {
            state.serialize_entry("room", &self.room)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\DeleteRoom
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRoomRequest {
    /// The resource name of the requested room.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRoomRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRoomRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRoomRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.DeleteRoomRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteRoomRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRoomRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteRoomRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRoomRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteRoomRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\ListRooms
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRoomsRequest {
    /// The maximum number of rooms return. Server may return fewer rooms
    /// than requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// The value of google.showcase.v1beta1.ListRoomsResponse.next_page_token
    /// returned from the previous call to
    /// `google.showcase.v1beta1.Messaging\ListRooms` method.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRoomsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListRoomsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRoomsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRoomsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListRoomsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRoomsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRoomsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRoomsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRoomsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRoomsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the google.showcase.v1beta1.Messaging\ListRooms
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRoomsResponse {
    /// The list of rooms.
    pub rooms: std::vec::Vec<crate::model::Room>,

    /// A token to retrieve next page of results.
    /// Pass this value in ListRoomsRequest.page_token field in the subsequent
    /// call to `google.showcase.v1beta1.Messaging\ListRooms` method to retrieve
    /// the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRoomsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [rooms][crate::model::ListRoomsResponse::rooms].
    pub fn set_rooms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Room>,
    {
        use std::iter::Iterator;
        self.rooms = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRoomsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRoomsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListRoomsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRoomsResponse {
    type PageItem = crate::model::Room;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rooms
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRoomsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __rooms,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRoomsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "rooms" => Ok(__FieldTag::__rooms),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRoomsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRoomsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__rooms => {
                            if !fields.insert(__FieldTag::__rooms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rooms",
                                ));
                            }
                            result.rooms = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Room>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRoomsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.rooms.is_empty() {
            state.serialize_entry("rooms", &self.rooms)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// This protocol buffer message represents a blurb sent to a chat room or
/// posted on a user profile.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Blurb {
    /// The resource name of the chat room.
    pub name: std::string::String,

    /// The resource name of the blurb's author.
    pub user: std::string::String,

    /// The timestamp at which the blurb was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The latest timestamp at which the blurb was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    pub content: std::option::Option<crate::model::blurb::Content>,

    /// (-- aip.dev/not-precedent: This is designed for testing non-slash
    /// resource patterns. Ordinarily, non-slash separators are discouraged.
    /// --)
    pub legacy_id: std::option::Option<crate::model::blurb::LegacyId>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Blurb {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Blurb::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [user][crate::model::Blurb::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Blurb::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Blurb::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Blurb::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Blurb::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [content][crate::model::Blurb::content].
    ///
    /// Note that all the setters affecting `content` are mutually
    /// exclusive.
    pub fn set_content<T: std::convert::Into<std::option::Option<crate::model::blurb::Content>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// The value of [content][crate::model::Blurb::content]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::blurb::Content::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Blurb::content]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = std::option::Option::Some(crate::model::blurb::Content::Text(v.into()));
        self
    }

    /// The value of [content][crate::model::Blurb::content]
    /// if it holds a `Image`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::blurb::Content::Image(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Blurb::content]
    /// to hold a `Image`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_image<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = std::option::Option::Some(crate::model::blurb::Content::Image(v.into()));
        self
    }

    /// Sets the value of [legacy_id][crate::model::Blurb::legacy_id].
    ///
    /// Note that all the setters affecting `legacy_id` are mutually
    /// exclusive.
    pub fn set_legacy_id<
        T: std::convert::Into<std::option::Option<crate::model::blurb::LegacyId>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.legacy_id = v.into();
        self
    }

    /// The value of [legacy_id][crate::model::Blurb::legacy_id]
    /// if it holds a `LegacyRoomId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn legacy_room_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.legacy_id.as_ref().and_then(|v| match v {
            crate::model::blurb::LegacyId::LegacyRoomId(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [legacy_id][crate::model::Blurb::legacy_id]
    /// to hold a `LegacyRoomId`.
    ///
    /// Note that all the setters affecting `legacy_id` are
    /// mutually exclusive.
    pub fn set_legacy_room_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.legacy_id =
            std::option::Option::Some(crate::model::blurb::LegacyId::LegacyRoomId(v.into()));
        self
    }

    /// The value of [legacy_id][crate::model::Blurb::legacy_id]
    /// if it holds a `LegacyUserId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn legacy_user_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.legacy_id.as_ref().and_then(|v| match v {
            crate::model::blurb::LegacyId::LegacyUserId(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [legacy_id][crate::model::Blurb::legacy_id]
    /// to hold a `LegacyUserId`.
    ///
    /// Note that all the setters affecting `legacy_id` are
    /// mutually exclusive.
    pub fn set_legacy_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.legacy_id =
            std::option::Option::Some(crate::model::blurb::LegacyId::LegacyUserId(v.into()));
        self
    }
}

impl wkt::message::Message for Blurb {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Blurb"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Blurb {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __user,
            __text,
            __image,
            __create_time,
            __update_time,
            __legacy_room_id,
            __legacy_user_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Blurb")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "user" => Ok(__FieldTag::__user),
                            "text" => Ok(__FieldTag::__text),
                            "image" => Ok(__FieldTag::__image),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "legacyRoomId" => Ok(__FieldTag::__legacy_room_id),
                            "legacy_room_id" => Ok(__FieldTag::__legacy_room_id),
                            "legacyUserId" => Ok(__FieldTag::__legacy_user_id),
                            "legacy_user_id" => Ok(__FieldTag::__legacy_user_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Blurb;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Blurb")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user => {
                            if !fields.insert(__FieldTag::__user) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user",
                                ));
                            }
                            result.user = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__text => {
                            if !fields.insert(__FieldTag::__text) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for text",
                                ));
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.showcase.v1beta1.Blurb.text, latest field was text",
                                ));
                            }
                            result.content =
                                std::option::Option::Some(crate::model::blurb::Content::Text(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            if result.content.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `content`, a oneof with full ID .google.showcase.v1beta1.Blurb.image, latest field was image",
                                ));
                            }
                            result.content =
                                std::option::Option::Some(crate::model::blurb::Content::Image(
                                    map.next_value::<__With>()?.0.unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__legacy_room_id => {
                            if !fields.insert(__FieldTag::__legacy_room_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for legacy_room_id",
                                ));
                            }
                            if result.legacy_id.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `legacy_id`, a oneof with full ID .google.showcase.v1beta1.Blurb.legacy_room_id, latest field was legacyRoomId",
                                ));
                            }
                            result.legacy_id = std::option::Option::Some(
                                crate::model::blurb::LegacyId::LegacyRoomId(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__legacy_user_id => {
                            if !fields.insert(__FieldTag::__legacy_user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for legacy_user_id",
                                ));
                            }
                            if result.legacy_id.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `legacy_id`, a oneof with full ID .google.showcase.v1beta1.Blurb.legacy_user_id, latest field was legacyUserId",
                                ));
                            }
                            result.legacy_id = std::option::Option::Some(
                                crate::model::blurb::LegacyId::LegacyUserId(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Blurb {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.user.is_empty() {
            state.serialize_entry("user", &self.user)?;
        }
        if let Some(value) = self.text() {
            state.serialize_entry("text", value)?;
        }
        if let Some(value) = self.image() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("image", &__With(value))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if let Some(value) = self.legacy_room_id() {
            state.serialize_entry("legacyRoomId", value)?;
        }
        if let Some(value) = self.legacy_user_id() {
            state.serialize_entry("legacyUserId", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Blurb].
pub mod blurb {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Content {
        /// The textual content of this blurb.
        Text(std::string::String),
        /// The image content of this blurb.
        Image(::bytes::Bytes),
    }

    /// (-- aip.dev/not-precedent: This is designed for testing non-slash
    /// resource patterns. Ordinarily, non-slash separators are discouraged.
    /// --)
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LegacyId {
        /// The legacy id of the room. This field is used to signal
        /// the use of the compound resource pattern
        /// `rooms/{room}/blurbs/legacy/{legacy_room}.{blurb}`
        LegacyRoomId(std::string::String),
        /// The legacy id of the user. This field is used to signal
        /// the use of the compound resource pattern
        /// `users/{user}/profile/blurbs/legacy/{legacy_user}~{blurb}`
        LegacyUserId(std::string::String),
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\CreateBlurb
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateBlurbRequest {
    /// The resource name of the chat room or user profile that this blurb will
    /// be tied to.
    pub parent: std::string::String,

    /// The blurb to create.
    pub blurb: std::option::Option<crate::model::Blurb>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBlurbRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBlurbRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [blurb][crate::model::CreateBlurbRequest::blurb].
    pub fn set_blurb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Blurb>,
    {
        self.blurb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [blurb][crate::model::CreateBlurbRequest::blurb].
    pub fn set_or_clear_blurb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Blurb>,
    {
        self.blurb = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateBlurbRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateBlurbRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateBlurbRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __blurb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateBlurbRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "blurb" => Ok(__FieldTag::__blurb),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateBlurbRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateBlurbRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__blurb => {
                            if !fields.insert(__FieldTag::__blurb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blurb",
                                ));
                            }
                            result.blurb =
                                map.next_value::<std::option::Option<crate::model::Blurb>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateBlurbRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.blurb.is_some() {
            state.serialize_entry("blurb", &self.blurb)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\GetBlurb
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBlurbRequest {
    /// The resource name of the requested blurb.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBlurbRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBlurbRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBlurbRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetBlurbRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBlurbRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBlurbRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBlurbRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBlurbRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBlurbRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\UpdateBlurb
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateBlurbRequest {
    /// The blurb to update.
    pub blurb: std::option::Option<crate::model::Blurb>,

    /// The field mask to determine which fields are to be updated. If empty, the
    /// server will assume all fields are to be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBlurbRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blurb][crate::model::UpdateBlurbRequest::blurb].
    pub fn set_blurb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Blurb>,
    {
        self.blurb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [blurb][crate::model::UpdateBlurbRequest::blurb].
    pub fn set_or_clear_blurb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Blurb>,
    {
        self.blurb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBlurbRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateBlurbRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateBlurbRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.UpdateBlurbRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateBlurbRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __blurb,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateBlurbRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "blurb" => Ok(__FieldTag::__blurb),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateBlurbRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateBlurbRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__blurb => {
                            if !fields.insert(__FieldTag::__blurb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blurb",
                                ));
                            }
                            result.blurb =
                                map.next_value::<std::option::Option<crate::model::Blurb>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateBlurbRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.blurb.is_some() {
            state.serialize_entry("blurb", &self.blurb)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\DeleteBlurb
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBlurbRequest {
    /// The resource name of the requested blurb.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBlurbRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBlurbRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBlurbRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.DeleteBlurbRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBlurbRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBlurbRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBlurbRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBlurbRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBlurbRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\ListBlurbs
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBlurbsRequest {
    /// The resource name of the requested room or profile who blurbs to list.
    pub parent: std::string::String,

    /// The maximum number of blurbs to return. Server may return fewer
    /// blurbs than requested. If unspecified, server will pick an appropriate
    /// default.
    pub page_size: i32,

    /// The value of google.showcase.v1beta1.ListBlurbsResponse.next_page_token
    /// returned from the previous call to
    /// `google.showcase.v1beta1.Messaging\ListBlurbs` method.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBlurbsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBlurbsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBlurbsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBlurbsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBlurbsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListBlurbsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBlurbsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBlurbsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBlurbsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBlurbsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBlurbsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the google.showcase.v1beta1.Messaging\ListBlurbs
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBlurbsResponse {
    /// The list of blurbs.
    pub blurbs: std::vec::Vec<crate::model::Blurb>,

    /// A token to retrieve next page of results.
    /// Pass this value in ListBlurbsRequest.page_token field in the subsequent
    /// call to `google.showcase.v1beta1.Blurb\ListBlurbs` method to retrieve
    /// the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBlurbsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blurbs][crate::model::ListBlurbsResponse::blurbs].
    pub fn set_blurbs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Blurb>,
    {
        use std::iter::Iterator;
        self.blurbs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBlurbsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBlurbsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListBlurbsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBlurbsResponse {
    type PageItem = crate::model::Blurb;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.blurbs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBlurbsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __blurbs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBlurbsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "blurbs" => Ok(__FieldTag::__blurbs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBlurbsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBlurbsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__blurbs => {
                            if !fields.insert(__FieldTag::__blurbs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blurbs",
                                ));
                            }
                            result.blurbs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Blurb>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBlurbsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.blurbs.is_empty() {
            state.serialize_entry("blurbs", &self.blurbs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\SearchBlurbs
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchBlurbsRequest {
    /// The query used to search for blurbs containing to words of this string.
    /// Only posts that contain an exact match of a queried word will be returned.
    pub query: std::string::String,

    /// The rooms or profiles to search. If unset, `SearchBlurbs` will search all
    /// rooms and all profiles.
    pub parent: std::string::String,

    /// The maximum number of blurbs return. Server may return fewer
    /// blurbs than requested. If unspecified, server will pick an appropriate
    /// default.
    pub page_size: i32,

    /// The value of
    /// google.showcase.v1beta1.SearchBlurbsResponse.next_page_token
    /// returned from the previous call to
    /// `google.showcase.v1beta1.Messaging\SearchBlurbs` method.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBlurbsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::SearchBlurbsRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::SearchBlurbsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchBlurbsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchBlurbsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchBlurbsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.SearchBlurbsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchBlurbsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __query,
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchBlurbsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "query" => Ok(__FieldTag::__query),
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchBlurbsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchBlurbsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__query => {
                            if !fields.insert(__FieldTag::__query) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for query",
                                ));
                            }
                            result.query = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchBlurbsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.query.is_empty() {
            state.serialize_entry("query", &self.query)?;
        }
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The operation metadata message for the
/// google.showcase.v1beta1.Messaging\SearchBlurbs method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchBlurbsMetadata {
    /// This signals to the client when to next poll for response.
    pub retry_info: std::option::Option<rpc::model::RetryInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBlurbsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retry_info][crate::model::SearchBlurbsMetadata::retry_info].
    pub fn set_retry_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::RetryInfo>,
    {
        self.retry_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retry_info][crate::model::SearchBlurbsMetadata::retry_info].
    pub fn set_or_clear_retry_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::RetryInfo>,
    {
        self.retry_info = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for SearchBlurbsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.SearchBlurbsMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchBlurbsMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __retry_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchBlurbsMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "retryInfo" => Ok(__FieldTag::__retry_info),
                            "retry_info" => Ok(__FieldTag::__retry_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchBlurbsMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchBlurbsMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__retry_info => {
                            if !fields.insert(__FieldTag::__retry_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retry_info",
                                ));
                            }
                            result.retry_info =
                                map.next_value::<std::option::Option<rpc::model::RetryInfo>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchBlurbsMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.retry_info.is_some() {
            state.serialize_entry("retryInfo", &self.retry_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The operation response message for the
/// google.showcase.v1beta1.Messaging\SearchBlurbs method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchBlurbsResponse {
    /// Blurbs that matched the search query.
    pub blurbs: std::vec::Vec<crate::model::Blurb>,

    /// A token to retrieve next page of results.
    /// Pass this value in SearchBlurbsRequest.page_token field in the subsequent
    /// call to `google.showcase.v1beta1.Blurb\SearchBlurbs` method to
    /// retrieve the next page of results.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBlurbsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blurbs][crate::model::SearchBlurbsResponse::blurbs].
    pub fn set_blurbs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Blurb>,
    {
        use std::iter::Iterator;
        self.blurbs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchBlurbsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchBlurbsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.SearchBlurbsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchBlurbsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __blurbs,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchBlurbsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "blurbs" => Ok(__FieldTag::__blurbs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchBlurbsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchBlurbsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__blurbs => {
                            if !fields.insert(__FieldTag::__blurbs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blurbs",
                                ));
                            }
                            result.blurbs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Blurb>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchBlurbsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.blurbs.is_empty() {
            state.serialize_entry("blurbs", &self.blurbs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\StreamBlurbs
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamBlurbsRequest {
    /// The resource name of a chat room or user profile whose blurbs to stream.
    pub name: std::string::String,

    /// The time at which this stream will close.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamBlurbsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StreamBlurbsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::StreamBlurbsRequest::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::StreamBlurbsRequest::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for StreamBlurbsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.StreamBlurbsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamBlurbsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __expire_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamBlurbsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamBlurbsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamBlurbsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamBlurbsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the google.showcase.v1beta1.Messaging\StreamBlurbs
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamBlurbsResponse {
    /// The blurb that was either created, updated, or deleted.
    pub blurb: std::option::Option<crate::model::Blurb>,

    /// The action that triggered the blurb to be returned.
    pub action: crate::model::stream_blurbs_response::Action,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamBlurbsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blurb][crate::model::StreamBlurbsResponse::blurb].
    pub fn set_blurb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Blurb>,
    {
        self.blurb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [blurb][crate::model::StreamBlurbsResponse::blurb].
    pub fn set_or_clear_blurb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Blurb>,
    {
        self.blurb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [action][crate::model::StreamBlurbsResponse::action].
    pub fn set_action<T: std::convert::Into<crate::model::stream_blurbs_response::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }
}

impl wkt::message::Message for StreamBlurbsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.StreamBlurbsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamBlurbsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __blurb,
            __action,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamBlurbsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "blurb" => Ok(__FieldTag::__blurb),
                            "action" => Ok(__FieldTag::__action),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamBlurbsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamBlurbsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__blurb => {
                            if !fields.insert(__FieldTag::__blurb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blurb",
                                ));
                            }
                            result.blurb =
                                map.next_value::<std::option::Option<crate::model::Blurb>>()?;
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action =
                                map.next_value::<std::option::Option<
                                    crate::model::stream_blurbs_response::Action,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamBlurbsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.blurb.is_some() {
            state.serialize_entry("blurb", &self.blurb)?;
        }
        if !wkt::internal::is_default(&self.action) {
            state.serialize_entry("action", &self.action)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamBlurbsResponse].
pub mod stream_blurbs_response {
    #[allow(unused_imports)]
    use super::*;

    /// The action that triggered the blurb to be returned.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        Unspecified,
        /// Specifies that the blurb was created.
        Create,
        /// Specifies that the blurb was updated.
        Update,
        /// Specifies that the blurb was deleted.
        Delete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Action::value] or
        /// [Action::name].
        UnknownValue(action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Action {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Create => std::option::Option::Some(1),
                Self::Update => std::option::Option::Some(2),
                Self::Delete => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACTION_UNSPECIFIED"),
                Self::Create => std::option::Option::Some("CREATE"),
                Self::Update => std::option::Option::Some("UPDATE"),
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Action {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Create,
                2 => Self::Update,
                3 => Self::Delete,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Action {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTION_UNSPECIFIED" => Self::Unspecified,
                "CREATE" => Self::Create,
                "UPDATE" => Self::Update,
                "DELETE" => Self::Delete,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Create => serializer.serialize_i32(1),
                Self::Update => serializer.serialize_i32(2),
                Self::Delete => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
                ".google.showcase.v1beta1.StreamBlurbsResponse.Action",
            ))
        }
    }
}

/// The response message for the google.showcase.v1beta1.Messaging\SendBlurbs
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SendBlurbsResponse {
    /// The names of successful blurb creations.
    pub names: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SendBlurbsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [names][crate::model::SendBlurbsResponse::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SendBlurbsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.SendBlurbsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SendBlurbsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __names,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SendBlurbsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "names" => Ok(__FieldTag::__names),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SendBlurbsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SendBlurbsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__names => {
                            if !fields.insert(__FieldTag::__names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for names",
                                ));
                            }
                            result.names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SendBlurbsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.names.is_empty() {
            state.serialize_entry("names", &self.names)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\Connect
/// method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ConnectRequest {
    pub request: std::option::Option<crate::model::connect_request::Request>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::ConnectRequest::request].
    ///
    /// Note that all the setters affecting `request` are mutually
    /// exclusive.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::connect_request::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::ConnectRequest::request]
    /// if it holds a `Config`, `None` if the field is not set or
    /// holds a different branch.
    pub fn config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::connect_request::ConnectConfig>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::connect_request::Request::Config(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::ConnectRequest::request]
    /// to hold a `Config`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_config<
        T: std::convert::Into<std::boxed::Box<crate::model::connect_request::ConnectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request =
            std::option::Option::Some(crate::model::connect_request::Request::Config(v.into()));
        self
    }

    /// The value of [request][crate::model::ConnectRequest::request]
    /// if it holds a `Blurb`, `None` if the field is not set or
    /// holds a different branch.
    pub fn blurb(&self) -> std::option::Option<&std::boxed::Box<crate::model::Blurb>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::connect_request::Request::Blurb(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::ConnectRequest::request]
    /// to hold a `Blurb`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_blurb<T: std::convert::Into<std::boxed::Box<crate::model::Blurb>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request =
            std::option::Option::Some(crate::model::connect_request::Request::Blurb(v.into()));
        self
    }
}

impl wkt::message::Message for ConnectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ConnectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConnectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            __blurb,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            "blurb" => Ok(__FieldTag::__blurb),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConnectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.showcase.v1beta1.ConnectRequest.config, latest field was config",
                                ));
                            }
                            result.request = std::option::Option::Some(
                                crate::model::connect_request::Request::Config(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::connect_request::ConnectConfig,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__blurb => {
                            if !fields.insert(__FieldTag::__blurb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blurb",
                                ));
                            }
                            if result.request.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `request`, a oneof with full ID .google.showcase.v1beta1.ConnectRequest.blurb, latest field was blurb",
                                ));
                            }
                            result.request =
                                std::option::Option::Some(
                                    crate::model::connect_request::Request::Blurb(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::Blurb>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConnectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.config() {
            state.serialize_entry("config", value)?;
        }
        if let Some(value) = self.blurb() {
            state.serialize_entry("blurb", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ConnectRequest].
pub mod connect_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConnectConfig {
        /// The room or profile to follow and create messages for.
        pub parent: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConnectConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parent][crate::model::connect_request::ConnectConfig::parent].
        pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.parent = v.into();
            self
        }
    }

    impl wkt::message::Message for ConnectConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.ConnectRequest.ConnectConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConnectConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __parent,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConnectConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "parent" => Ok(__FieldTag::__parent),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConnectConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConnectConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__parent => {
                                if !fields.insert(__FieldTag::__parent) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parent",
                                    ));
                                }
                                result.parent = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConnectConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.parent.is_empty() {
                state.serialize_entry("parent", &self.parent)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Request {
        /// Provides information that specifies how to process subsequent requests.
        /// The first `ConnectRequest` message must contain a `config`  message.
        Config(std::boxed::Box<crate::model::connect_request::ConnectConfig>),
        /// The blurb to be created.
        Blurb(std::boxed::Box<crate::model::Blurb>),
    }
}

/// HTTP/JSON error representation as defined in
/// <https://google.aip.dev/193#http11json-representation>,
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RestError {
    pub error: std::option::Option<crate::model::rest_error::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::RestError::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::rest_error::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::RestError::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::rest_error::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RestError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.RestError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RestError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RestError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RestError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RestError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error = map.next_value::<std::option::Option<crate::model::rest_error::Status>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RestError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RestError].
pub mod rest_error {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Status {
        /// The HTTP status code that corresponds to `google.rpc.Status.code`.
        pub code: i32,

        /// This corresponds to `google.rpc.Status.message`.
        pub message: std::string::String,

        /// This is the enum version for `google.rpc.Status.code`.
        pub status: rpc::model::Code,

        /// This corresponds to `google.rpc.Status.details`.
        pub details: std::vec::Vec<wkt::Any>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Status {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::rest_error::Status::code].
        pub fn set_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.code = v.into();
            self
        }

        /// Sets the value of [message][crate::model::rest_error::Status::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [status][crate::model::rest_error::Status::status].
        pub fn set_status<T: std::convert::Into<rpc::model::Code>>(mut self, v: T) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [details][crate::model::rest_error::Status::details].
        pub fn set_details<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<wkt::Any>,
        {
            use std::iter::Iterator;
            self.details = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Status {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.RestError.Status"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __code,
                __message,
                __status,
                __details,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Status")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "code" => Ok(__FieldTag::__code),
                                "message" => Ok(__FieldTag::__message),
                                "status" => Ok(__FieldTag::__status),
                                "details" => Ok(__FieldTag::__details),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Status;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Status")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__code => {
                                if !fields.insert(__FieldTag::__code) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for code",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.code = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__message => {
                                if !fields.insert(__FieldTag::__message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for message",
                                    ));
                                }
                                result.message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status = map
                                    .next_value::<std::option::Option<rpc::model::Code>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__details => {
                                if !fields.insert(__FieldTag::__details) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for details",
                                    ));
                                }
                                result.details = map
                                    .next_value::<std::option::Option<std::vec::Vec<wkt::Any>>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.code) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("code", &__With(&self.code))?;
            }
            if !self.message.is_empty() {
                state.serialize_entry("message", &self.message)?;
            }
            if !wkt::internal::is_default(&self.status) {
                state.serialize_entry("status", &self.status)?;
            }
            if !self.details.is_empty() {
                state.serialize_entry("details", &self.details)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Sequence {
    pub name: std::string::String,

    /// Sequence of responses to return in order for each attempt. If empty, the
    /// default response is an immediate OK.
    pub responses: std::vec::Vec<crate::model::sequence::Response>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Sequence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Sequence::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [responses][crate::model::Sequence::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::sequence::Response>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Sequence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Sequence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Sequence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __responses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Sequence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "responses" => Ok(__FieldTag::__responses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Sequence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Sequence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__responses => {
                            if !fields.insert(__FieldTag::__responses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for responses",
                                ));
                            }
                            result.responses = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::sequence::Response>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Sequence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.responses.is_empty() {
            state.serialize_entry("responses", &self.responses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Sequence].
pub mod sequence {
    #[allow(unused_imports)]
    use super::*;

    /// A server response to an RPC Attempt in a sequence.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Response {
        /// The status to return for an individual attempt.
        pub status: std::option::Option<rpc::model::Status>,

        /// The amount of time to delay sending the response.
        pub delay: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Response {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [status][crate::model::sequence::Response::status].
        pub fn set_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [status][crate::model::sequence::Response::status].
        pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = v.map(|x| x.into());
            self
        }

        /// Sets the value of [delay][crate::model::sequence::Response::delay].
        pub fn set_delay<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.delay = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [delay][crate::model::sequence::Response::delay].
        pub fn set_or_clear_delay<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.delay = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Response {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.Sequence.Response"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Response {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __status,
                __delay,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Response")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "status" => Ok(__FieldTag::__status),
                                "delay" => Ok(__FieldTag::__delay),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Response;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Response")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::__delay => {
                                if !fields.insert(__FieldTag::__delay) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for delay",
                                    ));
                                }
                                result.delay =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Response {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.status.is_some() {
                state.serialize_entry("status", &self.status)?;
            }
            if self.delay.is_some() {
                state.serialize_entry("delay", &self.delay)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingSequence {
    pub name: std::string::String,

    /// The Content that the stream will send
    pub content: std::string::String,

    /// Sequence of responses to return in order for each attempt. If empty, the
    /// default response is an immediate OK.
    pub responses: std::vec::Vec<crate::model::streaming_sequence::Response>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingSequence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StreamingSequence::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [content][crate::model::StreamingSequence::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [responses][crate::model::StreamingSequence::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::streaming_sequence::Response>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StreamingSequence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.StreamingSequence"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingSequence {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __content,
            __responses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingSequence")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "content" => Ok(__FieldTag::__content),
                            "responses" => Ok(__FieldTag::__responses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingSequence;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingSequence")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__responses => {
                            if !fields.insert(__FieldTag::__responses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for responses",
                                ));
                            }
                            result.responses = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::streaming_sequence::Response>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingSequence {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self.responses.is_empty() {
            state.serialize_entry("responses", &self.responses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamingSequence].
pub mod streaming_sequence {
    #[allow(unused_imports)]
    use super::*;

    /// A server response to an RPC Attempt in a sequence.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Response {
        /// The status to return for an individual attempt.
        pub status: std::option::Option<rpc::model::Status>,

        /// The amount of time to delay sending the response.
        pub delay: std::option::Option<wkt::Duration>,

        /// The index that the status should be sent
        pub response_index: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Response {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [status][crate::model::streaming_sequence::Response::status].
        pub fn set_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [status][crate::model::streaming_sequence::Response::status].
        pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = v.map(|x| x.into());
            self
        }

        /// Sets the value of [delay][crate::model::streaming_sequence::Response::delay].
        pub fn set_delay<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.delay = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [delay][crate::model::streaming_sequence::Response::delay].
        pub fn set_or_clear_delay<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.delay = v.map(|x| x.into());
            self
        }

        /// Sets the value of [response_index][crate::model::streaming_sequence::Response::response_index].
        pub fn set_response_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.response_index = v.into();
            self
        }
    }

    impl wkt::message::Message for Response {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.StreamingSequence.Response"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Response {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __status,
                __delay,
                __response_index,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Response")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "status" => Ok(__FieldTag::__status),
                                "delay" => Ok(__FieldTag::__delay),
                                "responseIndex" => Ok(__FieldTag::__response_index),
                                "response_index" => Ok(__FieldTag::__response_index),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Response;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Response")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::__delay => {
                                if !fields.insert(__FieldTag::__delay) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for delay",
                                    ));
                                }
                                result.delay =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__response_index => {
                                if !fields.insert(__FieldTag::__response_index) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for response_index",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.response_index =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Response {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.status.is_some() {
                state.serialize_entry("status", &self.status)?;
            }
            if self.delay.is_some() {
                state.serialize_entry("delay", &self.delay)?;
            }
            if !wkt::internal::is_default(&self.response_index) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("responseIndex", &__With(&self.response_index))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StreamingSequenceReport {
    pub name: std::string::String,

    /// The set of RPC attempts received by the server for a Sequence.
    pub attempts: std::vec::Vec<crate::model::streaming_sequence_report::Attempt>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingSequenceReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StreamingSequenceReport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [attempts][crate::model::StreamingSequenceReport::attempts].
    pub fn set_attempts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::streaming_sequence_report::Attempt>,
    {
        use std::iter::Iterator;
        self.attempts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StreamingSequenceReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.StreamingSequenceReport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StreamingSequenceReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __attempts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StreamingSequenceReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "attempts" => Ok(__FieldTag::__attempts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StreamingSequenceReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StreamingSequenceReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attempts => {
                            if !fields.insert(__FieldTag::__attempts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attempts",
                                ));
                            }
                            result.attempts = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::streaming_sequence_report::Attempt>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StreamingSequenceReport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.attempts.is_empty() {
            state.serialize_entry("attempts", &self.attempts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [StreamingSequenceReport].
pub mod streaming_sequence_report {
    #[allow(unused_imports)]
    use super::*;

    /// Contains metrics on individual RPC Attempts in a sequence.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Attempt {
        /// The attempt number - starting at 0.
        pub attempt_number: i32,

        /// The deadline dictated by the attempt to the server.
        pub attempt_deadline: std::option::Option<wkt::Timestamp>,

        /// The time that the server responded to the RPC attempt. Used for
        /// calculating attempt_delay.
        pub response_time: std::option::Option<wkt::Timestamp>,

        /// The server perceived delay between sending the last response and
        /// receiving this attempt. Used for validating attempt delay backoff.
        pub attempt_delay: std::option::Option<wkt::Duration>,

        /// The status returned to the attempt.
        pub status: std::option::Option<rpc::model::Status>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Attempt {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [attempt_number][crate::model::streaming_sequence_report::Attempt::attempt_number].
        pub fn set_attempt_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.attempt_number = v.into();
            self
        }

        /// Sets the value of [attempt_deadline][crate::model::streaming_sequence_report::Attempt::attempt_deadline].
        pub fn set_attempt_deadline<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.attempt_deadline = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [attempt_deadline][crate::model::streaming_sequence_report::Attempt::attempt_deadline].
        pub fn set_or_clear_attempt_deadline<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.attempt_deadline = v.map(|x| x.into());
            self
        }

        /// Sets the value of [response_time][crate::model::streaming_sequence_report::Attempt::response_time].
        pub fn set_response_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.response_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [response_time][crate::model::streaming_sequence_report::Attempt::response_time].
        pub fn set_or_clear_response_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.response_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [attempt_delay][crate::model::streaming_sequence_report::Attempt::attempt_delay].
        pub fn set_attempt_delay<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.attempt_delay = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [attempt_delay][crate::model::streaming_sequence_report::Attempt::attempt_delay].
        pub fn set_or_clear_attempt_delay<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.attempt_delay = v.map(|x| x.into());
            self
        }

        /// Sets the value of [status][crate::model::streaming_sequence_report::Attempt::status].
        pub fn set_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [status][crate::model::streaming_sequence_report::Attempt::status].
        pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Attempt {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.StreamingSequenceReport.Attempt"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Attempt {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __attempt_number,
                __attempt_deadline,
                __response_time,
                __attempt_delay,
                __status,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Attempt")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "attemptNumber" => Ok(__FieldTag::__attempt_number),
                                "attempt_number" => Ok(__FieldTag::__attempt_number),
                                "attemptDeadline" => Ok(__FieldTag::__attempt_deadline),
                                "attempt_deadline" => Ok(__FieldTag::__attempt_deadline),
                                "responseTime" => Ok(__FieldTag::__response_time),
                                "response_time" => Ok(__FieldTag::__response_time),
                                "attemptDelay" => Ok(__FieldTag::__attempt_delay),
                                "attempt_delay" => Ok(__FieldTag::__attempt_delay),
                                "status" => Ok(__FieldTag::__status),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Attempt;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Attempt")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__attempt_number => {
                                if !fields.insert(__FieldTag::__attempt_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attempt_number",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.attempt_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__attempt_deadline => {
                                if !fields.insert(__FieldTag::__attempt_deadline) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attempt_deadline",
                                    ));
                                }
                                result.attempt_deadline =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__response_time => {
                                if !fields.insert(__FieldTag::__response_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for response_time",
                                    ));
                                }
                                result.response_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__attempt_delay => {
                                if !fields.insert(__FieldTag::__attempt_delay) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attempt_delay",
                                    ));
                                }
                                result.attempt_delay =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Attempt {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.attempt_number) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("attemptNumber", &__With(&self.attempt_number))?;
            }
            if self.attempt_deadline.is_some() {
                state.serialize_entry("attemptDeadline", &self.attempt_deadline)?;
            }
            if self.response_time.is_some() {
                state.serialize_entry("responseTime", &self.response_time)?;
            }
            if self.attempt_delay.is_some() {
                state.serialize_entry("attemptDelay", &self.attempt_delay)?;
            }
            if self.status.is_some() {
                state.serialize_entry("status", &self.status)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SequenceReport {
    pub name: std::string::String,

    /// The set of RPC attempts received by the server for a Sequence.
    pub attempts: std::vec::Vec<crate::model::sequence_report::Attempt>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SequenceReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SequenceReport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [attempts][crate::model::SequenceReport::attempts].
    pub fn set_attempts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::sequence_report::Attempt>,
    {
        use std::iter::Iterator;
        self.attempts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SequenceReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.SequenceReport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SequenceReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __attempts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SequenceReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "attempts" => Ok(__FieldTag::__attempts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SequenceReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SequenceReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__attempts => {
                            if !fields.insert(__FieldTag::__attempts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for attempts",
                                ));
                            }
                            result.attempts = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::sequence_report::Attempt>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SequenceReport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.attempts.is_empty() {
            state.serialize_entry("attempts", &self.attempts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SequenceReport].
pub mod sequence_report {
    #[allow(unused_imports)]
    use super::*;

    /// Contains metrics on individual RPC Attempts in a sequence.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Attempt {
        /// The attempt number - starting at 0.
        pub attempt_number: i32,

        /// The deadline dictated by the attempt to the server.
        pub attempt_deadline: std::option::Option<wkt::Timestamp>,

        /// The time that the server responded to the RPC attempt. Used for
        /// calculating attempt_delay.
        pub response_time: std::option::Option<wkt::Timestamp>,

        /// The server perceived delay between sending the last response and
        /// receiving this attempt. Used for validating attempt delay backoff.
        pub attempt_delay: std::option::Option<wkt::Duration>,

        /// The status returned to the attempt.
        pub status: std::option::Option<rpc::model::Status>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Attempt {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [attempt_number][crate::model::sequence_report::Attempt::attempt_number].
        pub fn set_attempt_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.attempt_number = v.into();
            self
        }

        /// Sets the value of [attempt_deadline][crate::model::sequence_report::Attempt::attempt_deadline].
        pub fn set_attempt_deadline<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.attempt_deadline = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [attempt_deadline][crate::model::sequence_report::Attempt::attempt_deadline].
        pub fn set_or_clear_attempt_deadline<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.attempt_deadline = v.map(|x| x.into());
            self
        }

        /// Sets the value of [response_time][crate::model::sequence_report::Attempt::response_time].
        pub fn set_response_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.response_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [response_time][crate::model::sequence_report::Attempt::response_time].
        pub fn set_or_clear_response_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.response_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [attempt_delay][crate::model::sequence_report::Attempt::attempt_delay].
        pub fn set_attempt_delay<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.attempt_delay = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [attempt_delay][crate::model::sequence_report::Attempt::attempt_delay].
        pub fn set_or_clear_attempt_delay<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.attempt_delay = v.map(|x| x.into());
            self
        }

        /// Sets the value of [status][crate::model::sequence_report::Attempt::status].
        pub fn set_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [status][crate::model::sequence_report::Attempt::status].
        pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.status = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Attempt {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.SequenceReport.Attempt"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Attempt {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __attempt_number,
                __attempt_deadline,
                __response_time,
                __attempt_delay,
                __status,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Attempt")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "attemptNumber" => Ok(__FieldTag::__attempt_number),
                                "attempt_number" => Ok(__FieldTag::__attempt_number),
                                "attemptDeadline" => Ok(__FieldTag::__attempt_deadline),
                                "attempt_deadline" => Ok(__FieldTag::__attempt_deadline),
                                "responseTime" => Ok(__FieldTag::__response_time),
                                "response_time" => Ok(__FieldTag::__response_time),
                                "attemptDelay" => Ok(__FieldTag::__attempt_delay),
                                "attempt_delay" => Ok(__FieldTag::__attempt_delay),
                                "status" => Ok(__FieldTag::__status),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Attempt;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Attempt")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__attempt_number => {
                                if !fields.insert(__FieldTag::__attempt_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attempt_number",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.attempt_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__attempt_deadline => {
                                if !fields.insert(__FieldTag::__attempt_deadline) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attempt_deadline",
                                    ));
                                }
                                result.attempt_deadline =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__response_time => {
                                if !fields.insert(__FieldTag::__response_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for response_time",
                                    ));
                                }
                                result.response_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__attempt_delay => {
                                if !fields.insert(__FieldTag::__attempt_delay) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for attempt_delay",
                                    ));
                                }
                                result.attempt_delay =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::__status => {
                                if !fields.insert(__FieldTag::__status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for status",
                                    ));
                                }
                                result.status =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Attempt {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.attempt_number) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("attemptNumber", &__With(&self.attempt_number))?;
            }
            if self.attempt_deadline.is_some() {
                state.serialize_entry("attemptDeadline", &self.attempt_deadline)?;
            }
            if self.response_time.is_some() {
                state.serialize_entry("responseTime", &self.response_time)?;
            }
            if self.attempt_delay.is_some() {
                state.serialize_entry("attemptDelay", &self.attempt_delay)?;
            }
            if self.status.is_some() {
                state.serialize_entry("status", &self.status)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSequenceRequest {
    pub sequence: std::option::Option<crate::model::Sequence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSequenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sequence][crate::model::CreateSequenceRequest::sequence].
    pub fn set_sequence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Sequence>,
    {
        self.sequence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sequence][crate::model::CreateSequenceRequest::sequence].
    pub fn set_or_clear_sequence<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Sequence>,
    {
        self.sequence = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSequenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateSequenceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSequenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sequence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSequenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sequence" => Ok(__FieldTag::__sequence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSequenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSequenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sequence => {
                            if !fields.insert(__FieldTag::__sequence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sequence",
                                ));
                            }
                            result.sequence =
                                map.next_value::<std::option::Option<crate::model::Sequence>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSequenceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.sequence.is_some() {
            state.serialize_entry("sequence", &self.sequence)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateStreamingSequenceRequest {
    pub streaming_sequence: std::option::Option<crate::model::StreamingSequence>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateStreamingSequenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [streaming_sequence][crate::model::CreateStreamingSequenceRequest::streaming_sequence].
    pub fn set_streaming_sequence<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StreamingSequence>,
    {
        self.streaming_sequence = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [streaming_sequence][crate::model::CreateStreamingSequenceRequest::streaming_sequence].
    pub fn set_or_clear_streaming_sequence<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StreamingSequence>,
    {
        self.streaming_sequence = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateStreamingSequenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateStreamingSequenceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateStreamingSequenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __streaming_sequence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateStreamingSequenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "streamingSequence" => Ok(__FieldTag::__streaming_sequence),
                            "streaming_sequence" => Ok(__FieldTag::__streaming_sequence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateStreamingSequenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateStreamingSequenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__streaming_sequence => {
                            if !fields.insert(__FieldTag::__streaming_sequence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for streaming_sequence",
                                ));
                            }
                            result.streaming_sequence = map
                                .next_value::<std::option::Option<crate::model::StreamingSequence>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateStreamingSequenceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.streaming_sequence.is_some() {
            state.serialize_entry("streamingSequence", &self.streaming_sequence)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttemptSequenceRequest {
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttemptSequenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttemptSequenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AttemptSequenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.AttemptSequenceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttemptSequenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttemptSequenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttemptSequenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttemptSequenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttemptSequenceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttemptStreamingSequenceRequest {
    pub name: std::string::String,

    /// used to send the index of the last failed message
    /// in the string "content" of an AttemptStreamingSequenceResponse
    /// needed for stream resumption logic testing
    pub last_fail_index: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttemptStreamingSequenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttemptStreamingSequenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [last_fail_index][crate::model::AttemptStreamingSequenceRequest::last_fail_index].
    pub fn set_last_fail_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.last_fail_index = v.into();
        self
    }
}

impl wkt::message::Message for AttemptStreamingSequenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.AttemptStreamingSequenceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttemptStreamingSequenceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __last_fail_index,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttemptStreamingSequenceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "lastFailIndex" => Ok(__FieldTag::__last_fail_index),
                            "last_fail_index" => Ok(__FieldTag::__last_fail_index),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttemptStreamingSequenceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttemptStreamingSequenceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_fail_index => {
                            if !fields.insert(__FieldTag::__last_fail_index) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_fail_index",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_fail_index =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttemptStreamingSequenceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.last_fail_index) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("lastFailIndex", &__With(&self.last_fail_index))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response message for the Echo methods.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttemptStreamingSequenceResponse {
    /// The content specified in the request.
    pub content: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttemptStreamingSequenceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::AttemptStreamingSequenceResponse::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }
}

impl wkt::message::Message for AttemptStreamingSequenceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.AttemptStreamingSequenceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttemptStreamingSequenceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __content,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttemptStreamingSequenceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "content" => Ok(__FieldTag::__content),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttemptStreamingSequenceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttemptStreamingSequenceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__content => {
                            if !fields.insert(__FieldTag::__content) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for content",
                                ));
                            }
                            result.content = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttemptStreamingSequenceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.content.is_empty() {
            state.serialize_entry("content", &self.content)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSequenceReportRequest {
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSequenceReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSequenceReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSequenceReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetSequenceReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSequenceReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSequenceReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSequenceReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSequenceReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSequenceReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetStreamingSequenceReportRequest {
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStreamingSequenceReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStreamingSequenceReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStreamingSequenceReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetStreamingSequenceReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetStreamingSequenceReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetStreamingSequenceReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetStreamingSequenceReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetStreamingSequenceReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetStreamingSequenceReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A session is a suite of tests, generally being made in the context
/// of testing code generation.
///
/// A session defines tests it may expect, based on which version of the
/// code generation spec is in use.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Session {
    /// The name of the session. The ID must conform to ^[a-z]+$
    /// If this is not provided, Showcase chooses one at random.
    pub name: std::string::String,

    /// Required. The version this session is using.
    pub version: crate::model::session::Version,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Session {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Session::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Session::version].
    pub fn set_version<T: std::convert::Into<crate::model::session::Version>>(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for Session {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Session"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Session {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Session")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "version" => Ok(__FieldTag::__version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Session;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Session")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<crate::model::session::Version>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Session {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.version) {
            state.serialize_entry("version", &self.version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Session].
pub mod session {
    #[allow(unused_imports)]
    use super::*;

    /// The specification versions understood by Showcase.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Version {
        /// Unspecified version. If passed on creation, the session will default
        /// to using the latest stable release.
        Unspecified,
        /// The latest v1. Currently, this is v1.0.
        V1Latest,
        /// v1.0. (Until the spec is "GA", this will be a moving target.)
        V10,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Version::value] or
        /// [Version::name].
        UnknownValue(version::UnknownValue),
    }

    #[doc(hidden)]
    pub mod version {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Version {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::V1Latest => std::option::Option::Some(1),
                Self::V10 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VERSION_UNSPECIFIED"),
                Self::V1Latest => std::option::Option::Some("V1_LATEST"),
                Self::V10 => std::option::Option::Some("V1_0"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Version {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Version {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Version {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::V1Latest,
                2 => Self::V10,
                _ => Self::UnknownValue(version::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Version {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VERSION_UNSPECIFIED" => Self::Unspecified,
                "V1_LATEST" => Self::V1Latest,
                "V1_0" => Self::V10,
                _ => Self::UnknownValue(version::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Version {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::V1Latest => serializer.serialize_i32(1),
                Self::V10 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Version {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Version>::new(
                ".google.showcase.v1beta1.Session.Version",
            ))
        }
    }
}

/// The request for the CreateSession method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSessionRequest {
    /// The session to be created.
    /// Sessions are immutable once they are created (although they can
    /// be deleted).
    pub session: std::option::Option<crate::model::Session>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::CreateSessionRequest::session].
    pub fn set_session<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Session>,
    {
        self.session = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [session][crate::model::CreateSessionRequest::session].
    pub fn set_or_clear_session<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Session>,
    {
        self.session = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __session,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "session" => Ok(__FieldTag::__session),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__session => {
                            if !fields.insert(__FieldTag::__session) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for session",
                                ));
                            }
                            result.session =
                                map.next_value::<std::option::Option<crate::model::Session>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.session.is_some() {
            state.serialize_entry("session", &self.session)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for the GetSession method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSessionRequest {
    /// The session to be retrieved.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The request for the ListSessions method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionsRequest {
    /// The maximum number of sessions to return per page.
    pub page_size: i32,

    /// The page token, for retrieving subsequent pages.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListSessionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSessionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListSessionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSessionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for the ListSessions method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSessionsResponse {
    /// The sessions being returned.
    pub sessions: std::vec::Vec<crate::model::Session>,

    /// The next page token, if any.
    /// An empty value here means the last page has been reached.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sessions][crate::model::ListSessionsResponse::sessions].
    pub fn set_sessions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Session>,
    {
        use std::iter::Iterator;
        self.sessions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSessionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListSessionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSessionsResponse {
    type PageItem = crate::model::Session;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sessions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSessionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sessions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSessionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sessions" => Ok(__FieldTag::__sessions),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSessionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSessionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sessions => {
                            if !fields.insert(__FieldTag::__sessions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sessions",
                                ));
                            }
                            result.sessions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Session>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSessionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sessions.is_empty() {
            state.serialize_entry("sessions", &self.sessions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for the DeleteSession method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSessionRequest {
    /// The session to be deleted.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.DeleteSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for reporting on a session.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReportSessionRequest {
    /// The session to be reported on.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReportSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ReportSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ReportSessionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReportSessionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReportSessionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReportSessionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReportSessionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReportSessionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for reporting on a session.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReportSessionResponse {
    /// The state of the report.
    pub result: crate::model::report_session_response::Result,

    /// The test runs of this session.
    pub test_runs: std::vec::Vec<crate::model::TestRun>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportSessionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::ReportSessionResponse::result].
    pub fn set_result<T: std::convert::Into<crate::model::report_session_response::Result>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// Sets the value of [test_runs][crate::model::ReportSessionResponse::test_runs].
    pub fn set_test_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TestRun>,
    {
        use std::iter::Iterator;
        self.test_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReportSessionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ReportSessionResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReportSessionResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __result,
            __test_runs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReportSessionResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "result" => Ok(__FieldTag::__result),
                            "testRuns" => Ok(__FieldTag::__test_runs),
                            "test_runs" => Ok(__FieldTag::__test_runs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReportSessionResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReportSessionResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__result => {
                            if !fields.insert(__FieldTag::__result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for result",
                                ));
                            }
                            result.result =
                                map.next_value::<std::option::Option<
                                    crate::model::report_session_response::Result,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__test_runs => {
                            if !fields.insert(__FieldTag::__test_runs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test_runs",
                                ));
                            }
                            result.test_runs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TestRun>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReportSessionResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.result) {
            state.serialize_entry("result", &self.result)?;
        }
        if !self.test_runs.is_empty() {
            state.serialize_entry("testRuns", &self.test_runs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ReportSessionResponse].
pub mod report_session_response {
    #[allow(unused_imports)]
    use super::*;

    /// The topline state of the report.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Result {
        Unspecified,
        /// The session is complete, and everything passed.
        Passed,
        /// The session had an explicit failure.
        Failed,
        /// The session is incomplete. This is a failure response.
        Incomplete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Result::value] or
        /// [Result::name].
        UnknownValue(result::UnknownValue),
    }

    #[doc(hidden)]
    pub mod result {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Result {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Passed => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Incomplete => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESULT_UNSPECIFIED"),
                Self::Passed => std::option::Option::Some("PASSED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Incomplete => std::option::Option::Some("INCOMPLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Result {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Result {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Result {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Passed,
                2 => Self::Failed,
                3 => Self::Incomplete,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Result {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESULT_UNSPECIFIED" => Self::Unspecified,
                "PASSED" => Self::Passed,
                "FAILED" => Self::Failed,
                "INCOMPLETE" => Self::Incomplete,
                _ => Self::UnknownValue(result::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Result {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Passed => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Incomplete => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Result {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Result>::new(
                ".google.showcase.v1beta1.ReportSessionResponse.Result",
            ))
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Test {
    /// The name of the test.
    /// The tests/* portion of the names are hard-coded, and do not change
    /// from session to session.
    pub name: std::string::String,

    /// The expectation level for this test.
    pub expectation_level: crate::model::test::ExpectationLevel,

    /// A description of the test.
    pub description: std::string::String,

    /// The blueprints that will satisfy this test. There may be multiple blueprints
    /// that can signal to the server that this test case is being exercised. Although
    /// multiple blueprints are specified, only a single blueprint needs to be run to
    /// signal that the test case was exercised.
    pub blueprints: std::vec::Vec<crate::model::test::Blueprint>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Test {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Test::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [expectation_level][crate::model::Test::expectation_level].
    pub fn set_expectation_level<T: std::convert::Into<crate::model::test::ExpectationLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.expectation_level = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Test::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [blueprints][crate::model::Test::blueprints].
    pub fn set_blueprints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::test::Blueprint>,
    {
        use std::iter::Iterator;
        self.blueprints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Test {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Test"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Test {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __expectation_level,
            __description,
            __blueprints,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Test")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "expectationLevel" => Ok(__FieldTag::__expectation_level),
                            "expectation_level" => Ok(__FieldTag::__expectation_level),
                            "description" => Ok(__FieldTag::__description),
                            "blueprints" => Ok(__FieldTag::__blueprints),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Test;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Test")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expectation_level => {
                            if !fields.insert(__FieldTag::__expectation_level) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expectation_level",
                                ));
                            }
                            result.expectation_level = map.next_value::<std::option::Option<crate::model::test::ExpectationLevel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__blueprints => {
                            if !fields.insert(__FieldTag::__blueprints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for blueprints",
                                ));
                            }
                            result.blueprints =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::test::Blueprint>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Test {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.expectation_level) {
            state.serialize_entry("expectationLevel", &self.expectation_level)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.blueprints.is_empty() {
            state.serialize_entry("blueprints", &self.blueprints)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Test].
pub mod test {
    #[allow(unused_imports)]
    use super::*;

    /// A blueprint is an explicit definition of methods and requests that are needed
    /// to be made to test this specific test case. Ideally this would be represented
    /// by something more robust like CEL, but as of writing this, I am unsure if CEL
    /// is ready.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Blueprint {
        /// The name of this blueprint.
        pub name: std::string::String,

        /// A description of this blueprint.
        pub description: std::string::String,

        /// The initial request to trigger this test.
        pub request: std::option::Option<crate::model::test::blueprint::Invocation>,

        /// An ordered list of method calls that can be called to trigger this test.
        pub additional_requests: std::vec::Vec<crate::model::test::blueprint::Invocation>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Blueprint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::test::Blueprint::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::test::Blueprint::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [request][crate::model::test::Blueprint::request].
        pub fn set_request<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::test::blueprint::Invocation>,
        {
            self.request = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request][crate::model::test::Blueprint::request].
        pub fn set_or_clear_request<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::test::blueprint::Invocation>,
        {
            self.request = v.map(|x| x.into());
            self
        }

        /// Sets the value of [additional_requests][crate::model::test::Blueprint::additional_requests].
        pub fn set_additional_requests<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::test::blueprint::Invocation>,
        {
            use std::iter::Iterator;
            self.additional_requests = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Blueprint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.Test.Blueprint"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Blueprint {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __description,
                __request,
                __additional_requests,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Blueprint")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "description" => Ok(__FieldTag::__description),
                                "request" => Ok(__FieldTag::__request),
                                "additionalRequests" => Ok(__FieldTag::__additional_requests),
                                "additional_requests" => Ok(__FieldTag::__additional_requests),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Blueprint;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Blueprint")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__request => {
                                if !fields.insert(__FieldTag::__request) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for request",
                                    ));
                                }
                                result.request = map.next_value::<std::option::Option<
                                    crate::model::test::blueprint::Invocation,
                                >>()?;
                            }
                            __FieldTag::__additional_requests => {
                                if !fields.insert(__FieldTag::__additional_requests) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for additional_requests",
                                    ));
                                }
                                result.additional_requests = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::test::blueprint::Invocation>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Blueprint {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if self.request.is_some() {
                state.serialize_entry("request", &self.request)?;
            }
            if !self.additional_requests.is_empty() {
                state.serialize_entry("additionalRequests", &self.additional_requests)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Blueprint].
    pub mod blueprint {
        #[allow(unused_imports)]
        use super::*;

        /// A message representing a method invocation.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Invocation {
            /// The fully qualified name of the showcase method to be invoked.
            pub method: std::string::String,

            /// The request to be made if a specific request is necessary.
            pub serialized_request: ::bytes::Bytes,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Invocation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [method][crate::model::test::blueprint::Invocation::method].
            pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.method = v.into();
                self
            }

            /// Sets the value of [serialized_request][crate::model::test::blueprint::Invocation::serialized_request].
            pub fn set_serialized_request<T: std::convert::Into<::bytes::Bytes>>(
                mut self,
                v: T,
            ) -> Self {
                self.serialized_request = v.into();
                self
            }
        }

        impl wkt::message::Message for Invocation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.showcase.v1beta1.Test.Blueprint.Invocation"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Invocation {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __method,
                    __serialized_request,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Invocation")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "method" => Ok(__FieldTag::__method),
                                    "serializedRequest" => Ok(__FieldTag::__serialized_request),
                                    "serialized_request" => Ok(__FieldTag::__serialized_request),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Invocation;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Invocation")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__method => {
                                    if !fields.insert(__FieldTag::__method) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for method"),
                                        );
                                    }
                                    result.method = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__serialized_request => {
                                    if !fields.insert(__FieldTag::__serialized_request) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for serialized_request",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<::bytes::Bytes>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::<
                                                std::option::Option<serde_with::base64::Base64>,
                                            >::deserialize(
                                                deserializer
                                            )
                                            .map(__With)
                                        }
                                    }
                                    result.serialized_request =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Invocation {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.method.is_empty() {
                    state.serialize_entry("method", &self.method)?;
                }
                if !self.serialized_request.is_empty() {
                    struct __With<'a>(&'a ::bytes::Bytes);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<serde_with::base64::Base64>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state
                        .serialize_entry("serializedRequest", &__With(&self.serialized_request))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }
    }

    /// Whether or not a test is required, recommended, or optional.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExpectationLevel {
        Unspecified,
        /// This test is strictly required.
        Required,
        /// This test is recommended.
        ///
        /// If a generator explicitly ignores a recommended test (see `DeleteTest`),
        /// then the report may still pass, but with a warning.
        ///
        /// If a generator skips a recommended test and does not explicitly
        /// express that intention, the report will fail.
        Recommended,
        /// This test is optional.
        ///
        /// If a generator explicitly ignores an optional test (see `DeleteTest`),
        /// then the report may still pass, and no warning will be issued.
        ///
        /// If a generator skips an optional test and does not explicitly
        /// express that intention, the report may still pass, but with a
        /// warning.
        Optional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ExpectationLevel::value] or
        /// [ExpectationLevel::name].
        UnknownValue(expectation_level::UnknownValue),
    }

    #[doc(hidden)]
    pub mod expectation_level {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ExpectationLevel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Required => std::option::Option::Some(1),
                Self::Recommended => std::option::Option::Some(2),
                Self::Optional => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EXPECTATION_LEVEL_UNSPECIFIED"),
                Self::Required => std::option::Option::Some("REQUIRED"),
                Self::Recommended => std::option::Option::Some("RECOMMENDED"),
                Self::Optional => std::option::Option::Some("OPTIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ExpectationLevel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ExpectationLevel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ExpectationLevel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Required,
                2 => Self::Recommended,
                3 => Self::Optional,
                _ => Self::UnknownValue(expectation_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ExpectationLevel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXPECTATION_LEVEL_UNSPECIFIED" => Self::Unspecified,
                "REQUIRED" => Self::Required,
                "RECOMMENDED" => Self::Recommended,
                "OPTIONAL" => Self::Optional,
                _ => Self::UnknownValue(expectation_level::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ExpectationLevel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Required => serializer.serialize_i32(1),
                Self::Recommended => serializer.serialize_i32(2),
                Self::Optional => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ExpectationLevel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ExpectationLevel>::new(
                ".google.showcase.v1beta1.Test.ExpectationLevel",
            ))
        }
    }
}

/// An issue found in the test.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Issue {
    /// The type of the issue.
    pub r#type: crate::model::issue::Type,

    /// The severity of the issue.
    pub severity: crate::model::issue::Severity,

    /// A description of the issue.
    pub description: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Issue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Issue::type].
    pub fn set_type<T: std::convert::Into<crate::model::issue::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::Issue::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::issue::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Issue::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for Issue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Issue"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Issue {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __severity,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Issue")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "severity" => Ok(__FieldTag::__severity),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Issue;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Issue")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::issue::Type>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__severity => {
                            if !fields.insert(__FieldTag::__severity) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for severity",
                                ));
                            }
                            result.severity = map
                                .next_value::<std::option::Option<crate::model::issue::Severity>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Issue {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.severity) {
            state.serialize_entry("severity", &self.severity)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Issue].
pub mod issue {
    #[allow(unused_imports)]
    use super::*;

    /// The different potential types of issues.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        Unspecified,
        /// The test was never instrumented.
        Skipped,
        /// The test was started but never confirmed.
        Pending,
        /// The test was instrumented, but Showcase got an unexpected
        /// value when the generator tried to confirm success.
        IncorrectConfirmation,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Skipped => std::option::Option::Some(1),
                Self::Pending => std::option::Option::Some(2),
                Self::IncorrectConfirmation => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Skipped => std::option::Option::Some("SKIPPED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::IncorrectConfirmation => std::option::Option::Some("INCORRECT_CONFIRMATION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Skipped,
                2 => Self::Pending,
                3 => Self::IncorrectConfirmation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "SKIPPED" => Self::Skipped,
                "PENDING" => Self::Pending,
                "INCORRECT_CONFIRMATION" => Self::IncorrectConfirmation,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Skipped => serializer.serialize_i32(1),
                Self::Pending => serializer.serialize_i32(2),
                Self::IncorrectConfirmation => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.showcase.v1beta1.Issue.Type",
            ))
        }
    }

    /// Severity levels.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Severity {
        Unspecified,
        /// Errors.
        Error,
        /// Warnings.
        Warning,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Severity::value] or
        /// [Severity::name].
        UnknownValue(severity::UnknownValue),
    }

    #[doc(hidden)]
    pub mod severity {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Severity {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Error => std::option::Option::Some(1),
                Self::Warning => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SEVERITY_UNSPECIFIED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Warning => std::option::Option::Some("WARNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Severity {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Error,
                2 => Self::Warning,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Severity {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SEVERITY_UNSPECIFIED" => Self::Unspecified,
                "ERROR" => Self::Error,
                "WARNING" => Self::Warning,
                _ => Self::UnknownValue(severity::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Severity {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Error => serializer.serialize_i32(1),
                Self::Warning => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Severity {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
                ".google.showcase.v1beta1.Issue.Severity",
            ))
        }
    }
}

/// The request for the ListTests method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTestsRequest {
    /// The session.
    pub parent: std::string::String,

    /// The maximum number of tests to return per page.
    pub page_size: i32,

    /// The page token, for retrieving subsequent pages.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTestsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTestsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTestsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTestsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTestsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListTestsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTestsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTestsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTestsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTestsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTestsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The response for the ListTests method.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTestsResponse {
    /// The tests being returned.
    pub tests: std::vec::Vec<crate::model::Test>,

    /// The next page token, if any.
    /// An empty value here means the last page has been reached.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTestsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [tests][crate::model::ListTestsResponse::tests].
    pub fn set_tests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Test>,
    {
        use std::iter::Iterator;
        self.tests = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTestsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTestsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListTestsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTestsResponse {
    type PageItem = crate::model::Test;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tests
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTestsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __tests,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTestsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tests" => Ok(__FieldTag::__tests),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTestsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTestsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__tests => {
                            if !fields.insert(__FieldTag::__tests) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tests",
                                ));
                            }
                            result.tests = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Test>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTestsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.tests.is_empty() {
            state.serialize_entry("tests", &self.tests)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A TestRun is the result of running a Test.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct TestRun {
    /// The name of the test.
    /// The tests/* portion of the names are hard-coded, and do not change
    /// from session to session.
    pub test: std::string::String,

    /// An issue found with the test run. If empty, this test run was successful.
    pub issue: std::option::Option<crate::model::Issue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TestRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [test][crate::model::TestRun::test].
    pub fn set_test<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.test = v.into();
        self
    }

    /// Sets the value of [issue][crate::model::TestRun::issue].
    pub fn set_issue<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Issue>,
    {
        self.issue = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [issue][crate::model::TestRun::issue].
    pub fn set_or_clear_issue<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Issue>,
    {
        self.issue = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TestRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.TestRun"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TestRun {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __test,
            __issue,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TestRun")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "test" => Ok(__FieldTag::__test),
                            "issue" => Ok(__FieldTag::__issue),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TestRun;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TestRun")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__test => {
                            if !fields.insert(__FieldTag::__test) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for test",
                                ));
                            }
                            result.test = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__issue => {
                            if !fields.insert(__FieldTag::__issue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue",
                                ));
                            }
                            result.issue =
                                map.next_value::<std::option::Option<crate::model::Issue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TestRun {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.test.is_empty() {
            state.serialize_entry("test", &self.test)?;
        }
        if self.issue.is_some() {
            state.serialize_entry("issue", &self.issue)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for deleting a test.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTestRequest {
    /// The test to be deleted.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTestRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.DeleteTestRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyTestRequest {
    /// The test to have an answer registered to it.
    pub name: std::string::String,

    /// The answer from the test.
    pub answer: ::bytes::Bytes,

    /// The answers from the test if multiple are to be checked
    pub answers: std::vec::Vec<::bytes::Bytes>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VerifyTestRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [answer][crate::model::VerifyTestRequest::answer].
    pub fn set_answer<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.answer = v.into();
        self
    }

    /// Sets the value of [answers][crate::model::VerifyTestRequest::answers].
    pub fn set_answers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.answers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VerifyTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.VerifyTestRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerifyTestRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __answer,
            __answers,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyTestRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "answer" => Ok(__FieldTag::__answer),
                            "answers" => Ok(__FieldTag::__answers),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerifyTestRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyTestRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__answer => {
                            if !fields.insert(__FieldTag::__answer) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answer",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.answer = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__answers => {
                            if !fields.insert(__FieldTag::__answers) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for answers",
                                ));
                            }
                            struct __With(std::option::Option<std::vec::Vec<::bytes::Bytes>>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::<
                                        std::option::Option<
                                            std::vec::Vec<serde_with::base64::Base64>,
                                        >,
                                    >::deserialize(deserializer)
                                    .map(__With)
                                }
                            }
                            result.answers = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerifyTestRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.answer.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("answer", &__With(&self.answer))?;
        }
        if !self.answers.is_empty() {
            struct __With<'a>(&'a std::vec::Vec<::bytes::Bytes>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::vec::Vec<serde_with::base64::Base64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("answers", &__With(&self.answers))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VerifyTestResponse {
    /// An issue if check answer was unsuccessful. This will be empty if the check answer succeeded.
    pub issue: std::option::Option<crate::model::Issue>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyTestResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue][crate::model::VerifyTestResponse::issue].
    pub fn set_issue<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Issue>,
    {
        self.issue = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [issue][crate::model::VerifyTestResponse::issue].
    pub fn set_or_clear_issue<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Issue>,
    {
        self.issue = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VerifyTestResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.VerifyTestResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VerifyTestResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __issue,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VerifyTestResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "issue" => Ok(__FieldTag::__issue),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VerifyTestResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VerifyTestResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__issue => {
                            if !fields.insert(__FieldTag::__issue) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for issue",
                                ));
                            }
                            result.issue =
                                map.next_value::<std::option::Option<crate::model::Issue>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VerifyTestResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.issue.is_some() {
            state.serialize_entry("issue", &self.issue)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Continent {
    Unspecified,
    Africa,
    America,
    Antartica,
    Australia,
    Europe,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Continent::value] or
    /// [Continent::name].
    UnknownValue(continent::UnknownValue),
}

#[doc(hidden)]
pub mod continent {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Continent {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Africa => std::option::Option::Some(1),
            Self::America => std::option::Option::Some(2),
            Self::Antartica => std::option::Option::Some(3),
            Self::Australia => std::option::Option::Some(4),
            Self::Europe => std::option::Option::Some(5),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONTINENT_UNSPECIFIED"),
            Self::Africa => std::option::Option::Some("AFRICA"),
            Self::America => std::option::Option::Some("AMERICA"),
            Self::Antartica => std::option::Option::Some("ANTARTICA"),
            Self::Australia => std::option::Option::Some("AUSTRALIA"),
            Self::Europe => std::option::Option::Some("EUROPE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Continent {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Continent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Continent {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Africa,
            2 => Self::America,
            3 => Self::Antartica,
            4 => Self::Australia,
            5 => Self::Europe,
            _ => Self::UnknownValue(continent::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Continent {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONTINENT_UNSPECIFIED" => Self::Unspecified,
            "AFRICA" => Self::Africa,
            "AMERICA" => Self::America,
            "ANTARTICA" => Self::Antartica,
            "AUSTRALIA" => Self::Australia,
            "EUROPE" => Self::Europe,
            _ => Self::UnknownValue(continent::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Continent {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Africa => serializer.serialize_i32(1),
            Self::America => serializer.serialize_i32(2),
            Self::Antartica => serializer.serialize_i32(3),
            Self::Australia => serializer.serialize_i32(4),
            Self::Europe => serializer.serialize_i32(5),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Continent {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Continent>::new(
            ".google.showcase.v1beta1.Continent",
        ))
    }
}

/// A severity enum used to test enum capabilities in GAPIC surfaces.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Severity {
    Unnecessary,
    Necessary,
    Urgent,
    Critical,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [Severity::value] or
    /// [Severity::name].
    UnknownValue(severity::UnknownValue),
}

#[doc(hidden)]
pub mod severity {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl Severity {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unnecessary => std::option::Option::Some(0),
            Self::Necessary => std::option::Option::Some(1),
            Self::Urgent => std::option::Option::Some(2),
            Self::Critical => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unnecessary => std::option::Option::Some("UNNECESSARY"),
            Self::Necessary => std::option::Option::Some("NECESSARY"),
            Self::Urgent => std::option::Option::Some("URGENT"),
            Self::Critical => std::option::Option::Some("CRITICAL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for Severity {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for Severity {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unnecessary,
            1 => Self::Necessary,
            2 => Self::Urgent,
            3 => Self::Critical,
            _ => Self::UnknownValue(severity::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for Severity {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UNNECESSARY" => Self::Unnecessary,
            "NECESSARY" => Self::Necessary,
            "URGENT" => Self::Urgent,
            "CRITICAL" => Self::Critical,
            _ => Self::UnknownValue(severity::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for Severity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unnecessary => serializer.serialize_i32(0),
            Self::Necessary => serializer.serialize_i32(1),
            Self::Urgent => serializer.serialize_i32(2),
            Self::Critical => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for Severity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<Severity>::new(
            ".google.showcase.v1beta1.Severity",
        ))
    }
}
