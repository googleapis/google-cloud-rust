// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepeatRequest {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub info: std::option::Option<crate::model::ComplianceData>,

    /// If true, the server will verify that the received request matches
    /// the request with the same name in the compliance test suite.
    pub server_verify: bool,

    /// The URI template this request is expected to be bound to server-side.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub intended_binding_uri: std::option::Option<std::string::String>,

    /// Some top level fields, to test that these are encoded correctly
    /// in query params.
    pub f_int32: i32,

    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub f_int64: i64,

    pub f_double: f64,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_int32: std::option::Option<i32>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub p_int64: std::option::Option<i64>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_double: std::option::Option<f64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepeatRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RepeatRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [info][crate::model::RepeatRequest::info].
    pub fn set_info<T: std::convert::Into<std::option::Option<crate::model::ComplianceData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.info = v.into();
        self
    }

    /// Sets the value of [server_verify][crate::model::RepeatRequest::server_verify].
    pub fn set_server_verify<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.server_verify = v.into();
        self
    }

    /// Sets the value of [intended_binding_uri][crate::model::RepeatRequest::intended_binding_uri].
    pub fn set_intended_binding_uri<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.intended_binding_uri = v.into();
        self
    }

    /// Sets the value of [f_int32][crate::model::RepeatRequest::f_int32].
    pub fn set_f_int32<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.f_int32 = v.into();
        self
    }

    /// Sets the value of [f_int64][crate::model::RepeatRequest::f_int64].
    pub fn set_f_int64<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.f_int64 = v.into();
        self
    }

    /// Sets the value of [f_double][crate::model::RepeatRequest::f_double].
    pub fn set_f_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.f_double = v.into();
        self
    }

    /// Sets the value of [p_int32][crate::model::RepeatRequest::p_int32].
    pub fn set_p_int32<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.p_int32 = v.into();
        self
    }

    /// Sets the value of [p_int64][crate::model::RepeatRequest::p_int64].
    pub fn set_p_int64<T: std::convert::Into<std::option::Option<i64>>>(mut self, v: T) -> Self {
        self.p_int64 = v.into();
        self
    }

    /// Sets the value of [p_double][crate::model::RepeatRequest::p_double].
    pub fn set_p_double<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.p_double = v.into();
        self
    }
}

impl wkt::message::Message for RepeatRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.RepeatRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RepeatResponse {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::RepeatRequest>,

    /// The URI template the request was bound to server-side.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub binding_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RepeatResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::RepeatResponse::request].
    pub fn set_request<T: std::convert::Into<std::option::Option<crate::model::RepeatRequest>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [binding_uri][crate::model::RepeatResponse::binding_uri].
    pub fn set_binding_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.binding_uri = v.into();
        self
    }
}

impl wkt::message::Message for RepeatResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.RepeatResponse"
    }
}

/// ComplianceSuite contains a set of requests that microgenerators should issue
/// over REST to the Compliance service to test their gRPC-to-REST transcoding
/// implementation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComplianceSuite {
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub group: std::vec::Vec<crate::model::ComplianceGroup>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceSuite {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::ComplianceSuite::group].
    pub fn set_group<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ComplianceGroup>,
    {
        use std::iter::Iterator;
        self.group = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComplianceSuite {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ComplianceSuite"
    }
}

/// ComplianceGroups encapsulates a group of RPC requests to the Compliance
/// server: one request for each combination of elements of `rpcs` and of
/// `requests`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComplianceGroup {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rpcs: std::vec::Vec<std::string::String>,

    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub requests: std::vec::Vec<crate::model::RepeatRequest>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ComplianceGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [rpcs][crate::model::ComplianceGroup::rpcs].
    pub fn set_rpcs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.rpcs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [requests][crate::model::ComplianceGroup::requests].
    pub fn set_requests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::RepeatRequest>,
    {
        use std::iter::Iterator;
        self.requests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComplianceGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ComplianceGroup"
    }
}

/// ComplianceData is a message used for testing REST transcoding of
/// different data types.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComplianceData {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub f_string: std::string::String,

    pub f_int32: i32,

    pub f_sint32: i32,

    pub f_sfixed32: i32,

    pub f_uint32: u32,

    pub f_fixed32: u32,

    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub f_int64: i64,

    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub f_sint64: i64,

    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub f_sfixed64: i64,

    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub f_uint64: u64,

    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub f_fixed64: u64,

    pub f_double: f64,

    pub f_float: f32,

    pub f_bool: bool,

    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub f_bytes: ::bytes::Bytes,

    pub f_kingdom: crate::model::compliance_data::LifeKingdom,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub f_child: std::option::Option<crate::model::ComplianceDataChild>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_string: std::option::Option<std::string::String>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_int32: std::option::Option<i32>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_double: std::option::Option<f64>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_bool: std::option::Option<bool>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_kingdom: std::option::Option<crate::model::compliance_data::LifeKingdom>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_child: std::option::Option<crate::model::ComplianceDataChild>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [f_string][crate::model::ComplianceData::f_string].
    pub fn set_f_string<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.f_string = v.into();
        self
    }

    /// Sets the value of [f_int32][crate::model::ComplianceData::f_int32].
    pub fn set_f_int32<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.f_int32 = v.into();
        self
    }

    /// Sets the value of [f_sint32][crate::model::ComplianceData::f_sint32].
    pub fn set_f_sint32<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.f_sint32 = v.into();
        self
    }

    /// Sets the value of [f_sfixed32][crate::model::ComplianceData::f_sfixed32].
    pub fn set_f_sfixed32<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.f_sfixed32 = v.into();
        self
    }

    /// Sets the value of [f_uint32][crate::model::ComplianceData::f_uint32].
    pub fn set_f_uint32<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.f_uint32 = v.into();
        self
    }

    /// Sets the value of [f_fixed32][crate::model::ComplianceData::f_fixed32].
    pub fn set_f_fixed32<T: std::convert::Into<u32>>(mut self, v: T) -> Self {
        self.f_fixed32 = v.into();
        self
    }

    /// Sets the value of [f_int64][crate::model::ComplianceData::f_int64].
    pub fn set_f_int64<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.f_int64 = v.into();
        self
    }

    /// Sets the value of [f_sint64][crate::model::ComplianceData::f_sint64].
    pub fn set_f_sint64<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.f_sint64 = v.into();
        self
    }

    /// Sets the value of [f_sfixed64][crate::model::ComplianceData::f_sfixed64].
    pub fn set_f_sfixed64<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.f_sfixed64 = v.into();
        self
    }

    /// Sets the value of [f_uint64][crate::model::ComplianceData::f_uint64].
    pub fn set_f_uint64<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.f_uint64 = v.into();
        self
    }

    /// Sets the value of [f_fixed64][crate::model::ComplianceData::f_fixed64].
    pub fn set_f_fixed64<T: std::convert::Into<u64>>(mut self, v: T) -> Self {
        self.f_fixed64 = v.into();
        self
    }

    /// Sets the value of [f_double][crate::model::ComplianceData::f_double].
    pub fn set_f_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.f_double = v.into();
        self
    }

    /// Sets the value of [f_float][crate::model::ComplianceData::f_float].
    pub fn set_f_float<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.f_float = v.into();
        self
    }

    /// Sets the value of [f_bool][crate::model::ComplianceData::f_bool].
    pub fn set_f_bool<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.f_bool = v.into();
        self
    }

    /// Sets the value of [f_bytes][crate::model::ComplianceData::f_bytes].
    pub fn set_f_bytes<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.f_bytes = v.into();
        self
    }

    /// Sets the value of [f_kingdom][crate::model::ComplianceData::f_kingdom].
    pub fn set_f_kingdom<T: std::convert::Into<crate::model::compliance_data::LifeKingdom>>(
        mut self,
        v: T,
    ) -> Self {
        self.f_kingdom = v.into();
        self
    }

    /// Sets the value of [f_child][crate::model::ComplianceData::f_child].
    pub fn set_f_child<
        T: std::convert::Into<std::option::Option<crate::model::ComplianceDataChild>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.f_child = v.into();
        self
    }

    /// Sets the value of [p_string][crate::model::ComplianceData::p_string].
    pub fn set_p_string<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.p_string = v.into();
        self
    }

    /// Sets the value of [p_int32][crate::model::ComplianceData::p_int32].
    pub fn set_p_int32<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.p_int32 = v.into();
        self
    }

    /// Sets the value of [p_double][crate::model::ComplianceData::p_double].
    pub fn set_p_double<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.p_double = v.into();
        self
    }

    /// Sets the value of [p_bool][crate::model::ComplianceData::p_bool].
    pub fn set_p_bool<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.p_bool = v.into();
        self
    }

    /// Sets the value of [p_kingdom][crate::model::ComplianceData::p_kingdom].
    pub fn set_p_kingdom<
        T: std::convert::Into<std::option::Option<crate::model::compliance_data::LifeKingdom>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.p_kingdom = v.into();
        self
    }

    /// Sets the value of [p_child][crate::model::ComplianceData::p_child].
    pub fn set_p_child<
        T: std::convert::Into<std::option::Option<crate::model::ComplianceDataChild>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.p_child = v.into();
        self
    }
}

impl wkt::message::Message for ComplianceData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ComplianceData"
    }
}

/// Defines additional types related to [ComplianceData].
pub mod compliance_data {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct LifeKingdom(i32);

    impl LifeKingdom {
        pub const LIFE_KINGDOM_UNSPECIFIED: LifeKingdom = LifeKingdom::new(0);

        pub const ARCHAEBACTERIA: LifeKingdom = LifeKingdom::new(1);

        pub const EUBACTERIA: LifeKingdom = LifeKingdom::new(2);

        pub const PROTISTA: LifeKingdom = LifeKingdom::new(3);

        pub const FUNGI: LifeKingdom = LifeKingdom::new(4);

        pub const PLANTAE: LifeKingdom = LifeKingdom::new(5);

        pub const ANIMALIA: LifeKingdom = LifeKingdom::new(6);

        /// Creates a new LifeKingdom instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("LIFE_KINGDOM_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ARCHAEBACTERIA"),
                2 => std::borrow::Cow::Borrowed("EUBACTERIA"),
                3 => std::borrow::Cow::Borrowed("PROTISTA"),
                4 => std::borrow::Cow::Borrowed("FUNGI"),
                5 => std::borrow::Cow::Borrowed("PLANTAE"),
                6 => std::borrow::Cow::Borrowed("ANIMALIA"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "LIFE_KINGDOM_UNSPECIFIED" => {
                    std::option::Option::Some(Self::LIFE_KINGDOM_UNSPECIFIED)
                }
                "ARCHAEBACTERIA" => std::option::Option::Some(Self::ARCHAEBACTERIA),
                "EUBACTERIA" => std::option::Option::Some(Self::EUBACTERIA),
                "PROTISTA" => std::option::Option::Some(Self::PROTISTA),
                "FUNGI" => std::option::Option::Some(Self::FUNGI),
                "PLANTAE" => std::option::Option::Some(Self::PLANTAE),
                "ANIMALIA" => std::option::Option::Some(Self::ANIMALIA),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for LifeKingdom {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for LifeKingdom {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComplianceDataChild {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub f_string: std::string::String,

    pub f_float: f32,

    pub f_double: f64,

    pub f_bool: bool,

    pub f_continent: crate::model::Continent,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub f_child: std::option::Option<crate::model::ComplianceDataGrandchild>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_string: std::option::Option<std::string::String>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_float: std::option::Option<f32>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_double: std::option::Option<f64>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_bool: std::option::Option<bool>,

    pub p_continent: crate::model::Continent,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub p_child: std::option::Option<crate::model::ComplianceDataGrandchild>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceDataChild {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [f_string][crate::model::ComplianceDataChild::f_string].
    pub fn set_f_string<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.f_string = v.into();
        self
    }

    /// Sets the value of [f_float][crate::model::ComplianceDataChild::f_float].
    pub fn set_f_float<T: std::convert::Into<f32>>(mut self, v: T) -> Self {
        self.f_float = v.into();
        self
    }

    /// Sets the value of [f_double][crate::model::ComplianceDataChild::f_double].
    pub fn set_f_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.f_double = v.into();
        self
    }

    /// Sets the value of [f_bool][crate::model::ComplianceDataChild::f_bool].
    pub fn set_f_bool<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.f_bool = v.into();
        self
    }

    /// Sets the value of [f_continent][crate::model::ComplianceDataChild::f_continent].
    pub fn set_f_continent<T: std::convert::Into<crate::model::Continent>>(mut self, v: T) -> Self {
        self.f_continent = v.into();
        self
    }

    /// Sets the value of [f_child][crate::model::ComplianceDataChild::f_child].
    pub fn set_f_child<
        T: std::convert::Into<std::option::Option<crate::model::ComplianceDataGrandchild>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.f_child = v.into();
        self
    }

    /// Sets the value of [p_string][crate::model::ComplianceDataChild::p_string].
    pub fn set_p_string<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.p_string = v.into();
        self
    }

    /// Sets the value of [p_float][crate::model::ComplianceDataChild::p_float].
    pub fn set_p_float<T: std::convert::Into<std::option::Option<f32>>>(mut self, v: T) -> Self {
        self.p_float = v.into();
        self
    }

    /// Sets the value of [p_double][crate::model::ComplianceDataChild::p_double].
    pub fn set_p_double<T: std::convert::Into<std::option::Option<f64>>>(mut self, v: T) -> Self {
        self.p_double = v.into();
        self
    }

    /// Sets the value of [p_bool][crate::model::ComplianceDataChild::p_bool].
    pub fn set_p_bool<T: std::convert::Into<std::option::Option<bool>>>(mut self, v: T) -> Self {
        self.p_bool = v.into();
        self
    }

    /// Sets the value of [p_continent][crate::model::ComplianceDataChild::p_continent].
    pub fn set_p_continent<T: std::convert::Into<crate::model::Continent>>(mut self, v: T) -> Self {
        self.p_continent = v.into();
        self
    }

    /// Sets the value of [p_child][crate::model::ComplianceDataChild::p_child].
    pub fn set_p_child<
        T: std::convert::Into<std::option::Option<crate::model::ComplianceDataGrandchild>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.p_child = v.into();
        self
    }
}

impl wkt::message::Message for ComplianceDataChild {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ComplianceDataChild"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComplianceDataGrandchild {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub f_string: std::string::String,

    pub f_double: f64,

    pub f_bool: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComplianceDataGrandchild {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [f_string][crate::model::ComplianceDataGrandchild::f_string].
    pub fn set_f_string<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.f_string = v.into();
        self
    }

    /// Sets the value of [f_double][crate::model::ComplianceDataGrandchild::f_double].
    pub fn set_f_double<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.f_double = v.into();
        self
    }

    /// Sets the value of [f_bool][crate::model::ComplianceDataGrandchild::f_bool].
    pub fn set_f_bool<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.f_bool = v.into();
        self
    }
}

impl wkt::message::Message for ComplianceDataGrandchild {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ComplianceDataGrandchild"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnumRequest {
    /// Whether the client is requesting a new, unknown enum value or a known enum value already declared in this proto file.
    pub unknown_enum: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnumRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [unknown_enum][crate::model::EnumRequest::unknown_enum].
    pub fn set_unknown_enum<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.unknown_enum = v.into();
        self
    }
}

impl wkt::message::Message for EnumRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EnumRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnumResponse {
    /// The original request for a known or unknown enum from the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::EnumRequest>,

    /// The actual enum the server provided.
    pub continent: crate::model::Continent,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnumResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::EnumResponse::request].
    pub fn set_request<T: std::convert::Into<std::option::Option<crate::model::EnumRequest>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// Sets the value of [continent][crate::model::EnumResponse::continent].
    pub fn set_continent<T: std::convert::Into<crate::model::Continent>>(mut self, v: T) -> Self {
        self.continent = v.into();
        self
    }
}

impl wkt::message::Message for EnumResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EnumResponse"
    }
}

/// The request message used for the Echo, Collect and Chat methods.
/// If content or opt are set in this message then the request will succeed.
/// If status is set in this message then the status will be returned as an
/// error.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EchoRequest {
    /// The severity to be echoed by the server.
    pub severity: crate::model::Severity,

    /// Optional. This field can be set to test the routing annotation on the Echo method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub header: std::string::String,

    /// Optional. This field can be set to test the routing annotation on the Echo method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub other_header: std::string::String,

    /// To facilitate testing of <https://google.aip.dev/client-libraries/4235>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// To facilitate testing of <https://google.aip.dev/client-libraries/4235>
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub other_request_id: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub response: std::option::Option<crate::model::echo_request::Response>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EchoRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [severity][crate::model::EchoRequest::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [header][crate::model::EchoRequest::header].
    pub fn set_header<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.header = v.into();
        self
    }

    /// Sets the value of [other_header][crate::model::EchoRequest::other_header].
    pub fn set_other_header<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.other_header = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::EchoRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [other_request_id][crate::model::EchoRequest::other_request_id].
    pub fn set_other_request_id<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.other_request_id = v.into();
        self
    }

    /// Sets the value of [response][crate::model::EchoRequest::response].
    ///
    /// Note that all the setters affecting `response` are mutually
    /// exclusive.
    pub fn set_response<
        T: std::convert::Into<std::option::Option<crate::model::echo_request::Response>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }

    /// The value of [response][crate::model::EchoRequest::response]
    /// if it holds a `Content`, `None` if the field is not set or
    /// holds a different branch.
    pub fn content(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::echo_request::Response::Content(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [response][crate::model::EchoRequest::response]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::echo_request::Response::Error(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::EchoRequest::response]
    /// to hold a `Content`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.response =
            std::option::Option::Some(crate::model::echo_request::Response::Content(v.into()));
        self
    }

    /// Sets the value of [response][crate::model::EchoRequest::response]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response =
            std::option::Option::Some(crate::model::echo_request::Response::Error(v.into()));
        self
    }
}

impl wkt::message::Message for EchoRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EchoRequest"
    }
}

/// Defines additional types related to [EchoRequest].
pub mod echo_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Response {
        /// The content to be echoed by the server.
        Content(std::string::String),
        /// The error to be thrown by the server.
        Error(std::boxed::Box<rpc::model::Status>),
    }
}

/// The response message for the Echo methods.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EchoResponse {
    /// The content specified in the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// The severity specified in the request.
    pub severity: crate::model::Severity,

    /// The request ID specified or autopopulated in the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// The other request ID specified or autopopulated in the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub other_request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EchoResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::EchoResponse::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::EchoResponse::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::Severity>>(mut self, v: T) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::EchoResponse::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [other_request_id][crate::model::EchoResponse::other_request_id].
    pub fn set_other_request_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.other_request_id = v.into();
        self
    }
}

impl wkt::message::Message for EchoResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EchoResponse"
    }
}

/// The request message used for the EchoErrorDetails method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EchoErrorDetailsRequest {
    /// Content to return in a singular `*.error.details` field of type
    /// `google.protobuf.Any`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub single_detail_text: std::string::String,

    /// Content to return in a repeated `*.error.details` field of type
    /// `google.protobuf.Any`
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub multi_detail_text: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EchoErrorDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [single_detail_text][crate::model::EchoErrorDetailsRequest::single_detail_text].
    pub fn set_single_detail_text<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.single_detail_text = v.into();
        self
    }

    /// Sets the value of [multi_detail_text][crate::model::EchoErrorDetailsRequest::multi_detail_text].
    pub fn set_multi_detail_text<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.multi_detail_text = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EchoErrorDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EchoErrorDetailsRequest"
    }
}

/// The response message used for the EchoErrorDetails method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EchoErrorDetailsResponse {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub single_detail: std::option::Option<crate::model::echo_error_details_response::SingleDetail>,

    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub multiple_details:
        std::option::Option<crate::model::echo_error_details_response::MultipleDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EchoErrorDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [single_detail][crate::model::EchoErrorDetailsResponse::single_detail].
    pub fn set_single_detail<
        T: std::convert::Into<
                std::option::Option<crate::model::echo_error_details_response::SingleDetail>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.single_detail = v.into();
        self
    }

    /// Sets the value of [multiple_details][crate::model::EchoErrorDetailsResponse::multiple_details].
    pub fn set_multiple_details<
        T: std::convert::Into<
                std::option::Option<crate::model::echo_error_details_response::MultipleDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.multiple_details = v.into();
        self
    }
}

impl wkt::message::Message for EchoErrorDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.EchoErrorDetailsResponse"
    }
}

/// Defines additional types related to [EchoErrorDetailsResponse].
pub mod echo_error_details_response {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SingleDetail {
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub error: std::option::Option<crate::model::ErrorWithSingleDetail>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SingleDetail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error][crate::model::echo_error_details_response::SingleDetail::error].
        pub fn set_error<
            T: std::convert::Into<std::option::Option<crate::model::ErrorWithSingleDetail>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for SingleDetail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.EchoErrorDetailsResponse.SingleDetail"
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MultipleDetails {
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub error: std::option::Option<crate::model::ErrorWithMultipleDetails>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MultipleDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [error][crate::model::echo_error_details_response::MultipleDetails::error].
        pub fn set_error<
            T: std::convert::Into<std::option::Option<crate::model::ErrorWithMultipleDetails>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.error = v.into();
            self
        }
    }

    impl wkt::message::Message for MultipleDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.EchoErrorDetailsResponse.MultipleDetails"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorWithSingleDetail {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<wkt::Any>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorWithSingleDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::ErrorWithSingleDetail::details].
    pub fn set_details<T: std::convert::Into<std::option::Option<wkt::Any>>>(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }
}

impl wkt::message::Message for ErrorWithSingleDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ErrorWithSingleDetail"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ErrorWithMultipleDetails {
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub details: std::vec::Vec<wkt::Any>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ErrorWithMultipleDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::ErrorWithMultipleDetails::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ErrorWithMultipleDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ErrorWithMultipleDetails"
    }
}

/// The custom error detail to be included in the error response from the
/// FailEchoWithDetails method. Client libraries should be able to
/// surface this custom error detail.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PoetryError {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub poem: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PoetryError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [poem][crate::model::PoetryError::poem].
    pub fn set_poem<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.poem = v.into();
        self
    }
}

impl wkt::message::Message for PoetryError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PoetryError"
    }
}

/// The request message used for the FailEchoWithDetails method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FailEchoWithDetailsRequest {
    /// Optional message to echo back in the PoetryError. If empty, a value will be
    /// provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailEchoWithDetailsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [message][crate::model::FailEchoWithDetailsRequest::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }
}

impl wkt::message::Message for FailEchoWithDetailsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.FailEchoWithDetailsRequest"
    }
}

/// The response message declared (but never used) for the FailEchoWithDetails
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FailEchoWithDetailsResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FailEchoWithDetailsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for FailEchoWithDetailsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.FailEchoWithDetailsResponse"
    }
}

/// The request message for the Expand method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExpandRequest {
    /// The content that will be split into words and returned on the stream.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// The error that is thrown after all words are sent on the stream.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The wait time between each server streaming messages
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub stream_wait_time: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExpandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::ExpandRequest::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ExpandRequest::error].
    pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }

    /// Sets the value of [stream_wait_time][crate::model::ExpandRequest::stream_wait_time].
    pub fn set_stream_wait_time<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.stream_wait_time = v.into();
        self
    }
}

impl wkt::message::Message for ExpandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ExpandRequest"
    }
}

/// The request for the PagedExpand method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PagedExpandRequest {
    /// The string to expand.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// The number of words to returned in each page.
    pub page_size: i32,

    /// The position of the page to be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PagedExpandRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::PagedExpandRequest::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::PagedExpandRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::PagedExpandRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for PagedExpandRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PagedExpandRequest"
    }
}

/// The request for the PagedExpandLegacy method.  This is a pattern used by some legacy APIs. New
/// APIs should NOT use this pattern, but rather something like PagedExpandRequest which conforms to
/// aip.dev/158.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PagedExpandLegacyRequest {
    /// The string to expand.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// The number of words to returned in each page.
    /// (-- aip.dev/not-precedent: This is a legacy, non-standard pattern that
    /// violates aip.dev/158. Ordinarily, this should be page_size. --)
    pub max_results: i32,

    /// The position of the page to be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PagedExpandLegacyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::PagedExpandLegacyRequest::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [max_results][crate::model::PagedExpandLegacyRequest::max_results].
    pub fn set_max_results<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.max_results = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::PagedExpandLegacyRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for PagedExpandLegacyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PagedExpandLegacyRequest"
    }
}

/// The response for the PagedExpand method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PagedExpandResponse {
    /// The words that were expanded.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub responses: std::vec::Vec<crate::model::EchoResponse>,

    /// The next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PagedExpandResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::PagedExpandResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [responses][crate::model::PagedExpandResponse::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EchoResponse>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PagedExpandResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PagedExpandResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for PagedExpandResponse {
    type PageItem = crate::model::EchoResponse;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.responses
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A list of words.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PagedExpandResponseList {
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub words: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PagedExpandResponseList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [words][crate::model::PagedExpandResponseList::words].
    pub fn set_words<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.words = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for PagedExpandResponseList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PagedExpandResponseList"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PagedExpandLegacyMappedResponse {
    /// The words that were expanded, indexed by their initial character.
    /// (-- aip.dev/not-precedent: This is a legacy, non-standard pattern that violates
    /// aip.dev/158. Ordinarily, this should be a `repeated` field, as in PagedExpandResponse. --)
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub alphabetized:
        std::collections::HashMap<std::string::String, crate::model::PagedExpandResponseList>,

    /// The next page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PagedExpandLegacyMappedResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::PagedExpandLegacyMappedResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [alphabetized][crate::model::PagedExpandLegacyMappedResponse::alphabetized].
    pub fn set_alphabetized<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::PagedExpandResponseList>,
    {
        use std::iter::Iterator;
        self.alphabetized = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for PagedExpandLegacyMappedResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.PagedExpandLegacyMappedResponse"
    }
}

/// The request for Wait method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WaitRequest {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub end: std::option::Option<crate::model::wait_request::End>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub response: std::option::Option<crate::model::wait_request::Response>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WaitRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [end][crate::model::WaitRequest::end].
    ///
    /// Note that all the setters affecting `end` are mutually
    /// exclusive.
    pub fn set_end<T: std::convert::Into<std::option::Option<crate::model::wait_request::End>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end = v.into();
        self
    }

    /// The value of [end][crate::model::WaitRequest::end]
    /// if it holds a `EndTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn end_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.end.as_ref().and_then(|v| match v {
            crate::model::wait_request::End::EndTime(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [end][crate::model::WaitRequest::end]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.end.as_ref().and_then(|v| match v {
            crate::model::wait_request::End::Ttl(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [end][crate::model::WaitRequest::end]
    /// to hold a `EndTime`.
    ///
    /// Note that all the setters affecting `end` are
    /// mutually exclusive.
    pub fn set_end_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end = std::option::Option::Some(crate::model::wait_request::End::EndTime(v.into()));
        self
    }

    /// Sets the value of [end][crate::model::WaitRequest::end]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `end` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.end = std::option::Option::Some(crate::model::wait_request::End::Ttl(v.into()));
        self
    }

    /// Sets the value of [response][crate::model::WaitRequest::response].
    ///
    /// Note that all the setters affecting `response` are mutually
    /// exclusive.
    pub fn set_response<
        T: std::convert::Into<std::option::Option<crate::model::wait_request::Response>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }

    /// The value of [response][crate::model::WaitRequest::response]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::wait_request::Response::Error(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [response][crate::model::WaitRequest::response]
    /// if it holds a `Success`, `None` if the field is not set or
    /// holds a different branch.
    pub fn success(&self) -> std::option::Option<&std::boxed::Box<crate::model::WaitResponse>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::wait_request::Response::Success(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::WaitRequest::response]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response =
            std::option::Option::Some(crate::model::wait_request::Response::Error(v.into()));
        self
    }

    /// Sets the value of [response][crate::model::WaitRequest::response]
    /// to hold a `Success`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_success<T: std::convert::Into<std::boxed::Box<crate::model::WaitResponse>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response =
            std::option::Option::Some(crate::model::wait_request::Response::Success(v.into()));
        self
    }
}

impl wkt::message::Message for WaitRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.WaitRequest"
    }
}

/// Defines additional types related to [WaitRequest].
pub mod wait_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum End {
        /// The time that this operation will complete.
        EndTime(std::boxed::Box<wkt::Timestamp>),
        /// The duration of this operation.
        Ttl(std::boxed::Box<wkt::Duration>),
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Response {
        /// The error that will be returned by the server. If this code is specified
        /// to be the OK rpc code, an empty response will be returned.
        Error(std::boxed::Box<rpc::model::Status>),
        /// The response to be returned on operation completion.
        Success(std::boxed::Box<crate::model::WaitResponse>),
    }
}

/// The result of the Wait operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WaitResponse {
    /// This content of the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WaitResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::WaitResponse::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }
}

impl wkt::message::Message for WaitResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.WaitResponse"
    }
}

/// The metadata for Wait operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WaitMetadata {
    /// The time that this operation will complete.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WaitMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [end_time][crate::model::WaitMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for WaitMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.WaitMetadata"
    }
}

/// The request for Block method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BlockRequest {
    /// The amount of time to block before returning a response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub response_delay: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub response: std::option::Option<crate::model::block_request::Response>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BlockRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [response_delay][crate::model::BlockRequest::response_delay].
    pub fn set_response_delay<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response_delay = v.into();
        self
    }

    /// Sets the value of [response][crate::model::BlockRequest::response].
    ///
    /// Note that all the setters affecting `response` are mutually
    /// exclusive.
    pub fn set_response<
        T: std::convert::Into<std::option::Option<crate::model::block_request::Response>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.response = v.into();
        self
    }

    /// The value of [response][crate::model::BlockRequest::response]
    /// if it holds a `Error`, `None` if the field is not set or
    /// holds a different branch.
    pub fn error(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::block_request::Response::Error(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [response][crate::model::BlockRequest::response]
    /// if it holds a `Success`, `None` if the field is not set or
    /// holds a different branch.
    pub fn success(&self) -> std::option::Option<&std::boxed::Box<crate::model::BlockResponse>> {
        #[allow(unreachable_patterns)]
        self.response.as_ref().and_then(|v| match v {
            crate::model::block_request::Response::Success(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [response][crate::model::BlockRequest::response]
    /// to hold a `Error`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_error<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response =
            std::option::Option::Some(crate::model::block_request::Response::Error(v.into()));
        self
    }

    /// Sets the value of [response][crate::model::BlockRequest::response]
    /// to hold a `Success`.
    ///
    /// Note that all the setters affecting `response` are
    /// mutually exclusive.
    pub fn set_success<T: std::convert::Into<std::boxed::Box<crate::model::BlockResponse>>>(
        mut self,
        v: T,
    ) -> Self {
        self.response =
            std::option::Option::Some(crate::model::block_request::Response::Success(v.into()));
        self
    }
}

impl wkt::message::Message for BlockRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.BlockRequest"
    }
}

/// Defines additional types related to [BlockRequest].
pub mod block_request {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Response {
        /// The error that will be returned by the server. If this code is specified
        /// to be the OK rpc code, an empty response will be returned.
        Error(std::boxed::Box<rpc::model::Status>),
        /// The response to be returned that will signify successful method call.
        Success(std::boxed::Box<crate::model::BlockResponse>),
    }
}

/// The response for Block method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BlockResponse {
    /// This content can contain anything, the server will not depend on a value
    /// here.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BlockResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::BlockResponse::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }
}

impl wkt::message::Message for BlockResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.BlockResponse"
    }
}

/// A user.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct User {
    /// The resource name of the user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The display_name of the user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The email address of the user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub email: std::string::String,

    /// The timestamp at which the user was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The latest timestamp at which the user was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The age of the user in years.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub age: std::option::Option<i32>,

    /// The height of the user in feet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub height_feet: std::option::Option<f64>,

    /// The nickname of the user.
    ///
    /// (-- aip.dev/not-precedent: An empty string is a valid nickname.
    /// Ordinarily, proto3_optional should not be used on a `string` field. --)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub nickname: std::option::Option<std::string::String>,

    /// Enables the receiving of notifications. The default is true if unset.
    ///
    /// (-- aip.dev/not-precedent: The default for the feature is true.
    /// Ordinarily, the default for a `bool` field should be false. --)
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub enable_notifications: std::option::Option<bool>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl User {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::User::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::User::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [email][crate::model::User::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::User::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::User::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [age][crate::model::User::age].
    pub fn set_age<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.age = v.into();
        self
    }

    /// Sets the value of [height_feet][crate::model::User::height_feet].
    pub fn set_height_feet<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.height_feet = v.into();
        self
    }

    /// Sets the value of [nickname][crate::model::User::nickname].
    pub fn set_nickname<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.nickname = v.into();
        self
    }

    /// Sets the value of [enable_notifications][crate::model::User::enable_notifications].
    pub fn set_enable_notifications<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.enable_notifications = v.into();
        self
    }
}

impl wkt::message::Message for User {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.User"
    }
}

/// The request message for the google.showcase.v1beta1.Identity\CreateUser
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateUserRequest {
    /// The user to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user: std::option::Option<crate::model::User>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user][crate::model::CreateUserRequest::user].
    pub fn set_user<T: std::convert::Into<std::option::Option<crate::model::User>>>(
        mut self,
        v: T,
    ) -> Self {
        self.user = v.into();
        self
    }
}

impl wkt::message::Message for CreateUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateUserRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Identity\GetUser
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetUserRequest {
    /// The resource name of the requested user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUserRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetUserRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Identity\UpdateUser
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateUserRequest {
    /// The user to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user: std::option::Option<crate::model::User>,

    /// The field mask to determine which fields are to be updated. If empty, the
    /// server will assume all fields are to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user][crate::model::UpdateUserRequest::user].
    pub fn set_user<T: std::convert::Into<std::option::Option<crate::model::User>>>(
        mut self,
        v: T,
    ) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateUserRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.UpdateUserRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Identity\DeleteUser
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteUserRequest {
    /// The resource name of the user to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUserRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUserRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUserRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.DeleteUserRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Identity\ListUsers
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUsersRequest {
    /// The maximum number of users to return. Server may return fewer users
    /// than requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// The value of google.showcase.v1beta1.ListUsersResponse.next_page_token
    /// returned from the previous call to
    /// `google.showcase.v1beta1.Identity\ListUsers` method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListUsersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUsersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListUsersRequest"
    }
}

/// The response message for the google.showcase.v1beta1.Identity\ListUsers
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUsersResponse {
    /// The list of users.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub users: std::vec::Vec<crate::model::User>,

    /// A token to retrieve next page of results.
    /// Pass this value in ListUsersRequest.page_token field in the subsequent
    /// call to `google.showcase.v1beta1.Message\ListUsers` method to retrieve the
    /// next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListUsersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [users][crate::model::ListUsersResponse::users].
    pub fn set_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::User>,
    {
        use std::iter::Iterator;
        self.users = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUsersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListUsersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUsersResponse {
    type PageItem = crate::model::User;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.users
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A chat room.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Room {
    /// The resource name of the chat room.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The human readable name of the chat room.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description of the chat room.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The timestamp at which the room was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The latest timestamp at which the room was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Room {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Room::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Room::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Room::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Room::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Room::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }
}

impl wkt::message::Message for Room {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Room"
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\CreateRoom
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateRoomRequest {
    /// The room to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub room: std::option::Option<crate::model::Room>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRoomRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [room][crate::model::CreateRoomRequest::room].
    pub fn set_room<T: std::convert::Into<std::option::Option<crate::model::Room>>>(
        mut self,
        v: T,
    ) -> Self {
        self.room = v.into();
        self
    }
}

impl wkt::message::Message for CreateRoomRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateRoomRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\GetRoom
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetRoomRequest {
    /// The resource name of the requested room.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRoomRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRoomRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRoomRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetRoomRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\UpdateRoom
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateRoomRequest {
    /// The room to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub room: std::option::Option<crate::model::Room>,

    /// The field mask to determine which fields are to be updated. If empty, the
    /// server will assume all fields are to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRoomRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [room][crate::model::UpdateRoomRequest::room].
    pub fn set_room<T: std::convert::Into<std::option::Option<crate::model::Room>>>(
        mut self,
        v: T,
    ) -> Self {
        self.room = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateRoomRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateRoomRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.UpdateRoomRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\DeleteRoom
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteRoomRequest {
    /// The resource name of the requested room.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRoomRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRoomRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRoomRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.DeleteRoomRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\ListRooms
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRoomsRequest {
    /// The maximum number of rooms return. Server may return fewer rooms
    /// than requested. If unspecified, server will pick an appropriate default.
    pub page_size: i32,

    /// The value of google.showcase.v1beta1.ListRoomsResponse.next_page_token
    /// returned from the previous call to
    /// `google.showcase.v1beta1.Messaging\ListRooms` method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRoomsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListRoomsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRoomsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListRoomsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListRoomsRequest"
    }
}

/// The response message for the google.showcase.v1beta1.Messaging\ListRooms
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListRoomsResponse {
    /// The list of rooms.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub rooms: std::vec::Vec<crate::model::Room>,

    /// A token to retrieve next page of results.
    /// Pass this value in ListRoomsRequest.page_token field in the subsequent
    /// call to `google.showcase.v1beta1.Messaging\ListRooms` method to retrieve
    /// the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRoomsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListRoomsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [rooms][crate::model::ListRoomsResponse::rooms].
    pub fn set_rooms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Room>,
    {
        use std::iter::Iterator;
        self.rooms = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRoomsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListRoomsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRoomsResponse {
    type PageItem = crate::model::Room;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.rooms
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// This protocol buffer message represents a blurb sent to a chat room or
/// posted on a user profile.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Blurb {
    /// The resource name of the chat room.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The resource name of the blurb's author.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user: std::string::String,

    /// The timestamp at which the blurb was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The latest timestamp at which the blurb was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub content: std::option::Option<crate::model::blurb::Content>,

    /// (-- aip.dev/not-precedent: This is designed for testing non-slash
    /// resource patterns. Ordinarily, non-slash separators are discouraged.
    /// --)
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub legacy_id: std::option::Option<crate::model::blurb::LegacyId>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Blurb {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Blurb::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [user][crate::model::Blurb::user].
    pub fn set_user<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Blurb::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Blurb::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [content][crate::model::Blurb::content].
    ///
    /// Note that all the setters affecting `content` are mutually
    /// exclusive.
    pub fn set_content<T: std::convert::Into<std::option::Option<crate::model::blurb::Content>>>(
        mut self,
        v: T,
    ) -> Self {
        self.content = v.into();
        self
    }

    /// The value of [content][crate::model::Blurb::content]
    /// if it holds a `Text`, `None` if the field is not set or
    /// holds a different branch.
    pub fn text(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::blurb::Content::Text(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [content][crate::model::Blurb::content]
    /// if it holds a `Image`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image(&self) -> std::option::Option<&::bytes::Bytes> {
        #[allow(unreachable_patterns)]
        self.content.as_ref().and_then(|v| match v {
            crate::model::blurb::Content::Image(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [content][crate::model::Blurb::content]
    /// to hold a `Text`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_text<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = std::option::Option::Some(crate::model::blurb::Content::Text(v.into()));
        self
    }

    /// Sets the value of [content][crate::model::Blurb::content]
    /// to hold a `Image`.
    ///
    /// Note that all the setters affecting `content` are
    /// mutually exclusive.
    pub fn set_image<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.content = std::option::Option::Some(crate::model::blurb::Content::Image(v.into()));
        self
    }

    /// Sets the value of [legacy_id][crate::model::Blurb::legacy_id].
    ///
    /// Note that all the setters affecting `legacy_id` are mutually
    /// exclusive.
    pub fn set_legacy_id<
        T: std::convert::Into<std::option::Option<crate::model::blurb::LegacyId>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.legacy_id = v.into();
        self
    }

    /// The value of [legacy_id][crate::model::Blurb::legacy_id]
    /// if it holds a `LegacyRoomId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn legacy_room_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.legacy_id.as_ref().and_then(|v| match v {
            crate::model::blurb::LegacyId::LegacyRoomId(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [legacy_id][crate::model::Blurb::legacy_id]
    /// if it holds a `LegacyUserId`, `None` if the field is not set or
    /// holds a different branch.
    pub fn legacy_user_id(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.legacy_id.as_ref().and_then(|v| match v {
            crate::model::blurb::LegacyId::LegacyUserId(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [legacy_id][crate::model::Blurb::legacy_id]
    /// to hold a `LegacyRoomId`.
    ///
    /// Note that all the setters affecting `legacy_id` are
    /// mutually exclusive.
    pub fn set_legacy_room_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.legacy_id =
            std::option::Option::Some(crate::model::blurb::LegacyId::LegacyRoomId(v.into()));
        self
    }

    /// Sets the value of [legacy_id][crate::model::Blurb::legacy_id]
    /// to hold a `LegacyUserId`.
    ///
    /// Note that all the setters affecting `legacy_id` are
    /// mutually exclusive.
    pub fn set_legacy_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.legacy_id =
            std::option::Option::Some(crate::model::blurb::LegacyId::LegacyUserId(v.into()));
        self
    }
}

impl wkt::message::Message for Blurb {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Blurb"
    }
}

/// Defines additional types related to [Blurb].
pub mod blurb {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Content {
        /// The textual content of this blurb.
        Text(std::string::String),
        /// The image content of this blurb.
        Image(::bytes::Bytes),
    }

    /// (-- aip.dev/not-precedent: This is designed for testing non-slash
    /// resource patterns. Ordinarily, non-slash separators are discouraged.
    /// --)
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum LegacyId {
        /// The legacy id of the room. This field is used to signal
        /// the use of the compound resource pattern
        /// `rooms/{room}/blurbs/legacy/{legacy_room}.{blurb}`
        LegacyRoomId(std::string::String),
        /// The legacy id of the user. This field is used to signal
        /// the use of the compound resource pattern
        /// `users/{user}/profile/blurbs/legacy/{legacy_user}~{blurb}`
        LegacyUserId(std::string::String),
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\CreateBlurb
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBlurbRequest {
    /// The resource name of the chat room or user profile that this blurb will
    /// be tied to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The blurb to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blurb: std::option::Option<crate::model::Blurb>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateBlurbRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBlurbRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [blurb][crate::model::CreateBlurbRequest::blurb].
    pub fn set_blurb<T: std::convert::Into<std::option::Option<crate::model::Blurb>>>(
        mut self,
        v: T,
    ) -> Self {
        self.blurb = v.into();
        self
    }
}

impl wkt::message::Message for CreateBlurbRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateBlurbRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\GetBlurb
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBlurbRequest {
    /// The resource name of the requested blurb.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBlurbRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBlurbRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBlurbRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetBlurbRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\UpdateBlurb
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBlurbRequest {
    /// The blurb to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blurb: std::option::Option<crate::model::Blurb>,

    /// The field mask to determine which fields are to be updated. If empty, the
    /// server will assume all fields are to be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateBlurbRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blurb][crate::model::UpdateBlurbRequest::blurb].
    pub fn set_blurb<T: std::convert::Into<std::option::Option<crate::model::Blurb>>>(
        mut self,
        v: T,
    ) -> Self {
        self.blurb = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateBlurbRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBlurbRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.UpdateBlurbRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\DeleteBlurb
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBlurbRequest {
    /// The resource name of the requested blurb.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBlurbRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBlurbRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBlurbRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.DeleteBlurbRequest"
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\ListBlurbs
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBlurbsRequest {
    /// The resource name of the requested room or profile who blurbs to list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of blurbs to return. Server may return fewer
    /// blurbs than requested. If unspecified, server will pick an appropriate
    /// default.
    pub page_size: i32,

    /// The value of google.showcase.v1beta1.ListBlurbsResponse.next_page_token
    /// returned from the previous call to
    /// `google.showcase.v1beta1.Messaging\ListBlurbs` method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBlurbsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBlurbsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBlurbsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBlurbsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBlurbsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListBlurbsRequest"
    }
}

/// The response message for the google.showcase.v1beta1.Messaging\ListBlurbs
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBlurbsResponse {
    /// The list of blurbs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blurbs: std::vec::Vec<crate::model::Blurb>,

    /// A token to retrieve next page of results.
    /// Pass this value in ListBlurbsRequest.page_token field in the subsequent
    /// call to `google.showcase.v1beta1.Blurb\ListBlurbs` method to retrieve
    /// the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBlurbsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBlurbsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [blurbs][crate::model::ListBlurbsResponse::blurbs].
    pub fn set_blurbs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Blurb>,
    {
        use std::iter::Iterator;
        self.blurbs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBlurbsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListBlurbsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBlurbsResponse {
    type PageItem = crate::model::Blurb;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.blurbs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\SearchBlurbs
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchBlurbsRequest {
    /// The query used to search for blurbs containing to words of this string.
    /// Only posts that contain an exact match of a queried word will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub query: std::string::String,

    /// The rooms or profiles to search. If unset, `SearchBlurbs` will search all
    /// rooms and all profiles.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of blurbs return. Server may return fewer
    /// blurbs than requested. If unspecified, server will pick an appropriate
    /// default.
    pub page_size: i32,

    /// The value of
    /// google.showcase.v1beta1.SearchBlurbsResponse.next_page_token
    /// returned from the previous call to
    /// `google.showcase.v1beta1.Messaging\SearchBlurbs` method.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBlurbsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [query][crate::model::SearchBlurbsRequest::query].
    pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.query = v.into();
        self
    }

    /// Sets the value of [parent][crate::model::SearchBlurbsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchBlurbsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchBlurbsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchBlurbsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.SearchBlurbsRequest"
    }
}

/// The operation metadata message for the
/// google.showcase.v1beta1.Messaging\SearchBlurbs method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchBlurbsMetadata {
    /// This signals to the client when to next poll for response.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retry_info: std::option::Option<rpc::model::RetryInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBlurbsMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [retry_info][crate::model::SearchBlurbsMetadata::retry_info].
    pub fn set_retry_info<T: std::convert::Into<std::option::Option<rpc::model::RetryInfo>>>(
        mut self,
        v: T,
    ) -> Self {
        self.retry_info = v.into();
        self
    }
}

impl wkt::message::Message for SearchBlurbsMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.SearchBlurbsMetadata"
    }
}

/// The operation response message for the
/// google.showcase.v1beta1.Messaging\SearchBlurbs method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchBlurbsResponse {
    /// Blurbs that matched the search query.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blurbs: std::vec::Vec<crate::model::Blurb>,

    /// A token to retrieve next page of results.
    /// Pass this value in SearchBlurbsRequest.page_token field in the subsequent
    /// call to `google.showcase.v1beta1.Blurb\SearchBlurbs` method to
    /// retrieve the next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchBlurbsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchBlurbsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [blurbs][crate::model::SearchBlurbsResponse::blurbs].
    pub fn set_blurbs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Blurb>,
    {
        use std::iter::Iterator;
        self.blurbs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchBlurbsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.SearchBlurbsResponse"
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\StreamBlurbs
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamBlurbsRequest {
    /// The resource name of a chat room or user profile whose blurbs to stream.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The time at which this stream will close.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamBlurbsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StreamBlurbsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::StreamBlurbsRequest::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }
}

impl wkt::message::Message for StreamBlurbsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.StreamBlurbsRequest"
    }
}

/// The response message for the google.showcase.v1beta1.Messaging\StreamBlurbs
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamBlurbsResponse {
    /// The blurb that was either created, updated, or deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub blurb: std::option::Option<crate::model::Blurb>,

    /// The action that triggered the blurb to be returned.
    pub action: crate::model::stream_blurbs_response::Action,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamBlurbsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [blurb][crate::model::StreamBlurbsResponse::blurb].
    pub fn set_blurb<T: std::convert::Into<std::option::Option<crate::model::Blurb>>>(
        mut self,
        v: T,
    ) -> Self {
        self.blurb = v.into();
        self
    }

    /// Sets the value of [action][crate::model::StreamBlurbsResponse::action].
    pub fn set_action<T: std::convert::Into<crate::model::stream_blurbs_response::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }
}

impl wkt::message::Message for StreamBlurbsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.StreamBlurbsResponse"
    }
}

/// Defines additional types related to [StreamBlurbsResponse].
pub mod stream_blurbs_response {
    #[allow(unused_imports)]
    use super::*;

    /// The action that triggered the blurb to be returned.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Action(i32);

    impl Action {
        pub const ACTION_UNSPECIFIED: Action = Action::new(0);

        /// Specifies that the blurb was created.
        pub const CREATE: Action = Action::new(1);

        /// Specifies that the blurb was updated.
        pub const UPDATE: Action = Action::new(2);

        /// Specifies that the blurb was deleted.
        pub const DELETE: Action = Action::new(3);

        /// Creates a new Action instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ACTION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATE"),
                2 => std::borrow::Cow::Borrowed("UPDATE"),
                3 => std::borrow::Cow::Borrowed("DELETE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ACTION_UNSPECIFIED" => std::option::Option::Some(Self::ACTION_UNSPECIFIED),
                "CREATE" => std::option::Option::Some(Self::CREATE),
                "UPDATE" => std::option::Option::Some(Self::UPDATE),
                "DELETE" => std::option::Option::Some(Self::DELETE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The response message for the google.showcase.v1beta1.Messaging\SendBlurbs
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SendBlurbsResponse {
    /// The names of successful blurb creations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub names: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SendBlurbsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [names][crate::model::SendBlurbsResponse::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SendBlurbsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.SendBlurbsResponse"
    }
}

/// The request message for the google.showcase.v1beta1.Messaging\Connect
/// method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectRequest {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub request: std::option::Option<crate::model::connect_request::Request>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request][crate::model::ConnectRequest::request].
    ///
    /// Note that all the setters affecting `request` are mutually
    /// exclusive.
    pub fn set_request<
        T: std::convert::Into<std::option::Option<crate::model::connect_request::Request>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request = v.into();
        self
    }

    /// The value of [request][crate::model::ConnectRequest::request]
    /// if it holds a `Config`, `None` if the field is not set or
    /// holds a different branch.
    pub fn config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::connect_request::ConnectConfig>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::connect_request::Request::Config(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [request][crate::model::ConnectRequest::request]
    /// if it holds a `Blurb`, `None` if the field is not set or
    /// holds a different branch.
    pub fn blurb(&self) -> std::option::Option<&std::boxed::Box<crate::model::Blurb>> {
        #[allow(unreachable_patterns)]
        self.request.as_ref().and_then(|v| match v {
            crate::model::connect_request::Request::Blurb(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [request][crate::model::ConnectRequest::request]
    /// to hold a `Config`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_config<
        T: std::convert::Into<std::boxed::Box<crate::model::connect_request::ConnectConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.request =
            std::option::Option::Some(crate::model::connect_request::Request::Config(v.into()));
        self
    }

    /// Sets the value of [request][crate::model::ConnectRequest::request]
    /// to hold a `Blurb`.
    ///
    /// Note that all the setters affecting `request` are
    /// mutually exclusive.
    pub fn set_blurb<T: std::convert::Into<std::boxed::Box<crate::model::Blurb>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request =
            std::option::Option::Some(crate::model::connect_request::Request::Blurb(v.into()));
        self
    }
}

impl wkt::message::Message for ConnectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ConnectRequest"
    }
}

/// Defines additional types related to [ConnectRequest].
pub mod connect_request {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConnectConfig {
        /// The room or profile to follow and create messages for.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub parent: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConnectConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [parent][crate::model::connect_request::ConnectConfig::parent].
        pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.parent = v.into();
            self
        }
    }

    impl wkt::message::Message for ConnectConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.ConnectRequest.ConnectConfig"
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Request {
        /// Provides information that specifies how to process subsequent requests.
        /// The first `ConnectRequest` message must contain a `config`  message.
        Config(std::boxed::Box<crate::model::connect_request::ConnectConfig>),
        /// The blurb to be created.
        Blurb(std::boxed::Box<crate::model::Blurb>),
    }
}

/// HTTP/JSON error representation as defined in
/// <https://google.aip.dev/193#http11json-representation>,
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RestError {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<crate::model::rest_error::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RestError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::RestError::error].
    pub fn set_error<
        T: std::convert::Into<std::option::Option<crate::model::rest_error::Status>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.error = v.into();
        self
    }
}

impl wkt::message::Message for RestError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.RestError"
    }
}

/// Defines additional types related to [RestError].
pub mod rest_error {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Status {
        /// The HTTP status code that corresponds to `google.rpc.Status.code`.
        pub code: i32,

        /// This corresponds to `google.rpc.Status.message`.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub message: std::string::String,

        /// This is the enum version for `google.rpc.Status.code`.
        pub status: rpc::model::Code,

        /// This corresponds to `google.rpc.Status.details`.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub details: std::vec::Vec<wkt::Any>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Status {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::rest_error::Status::code].
        pub fn set_code<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.code = v.into();
            self
        }

        /// Sets the value of [message][crate::model::rest_error::Status::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [status][crate::model::rest_error::Status::status].
        pub fn set_status<T: std::convert::Into<rpc::model::Code>>(mut self, v: T) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [details][crate::model::rest_error::Status::details].
        pub fn set_details<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<wkt::Any>,
        {
            use std::iter::Iterator;
            self.details = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Status {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.RestError.Status"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Sequence {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Sequence of responses to return in order for each attempt. If empty, the
    /// default response is an immediate OK.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub responses: std::vec::Vec<crate::model::sequence::Response>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Sequence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Sequence::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [responses][crate::model::Sequence::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::sequence::Response>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Sequence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Sequence"
    }
}

/// Defines additional types related to [Sequence].
pub mod sequence {
    #[allow(unused_imports)]
    use super::*;

    /// A server response to an RPC Attempt in a sequence.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Response {
        /// The status to return for an individual attempt.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub status: std::option::Option<rpc::model::Status>,

        /// The amount of time to delay sending the response.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub delay: std::option::Option<wkt::Duration>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Response {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [status][crate::model::sequence::Response::status].
        pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [delay][crate::model::sequence::Response::delay].
        pub fn set_delay<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.delay = v.into();
            self
        }
    }

    impl wkt::message::Message for Response {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.Sequence.Response"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingSequence {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The Content that the stream will send
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    /// Sequence of responses to return in order for each attempt. If empty, the
    /// default response is an immediate OK.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub responses: std::vec::Vec<crate::model::streaming_sequence::Response>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingSequence {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StreamingSequence::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [content][crate::model::StreamingSequence::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }

    /// Sets the value of [responses][crate::model::StreamingSequence::responses].
    pub fn set_responses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::streaming_sequence::Response>,
    {
        use std::iter::Iterator;
        self.responses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StreamingSequence {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.StreamingSequence"
    }
}

/// Defines additional types related to [StreamingSequence].
pub mod streaming_sequence {
    #[allow(unused_imports)]
    use super::*;

    /// A server response to an RPC Attempt in a sequence.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Response {
        /// The status to return for an individual attempt.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub status: std::option::Option<rpc::model::Status>,

        /// The amount of time to delay sending the response.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub delay: std::option::Option<wkt::Duration>,

        /// The index that the status should be sent
        pub response_index: i32,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Response {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [status][crate::model::streaming_sequence::Response::status].
        pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }

        /// Sets the value of [delay][crate::model::streaming_sequence::Response::delay].
        pub fn set_delay<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.delay = v.into();
            self
        }

        /// Sets the value of [response_index][crate::model::streaming_sequence::Response::response_index].
        pub fn set_response_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.response_index = v.into();
            self
        }
    }

    impl wkt::message::Message for Response {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.StreamingSequence.Response"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StreamingSequenceReport {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The set of RPC attempts received by the server for a Sequence.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub attempts: std::vec::Vec<crate::model::streaming_sequence_report::Attempt>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StreamingSequenceReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StreamingSequenceReport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [attempts][crate::model::StreamingSequenceReport::attempts].
    pub fn set_attempts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::streaming_sequence_report::Attempt>,
    {
        use std::iter::Iterator;
        self.attempts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for StreamingSequenceReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.StreamingSequenceReport"
    }
}

/// Defines additional types related to [StreamingSequenceReport].
pub mod streaming_sequence_report {
    #[allow(unused_imports)]
    use super::*;

    /// Contains metrics on individual RPC Attempts in a sequence.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Attempt {
        /// The attempt number - starting at 0.
        pub attempt_number: i32,

        /// The deadline dictated by the attempt to the server.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub attempt_deadline: std::option::Option<wkt::Timestamp>,

        /// The time that the server responded to the RPC attempt. Used for
        /// calculating attempt_delay.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub response_time: std::option::Option<wkt::Timestamp>,

        /// The server perceived delay between sending the last response and
        /// receiving this attempt. Used for validating attempt delay backoff.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub attempt_delay: std::option::Option<wkt::Duration>,

        /// The status returned to the attempt.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub status: std::option::Option<rpc::model::Status>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Attempt {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [attempt_number][crate::model::streaming_sequence_report::Attempt::attempt_number].
        pub fn set_attempt_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.attempt_number = v.into();
            self
        }

        /// Sets the value of [attempt_deadline][crate::model::streaming_sequence_report::Attempt::attempt_deadline].
        pub fn set_attempt_deadline<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.attempt_deadline = v.into();
            self
        }

        /// Sets the value of [response_time][crate::model::streaming_sequence_report::Attempt::response_time].
        pub fn set_response_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.response_time = v.into();
            self
        }

        /// Sets the value of [attempt_delay][crate::model::streaming_sequence_report::Attempt::attempt_delay].
        pub fn set_attempt_delay<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.attempt_delay = v.into();
            self
        }

        /// Sets the value of [status][crate::model::streaming_sequence_report::Attempt::status].
        pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }
    }

    impl wkt::message::Message for Attempt {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.StreamingSequenceReport.Attempt"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SequenceReport {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The set of RPC attempts received by the server for a Sequence.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub attempts: std::vec::Vec<crate::model::sequence_report::Attempt>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SequenceReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SequenceReport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [attempts][crate::model::SequenceReport::attempts].
    pub fn set_attempts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::sequence_report::Attempt>,
    {
        use std::iter::Iterator;
        self.attempts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SequenceReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.SequenceReport"
    }
}

/// Defines additional types related to [SequenceReport].
pub mod sequence_report {
    #[allow(unused_imports)]
    use super::*;

    /// Contains metrics on individual RPC Attempts in a sequence.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Attempt {
        /// The attempt number - starting at 0.
        pub attempt_number: i32,

        /// The deadline dictated by the attempt to the server.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub attempt_deadline: std::option::Option<wkt::Timestamp>,

        /// The time that the server responded to the RPC attempt. Used for
        /// calculating attempt_delay.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub response_time: std::option::Option<wkt::Timestamp>,

        /// The server perceived delay between sending the last response and
        /// receiving this attempt. Used for validating attempt delay backoff.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub attempt_delay: std::option::Option<wkt::Duration>,

        /// The status returned to the attempt.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub status: std::option::Option<rpc::model::Status>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Attempt {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [attempt_number][crate::model::sequence_report::Attempt::attempt_number].
        pub fn set_attempt_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.attempt_number = v.into();
            self
        }

        /// Sets the value of [attempt_deadline][crate::model::sequence_report::Attempt::attempt_deadline].
        pub fn set_attempt_deadline<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.attempt_deadline = v.into();
            self
        }

        /// Sets the value of [response_time][crate::model::sequence_report::Attempt::response_time].
        pub fn set_response_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.response_time = v.into();
            self
        }

        /// Sets the value of [attempt_delay][crate::model::sequence_report::Attempt::attempt_delay].
        pub fn set_attempt_delay<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.attempt_delay = v.into();
            self
        }

        /// Sets the value of [status][crate::model::sequence_report::Attempt::status].
        pub fn set_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.status = v.into();
            self
        }
    }

    impl wkt::message::Message for Attempt {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.SequenceReport.Attempt"
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSequenceRequest {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub sequence: std::option::Option<crate::model::Sequence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSequenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sequence][crate::model::CreateSequenceRequest::sequence].
    pub fn set_sequence<T: std::convert::Into<std::option::Option<crate::model::Sequence>>>(
        mut self,
        v: T,
    ) -> Self {
        self.sequence = v.into();
        self
    }
}

impl wkt::message::Message for CreateSequenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateSequenceRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateStreamingSequenceRequest {
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub streaming_sequence: std::option::Option<crate::model::StreamingSequence>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateStreamingSequenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [streaming_sequence][crate::model::CreateStreamingSequenceRequest::streaming_sequence].
    pub fn set_streaming_sequence<
        T: std::convert::Into<std::option::Option<crate::model::StreamingSequence>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.streaming_sequence = v.into();
        self
    }
}

impl wkt::message::Message for CreateStreamingSequenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateStreamingSequenceRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttemptSequenceRequest {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttemptSequenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttemptSequenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AttemptSequenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.AttemptSequenceRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttemptStreamingSequenceRequest {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// used to send the index of the last failed message
    /// in the string "content" of an AttemptStreamingSequenceResponse
    /// needed for stream resumption logic testing
    pub last_fail_index: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttemptStreamingSequenceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttemptStreamingSequenceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [last_fail_index][crate::model::AttemptStreamingSequenceRequest::last_fail_index].
    pub fn set_last_fail_index<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.last_fail_index = v.into();
        self
    }
}

impl wkt::message::Message for AttemptStreamingSequenceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.AttemptStreamingSequenceRequest"
    }
}

/// The response message for the Echo methods.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttemptStreamingSequenceResponse {
    /// The content specified in the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub content: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttemptStreamingSequenceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::AttemptStreamingSequenceResponse::content].
    pub fn set_content<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.content = v.into();
        self
    }
}

impl wkt::message::Message for AttemptStreamingSequenceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.AttemptStreamingSequenceResponse"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSequenceReportRequest {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSequenceReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSequenceReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSequenceReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetSequenceReportRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetStreamingSequenceReportRequest {
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetStreamingSequenceReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetStreamingSequenceReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetStreamingSequenceReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetStreamingSequenceReportRequest"
    }
}

/// A session is a suite of tests, generally being made in the context
/// of testing code generation.
///
/// A session defines tests it may expect, based on which version of the
/// code generation spec is in use.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Session {
    /// The name of the session. The ID must conform to ^[a-z]+$
    /// If this is not provided, Showcase chooses one at random.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The version this session is using.
    pub version: crate::model::session::Version,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Session {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Session::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Session::version].
    pub fn set_version<T: std::convert::Into<crate::model::session::Version>>(
        mut self,
        v: T,
    ) -> Self {
        self.version = v.into();
        self
    }
}

impl wkt::message::Message for Session {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Session"
    }
}

/// Defines additional types related to [Session].
pub mod session {
    #[allow(unused_imports)]
    use super::*;

    /// The specification versions understood by Showcase.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Version(i32);

    impl Version {
        /// Unspecified version. If passed on creation, the session will default
        /// to using the latest stable release.
        pub const VERSION_UNSPECIFIED: Version = Version::new(0);

        /// The latest v1. Currently, this is v1.0.
        pub const V1_LATEST: Version = Version::new(1);

        /// v1.0. (Until the spec is "GA", this will be a moving target.)
        pub const V1_0: Version = Version::new(2);

        /// Creates a new Version instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("VERSION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("V1_LATEST"),
                2 => std::borrow::Cow::Borrowed("V1_0"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "VERSION_UNSPECIFIED" => std::option::Option::Some(Self::VERSION_UNSPECIFIED),
                "V1_LATEST" => std::option::Option::Some(Self::V1_LATEST),
                "V1_0" => std::option::Option::Some(Self::V1_0),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Version {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Version {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The request for the CreateSession method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSessionRequest {
    /// The session to be created.
    /// Sessions are immutable once they are created (although they can
    /// be deleted).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub session: std::option::Option<crate::model::Session>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [session][crate::model::CreateSessionRequest::session].
    pub fn set_session<T: std::convert::Into<std::option::Option<crate::model::Session>>>(
        mut self,
        v: T,
    ) -> Self {
        self.session = v.into();
        self
    }
}

impl wkt::message::Message for CreateSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.CreateSessionRequest"
    }
}

/// The request for the GetSession method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSessionRequest {
    /// The session to be retrieved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.GetSessionRequest"
    }
}

/// The request for the ListSessions method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSessionsRequest {
    /// The maximum number of sessions to return per page.
    pub page_size: i32,

    /// The page token, for retrieving subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [page_size][crate::model::ListSessionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSessionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListSessionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListSessionsRequest"
    }
}

/// Response for the ListSessions method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSessionsResponse {
    /// The sessions being returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sessions: std::vec::Vec<crate::model::Session>,

    /// The next page token, if any.
    /// An empty value here means the last page has been reached.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSessionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListSessionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [sessions][crate::model::ListSessionsResponse::sessions].
    pub fn set_sessions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Session>,
    {
        use std::iter::Iterator;
        self.sessions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSessionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListSessionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSessionsResponse {
    type PageItem = crate::model::Session;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sessions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request for the DeleteSession method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSessionRequest {
    /// The session to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.DeleteSessionRequest"
    }
}

/// Request message for reporting on a session.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReportSessionRequest {
    /// The session to be reported on.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportSessionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReportSessionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ReportSessionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ReportSessionRequest"
    }
}

/// Response message for reporting on a session.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReportSessionResponse {
    /// The state of the report.
    pub result: crate::model::report_session_response::Result,

    /// The test runs of this session.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub test_runs: std::vec::Vec<crate::model::TestRun>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReportSessionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [result][crate::model::ReportSessionResponse::result].
    pub fn set_result<T: std::convert::Into<crate::model::report_session_response::Result>>(
        mut self,
        v: T,
    ) -> Self {
        self.result = v.into();
        self
    }

    /// Sets the value of [test_runs][crate::model::ReportSessionResponse::test_runs].
    pub fn set_test_runs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TestRun>,
    {
        use std::iter::Iterator;
        self.test_runs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReportSessionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ReportSessionResponse"
    }
}

/// Defines additional types related to [ReportSessionResponse].
pub mod report_session_response {
    #[allow(unused_imports)]
    use super::*;

    /// The topline state of the report.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Result(i32);

    impl Result {
        pub const RESULT_UNSPECIFIED: Result = Result::new(0);

        /// The session is complete, and everything passed.
        pub const PASSED: Result = Result::new(1);

        /// The session had an explicit failure.
        pub const FAILED: Result = Result::new(2);

        /// The session is incomplete. This is a failure response.
        pub const INCOMPLETE: Result = Result::new(3);

        /// Creates a new Result instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RESULT_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("PASSED"),
                2 => std::borrow::Cow::Borrowed("FAILED"),
                3 => std::borrow::Cow::Borrowed("INCOMPLETE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RESULT_UNSPECIFIED" => std::option::Option::Some(Self::RESULT_UNSPECIFIED),
                "PASSED" => std::option::Option::Some(Self::PASSED),
                "FAILED" => std::option::Option::Some(Self::FAILED),
                "INCOMPLETE" => std::option::Option::Some(Self::INCOMPLETE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Result {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Result {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Test {
    /// The name of the test.
    /// The tests/* portion of the names are hard-coded, and do not change
    /// from session to session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The expectation level for this test.
    pub expectation_level: crate::model::test::ExpectationLevel,

    /// A description of the test.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The blueprints that will satisfy this test. There may be multiple blueprints
    /// that can signal to the server that this test case is being exercised. Although
    /// multiple blueprints are specified, only a single blueprint needs to be run to
    /// signal that the test case was exercised.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub blueprints: std::vec::Vec<crate::model::test::Blueprint>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Test {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Test::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [expectation_level][crate::model::Test::expectation_level].
    pub fn set_expectation_level<T: std::convert::Into<crate::model::test::ExpectationLevel>>(
        mut self,
        v: T,
    ) -> Self {
        self.expectation_level = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Test::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [blueprints][crate::model::Test::blueprints].
    pub fn set_blueprints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::test::Blueprint>,
    {
        use std::iter::Iterator;
        self.blueprints = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Test {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Test"
    }
}

/// Defines additional types related to [Test].
pub mod test {
    #[allow(unused_imports)]
    use super::*;

    /// A blueprint is an explicit definition of methods and requests that are needed
    /// to be made to test this specific test case. Ideally this would be represented
    /// by something more robust like CEL, but as of writing this, I am unsure if CEL
    /// is ready.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Blueprint {
        /// The name of this blueprint.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// A description of this blueprint.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub description: std::string::String,

        /// The initial request to trigger this test.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub request: std::option::Option<crate::model::test::blueprint::Invocation>,

        /// An ordered list of method calls that can be called to trigger this test.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub additional_requests: std::vec::Vec<crate::model::test::blueprint::Invocation>,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Blueprint {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::test::Blueprint::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [description][crate::model::test::Blueprint::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [request][crate::model::test::Blueprint::request].
        pub fn set_request<
            T: std::convert::Into<std::option::Option<crate::model::test::blueprint::Invocation>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.request = v.into();
            self
        }

        /// Sets the value of [additional_requests][crate::model::test::Blueprint::additional_requests].
        pub fn set_additional_requests<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::test::blueprint::Invocation>,
        {
            use std::iter::Iterator;
            self.additional_requests = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Blueprint {
        fn typename() -> &'static str {
            "type.googleapis.com/google.showcase.v1beta1.Test.Blueprint"
        }
    }

    /// Defines additional types related to [Blueprint].
    pub mod blueprint {
        #[allow(unused_imports)]
        use super::*;

        /// A message representing a method invocation.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Invocation {
            /// The fully qualified name of the showcase method to be invoked.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub method: std::string::String,

            /// The request to be made if a specific request is necessary.
            #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
            #[serde_as(as = "serde_with::base64::Base64")]
            pub serialized_request: ::bytes::Bytes,

            #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Invocation {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [method][crate::model::test::blueprint::Invocation::method].
            pub fn set_method<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.method = v.into();
                self
            }

            /// Sets the value of [serialized_request][crate::model::test::blueprint::Invocation::serialized_request].
            pub fn set_serialized_request<T: std::convert::Into<::bytes::Bytes>>(
                mut self,
                v: T,
            ) -> Self {
                self.serialized_request = v.into();
                self
            }
        }

        impl wkt::message::Message for Invocation {
            fn typename() -> &'static str {
                "type.googleapis.com/google.showcase.v1beta1.Test.Blueprint.Invocation"
            }
        }
    }

    /// Whether or not a test is required, recommended, or optional.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ExpectationLevel(i32);

    impl ExpectationLevel {
        pub const EXPECTATION_LEVEL_UNSPECIFIED: ExpectationLevel = ExpectationLevel::new(0);

        /// This test is strictly required.
        pub const REQUIRED: ExpectationLevel = ExpectationLevel::new(1);

        /// This test is recommended.
        ///
        /// If a generator explicitly ignores a recommended test (see `DeleteTest`),
        /// then the report may still pass, but with a warning.
        ///
        /// If a generator skips a recommended test and does not explicitly
        /// express that intention, the report will fail.
        pub const RECOMMENDED: ExpectationLevel = ExpectationLevel::new(2);

        /// This test is optional.
        ///
        /// If a generator explicitly ignores an optional test (see `DeleteTest`),
        /// then the report may still pass, and no warning will be issued.
        ///
        /// If a generator skips an optional test and does not explicitly
        /// express that intention, the report may still pass, but with a
        /// warning.
        pub const OPTIONAL: ExpectationLevel = ExpectationLevel::new(3);

        /// Creates a new ExpectationLevel instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("EXPECTATION_LEVEL_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("REQUIRED"),
                2 => std::borrow::Cow::Borrowed("RECOMMENDED"),
                3 => std::borrow::Cow::Borrowed("OPTIONAL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "EXPECTATION_LEVEL_UNSPECIFIED" => {
                    std::option::Option::Some(Self::EXPECTATION_LEVEL_UNSPECIFIED)
                }
                "REQUIRED" => std::option::Option::Some(Self::REQUIRED),
                "RECOMMENDED" => std::option::Option::Some(Self::RECOMMENDED),
                "OPTIONAL" => std::option::Option::Some(Self::OPTIONAL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ExpectationLevel {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ExpectationLevel {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// An issue found in the test.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Issue {
    /// The type of the issue.
    #[serde(rename = "type")]
    pub r#type: crate::model::issue::Type,

    /// The severity of the issue.
    pub severity: crate::model::issue::Severity,

    /// A description of the issue.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Issue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::Issue::type].
    pub fn set_type<T: std::convert::Into<crate::model::issue::Type>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [severity][crate::model::Issue::severity].
    pub fn set_severity<T: std::convert::Into<crate::model::issue::Severity>>(
        mut self,
        v: T,
    ) -> Self {
        self.severity = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Issue::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }
}

impl wkt::message::Message for Issue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.Issue"
    }
}

/// Defines additional types related to [Issue].
pub mod issue {
    #[allow(unused_imports)]
    use super::*;

    /// The different potential types of issues.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// The test was never instrumented.
        pub const SKIPPED: Type = Type::new(1);

        /// The test was started but never confirmed.
        pub const PENDING: Type = Type::new(2);

        /// The test was instrumented, but Showcase got an unexpected
        /// value when the generator tried to confirm success.
        pub const INCORRECT_CONFIRMATION: Type = Type::new(3);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("SKIPPED"),
                2 => std::borrow::Cow::Borrowed("PENDING"),
                3 => std::borrow::Cow::Borrowed("INCORRECT_CONFIRMATION"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "SKIPPED" => std::option::Option::Some(Self::SKIPPED),
                "PENDING" => std::option::Option::Some(Self::PENDING),
                "INCORRECT_CONFIRMATION" => std::option::Option::Some(Self::INCORRECT_CONFIRMATION),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Severity levels.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Severity(i32);

    impl Severity {
        pub const SEVERITY_UNSPECIFIED: Severity = Severity::new(0);

        /// Errors.
        pub const ERROR: Severity = Severity::new(1);

        /// Warnings.
        pub const WARNING: Severity = Severity::new(2);

        /// Creates a new Severity instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("SEVERITY_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ERROR"),
                2 => std::borrow::Cow::Borrowed("WARNING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "SEVERITY_UNSPECIFIED" => std::option::Option::Some(Self::SEVERITY_UNSPECIFIED),
                "ERROR" => std::option::Option::Some(Self::ERROR),
                "WARNING" => std::option::Option::Some(Self::WARNING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Severity {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Severity {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The request for the ListTests method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTestsRequest {
    /// The session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of tests to return per page.
    pub page_size: i32,

    /// The page token, for retrieving subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTestsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTestsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTestsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTestsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListTestsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListTestsRequest"
    }
}

/// The response for the ListTests method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTestsResponse {
    /// The tests being returned.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tests: std::vec::Vec<crate::model::Test>,

    /// The next page token, if any.
    /// An empty value here means the last page has been reached.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTestsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListTestsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [tests][crate::model::ListTestsResponse::tests].
    pub fn set_tests<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Test>,
    {
        use std::iter::Iterator;
        self.tests = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTestsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.ListTestsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTestsResponse {
    type PageItem = crate::model::Test;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.tests
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// A TestRun is the result of running a Test.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TestRun {
    /// The name of the test.
    /// The tests/* portion of the names are hard-coded, and do not change
    /// from session to session.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub test: std::string::String,

    /// An issue found with the test run. If empty, this test run was successful.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub issue: std::option::Option<crate::model::Issue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TestRun {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [test][crate::model::TestRun::test].
    pub fn set_test<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.test = v.into();
        self
    }

    /// Sets the value of [issue][crate::model::TestRun::issue].
    pub fn set_issue<T: std::convert::Into<std::option::Option<crate::model::Issue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.issue = v.into();
        self
    }
}

impl wkt::message::Message for TestRun {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.TestRun"
    }
}

/// Request message for deleting a test.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTestRequest {
    /// The test to be deleted.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTestRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.DeleteTestRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyTestRequest {
    /// The test to have an answer registered to it.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The answer from the test.
    #[serde(skip_serializing_if = "::bytes::Bytes::is_empty")]
    #[serde_as(as = "serde_with::base64::Base64")]
    pub answer: ::bytes::Bytes,

    /// The answers from the test if multiple are to be checked
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    #[serde_as(as = "std::vec::Vec<serde_with::base64::Base64>")]
    pub answers: std::vec::Vec<::bytes::Bytes>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyTestRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VerifyTestRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [answer][crate::model::VerifyTestRequest::answer].
    pub fn set_answer<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.answer = v.into();
        self
    }

    /// Sets the value of [answers][crate::model::VerifyTestRequest::answers].
    pub fn set_answers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<::bytes::Bytes>,
    {
        use std::iter::Iterator;
        self.answers = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VerifyTestRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.VerifyTestRequest"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VerifyTestResponse {
    /// An issue if check answer was unsuccessful. This will be empty if the check answer succeeded.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub issue: std::option::Option<crate::model::Issue>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VerifyTestResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [issue][crate::model::VerifyTestResponse::issue].
    pub fn set_issue<T: std::convert::Into<std::option::Option<crate::model::Issue>>>(
        mut self,
        v: T,
    ) -> Self {
        self.issue = v.into();
        self
    }
}

impl wkt::message::Message for VerifyTestResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.showcase.v1beta1.VerifyTestResponse"
    }
}

#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct Continent(i32);

impl Continent {
    pub const CONTINENT_UNSPECIFIED: Continent = Continent::new(0);

    pub const AFRICA: Continent = Continent::new(1);

    pub const AMERICA: Continent = Continent::new(2);

    pub const ANTARTICA: Continent = Continent::new(3);

    pub const AUSTRALIA: Continent = Continent::new(4);

    pub const EUROPE: Continent = Continent::new(5);

    /// Creates a new Continent instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("CONTINENT_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("AFRICA"),
            2 => std::borrow::Cow::Borrowed("AMERICA"),
            3 => std::borrow::Cow::Borrowed("ANTARTICA"),
            4 => std::borrow::Cow::Borrowed("AUSTRALIA"),
            5 => std::borrow::Cow::Borrowed("EUROPE"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "CONTINENT_UNSPECIFIED" => std::option::Option::Some(Self::CONTINENT_UNSPECIFIED),
            "AFRICA" => std::option::Option::Some(Self::AFRICA),
            "AMERICA" => std::option::Option::Some(Self::AMERICA),
            "ANTARTICA" => std::option::Option::Some(Self::ANTARTICA),
            "AUSTRALIA" => std::option::Option::Some(Self::AUSTRALIA),
            "EUROPE" => std::option::Option::Some(Self::EUROPE),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for Continent {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for Continent {
    fn default() -> Self {
        Self::new(0)
    }
}

/// A severity enum used to test enum capabilities in GAPIC surfaces.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct Severity(i32);

impl Severity {
    pub const UNNECESSARY: Severity = Severity::new(0);

    pub const NECESSARY: Severity = Severity::new(1);

    pub const URGENT: Severity = Severity::new(2);

    pub const CRITICAL: Severity = Severity::new(3);

    /// Creates a new Severity instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("UNNECESSARY"),
            1 => std::borrow::Cow::Borrowed("NECESSARY"),
            2 => std::borrow::Cow::Borrowed("URGENT"),
            3 => std::borrow::Cow::Borrowed("CRITICAL"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "UNNECESSARY" => std::option::Option::Some(Self::UNNECESSARY),
            "NECESSARY" => std::option::Option::Some(Self::NECESSARY),
            "URGENT" => std::option::Option::Some(Self::URGENT),
            "CRITICAL" => std::option::Option::Some(Self::CRITICAL),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for Severity {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for Severity {
    fn default() -> Self {
        Self::new(0)
    }
}
