// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [Compliance](super::stub::Compliance) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Compliance {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Compliance {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Compliance")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Compliance {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Compliance for Compliance {
    async fn repeat_data_body(
        &self,
        req: crate::model::RepeatRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RepeatResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, "/v1beta1/repeat:body".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn repeat_data_body_info(
        &self,
        req: crate::model::RepeatRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RepeatResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                "/v1beta1/repeat:bodyinfo".to_string(),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("name", &req.name)]);
        let builder = builder.query(&[("serverVerify", &req.server_verify)]);
        let builder = req.intended_binding_uri.iter().fold(builder, |builder, p| {
            builder.query(&[("intendedBindingUri", p)])
        });
        let builder = builder.query(&[("fInt32", &req.f_int32)]);
        let builder = builder.query(&[("fInt64", &req.f_int64)]);
        let builder = builder.query(&[("fDouble", &req.f_double)]);
        let builder = req
            .p_int32
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pInt32", p)]));
        let builder = req
            .p_int64
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pInt64", p)]));
        let builder = req
            .p_double
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pDouble", p)]));
        self.inner.execute(builder, Some(req.info), options).await
    }

    async fn repeat_data_query(
        &self,
        req: crate::model::RepeatRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RepeatResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v1beta1/repeat:query".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("name", &req.name)]);
        let builder = req
            .info
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "info")
            });
        let builder = builder.query(&[("serverVerify", &req.server_verify)]);
        let builder = req.intended_binding_uri.iter().fold(builder, |builder, p| {
            builder.query(&[("intendedBindingUri", p)])
        });
        let builder = builder.query(&[("fInt32", &req.f_int32)]);
        let builder = builder.query(&[("fInt64", &req.f_int64)]);
        let builder = builder.query(&[("fDouble", &req.f_double)]);
        let builder = req
            .p_int32
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pInt32", p)]));
        let builder = req
            .p_int64
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pInt64", p)]));
        let builder = req
            .p_double
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pDouble", p)]));
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn repeat_data_simple_path(
        &self,
        req: crate::model::RepeatRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RepeatResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!(
                    "/v1beta1/repeat/{}/{}/{}/{}/{}:simplepath",
                    req.info
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("info"))?
                        .f_string,
                    req.info
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("info"))?
                        .f_int32,
                    req.info
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("info"))?
                        .f_double,
                    req.info
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("info"))?
                        .f_bool,
                    req.info
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("info"))?
                        .f_kingdom
                        .value()
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("name", &req.name)]);
        let builder = req
            .info
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "info")
            });
        let builder = builder.query(&[("serverVerify", &req.server_verify)]);
        let builder = req.intended_binding_uri.iter().fold(builder, |builder, p| {
            builder.query(&[("intendedBindingUri", p)])
        });
        let builder = builder.query(&[("fInt32", &req.f_int32)]);
        let builder = builder.query(&[("fInt64", &req.f_int64)]);
        let builder = builder.query(&[("fDouble", &req.f_double)]);
        let builder = req
            .p_int32
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pInt32", p)]));
        let builder = req
            .p_int64
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pInt64", p)]));
        let builder = req
            .p_double
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pDouble", p)]));
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn repeat_data_path_resource(
        &self,
        req: crate::model::RepeatRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RepeatResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!(
                    "/v1beta1/repeat/{}/{}/bool/{}:pathresource",
                    req.info
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("info"))?
                        .f_string,
                    req.info
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("info"))?
                        .f_child
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("f_child"))?
                        .f_string,
                    req.info
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("info"))?
                        .f_bool
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("name", &req.name)]);
        let builder = req
            .info
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "info")
            });
        let builder = builder.query(&[("serverVerify", &req.server_verify)]);
        let builder = req.intended_binding_uri.iter().fold(builder, |builder, p| {
            builder.query(&[("intendedBindingUri", p)])
        });
        let builder = builder.query(&[("fInt32", &req.f_int32)]);
        let builder = builder.query(&[("fInt64", &req.f_int64)]);
        let builder = builder.query(&[("fDouble", &req.f_double)]);
        let builder = req
            .p_int32
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pInt32", p)]));
        let builder = req
            .p_int64
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pInt64", p)]));
        let builder = req
            .p_double
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pDouble", p)]));
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn repeat_data_path_trailing_resource(
        &self,
        req: crate::model::RepeatRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RepeatResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!(
                    "/v1beta1/repeat/{}/{}:pathtrailingresource",
                    req.info
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("info"))?
                        .f_string,
                    req.info
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("info"))?
                        .f_child
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("f_child"))?
                        .f_string
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("name", &req.name)]);
        let builder = req
            .info
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "info")
            });
        let builder = builder.query(&[("serverVerify", &req.server_verify)]);
        let builder = req.intended_binding_uri.iter().fold(builder, |builder, p| {
            builder.query(&[("intendedBindingUri", p)])
        });
        let builder = builder.query(&[("fInt32", &req.f_int32)]);
        let builder = builder.query(&[("fInt64", &req.f_int64)]);
        let builder = builder.query(&[("fDouble", &req.f_double)]);
        let builder = req
            .p_int32
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pInt32", p)]));
        let builder = req
            .p_int64
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pInt64", p)]));
        let builder = req
            .p_double
            .iter()
            .fold(builder, |builder, p| builder.query(&[("pDouble", p)]));
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn repeat_data_body_put(
        &self,
        req: crate::model::RepeatRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RepeatResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::PUT, "/v1beta1/repeat:bodyput".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn repeat_data_body_patch(
        &self,
        req: crate::model::RepeatRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RepeatResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                "/v1beta1/repeat:bodypatch".to_string(),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_enum(
        &self,
        req: crate::model::EnumRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EnumResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v1beta1/compliance/enum".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("unknownEnum", &req.unknown_enum)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn verify_enum(
        &self,
        req: crate::model::EnumResponse,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EnumResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                "/v1beta1/compliance/enum".to_string(),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .request
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "request")
            });
        let builder = builder.query(&[("continent", &req.continent.value())]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}/locations", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:setIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}:getIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:testIamPermissions", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v1beta1/operations".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("name", &req.name)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:cancel", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [Echo](super::stub::Echo) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Echo {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Echo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Echo").field("inner", &self.inner).finish()
    }
}

impl Echo {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Echo for Echo {
    async fn echo(
        &self,
        req: crate::model::EchoRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EchoResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, "/v1beta1/echo:echo".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn echo_error_details(
        &self,
        req: crate::model::EchoErrorDetailsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::EchoErrorDetailsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                "/v1beta1/echo:error-details".to_string(),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn fail_echo_with_details(
        &self,
        req: crate::model::FailEchoWithDetailsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FailEchoWithDetailsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                "/v1beta1/echo:failWithDetails".to_string(),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn paged_expand(
        &self,
        req: crate::model::PagedExpandRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PagedExpandResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                "/v1beta1/echo:pagedExpand".to_string(),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn paged_expand_legacy(
        &self,
        req: crate::model::PagedExpandLegacyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PagedExpandResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                "/v1beta1/echo:pagedExpandLegacy".to_string(),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn paged_expand_legacy_mapped(
        &self,
        req: crate::model::PagedExpandRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PagedExpandLegacyMappedResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                "/v1beta1/echo:pagedExpandLegacyMapped".to_string(),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn wait(
        &self,
        req: crate::model::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, "/v1beta1/echo:wait".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn block(
        &self,
        req: crate::model::BlockRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BlockResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, "/v1beta1/echo:block".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}/locations", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:setIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}:getIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:testIamPermissions", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v1beta1/operations".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("name", &req.name)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:cancel", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Identity](super::stub::Identity) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Identity {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Identity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Identity")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Identity {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Identity for Identity {
    async fn create_user(
        &self,
        req: crate::model::CreateUserRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::User>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, "/v1beta1/users".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_user(
        &self,
        req: crate::model::GetUserRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::User>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_user(
        &self,
        req: crate::model::UpdateUserRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::User>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v1beta1/{}",
                    req.user
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("user"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        self.inner.execute(builder, Some(req.user), options).await
    }

    async fn delete_user(
        &self,
        req: crate::model::DeleteUserRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_users(
        &self,
        req: crate::model::ListUsersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListUsersResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v1beta1/users".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}/locations", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:setIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}:getIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:testIamPermissions", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v1beta1/operations".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("name", &req.name)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:cancel", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [Messaging](super::stub::Messaging) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Messaging {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Messaging {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Messaging")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Messaging {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Messaging for Messaging {
    async fn create_room(
        &self,
        req: crate::model::CreateRoomRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Room>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, "/v1beta1/rooms".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_room(
        &self,
        req: crate::model::GetRoomRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Room>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_room(
        &self,
        req: crate::model::UpdateRoomRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Room>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v1beta1/{}",
                    req.room
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("room"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        self.inner.execute(builder, Some(req.room), options).await
    }

    async fn delete_room(
        &self,
        req: crate::model::DeleteRoomRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_rooms(
        &self,
        req: crate::model::ListRoomsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListRoomsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v1beta1/rooms".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn create_blurb(
        &self,
        req: crate::model::CreateBlurbRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Blurb>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}/blurbs", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_blurb(
        &self,
        req: crate::model::GetBlurbRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Blurb>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn update_blurb(
        &self,
        req: crate::model::UpdateBlurbRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Blurb>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::PATCH,
                format!(
                    "/v1beta1/{}",
                    req.blurb
                        .as_ref()
                        .ok_or_else(|| gaxi::path_parameter::missing("blurb"))?
                        .name
                ),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .update_mask
            .as_ref()
            .iter()
            .flat_map(|p| p.paths.iter())
            .fold(builder, |builder, v| builder.query(&[("updateMask", v)]));
        self.inner.execute(builder, Some(req.blurb), options).await
    }

    async fn delete_blurb(
        &self,
        req: crate::model::DeleteBlurbRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn list_blurbs(
        &self,
        req: crate::model::ListBlurbsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListBlurbsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}/blurbs", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn search_blurbs(
        &self,
        req: crate::model::SearchBlurbsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}/blurbs:search", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}/locations", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:setIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}:getIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:testIamPermissions", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v1beta1/operations".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("name", &req.name)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:cancel", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [SequenceService](super::stub::SequenceService) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct SequenceService {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for SequenceService {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SequenceService")
            .field("inner", &self.inner)
            .finish()
    }
}

impl SequenceService {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::SequenceService for SequenceService {
    async fn create_sequence(
        &self,
        req: crate::model::CreateSequenceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Sequence>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, "/v1beta1/sequences".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.sequence), options)
            .await
    }

    async fn create_streaming_sequence(
        &self,
        req: crate::model::CreateStreamingSequenceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StreamingSequence>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                "/v1beta1/streamingSequences".to_string(),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.streaming_sequence), options)
            .await
    }

    async fn get_sequence_report(
        &self,
        req: crate::model::GetSequenceReportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SequenceReport>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_streaming_sequence_report(
        &self,
        req: crate::model::GetStreamingSequenceReportRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StreamingSequenceReport>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn attempt_sequence(
        &self,
        req: crate::model::AttemptSequenceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await.map(
            |r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            },
        )
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}/locations", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:setIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}:getIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:testIamPermissions", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v1beta1/operations".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("name", &req.name)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:cancel", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}

/// Implements [Testing](super::stub::Testing) using a [gaxi::http::ReqwestClient].
#[derive(Clone)]
pub struct Testing {
    inner: gaxi::http::ReqwestClient,
}

impl std::fmt::Debug for Testing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Testing")
            .field("inner", &self.inner)
            .finish()
    }
}

impl Testing {
    pub async fn new(config: gaxi::options::ClientConfig) -> Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

impl super::stub::Testing for Testing {
    async fn create_session(
        &self,
        req: crate::model::CreateSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(reqwest::Method::POST, "/v1beta1/sessions".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, Some(req.session), options)
            .await
    }

    async fn get_session(
        &self,
        req: crate::model::GetSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Session>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_sessions(
        &self,
        req: crate::model::ListSessionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListSessionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v1beta1/sessions".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_session(
        &self,
        req: crate::model::DeleteSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn report_session(
        &self,
        req: crate::model::ReportSessionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReportSessionResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:report", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_tests(
        &self,
        req: crate::model::ListTestsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ListTestsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}/tests", req.parent),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_test(
        &self,
        req: crate::model::DeleteTestRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn verify_test(
        &self,
        req: crate::model::VerifyTestRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VerifyTestResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:check", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("answer", &req.answer)]);
        let builder = req
            .answers
            .iter()
            .fold(builder, |builder, p| builder.query(&[("answers", p)]));
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn list_locations(
        &self,
        req: location::model::ListLocationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::ListLocationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}/locations", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_location(
        &self,
        req: location::model::GetLocationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<location::model::Location>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn set_iam_policy(
        &self,
        req: iam_v1::model::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:setIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn get_iam_policy(
        &self,
        req: iam_v1::model::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::Policy>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(
                reqwest::Method::GET,
                format!("/v1beta1/{}:getIamPolicy", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = req
            .options
            .as_ref()
            .map(|p| serde_json::to_value(p).map_err(Error::serde))
            .transpose()?
            .into_iter()
            .fold(builder, |builder, v| {
                use gaxi::query_parameter::QueryParameter;
                v.add(builder, "options")
            });
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn test_iam_permissions(
        &self,
        req: iam_v1::model::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<iam_v1::model::TestIamPermissionsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:testIamPermissions", req.resource),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner.execute(builder, Some(req), options).await
    }

    async fn list_operations(
        &self,
        req: longrunning::model::ListOperationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::ListOperationsResponse>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, "/v1beta1/operations".to_string())
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        let builder = builder.query(&[("name", &req.name)]);
        let builder = builder.query(&[("filter", &req.filter)]);
        let builder = builder.query(&[("pageSize", &req.page_size)]);
        let builder = builder.query(&[("pageToken", &req.page_token)]);
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn get_operation(
        &self,
        req: longrunning::model::GetOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<longrunning::model::Operation>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::GET, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
    }

    async fn delete_operation(
        &self,
        req: longrunning::model::DeleteOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, true);
        let builder = self
            .inner
            .builder(reqwest::Method::DELETE, format!("/v1beta1/{}", req.name))
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }

    async fn cancel_operation(
        &self,
        req: longrunning::model::CancelOperationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<()>> {
        let options = gax::options::internal::set_default_idempotency(options, false);
        let builder = self
            .inner
            .builder(
                reqwest::Method::POST,
                format!("/v1beta1/{}:cancel", req.name),
            )
            .query(&[("$alt", "json;enum-encoding=int")])
            .header(
                "x-goog-api-client",
                reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
            );
        self.inner
            .execute(builder, None::<gaxi::http::NoBody>, options)
            .await
            .map(|r: gax::response::Response<wkt::Empty>| {
                let (parts, _) = r.into_parts();
                gax::response::Response::from_parts(parts, ())
            })
    }
}
