// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// The response message for Locations.ListLocations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLocationsResponse {
    /// A list of locations that matches the specified filter in the request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub locations: std::vec::Vec<crate::model::Location>,

    /// The standard List next-page token.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_page_token: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLocationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [locations][crate::model::ListLocationsResponse::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Location>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListLocationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListLocationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.ListLocationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListLocationsResponse {
    type PageItem = crate::model::Location;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.locations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// A resource that represents a Google Cloud location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Location {
    /// Resource name for the location, which may vary between implementations.
    /// For example: `"projects/example-project/locations/us-east1"`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub name: std::option::Option<std::string::String>,

    /// The canonical id for this location. For example: `"us-east1"`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location_id: std::option::Option<std::string::String>,

    /// The friendly name for this location, typically a nearby city name.
    /// For example, "Tokyo".
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub display_name: std::option::Option<std::string::String>,

    /// Cross-service attributes for the location. For example
    ///
    /// ```norust
    /// {"cloud.googleapis.com/region": "us-east1"}
    /// ```
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Service-specific metadata. For example the available capacity at the given
    /// location.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub metadata: std::option::Option<wkt::Any>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Location {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Location::name].
    pub fn set_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [location_id][crate::model::Location::location_id].
    pub fn set_location_id<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.location_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Location::display_name].
    pub fn set_display_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Location::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::Location::metadata].
    pub fn set_metadata<T: std::convert::Into<std::option::Option<wkt::Any>>>(
        mut self,
        v: T,
    ) -> Self {
        self.metadata = v.into();
        self
    }
}

impl wkt::message::Message for Location {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Location"
    }
}

/// Response message for SecretManagerService.ListSecrets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSecretsResponse {
    /// The list of Secrets sorted in reverse by create_time (newest
    /// first).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub secrets: std::vec::Vec<crate::model::Secret>,

    /// A token to retrieve the next page of results. Pass this value in
    /// ListSecretsRequest.page_token to retrieve the next page.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_page_token: std::option::Option<std::string::String>,

    /// The total number of Secrets but 0 when the
    /// ListSecretsRequest.filter field is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub total_size: std::option::Option<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSecretsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secrets][crate::model::ListSecretsResponse::secrets].
    pub fn set_secrets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Secret>,
    {
        use std::iter::Iterator;
        self.secrets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSecretsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListSecretsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListSecretsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.ListSecretsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSecretsResponse {
    type PageItem = crate::model::Secret;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.secrets
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// A Secret is a logical secret whose value and versions can
/// be accessed.
///
/// A Secret is made up of zero or more SecretVersions that
/// represent the secret data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Secret {
    /// Output only. The resource name of the Secret in the format `projects/_*_/secrets/*`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub name: std::option::Option<std::string::String>,

    /// Optional. Immutable. The replication policy of the secret data attached to the Secret.
    ///
    /// The replication policy cannot be changed after the Secret has been created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replication: std::option::Option<crate::model::Replication>,

    /// Output only. The time at which the Secret was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The labels assigned to this Secret.
    ///
    /// Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
    /// of maximum 128 bytes, and must conform to the following PCRE regular
    /// expression: `\p{Ll}\p{Lo}{0,62}`
    ///
    /// Label values must be between 0 and 63 characters long, have a UTF-8
    /// encoding of maximum 128 bytes, and must conform to the following PCRE
    /// regular expression: `[\p{Ll}\p{Lo}\p{N}_-]{0,63}`
    ///
    /// No more than 64 labels can be assigned to a given resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. A list of up to 10 Pub/Sub topics to which messages are published when
    /// control plane operations are called on the secret or its versions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub topics: std::vec::Vec<crate::model::Topic>,

    /// Optional. Timestamp in UTC when the Secret is scheduled to expire. This is
    /// always provided on output, regardless of what was sent on input.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Input only. The TTL for the Secret.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ttl: std::option::Option<wkt::Duration>,

    /// Optional. Etag of the currently stored Secret.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub etag: std::option::Option<std::string::String>,

    /// Optional. Rotation policy attached to the Secret. May be excluded if there is no
    /// rotation policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rotation: std::option::Option<crate::model::Rotation>,

    /// Optional. Mapping from version alias to version name.
    ///
    /// A version alias is a string with a maximum length of 63 characters and can
    /// contain uppercase and lowercase letters, numerals, and the hyphen (`-`)
    /// and underscore ('_') characters. An alias string must start with a
    /// letter and cannot be the string 'latest' or 'NEW'.
    /// No more than 50 aliases can be assigned to a given secret.
    ///
    /// Version-Alias pairs will be viewable via GetSecret and modifiable via
    /// UpdateSecret. Access by alias is only be supported on
    /// GetSecretVersion and AccessSecretVersion.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    #[serde_as(as = "std::collections::HashMap<_, serde_with::DisplayFromStr>")]
    pub version_aliases: std::collections::HashMap<std::string::String, i64>,

    /// Optional. Custom metadata about the secret.
    ///
    /// Annotations are distinct from various forms of labels.
    /// Annotations exist to allow client tools to store their own state
    /// information without requiring a database.
    ///
    /// Annotation keys must be between 1 and 63 characters long, have a UTF-8
    /// encoding of maximum 128 bytes, begin and end with an alphanumeric character
    /// ([a-z0-9A-Z]), and may have dashes (-), underscores (_), dots (.), and
    /// alphanumerics in between these symbols.
    ///
    /// The total size of annotation keys and values must be less than 16KiB.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Secret Version TTL after destruction request
    ///
    /// This is a part of the Delayed secret version destroy feature.
    /// For secret with TTL>0, version destruction doesn't happen immediately
    /// on calling destroy instead the version goes to a disabled state and
    /// destruction happens after the TTL expires.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version_destroy_ttl: std::option::Option<wkt::Duration>,

    /// Optional. The customer-managed encryption configuration of the Regionalised Secrets.
    /// If no configuration is provided, Google-managed default encryption is used.
    ///
    /// Updates to the Secret encryption configuration only apply to
    /// SecretVersions added afterwards. They do not apply
    /// retroactively to existing SecretVersions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer_managed_encryption: std::option::Option<crate::model::CustomerManagedEncryption>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Secret {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Secret::name].
    pub fn set_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [replication][crate::model::Secret::replication].
    pub fn set_replication<
        T: std::convert::Into<std::option::Option<crate::model::Replication>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Secret::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Secret::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [topics][crate::model::Secret::topics].
    pub fn set_topics<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Topic>,
    {
        use std::iter::Iterator;
        self.topics = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [expire_time][crate::model::Secret::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [ttl][crate::model::Secret::ttl].
    pub fn set_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ttl = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Secret::etag].
    pub fn set_etag<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [rotation][crate::model::Secret::rotation].
    pub fn set_rotation<T: std::convert::Into<std::option::Option<crate::model::Rotation>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rotation = v.into();
        self
    }

    /// Sets the value of [version_aliases][crate::model::Secret::version_aliases].
    pub fn set_version_aliases<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.version_aliases = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::Secret::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [version_destroy_ttl][crate::model::Secret::version_destroy_ttl].
    pub fn set_version_destroy_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.version_destroy_ttl = v.into();
        self
    }

    /// Sets the value of [customer_managed_encryption][crate::model::Secret::customer_managed_encryption].
    pub fn set_customer_managed_encryption<
        T: std::convert::Into<std::option::Option<crate::model::CustomerManagedEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.customer_managed_encryption = v.into();
        self
    }
}

impl wkt::message::Message for Secret {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Secret"
    }
}

/// A policy that defines the replication and encryption configuration of data.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Replication {
    /// The Secret will automatically be replicated without any restrictions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automatic: std::option::Option<crate::model::Automatic>,

    /// The Secret will only be replicated into the locations specified.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_managed: std::option::Option<crate::model::UserManaged>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Replication {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automatic][crate::model::Replication::automatic].
    pub fn set_automatic<T: std::convert::Into<std::option::Option<crate::model::Automatic>>>(
        mut self,
        v: T,
    ) -> Self {
        self.automatic = v.into();
        self
    }

    /// Sets the value of [user_managed][crate::model::Replication::user_managed].
    pub fn set_user_managed<
        T: std::convert::Into<std::option::Option<crate::model::UserManaged>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_managed = v.into();
        self
    }
}

impl wkt::message::Message for Replication {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Replication"
    }
}

/// A replication policy that replicates the Secret payload without any
/// restrictions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Automatic {
    /// Optional. The customer-managed encryption configuration of the Secret. If no
    /// configuration is provided, Google-managed default encryption is used.
    ///
    /// Updates to the Secret encryption configuration only apply to
    /// SecretVersions added afterwards. They do not apply
    /// retroactively to existing SecretVersions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer_managed_encryption: std::option::Option<crate::model::CustomerManagedEncryption>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Automatic {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [customer_managed_encryption][crate::model::Automatic::customer_managed_encryption].
    pub fn set_customer_managed_encryption<
        T: std::convert::Into<std::option::Option<crate::model::CustomerManagedEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.customer_managed_encryption = v.into();
        self
    }
}

impl wkt::message::Message for Automatic {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Automatic"
    }
}

/// Configuration for encrypting secret payloads using customer-managed
/// encryption keys (CMEK).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerManagedEncryption {
    /// Required. The resource name of the Cloud KMS CryptoKey used to encrypt secret
    /// payloads.
    ///
    /// For secrets using the UserManaged replication
    /// policy type, Cloud KMS CryptoKeys must reside in the same location as the
    /// replica location.
    ///
    /// For secrets using the Automatic replication policy
    /// type, Cloud KMS CryptoKeys must reside in `global`.
    ///
    /// The expected format is `projects/_*_/locations/_*_/keyRings/_*_/cryptoKeys/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerManagedEncryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::CustomerManagedEncryption::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }
}

impl wkt::message::Message for CustomerManagedEncryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.CustomerManagedEncryption"
    }
}

/// A replication policy that replicates the Secret payload into the
/// locations specified in Secret.replication.user_managed.replicas
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserManaged {
    /// Required. The list of Replicas for this Secret.
    ///
    /// Cannot be empty.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replicas: std::vec::Vec<crate::model::Replica>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserManaged {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replicas][crate::model::UserManaged::replicas].
    pub fn set_replicas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Replica>,
    {
        use std::iter::Iterator;
        self.replicas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UserManaged {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.UserManaged"
    }
}

/// Represents a Replica for this Secret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Replica {
    /// The canonical IDs of the location to replicate data.
    /// For example: `"us-east1"`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<std::string::String>,

    /// Optional. The customer-managed encryption configuration of the User-Managed
    /// Replica. If no configuration is
    /// provided, Google-managed default encryption is used.
    ///
    /// Updates to the Secret encryption configuration only apply to
    /// SecretVersions added afterwards. They do not apply
    /// retroactively to existing SecretVersions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer_managed_encryption: std::option::Option<crate::model::CustomerManagedEncryption>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Replica {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::Replica::location].
    pub fn set_location<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [customer_managed_encryption][crate::model::Replica::customer_managed_encryption].
    pub fn set_customer_managed_encryption<
        T: std::convert::Into<std::option::Option<crate::model::CustomerManagedEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.customer_managed_encryption = v.into();
        self
    }
}

impl wkt::message::Message for Replica {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Replica"
    }
}

/// A Pub/Sub topic which Secret Manager will publish to when control plane
/// events occur on this secret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Topic {
    /// Required. The resource name of the Pub/Sub topic that will be published to, in the
    /// following format: `projects/_*_/topics/*`. For publication to succeed, the
    /// Secret Manager service agent must have the `pubsub.topic.publish`
    /// permission on the topic. The Pub/Sub Publisher role
    /// (`roles/pubsub.publisher`) includes this permission.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Topic {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Topic::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for Topic {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Topic"
    }
}

/// The rotation time and period for a Secret. At next_rotation_time, Secret
/// Manager will send a Pub/Sub notification to the topics configured on the
/// Secret. Secret.topics must be set to configure rotation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Rotation {
    /// Optional. Timestamp in UTC at which the Secret is scheduled to rotate. Cannot be
    /// set to less than 300s (5 min) in the future and at most 3153600000s (100
    /// years).
    ///
    /// next_rotation_time MUST  be set if rotation_period is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_rotation_time: std::option::Option<wkt::Timestamp>,

    /// Input only. The Duration between rotation notifications. Must be in seconds
    /// and at least 3600s (1h) and at most 3153600000s (100 years).
    ///
    /// If rotation_period is set, next_rotation_time must be set.
    /// next_rotation_time will be advanced by this period when the service
    /// automatically sends rotation notifications.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rotation_period: std::option::Option<wkt::Duration>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Rotation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_rotation_time][crate::model::Rotation::next_rotation_time].
    pub fn set_next_rotation_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_rotation_time = v.into();
        self
    }

    /// Sets the value of [rotation_period][crate::model::Rotation::rotation_period].
    pub fn set_rotation_period<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.rotation_period = v.into();
        self
    }
}

impl wkt::message::Message for Rotation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Rotation"
    }
}

/// Request message for SecretManagerService.AddSecretVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddSecretVersionRequest {
    /// Required. The secret payload of the SecretVersion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<crate::model::SecretPayload>,

    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}:addVersion`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}:addVersion`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}:addVersion`.
    #[serde(skip)]
    pub location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddSecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [payload][crate::model::AddSecretVersionRequest::payload].
    pub fn set_payload<T: std::convert::Into<std::option::Option<crate::model::SecretPayload>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }

    /// Sets the value of [project][crate::model::AddSecretVersionRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::AddSecretVersionRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [location][crate::model::AddSecretVersionRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

/// A secret payload resource in the Secret Manager API. This contains the
/// sensitive secret payload that is associated with a SecretVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretPayload {
    /// The secret data. Must be no larger than 64KiB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::base64::Base64>")]
    pub data: std::option::Option<::bytes::Bytes>,

    /// Optional. If specified, SecretManagerService will verify the integrity of the
    /// received data on SecretManagerService.AddSecretVersion calls using
    /// the crc32c checksum and store it to include in future
    /// SecretManagerService.AccessSecretVersion responses. If a checksum is
    /// not provided in the SecretManagerService.AddSecretVersion request, the
    /// SecretManagerService will generate and store one for you.
    ///
    /// The CRC32C value is encoded as a Int64 for compatibility, and can be
    /// safely downconverted to uint32 in languages that support this type.
    /// <https://cloud.google.com/apis/design/design_patterns#integer_types>
    #[serde(rename = "dataCrc32c")]
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::DisplayFromStr>")]
    pub data_crc_32_c: std::option::Option<i64>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretPayload {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [data][crate::model::SecretPayload::data].
    pub fn set_data<T: std::convert::Into<std::option::Option<::bytes::Bytes>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data = v.into();
        self
    }

    /// Sets the value of [data_crc_32_c][crate::model::SecretPayload::data_crc_32_c].
    pub fn set_data_crc_32_c<T: std::convert::Into<std::option::Option<i64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.data_crc_32_c = v.into();
        self
    }
}

impl wkt::message::Message for SecretPayload {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.SecretPayload"
    }
}

/// A secret version resource in the Secret Manager API.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SecretVersion {
    /// Output only. The resource name of the SecretVersion in the
    /// format `projects/_*_/secrets/_*_/versions/*`.
    ///
    /// SecretVersion IDs in a Secret start at 1 and
    /// are incremented for each subsequent version of the secret.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub name: std::option::Option<std::string::String>,

    /// Output only. The time at which the SecretVersion was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time this SecretVersion was destroyed.
    /// Only present if state is
    /// DESTROYED.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub destroy_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the SecretVersion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state: std::option::Option<std::string::String>,

    /// The replication status of the SecretVersion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replication_status: std::option::Option<crate::model::ReplicationStatus>,

    /// Output only. Etag of the currently stored SecretVersion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub etag: std::option::Option<std::string::String>,

    /// Output only. True if payload checksum specified in SecretPayload object has been
    /// received by SecretManagerService on
    /// SecretManagerService.AddSecretVersion.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub client_specified_payload_checksum: std::option::Option<bool>,

    /// Optional. Output only. Scheduled destroy time for secret version.
    /// This is a part of the Delayed secret version destroy feature. For a
    /// Secret with a valid version destroy TTL, when a secert version is
    /// destroyed, version is moved to disabled state and it is scheduled for
    /// destruction Version is destroyed only after the scheduled_destroy_time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub scheduled_destroy_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The customer-managed encryption status of the SecretVersion. Only
    /// populated if customer-managed encryption is used and Secret is
    /// a Regionalised Secret.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer_managed_encryption:
        std::option::Option<crate::model::CustomerManagedEncryptionStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SecretVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::SecretVersion::name].
    pub fn set_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::SecretVersion::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [destroy_time][crate::model::SecretVersion::destroy_time].
    pub fn set_destroy_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.destroy_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::SecretVersion::state].
    pub fn set_state<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [replication_status][crate::model::SecretVersion::replication_status].
    pub fn set_replication_status<
        T: std::convert::Into<std::option::Option<crate::model::ReplicationStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.replication_status = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::SecretVersion::etag].
    pub fn set_etag<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [client_specified_payload_checksum][crate::model::SecretVersion::client_specified_payload_checksum].
    pub fn set_client_specified_payload_checksum<
        T: std::convert::Into<std::option::Option<bool>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.client_specified_payload_checksum = v.into();
        self
    }

    /// Sets the value of [scheduled_destroy_time][crate::model::SecretVersion::scheduled_destroy_time].
    pub fn set_scheduled_destroy_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.scheduled_destroy_time = v.into();
        self
    }

    /// Sets the value of [customer_managed_encryption][crate::model::SecretVersion::customer_managed_encryption].
    pub fn set_customer_managed_encryption<
        T: std::convert::Into<std::option::Option<crate::model::CustomerManagedEncryptionStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.customer_managed_encryption = v.into();
        self
    }
}

impl wkt::message::Message for SecretVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.SecretVersion"
    }
}

/// The replication status of a SecretVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicationStatus {
    /// Describes the replication status of a SecretVersion with
    /// automatic replication.
    ///
    /// Only populated if the parent Secret has an automatic replication
    /// policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automatic: std::option::Option<crate::model::AutomaticStatus>,

    /// Describes the replication status of a SecretVersion with
    /// user-managed replication.
    ///
    /// Only populated if the parent Secret has a user-managed replication
    /// policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub user_managed: std::option::Option<crate::model::UserManagedStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automatic][crate::model::ReplicationStatus::automatic].
    pub fn set_automatic<
        T: std::convert::Into<std::option::Option<crate::model::AutomaticStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automatic = v.into();
        self
    }

    /// Sets the value of [user_managed][crate::model::ReplicationStatus::user_managed].
    pub fn set_user_managed<
        T: std::convert::Into<std::option::Option<crate::model::UserManagedStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.user_managed = v.into();
        self
    }
}

impl wkt::message::Message for ReplicationStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.ReplicationStatus"
    }
}

/// The replication status of a SecretVersion using automatic replication.
///
/// Only populated if the parent Secret has an automatic replication
/// policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomaticStatus {
    /// Output only. The customer-managed encryption status of the SecretVersion. Only
    /// populated if customer-managed encryption is used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer_managed_encryption:
        std::option::Option<crate::model::CustomerManagedEncryptionStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomaticStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [customer_managed_encryption][crate::model::AutomaticStatus::customer_managed_encryption].
    pub fn set_customer_managed_encryption<
        T: std::convert::Into<std::option::Option<crate::model::CustomerManagedEncryptionStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.customer_managed_encryption = v.into();
        self
    }
}

impl wkt::message::Message for AutomaticStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.AutomaticStatus"
    }
}

/// Describes the status of customer-managed encryption.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CustomerManagedEncryptionStatus {
    /// Required. The resource name of the Cloud KMS CryptoKeyVersion used to encrypt the
    /// secret payload, in the following format:
    /// `projects/_*_/locations/_*_/keyRings/_*_/cryptoKeys/_*_/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key_version_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CustomerManagedEncryptionStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_version_name][crate::model::CustomerManagedEncryptionStatus::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }
}

impl wkt::message::Message for CustomerManagedEncryptionStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.CustomerManagedEncryptionStatus"
    }
}

/// The replication status of a SecretVersion using user-managed
/// replication.
///
/// Only populated if the parent Secret has a user-managed replication
/// policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserManagedStatus {
    /// Output only. The list of replica statuses for the SecretVersion.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replicas: std::vec::Vec<crate::model::ReplicaStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserManagedStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replicas][crate::model::UserManagedStatus::replicas].
    pub fn set_replicas<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicaStatus>,
    {
        use std::iter::Iterator;
        self.replicas = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UserManagedStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.UserManagedStatus"
    }
}

/// Describes the status of a user-managed replica for the SecretVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicaStatus {
    /// Output only. The canonical ID of the replica location.
    /// For example: `"us-east1"`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<std::string::String>,

    /// Output only. The customer-managed encryption status of the SecretVersion. Only
    /// populated if customer-managed encryption is used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub customer_managed_encryption:
        std::option::Option<crate::model::CustomerManagedEncryptionStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicaStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [location][crate::model::ReplicaStatus::location].
    pub fn set_location<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [customer_managed_encryption][crate::model::ReplicaStatus::customer_managed_encryption].
    pub fn set_customer_managed_encryption<
        T: std::convert::Into<std::option::Option<crate::model::CustomerManagedEncryptionStatus>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.customer_managed_encryption = v.into();
        self
    }
}

impl wkt::message::Message for ReplicaStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.ReplicaStatus"
    }
}

/// A generic empty message that you can re-use to avoid defining duplicated
/// empty messages in your APIs. A typical example is to use it as the request
/// or the response type of an API method. For instance:
///
/// ```norust
/// service Foo {
///   rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
/// }
/// ```
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Empty {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Empty {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for Empty {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Empty"
    }
}

/// Response message for SecretManagerService.ListSecretVersions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSecretVersionsResponse {
    /// The list of SecretVersions sorted in reverse by
    /// create_time (newest first).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub versions: std::vec::Vec<crate::model::SecretVersion>,

    /// A token to retrieve the next page of results. Pass this value in
    /// ListSecretVersionsRequest.page_token to retrieve the next page.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub next_page_token: std::option::Option<std::string::String>,

    /// The total number of SecretVersions but 0 when the
    /// ListSecretsRequest.filter field is set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub total_size: std::option::Option<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSecretVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [versions][crate::model::ListSecretVersionsResponse::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SecretVersion>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSecretVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [total_size][crate::model::ListSecretVersionsResponse::total_size].
    pub fn set_total_size<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.total_size = v.into();
        self
    }
}

impl wkt::message::Message for ListSecretVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.ListSecretVersionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSecretVersionsResponse {
    type PageItem = crate::model::SecretVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.versions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Response message for SecretManagerService.AccessSecretVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessSecretVersionResponse {
    /// The resource name of the SecretVersion in the format
    /// `projects/_*_/secrets/_*_/versions/*` or
    /// `projects/_*_/locations/_*_/secrets/_*_/versions/*`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub name: std::option::Option<std::string::String>,

    /// Secret payload
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub payload: std::option::Option<crate::model::SecretPayload>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessSecretVersionResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AccessSecretVersionResponse::name].
    pub fn set_name<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [payload][crate::model::AccessSecretVersionResponse::payload].
    pub fn set_payload<T: std::convert::Into<std::option::Option<crate::model::SecretPayload>>>(
        mut self,
        v: T,
    ) -> Self {
        self.payload = v.into();
        self
    }
}

impl wkt::message::Message for AccessSecretVersionResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.AccessSecretVersionResponse"
    }
}

/// Request message for SecretManagerService.DisableSecretVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DisableSecretVersionRequest {
    /// Optional. Etag of the SecretVersion. The request succeeds if it matches
    /// the etag of the currently stored secret version object. If the etag is
    /// omitted, the request succeeds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub etag: std::option::Option<std::string::String>,

    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:disable`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:disable`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// The `{version}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:disable`.
    #[serde(skip)]
    pub version: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions/{version}:disable`.
    #[serde(skip)]
    pub location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisableSecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::DisableSecretVersionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [project][crate::model::DisableSecretVersionRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::DisableSecretVersionRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [version][crate::model::DisableSecretVersionRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [location][crate::model::DisableSecretVersionRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

/// Request message for SecretManagerService.EnableSecretVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EnableSecretVersionRequest {
    /// Optional. Etag of the SecretVersion. The request succeeds if it matches
    /// the etag of the currently stored secret version object. If the etag is
    /// omitted, the request succeeds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub etag: std::option::Option<std::string::String>,

    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:enable`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:enable`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// The `{version}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:enable`.
    #[serde(skip)]
    pub version: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions/{version}:enable`.
    #[serde(skip)]
    pub location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EnableSecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::EnableSecretVersionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [project][crate::model::EnableSecretVersionRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::EnableSecretVersionRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [version][crate::model::EnableSecretVersionRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [location][crate::model::EnableSecretVersionRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

/// Request message for SecretManagerService.DestroySecretVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DestroySecretVersionRequest {
    /// Optional. Etag of the SecretVersion. The request succeeds if it matches
    /// the etag of the currently stored secret version object. If the etag is
    /// omitted, the request succeeds.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub etag: std::option::Option<std::string::String>,

    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:destroy`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:destroy`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// The `{version}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:destroy`.
    #[serde(skip)]
    pub version: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions/{version}:destroy`.
    #[serde(skip)]
    pub location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DestroySecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [etag][crate::model::DestroySecretVersionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [project][crate::model::DestroySecretVersionRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::DestroySecretVersionRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [version][crate::model::DestroySecretVersionRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [location][crate::model::DestroySecretVersionRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

/// Request message for `SetIamPolicy` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SetIamPolicyRequest {
    /// REQUIRED: The complete policy to be applied to the `resource`. The size of
    /// the policy is limited to a few 10s of KB. An empty policy is a
    /// valid policy but certain Google Cloud services (such as Projects)
    /// might reject them.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<crate::model::Policy>,

    /// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
    /// the fields in the mask will be modified. If no mask is provided, the
    /// following default mask is used:
    ///
    /// `paths: "bindings, etag"`
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}:setIamPolicy`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}:setIamPolicy`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}:setIamPolicy`.
    #[serde(skip)]
    pub location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SetIamPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [policy][crate::model::SetIamPolicyRequest::policy].
    pub fn set_policy<T: std::convert::Into<std::option::Option<crate::model::Policy>>>(
        mut self,
        v: T,
    ) -> Self {
        self.policy = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::SetIamPolicyRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [project][crate::model::SetIamPolicyRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::SetIamPolicyRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [location][crate::model::SetIamPolicyRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
/// A `Policy` is a collection of `bindings`. A `binding` binds one or more
/// `members`, or principals, to a single `role`. Principals can be user
/// accounts, service accounts, Google groups, and domains (such as G Suite). A
/// `role` is a named list of permissions; each `role` can be an IAM predefined
/// role or a user-created custom role.
///
/// For some types of Google Cloud resources, a `binding` can also specify a
/// `condition`, which is a logical expression that allows access to a resource
/// only if the expression evaluates to `true`. A condition can add constraints
/// based on attributes of the request, the resource, or both. To learn which
/// resources support conditions in their IAM policies, see the
/// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
///
/// **JSON example:**
///
/// ```norust
///     {
///       "bindings": [
///         {
///           "role": "roles/resourcemanager.organizationAdmin",
///           "members": [
///             "user:mike@example.com",
///             "group:admins@example.com",
///             "domain:google.com",
///             "serviceAccount:my-project-id@appspot.gserviceaccount.com"
///           ]
///         },
///         {
///           "role": "roles/resourcemanager.organizationViewer",
///           "members": [
///             "user:eve@example.com"
///           ],
///           "condition": {
///             "title": "expirable access",
///             "description": "Does not grant access after Sep 2020",
///             "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')",
///           }
///         }
///       ],
///       "etag": "BwWWja0YfJA=",
///       "version": 3
///     }
/// ```
///
/// **YAML example:**
///
/// ```norust
///     bindings:
///     - members:
///       - user:mike@example.com
///       - group:admins@example.com
///       - domain:google.com
///       - serviceAccount:my-project-id@appspot.gserviceaccount.com
///       role: roles/resourcemanager.organizationAdmin
///     - members:
///       - user:eve@example.com
///       role: roles/resourcemanager.organizationViewer
///       condition:
///         title: expirable access
///         description: Does not grant access after Sep 2020
///         expression: request.time < timestamp('2020-10-01T00:00:00.000Z')
///     etag: BwWWja0YfJA=
///     version: 3
/// ```
///
/// For a description of IAM and its features, see the
/// [IAM documentation](https://cloud.google.com/iam/docs/).
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Policy {
    /// Specifies the format of the policy.
    ///
    /// Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
    /// are rejected.
    ///
    /// Any operation that affects conditional role bindings must specify version
    /// `3`. This requirement applies to the following operations:
    ///
    /// * Getting a policy that includes a conditional role binding
    /// * Adding a conditional role binding to a policy
    /// * Changing a conditional role binding in a policy
    /// * Removing any role binding, with or without a condition, from a policy
    ///   that includes conditions
    ///
    /// **Important:** If you use IAM Conditions, you must include the `etag` field
    /// whenever you call `setIamPolicy`. If you omit this field, then IAM allows
    /// you to overwrite a version `3` policy with a version `1` policy, and all of
    /// the conditions in the version `3` policy are lost.
    ///
    /// If a policy does not include any conditions, operations on that policy may
    /// specify any valid version or leave the field unset.
    ///
    /// To learn which resources support conditions in their IAM policies, see the
    /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub version: std::option::Option<i32>,

    /// Associates a list of `members`, or principals, with a `role`. Optionally,
    /// may specify a `condition` that determines how and when the `bindings` are
    /// applied. Each of the `bindings` must contain at least one principal.
    ///
    /// The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
    /// of these principals can be Google groups. Each occurrence of a principal
    /// counts towards these limits. For example, if the `bindings` grant 50
    /// different roles to `user:alice@example.com`, and not to any other
    /// principal, then you can add another 1,450 principals to the `bindings` in
    /// the `Policy`.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub bindings: std::vec::Vec<crate::model::Binding>,

    /// Specifies cloud audit logging configuration for this policy.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub audit_configs: std::vec::Vec<crate::model::AuditConfig>,

    /// `etag` is used for optimistic concurrency control as a way to help
    /// prevent simultaneous updates of a policy from overwriting each other.
    /// It is strongly suggested that systems make use of the `etag` in the
    /// read-modify-write cycle to perform policy updates in order to avoid race
    /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
    /// systems are expected to put that etag in the request to `setIamPolicy` to
    /// ensure that their change will be applied to the same version of the policy.
    ///
    /// **Important:** If you use IAM Conditions, you must include the `etag` field
    /// whenever you call `setIamPolicy`. If you omit this field, then IAM allows
    /// you to overwrite a version `3` policy with a version `1` policy, and all of
    /// the conditions in the version `3` policy are lost.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    #[serde_as(as = "std::option::Option<serde_with::base64::Base64>")]
    pub etag: std::option::Option<::bytes::Bytes>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Policy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::Policy::version].
    pub fn set_version<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [bindings][crate::model::Policy::bindings].
    pub fn set_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Binding>,
    {
        use std::iter::Iterator;
        self.bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [audit_configs][crate::model::Policy::audit_configs].
    pub fn set_audit_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuditConfig>,
    {
        use std::iter::Iterator;
        self.audit_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::Policy::etag].
    pub fn set_etag<T: std::convert::Into<std::option::Option<::bytes::Bytes>>>(
        mut self,
        v: T,
    ) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Policy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Policy"
    }
}

/// Associates `members`, or principals, with a `role`.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Binding {
    /// Role that is assigned to the list of `members`, or principals.
    /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
    ///
    /// For an overview of the IAM roles and permissions, see the
    /// [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For
    /// a list of the available pre-defined roles, see
    /// [here](https://cloud.google.com/iam/docs/understanding-roles).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub role: std::option::Option<std::string::String>,

    /// Specifies the principals requesting access for a Google Cloud resource.
    /// `members` can have the following values:
    ///
    /// * `allUsers`: A special identifier that represents anyone who is
    ///   on the internet; with or without a Google account.
    ///
    /// * `allAuthenticatedUsers`: A special identifier that represents anyone
    ///   who is authenticated with a Google account or a service account.
    ///   Does not include identities that come from external identity providers
    ///   (IdPs) through identity federation.
    ///
    /// * `user:{emailid}`: An email address that represents a specific Google
    ///   account. For example, `alice@example.com` .
    ///
    /// * `serviceAccount:{emailid}`: An email address that represents a Google
    ///   service account. For example,
    ///   `my-other-app@appspot.gserviceaccount.com`.
    ///
    /// * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
    ///   identifier for a
    ///   [Kubernetes service
    ///   account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
    ///   For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`.
    ///
    /// * `group:{emailid}`: An email address that represents a Google group.
    ///   For example, `admins@example.com`.
    ///
    /// * `domain:{domain}`: The G Suite domain (primary) that represents all the
    ///   users of that domain. For example, `google.com` or `example.com`.
    ///
    /// * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
    ///   A single identity in a workforce identity pool.
    ///
    /// * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`:
    ///   All workforce identities in a group.
    ///
    /// * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
    ///   All workforce identities with a specific attribute value.
    ///
    /// * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`:
    ///   All identities in a workforce identity pool.
    ///
    /// * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`:
    ///   A single identity in a workload identity pool.
    ///
    /// * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`:
    ///   A workload identity pool group.
    ///
    /// * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
    ///   All identities in a workload identity pool with a certain attribute.
    ///
    /// * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`:
    ///   All identities in a workload identity pool.
    ///
    /// * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
    ///   identifier) representing a user that has been recently deleted. For
    ///   example, `alice@example.com?uid=123456789012345678901`. If the user is
    ///   recovered, this value reverts to `user:{emailid}` and the recovered user
    ///   retains the role in the binding.
    ///
    /// * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus
    ///   unique identifier) representing a service account that has been recently
    ///   deleted. For example,
    ///   `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.
    ///   If the service account is undeleted, this value reverts to
    ///   `serviceAccount:{emailid}` and the undeleted service account retains the
    ///   role in the binding.
    ///
    /// * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
    ///   identifier) representing a Google group that has been recently
    ///   deleted. For example, `admins@example.com?uid=123456789012345678901`. If
    ///   the group is recovered, this value reverts to `group:{emailid}` and the
    ///   recovered group retains the role in the binding.
    ///
    /// * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
    ///   Deleted single identity in a workforce identity pool. For example,
    ///   `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
    ///
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub members: std::vec::Vec<std::string::String>,

    /// The condition that is associated with this binding.
    ///
    /// If the condition evaluates to `true`, then this binding applies to the
    /// current request.
    ///
    /// If the condition evaluates to `false`, then this binding does not apply to
    /// the current request. However, a different role binding might grant the same
    /// role to one or more of the principals in this binding.
    ///
    /// To learn which resources support conditions in their IAM policies, see the
    /// [IAM
    /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub condition: std::option::Option<crate::model::Expr>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Binding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [role][crate::model::Binding::role].
    pub fn set_role<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.role = v.into();
        self
    }

    /// Sets the value of [members][crate::model::Binding::members].
    pub fn set_members<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.members = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [condition][crate::model::Binding::condition].
    pub fn set_condition<T: std::convert::Into<std::option::Option<crate::model::Expr>>>(
        mut self,
        v: T,
    ) -> Self {
        self.condition = v.into();
        self
    }
}

impl wkt::message::Message for Binding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Binding"
    }
}

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax. CEL is a C-like expression language. The syntax and semantics of CEL
/// are documented at <https://github.com/google/cel-spec>.
///
/// Example (Comparison):
///
/// ```norust
/// title: "Summary size limit"
/// description: "Determines if a summary is less than 100 chars"
/// expression: "document.summary.size() < 100"
/// ```
///
/// Example (Equality):
///
/// ```norust
/// title: "Requestor is owner"
/// description: "Determines if requestor is the document owner"
/// expression: "document.owner == request.auth.claims.email"
/// ```
///
/// Example (Logic):
///
/// ```norust
/// title: "Public documents"
/// description: "Determine whether the document should be publicly visible"
/// expression: "document.type != 'private' && document.type != 'internal'"
/// ```
///
/// Example (Data Manipulation):
///
/// ```norust
/// title: "Notification string"
/// description: "Create a notification string with a timestamp."
/// expression: "'New message received at ' + string(document.create_time)"
/// ```
///
/// The exact variables and functions that may be referenced within an expression
/// are determined by the service that evaluates it. See the service
/// documentation for additional information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Expr {
    /// Textual representation of an expression in Common Expression Language
    /// syntax.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expression: std::option::Option<std::string::String>,

    /// Optional. Title for the expression, i.e. a short string describing
    /// its purpose. This can be used e.g. in UIs which allow to enter the
    /// expression.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub title: std::option::Option<std::string::String>,

    /// Optional. Description of the expression. This is a longer text which
    /// describes the expression, e.g. when hovered over it in a UI.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub description: std::option::Option<std::string::String>,

    /// Optional. String indicating the location of the expression for error
    /// reporting, e.g. a file name and a position in the file.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub location: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Expr {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [expression][crate::model::Expr::expression].
    pub fn set_expression<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expression = v.into();
        self
    }

    /// Sets the value of [title][crate::model::Expr::title].
    pub fn set_title<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.title = v.into();
        self
    }

    /// Sets the value of [description][crate::model::Expr::description].
    pub fn set_description<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [location][crate::model::Expr::location].
    pub fn set_location<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }
}

impl wkt::message::Message for Expr {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.Expr"
    }
}

/// Specifies the audit configuration for a service.
/// The configuration determines which permission types are logged, and what
/// identities, if any, are exempted from logging.
/// An AuditConfig must have one or more AuditLogConfigs.
///
/// If there are AuditConfigs for both `allServices` and a specific service,
/// the union of the two AuditConfigs is used for that service: the log_types
/// specified in each AuditConfig are enabled, and the exempted_members in each
/// AuditLogConfig are exempted.
///
/// Example Policy with multiple AuditConfigs:
///
/// ```norust
/// {
///   "audit_configs": [
///     {
///       "service": "allServices",
///       "audit_log_configs": [
///         {
///           "log_type": "DATA_READ",
///           "exempted_members": [
///             "user:jose@example.com"
///           ]
///         },
///         {
///           "log_type": "DATA_WRITE"
///         },
///         {
///           "log_type": "ADMIN_READ"
///         }
///       ]
///     },
///     {
///       "service": "sampleservice.googleapis.com",
///       "audit_log_configs": [
///         {
///           "log_type": "DATA_READ"
///         },
///         {
///           "log_type": "DATA_WRITE",
///           "exempted_members": [
///             "user:aliya@example.com"
///           ]
///         }
///       ]
///     }
///   ]
/// }
/// ```
///
/// For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
/// logging. It also exempts `jose@example.com` from DATA_READ logging, and
/// `aliya@example.com` from DATA_WRITE logging.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuditConfig {
    /// Specifies a service that will be enabled for audit logging.
    /// For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
    /// `allServices` is a special value that covers all services.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service: std::option::Option<std::string::String>,

    /// The configuration for logging of each type of permission.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub audit_log_configs: std::vec::Vec<crate::model::AuditLogConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuditConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::AuditConfig::service].
    pub fn set_service<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.service = v.into();
        self
    }

    /// Sets the value of [audit_log_configs][crate::model::AuditConfig::audit_log_configs].
    pub fn set_audit_log_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuditLogConfig>,
    {
        use std::iter::Iterator;
        self.audit_log_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AuditConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.AuditConfig"
    }
}

/// Provides the configuration for logging a type of permissions.
/// Example:
///
/// ```norust
/// {
///   "audit_log_configs": [
///     {
///       "log_type": "DATA_READ",
///       "exempted_members": [
///         "user:jose@example.com"
///       ]
///     },
///     {
///       "log_type": "DATA_WRITE"
///     }
///   ]
/// }
/// ```
///
/// This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
/// jose@example.com from DATA_READ logging.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AuditLogConfig {
    /// The log type that this config enables.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub log_type: std::option::Option<std::string::String>,

    /// Specifies the identities that do not cause logging for this type of
    /// permission.
    /// Follows the same format of Binding.members.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub exempted_members: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AuditLogConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [log_type][crate::model::AuditLogConfig::log_type].
    pub fn set_log_type<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.log_type = v.into();
        self
    }

    /// Sets the value of [exempted_members][crate::model::AuditLogConfig::exempted_members].
    pub fn set_exempted_members<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exempted_members = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AuditLogConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.AuditLogConfig"
    }
}

/// Request message for `TestIamPermissions` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TestIamPermissionsRequest {
    /// The set of permissions to check for the `resource`. Permissions with
    /// wildcards (such as `*` or `storage.*`) are not allowed. For more
    /// information see
    /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub permissions: std::vec::Vec<std::string::String>,

    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}:testIamPermissions`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}:testIamPermissions`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}:testIamPermissions`.
    #[serde(skip)]
    pub location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TestIamPermissionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [permissions][crate::model::TestIamPermissionsRequest::permissions].
    pub fn set_permissions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.permissions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [project][crate::model::TestIamPermissionsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::TestIamPermissionsRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [location][crate::model::TestIamPermissionsRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

/// Response message for `TestIamPermissions` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TestIamPermissionsResponse {
    /// A subset of `TestPermissionsRequest.permissions` that the caller is
    /// allowed.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub permissions: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TestIamPermissionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [permissions][crate::model::TestIamPermissionsResponse::permissions].
    pub fn set_permissions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.permissions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for TestIamPermissionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.secretmanager.v1.TestIamPermissionsResponse"
    }
}

/// The request message for ListLocations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListLocationsRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations`.
    #[serde(skip)]
    pub project: std::string::String,

    /// A filter to narrow down results to a preferred subset.
    /// The filtering language accepts strings like `"displayName=tokyo"`, and
    /// is documented in more detail in [AIP-160](https://google.aip.dev/160).
    #[serde(skip)]
    pub filter: std::option::Option<std::string::String>,

    /// The maximum number of results to return.
    /// If not set, the service selects a default.
    #[serde(skip)]
    pub page_size: std::option::Option<i32>,

    /// A page token received from the `next_page_token` field in the response.
    /// Send that page token to receive the subsequent page.
    #[serde(skip)]
    pub page_token: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListLocationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ListLocationsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListLocationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListLocationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListLocationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.page_token = v.into();
        self
    }
}

/// The request message for GetLocation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetLocationRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}`.
    #[serde(skip)]
    pub location: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetLocationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::GetLocationRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::GetLocationRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }
}

/// The request message for ListSecrets.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSecretsRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets`.
    #[serde(skip)]
    pub project: std::string::String,

    /// Optional. The maximum number of results to be returned in a single page. If
    /// set to 0, the server decides the number of results to return. If the
    /// number is greater than 25000, it is capped at 25000.
    #[serde(skip)]
    pub page_size: std::option::Option<i32>,

    /// Optional. Pagination token, returned earlier via
    /// ListSecretsResponse.next_page_token.
    #[serde(skip)]
    pub page_token: std::option::Option<std::string::String>,

    /// Optional. Filter string, adhering to the rules in
    /// [List-operation
    /// filtering](https://cloud.google.com/secret-manager/docs/filtering). List
    /// only secrets matching the filter. If filter is empty, all secrets are
    /// listed.
    #[serde(skip)]
    pub filter: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSecretsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ListSecretsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSecretsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSecretsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSecretsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }
}

/// The request message for CreateSecret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSecretRequest {
    /// The request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_body: std::option::Option<crate::model::Secret>,

    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets`.
    #[serde(skip)]
    pub project: std::string::String,

    /// Required. This must be unique within the project.
    ///
    /// A secret ID is a string with a maximum length of 255 characters and can
    /// contain uppercase and lowercase letters, numerals, and the hyphen (`-`) and
    /// underscore (`_`) characters.
    #[serde(skip)]
    pub secret_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_body][crate::model::CreateSecretRequest::request_body].
    pub fn set_request_body<T: std::convert::Into<std::option::Option<crate::model::Secret>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_body = v.into();
        self
    }

    /// Sets the value of [project][crate::model::CreateSecretRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret_id][crate::model::CreateSecretRequest::secret_id].
    pub fn set_secret_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_id = v.into();
        self
    }
}

/// The request message for ListSecretsByProjectAndLocation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSecretsByProjectAndLocationRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets`.
    #[serde(skip)]
    pub location: std::string::String,

    /// Optional. The maximum number of results to be returned in a single page. If
    /// set to 0, the server decides the number of results to return. If the
    /// number is greater than 25000, it is capped at 25000.
    #[serde(skip)]
    pub page_size: std::option::Option<i32>,

    /// Optional. Pagination token, returned earlier via
    /// ListSecretsResponse.next_page_token.
    #[serde(skip)]
    pub page_token: std::option::Option<std::string::String>,

    /// Optional. Filter string, adhering to the rules in
    /// [List-operation
    /// filtering](https://cloud.google.com/secret-manager/docs/filtering). List
    /// only secrets matching the filter. If filter is empty, all secrets are
    /// listed.
    #[serde(skip)]
    pub filter: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSecretsByProjectAndLocationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ListSecretsByProjectAndLocationRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ListSecretsByProjectAndLocationRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSecretsByProjectAndLocationRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSecretsByProjectAndLocationRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSecretsByProjectAndLocationRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }
}

/// The request message for CreateSecretByProjectAndLocation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSecretByProjectAndLocationRequest {
    /// The request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_body: std::option::Option<crate::model::Secret>,

    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets`.
    #[serde(skip)]
    pub location: std::string::String,

    /// Required. This must be unique within the project.
    ///
    /// A secret ID is a string with a maximum length of 255 characters and can
    /// contain uppercase and lowercase letters, numerals, and the hyphen (`-`) and
    /// underscore (`_`) characters.
    #[serde(skip)]
    pub secret_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSecretByProjectAndLocationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_body][crate::model::CreateSecretByProjectAndLocationRequest::request_body].
    pub fn set_request_body<T: std::convert::Into<std::option::Option<crate::model::Secret>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_body = v.into();
        self
    }

    /// Sets the value of [project][crate::model::CreateSecretByProjectAndLocationRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::CreateSecretByProjectAndLocationRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [secret_id][crate::model::CreateSecretByProjectAndLocationRequest::secret_id].
    pub fn set_secret_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret_id = v.into();
        self
    }
}

/// The request message for GetSecret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSecretRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}`.
    #[serde(skip)]
    pub secret: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::GetSecretRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::GetSecretRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }
}

/// The request message for DeleteSecret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSecretRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// Optional. Etag of the Secret. The request succeeds if it matches
    /// the etag of the currently stored secret object. If the etag is omitted,
    /// the request succeeds.
    #[serde(skip)]
    pub etag: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::DeleteSecretRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::DeleteSecretRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteSecretRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.etag = v.into();
        self
    }
}

/// The request message for UpdateSecret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSecretRequest {
    /// The request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_body: std::option::Option<crate::model::Secret>,

    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// Required. Specifies the fields to be updated.
    #[serde(skip)]
    pub update_mask: wkt::FieldMask,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_body][crate::model::UpdateSecretRequest::request_body].
    pub fn set_request_body<T: std::convert::Into<std::option::Option<crate::model::Secret>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_body = v.into();
        self
    }

    /// Sets the value of [project][crate::model::UpdateSecretRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::UpdateSecretRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSecretRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<wkt::FieldMask>>(mut self, v: T) -> Self {
        self.update_mask = v.into();
        self
    }
}

/// The request message for GetSecretByProjectAndLocationAndSecret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSecretByProjectAndLocationAndSecretRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}`.
    #[serde(skip)]
    pub location: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}`.
    #[serde(skip)]
    pub secret: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSecretByProjectAndLocationAndSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::GetSecretByProjectAndLocationAndSecretRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::GetSecretByProjectAndLocationAndSecretRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::GetSecretByProjectAndLocationAndSecretRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }
}

/// The request message for DeleteSecretByProjectAndLocationAndSecret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSecretByProjectAndLocationAndSecretRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}`.
    #[serde(skip)]
    pub location: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// Optional. Etag of the Secret. The request succeeds if it matches
    /// the etag of the currently stored secret object. If the etag is omitted,
    /// the request succeeds.
    #[serde(skip)]
    pub etag: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSecretByProjectAndLocationAndSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::DeleteSecretByProjectAndLocationAndSecretRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::DeleteSecretByProjectAndLocationAndSecretRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::DeleteSecretByProjectAndLocationAndSecretRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteSecretByProjectAndLocationAndSecretRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.etag = v.into();
        self
    }
}

/// The request message for UpdateSecretByProjectAndLocationAndSecret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSecretByProjectAndLocationAndSecretRequest {
    /// The request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub request_body: std::option::Option<crate::model::Secret>,

    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}`.
    #[serde(skip)]
    pub location: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// Required. Specifies the fields to be updated.
    #[serde(skip)]
    pub update_mask: wkt::FieldMask,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSecretByProjectAndLocationAndSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_body][crate::model::UpdateSecretByProjectAndLocationAndSecretRequest::request_body].
    pub fn set_request_body<T: std::convert::Into<std::option::Option<crate::model::Secret>>>(
        mut self,
        v: T,
    ) -> Self {
        self.request_body = v.into();
        self
    }

    /// Sets the value of [project][crate::model::UpdateSecretByProjectAndLocationAndSecretRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::UpdateSecretByProjectAndLocationAndSecretRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::UpdateSecretByProjectAndLocationAndSecretRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateSecretByProjectAndLocationAndSecretRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<wkt::FieldMask>>(mut self, v: T) -> Self {
        self.update_mask = v.into();
        self
    }
}

/// The request message for ListSecretVersions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSecretVersionsRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// Optional. The maximum number of results to be returned in a single page. If
    /// set to 0, the server decides the number of results to return. If the
    /// number is greater than 25000, it is capped at 25000.
    #[serde(skip)]
    pub page_size: std::option::Option<i32>,

    /// Optional. Pagination token, returned earlier via
    /// ListSecretVersionsResponse.next_page_token][].
    #[serde(skip)]
    pub page_token: std::option::Option<std::string::String>,

    /// Optional. Filter string, adhering to the rules in
    /// [List-operation
    /// filtering](https://cloud.google.com/secret-manager/docs/filtering). List
    /// only secret versions matching the filter. If filter is empty, all secret
    /// versions are listed.
    #[serde(skip)]
    pub filter: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSecretVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ListSecretVersionsRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::ListSecretVersionsRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSecretVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSecretVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSecretVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }
}

/// The request message for ListSecretVersionsByProjectAndLocationAndSecret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSecretVersionsByProjectAndLocationAndSecretRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions`.
    #[serde(skip)]
    pub location: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// Optional. The maximum number of results to be returned in a single page. If
    /// set to 0, the server decides the number of results to return. If the
    /// number is greater than 25000, it is capped at 25000.
    #[serde(skip)]
    pub page_size: std::option::Option<i32>,

    /// Optional. Pagination token, returned earlier via
    /// ListSecretVersionsResponse.next_page_token][].
    #[serde(skip)]
    pub page_token: std::option::Option<std::string::String>,

    /// Optional. Filter string, adhering to the rules in
    /// [List-operation
    /// filtering](https://cloud.google.com/secret-manager/docs/filtering). List
    /// only secret versions matching the filter. If filter is empty, all secret
    /// versions are listed.
    #[serde(skip)]
    pub filter: std::option::Option<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSecretVersionsByProjectAndLocationAndSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::ListSecretVersionsByProjectAndLocationAndSecretRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::ListSecretVersionsByProjectAndLocationAndSecretRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::ListSecretVersionsByProjectAndLocationAndSecretRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSecretVersionsByProjectAndLocationAndSecretRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSecretVersionsByProjectAndLocationAndSecretRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSecretVersionsByProjectAndLocationAndSecretRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.filter = v.into();
        self
    }
}

/// The request message for GetSecretVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSecretVersionRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// The `{version}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}`.
    #[serde(skip)]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::GetSecretVersionRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::GetSecretVersionRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GetSecretVersionRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

/// The request message for GetSecretVersionByProjectAndLocationAndSecretAndVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSecretVersionByProjectAndLocationAndSecretAndVersionRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions/{version}`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions/{version}`.
    #[serde(skip)]
    pub location: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions/{version}`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// The `{version}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions/{version}`.
    #[serde(skip)]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSecretVersionByProjectAndLocationAndSecretAndVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::GetSecretVersionByProjectAndLocationAndSecretAndVersionRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::GetSecretVersionByProjectAndLocationAndSecretAndVersionRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::GetSecretVersionByProjectAndLocationAndSecretAndVersionRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [version][crate::model::GetSecretVersionByProjectAndLocationAndSecretAndVersionRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

/// The request message for AccessSecretVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessSecretVersionRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:access`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:access`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// The `{version}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}/versions/{version}:access`.
    #[serde(skip)]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessSecretVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::AccessSecretVersionRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::AccessSecretVersionRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AccessSecretVersionRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

/// The request message for AccessSecretVersionByProjectAndLocationAndSecretAndVersion.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessSecretVersionByProjectAndLocationAndSecretAndVersionRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions/{version}:access`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions/{version}:access`.
    #[serde(skip)]
    pub location: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions/{version}:access`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// The `{version}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}/versions/{version}:access`.
    #[serde(skip)]
    pub version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessSecretVersionByProjectAndLocationAndSecretAndVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::AccessSecretVersionByProjectAndLocationAndSecretAndVersionRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::AccessSecretVersionByProjectAndLocationAndSecretAndVersionRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::AccessSecretVersionByProjectAndLocationAndSecretAndVersionRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [version][crate::model::AccessSecretVersionByProjectAndLocationAndSecretAndVersionRequest::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }
}

/// The request message for GetIamPolicy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIamPolicyRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}:getIamPolicy`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/secrets/{secret}:getIamPolicy`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// Optional. The maximum policy version that will be used to format the
    /// policy.
    ///
    /// Valid values are 0, 1, and 3. Requests specifying an invalid value will be
    /// rejected.
    ///
    /// Requests for policies with any conditional role bindings must specify
    /// version 3. Policies with no conditional role bindings may specify any valid
    /// value or leave the field unset.
    ///
    /// The policy in the response might use the policy version that you specified,
    /// or it might use a lower policy version. For example, if you specify version
    /// 3, but the policy has no conditional role bindings, the response uses
    /// version 1.
    ///
    /// To learn which resources support conditions in their IAM policies, see the
    /// [IAM
    /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
    #[serde(skip)]
    pub options_requested_policy_version: std::option::Option<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIamPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::GetIamPolicyRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::GetIamPolicyRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [options_requested_policy_version][crate::model::GetIamPolicyRequest::options_requested_policy_version].
    pub fn set_options_requested_policy_version<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.options_requested_policy_version = v.into();
        self
    }
}

/// The request message for GetIamPolicyByProjectAndLocationAndSecret.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetIamPolicyByProjectAndLocationAndSecretRequest {
    /// The `{project}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}:getIamPolicy`.
    #[serde(skip)]
    pub project: std::string::String,

    /// The `{location}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}:getIamPolicy`.
    #[serde(skip)]
    pub location: std::string::String,

    /// The `{secret}` component of the target path.
    ///
    /// The full target path will be in the form `/v1/projects/{project}/locations/{location}/secrets/{secret}:getIamPolicy`.
    #[serde(skip)]
    pub secret: std::string::String,

    /// Optional. The maximum policy version that will be used to format the
    /// policy.
    ///
    /// Valid values are 0, 1, and 3. Requests specifying an invalid value will be
    /// rejected.
    ///
    /// Requests for policies with any conditional role bindings must specify
    /// version 3. Policies with no conditional role bindings may specify any valid
    /// value or leave the field unset.
    ///
    /// The policy in the response might use the policy version that you specified,
    /// or it might use a lower policy version. For example, if you specify version
    /// 3, but the policy has no conditional role bindings, the response uses
    /// version 1.
    ///
    /// To learn which resources support conditions in their IAM policies, see the
    /// [IAM
    /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
    #[serde(skip)]
    pub options_requested_policy_version: std::option::Option<i32>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetIamPolicyByProjectAndLocationAndSecretRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::GetIamPolicyByProjectAndLocationAndSecretRequest::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [location][crate::model::GetIamPolicyByProjectAndLocationAndSecretRequest::location].
    pub fn set_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = v.into();
        self
    }

    /// Sets the value of [secret][crate::model::GetIamPolicyByProjectAndLocationAndSecretRequest::secret].
    pub fn set_secret<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.secret = v.into();
        self
    }

    /// Sets the value of [options_requested_policy_version][crate::model::GetIamPolicyByProjectAndLocationAndSecretRequest::options_requested_policy_version].
    pub fn set_options_requested_policy_version<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.options_requested_policy_version = v.into();
        self
    }
}
